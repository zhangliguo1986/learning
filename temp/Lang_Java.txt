文档结构：一、A、1、（1）、1）、<1>、I
※·•◆★●̑∵∴®¤≈……┌┐└┘∟「」⊥┼┤┴├┬↑↓→←↖↗↘↙♀♂≠╳√╱╲—│∞
∟
㊣①②③④⑤⑥⑦⑧⑨⑩
┌—┐
│  │
└—┘
枫叶城


零、基本概念
0.安装jdk
# centos7自带的jdk是不带JVM调优工具的，可通过以下命令安装
$ yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 java-1.8.0-openjdk-devel.x86_64
$ yum install -y java-11-openjdk.x86_64 java-11-openjdk-headless.x86_64

$ yum install -y java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64

https://ghboke.ctfile.com/dir/7369060-29302051-742f0f/29603311/



1.JVM

                                                ┌----┐  ┌--------------------┐  ┌----------------------------------------┐
                                                │    │  │ 操作系统栈         │  │   操作系统堆                           │
                                                │    │  │（由操作系统管理）  │  │  （由程序管理）                        │
                                                │    │  │                    │  │                                        │
                                                │    │  │ 本地方法栈         │  │ ┌----┐  ┌------------------------┐ │
                                                │ 寄 │  │                    │  │ │ 程 │  │JVM内存                 │ │
                                                │    │  │                    │  │ │    │  │ classloader            │ │
                                                │    │  │                    │  │ │ 序 │  │ ┌------┐  ┌------┐ │ │
                                                │ 存 │  │                    │  │ │    │  │ │Java堆│  │Java栈│ │ │
                                                │    │  │                    │  │ │ 计 │  │ └------┘  └------┘ │ │
                                                │    │  │                    │  │ │    │  │                        │ │
                                                │ 器 │  │                    │  │ │ 数 │  │   ┌-------------┐    │ │
                                                │    │  │                    │  │ │    │  │   │  JVM方法区  │    │ │
                                                │    │  │                    │  │ │ 器 │  │   └-------------┘    │ │
                                                │    │  │                    │  │ │    │  │                        │ │
                                                │    │  │                    │  │ └----┘  └------------------------┘ │
                                                └----┘  └--------------------┘  └----------------------------------------┘
                                                ┌----------------------------------------------------------------------------┐
                                                │                                 硬  盘（.class文件）                       │
                                                └----------------------------------------------------------------------------┘
·本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
·JVM栈：一个线程对应一个私有栈，用于存放“正在执行的方法上下文”（包括方法中的局部变量），即每执行一个方法就会向其中压入一个元素，称为“栈帧”，如果栈空间不足，JVM会抛出java.lang.StackOverFlowError。
·JVM堆：所有线程共享同一个堆，用于存放对象，如果堆空间不足，JVM会抛出java.lang.OutOfMemoryError。
所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。
¤你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。
® 堆内存与栈内存需要说明：
基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈空间收回。字符串常量、static在DATA区域分配，this在堆空间分配。数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小。

·JVM方法区/静态区：Java在内存中专门划分出一块“被所有线程共享”的静态存储区域（即在固定位置上存放应用程序运行时一直存在的数据，由于位置固定，下次调用时便省去了查找的麻烦），称为方法区。
所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。
※静态变量+常量+类信息+运行时常量池存在方法区中，实例变量存在堆内存中。JVM用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。
类型信息和类的静态变量都存储在方法区中。方法区中对于每个类存储了以下数据：
    a.类及其父类的全限定名（java.lang.Object没有父类）
    b.类的类型（Class or Interface）
    c.访问修饰符（public, abstract, final）
    d.实现的接口的全限定名的列表
    e.常量池
    f.字段信息
    g.方法信息
    h.静态变量
    i.ClassLoader引用
    j.Class引用
·寄存器：计算机上的硬件，用于存放“伪指令”或地址。
·程序计数器（Program Counter Register）：JVM执行class字节码，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。在虚拟机的世界中，字节码解释器就是通过改变计数器的值来选取下一条执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都需要它来实现。
    •如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址，实现上可能有两种形式：
      ①一种是相对该方法字节码开始处的偏移量，叫做bytecode index，简称bci；
      ②另一种是该Java字节码指令在内存里的地址，叫做bytecode pointer，简称bcp。
    •如果正在执行的是Native 方法，则这个技术器值为空（Undefined）。
    •此外，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。


JVM工作过程：
①启动JVM进程，该进程从classpath加载相应的class文件到方法区。（先从classpath找到class文件，读取二进制字节流，存入方法区）；
②JVM定位到main方法，开始执行程序；
③命令执行过程中若有未加载的类，加载该类到方法区；
④JVM为main方法中要创建的对象分配堆内存，并创建对象，对象的引用（对应类在方法区中的内存地址，指向方法区对应的类）存在当前线程的栈区，对象本身存在JVM堆区；
⑤继续执行代码，JVM根据新创建的对象的引用，定位到堆区的实例，再根据堆区实例持有的引用定位到方法区中的类信息，找到具体方法的字节码，执行。

Java源文件(.java源文件)—->编译器—->字节码文件(与平台无关的.class文件)—->Windows机器码—->Windows OS
                                                                       —->Linux机器码—->Linux OS

2.目录结构
ProjectXXX
        ∟src
             ∟main
                 ∟resources
                      ∟application.properties
        ∟target
             ∟classes                                   // intellij idea的默认输出目录，用于存放java字节码文件
        ∟web
             ∟META-INF                                  // 存放一些meta information相关的文件的这么一个文件夹, 一般来说尽量不要自己手工放置文件到这个文件夹。
             ∟WEB-INF
                 ∟classes                               // eclipse的默认输出目录，用于存放java字节码文件
                 ∟lib                                   // 用于存放该工程用到的库，例如servlet-api.jar等等
                 ∟web.xml                               // web工程的配置文件，完成用户请求的逻辑名称到真正的servlet类的映射
                 ∟applicationContext.xml
                 ∟dispatcher-servlet.xml
             ∟index.jsp
        ∟pom.xml


classpath即指classes目录，引用classpath路径下的文件，只需在文件名前加classpath:(需保证该文件确实位于classpath路径下)，如：<param-value>classpath:applicationContext-*.xml</param-value> 


指定编译生成后的class文件和resource下的文件都输出到target/classes 文件夹下，那么访问resource文件夹下的文件的方法就是
String filePath = CurrentDirTest.class.getClassLoader.getResource("").getPath() + "test.txt";
BufferedReader br = new BufferedReader(filepath);
br.readLine();

3.resource
classpath:/application.properties


一、基本类型
原始类型: boolean，char，byte，short，int，long，float，double
包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
1.数字类型
（1）
// 通常情况下，包装类型
Integer i = 200;  
Integer j = 200;  
System.out.println(i == j);                         // print false
System.out.println(i.equals(j));                    // print true
System.out.println(i.intValue() == j.intValue())    // print true
// 但当-128 =< i <= 127的时候，是特殊情况，其已经被缓存起来
Integer i = 100;
Integer j = 100;
System.out.println(i == j);                         // print true


long a = 10; int b = (int)a;                        // 将long转化为int
Integer a = 10; int b = a.intValue();               // 将Integer转化为int
int a = 10; Integer b = new Integer(a);             // 将int转化为Integer
int a = 10; Integer b = a;                          // 将int转化为Integer
int a = 10; Integer b = Integer.valueOf(a);         // 将int转化为Integer



总结：这里的转化就是要注意java的八种基础数据类型以及八种包装数据类型的区别。

（2）位移运算
   1 1
  10 2
 100 4
1000 8

1 << 3 == 1 * (2^3) == 8
3 << 3 == 3 * (2^3) == 24
24 >> 3 == 24 * (2^-3) == 3
∴
x << n == x * (2^n)
x >> n == x * (2^-n)


2.String
StringUtils
（1）字符串比较
Java重载了String的+和+=，但没有重载==，这是我这段时间犯的最多的错误。C#中String的==是比较值相等（因为重写的该操作），Java中==是Object的默认行为：要比较引用相等用==，要比较值相等用equals。（这么多年编程以来，我似乎从来没有遇到过要比较两个字符串变量的引用相等。对于比较值相等来讲，==符号比equals方法调用看上去优雅得多，况且方法调用还得注意空指针的情况）




（2）String s = new String("xyz");创建了几个字符串对象？
答：两个对象，一个是静态存储区的"xyz"，一个是用new创建的在堆上的对象。
String x = "张三";
String y = "张三";
String z = new String("张三");
System.out.println(x == y);                     // true，因为都是取自常量池的值
System.out.println(x == z);                     // false，因为x取常量池的值，z取自堆的值



（3）
String a = new String("abc");
String b = new String("abc");
String c = "abc";
String str = new String("a") + new String("b"); // str 在常量

// s.intern()查询字符串常量池中是否存在“abc”，如存在即返回常量池；如不存在将堆中的“abc”复制到字符串常量池中后，再返回字符串常量池的引用。
System.out.println(a.intern() == b.intern());   // true
System.out.println(a.intern() == b);            // false
System.out.println(a.intern() == a);            // false
System.out.println(a.intern() == c);            // true

// 1.7以后，s.intern()查询字符串常量池中是否存在“abc”，如存在即返回常量池，但自己仍为引用类型；如不存在，同样返回常量的引用，把自己转成常量值。
// 也就是说，如果常量池为空，即把自身移到常量池（即如果自身是引用类型，会变为一个常量），否则不会。但不论如何始终的是返回常量值
System.out.println(str.intern() == str);        // true

{
    String str = new String("a") + new String("b");
    System.out.println(str.intern() == "ab");           // true     返回常量。不存在常量池，所以自身移入常量池，变为常量
    System.out.println(str == "ab");                    // true
}
{
    String strtwo = "ab";
    String str2 = new String("a") + new String("b");
    System.out.println(str2.intern() == "ab");          // true     返回常量。存在常量池，所以自身不移入常量池，仍为引用类型
    System.out.println(str2 == "ab");                   // false
}





（3）使用 StringEscapeUtils 中的转义与反转义
apache工具包common-lang中有一个很有用的处理字符串的工具类，其中之一就是StringEscapeUtils。利用它可方便地进行html、xml、java等的转义与反转义。

String str = "{\\\"name\\\":\\\"spy\\\",\\\"id\\\\":\\\"123456\\\"}";
System.out.println("原始 str = " + str);
String str1 = StringEscapeUtils.unescapeJava(str);
System.out.println("目标 str1 = " + str1);
//对应方法的StringEscapeUtils.escapeJava(str1);
//可将str1转义回str


（4）format方法
jdk 1.5里面就有 格式化 字符串
// 输出结果：select item from table where 1=1
String sql1 = String.format("select %s from %s where 1=1", "item", "table");
String sql2 = java.text.MessageFormat.format("select {0} from {1} where 1=1", "item", "table");
// 如果format中有“{”或“}”符号，可以'{'或'}'的形式进行转义
MessageFormat.format("This is a char '{'. {0} ", "Thank you.")

（5）spring framework的StringUtiles
Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))

3.Object


4.hashCode()方法与equals
不被重写（原生）的hashCode和equals是什么样的？
（1）不被重写（原生）的hashCode值是根据内存地址换算出来的一个值。
（2）不被重写（原生）的equals方法是严格判断一个对象是否相等的方法（object1 == object2）。
即：
// hashcode()方法是根据对象的内存地址，进行哈希计算得出的值
// 原生的equals
public boolean equals(Object obj) {
    return (this == obj);
}



我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：
? 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 
? 反射性：x.equals(x)必须返回是“true”。 
? 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 
? 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 
? 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 
以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守。

Java对于eqauls方法和hashCode方法是这样规定的：
(1)如果a == b，那么他们的hashCode一定相同，
(2)如果a.hashCode() == b.hashCode()，那么不一定a == b，如：
Integer a= new Integer(10);
Integer b = new Integer("10");
System.out.println(a.hashCode() == b.hashCode());       // true
System.out.println(a == b);                             // false
(3)a.equals(b)，那么它们的hashCode值一定要相同；
(4)如果两个对象的hashCode相同，它们并不一定相同。
即：
equals()相等的两个对象，hashcode()一定相等； 
equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。
反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。解释下第3点的使用范围，我的理解是在object、String等类中都能使用。在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时， 
Hashcode()方法根据String类的重写（第2点里面已经分析了）代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。 

5.时间日期
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Calendar;

（1）Calendar
Calendar cal = Calendar.getInstance();
int YY = cal.get(Calendar.YEAR) ;
int MM = cal.get(Calendar.MONTH)+1;
int DD = cal.get(Calendar.DATE);
int HH = cal.get(Calendar.HOUR_OF_DAY);
int mm = cal.get(Calendar.MINUTE);
int SS = cal.get(Calendar.SECOND);
int MI = cal.get(Calendar.MILLISECOND);    
//由整型而来，因此格式不加0,如  2016/5/5-1:1:32:694
System.out.println(YY + "/" + MM + "/" + DD + "-" + HH + ":" + mm + ":" + SS + ":" + MI);

（2）Date
Date date = cal.getTime();
Date date = new Date();
{
    // 
    DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.DEFAULT, Locale.CHINA);
    System.out.println(dateFormat.format(date));
}
{
    //  2016/05/05-01:01:34:364
    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    System.out.println(dateFormat.format(date));
}

java中System.nanoTime()返回的是纳秒，nanoTime而返回的可能是任意时间，甚至可能是负数…… 
java中System.currentTimeMillis()返回的毫秒，这个毫秒其实就是自1970年1月1日0时起的毫秒数. 

Java毫秒SSS
.net毫秒fff


（3）LocalDateTime
LocalDateTime.toInstant(ZoneOffset.of("+8")).toEpochMilli()
LocalDateTime.now().toEpochSecond(ZoneOffset.of("+8"));

    long time0 = System.currentTimeMillis();
    long time1 = new Date().getTime();
    long time2 = LocalDateTime.now().toInstant(ZoneOffset.of("+8")).toEpochMilli();
    long time3 = Calendar.getInstance().getTimeInMillis();
    System.out.println(time0);
    System.out.println(time1);
    System.out.println(time2);
    System.out.println(time3);


6.关键词
strictfp

volatile








6.枚举类型
（1）简单
public enum Color {  
  RED, GREEN, BLANK, YELLOW  
} 

（2）复杂
public enum Color {  
    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);               // 除此部分，其他与普通类一样
    // 成员变量  
    private String name;  
    private int index;  
    // 构造方法  
    private Color(String name, int index) {  
        this.name = name;  
        this.index = index;  
    }  
    // 普通方法  
    public static String getName(int index) {  
        for (Color c : Color.values()) {  
            if (c.getIndex() == index) {  
                return c.name;  
            }  
        }  
        return null;  
    }

    // get set 方法  
    public String getName() {  
        return name;  
    }

    public int getIndex() {  
        return index;  
    }
}

※枚举类型对象之间的值比较，是可以使用==，直接来比较值，是否相等的，不是必须使用equals方法

（3）枚举集合
java.util.EnumMap<K extends Enum<K>, V> extends AbstractMap<K, V>
    implements java.io.Serializable, Cloneable


7.集合
o.数组
String[] strings = new String[]{};
String[] strings = new String[0];


a.对象排列接口
Comparable 与 Comparator 对象排列接口，有什么不同？
Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

a.Collection的类继承图
                                                      Collection
                                                           |
                  --------------------------------------------------------------------
                  |                                        |                         |
                 Set                                      List                     Queue
    ------------------------------            -----------------------------    --------------
    |             |              |            |            |              |    |            |
HashSet     LinkedHashSet     TreeSet     ArrayList      Vector         LinkedList     PriorityQueue

集合和数组的区别?  
        A:长度区别  
            数组固定  
            集合可变  
        B:内容区别  
            数组可以是基本类型，也可以是引用类型  
            集合只能是引用类型  
        C:元素内容  
            数组只能存储同一种类型  
            集合可以存储不同类型(其实集合一般存储的也是同一种类型)  


·ArrayList      就是动态数组，是Array的复杂版本，动态的增加和减少元素。当更多的元素加入到ArrayList中时，其大小将会动态地增长。它的元素可以通过get/set方法直接访问，因为ArrayList本质上是一个数组。
·Vector         和ArrayList类似， 区别在于Vector是同步类(synchronized)。因此，开销就比ArrayList要大。
·LinkedList     是一个双链表，在添加和删除元素时具有比ArrayList更好的性能。但在get与set方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比。它还实现了 Queue 接口，该接口比List提供了更多的方法，包括 offer(),peek(),poll()等。

★从效率上来讲，ArrayList更适合读取数据，linkedList更多的时候添加或删除数据。
★Vector的方法都是同步的(Synchronized)，是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此，ArrayList的性能比Vector好。

b.Set
Set对每个对象只接受一次，并使用自己内部的排序方法（通常，你只关心某个元素是否属于Set，而不关心它的顺序--否则应该使用List）。Map同样对每个元素保存一份，但这是基于"键"的，Map也有内置的排序，因而不关心元素添加的顺序。如果添加元素的顺序对你很重要，应该使用 LinkedHashSet或者LinkedHashMap.
总结：List有顺序有重复没有排序，set无重复有排序，map的key也和set一样。如果想跟List一样需要有插入元素的顺序，请使用LinkedHashSet或者LinkedHashMap。


c.List
    实际上有两种List：一种是基本的ArrayList，其优点在于随机访问元素，另一种是更强大的LinkedList，它并不是为快速随机访问设计的，而是具有一套更通用的方法。
    List：次序是List最重要的特点：它保证维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(这只推荐LinkedList使用。)一个List可以生成ListIterator，使用它可以从两个方向遍历List，也可以从List中间插入和移除元素。
    ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList，而不是用来插入和移除元素。因为那比LinkedList开销要大很多。
    LinkedList：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。(使用ArrayList代替。)还具有下列方法：addFirst()， addLast()， getFirst()， getLast()， removeFirst() 和 removeLast()， 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。
    Set的功能方法
    Set：存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。
    HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。
    TreeSet：保存次序的Set， 底层为树结构。使用它可以从Set中提取有序的序列。
    LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。
    Map的功能方法
    方法put(Object key， Object value)添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)。方法get(Object key)返回与给定“键”相关联的“值”。可以用containsKey()和containsValue()测试Map中是否包含某个“键”或“值”。标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。
    执行效率是Map的一个大问题。看看get()要做哪些事，就会明白为什么在ArrayList中搜索“键”是相当慢的。而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称为“散列码”(hash code)，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。所有Java对象都能产生散列码，因为hashCode()是定义在基类Object中的方法。
    HashMap就是使用对象的hashCode()进行快速查询的。此方法能够显著提高性能。
    Map：维护“键值对”的关联性，使你可以通过“键”查找“值”
    HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。
    LinkedHashMap 搜索: 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入顺序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。
    SortedMap（接口）：保证按照键的升序排列的映射，可以按照键的自然顺序（参见 Comparable 接口）进行排序， 或者通过创建有序映射时提供的比较器进行排序。
    TreeMap：基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。
    WeakHashMao：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。
    IdentifyHashMap：使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计。
    ※HashMap的putAll是深度复制

HashSet<Name> s = new HashSet<Name>();
s.add(new Name("Marry"));
if (s.contains(new Name("Marry"))
    ...
else
    System.out.println("It is not equal.");

★集合的初始化
ArrayList<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
->
·方式一
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};
·方式二
List<String> list = ["A", "B", "C"]
·方式三
// ※注意：此种方式返回的是java.util.Arrays$ArrayList类型，是只读的。如果调用了add方法会提示“java.lang.UnsupportedOperationException”
List<String> places = Arrays.asList("Buenos Aires", "Córdoba", "La Plata");
// 如果想返回非只读的java.util.ArrayList类型，可通过下面的方式
List<String> places = new ArrayList<>(Arrays.asList("Buenos Aires", "Córdoba", "La Plata"););
·方式四
import com.google.common.collect.ImmutableList;
List<String> places = ImmutableList.of("Buenos Aires", "Córdoba", "La Plata");
·方式五
List<String> cups = List.of("A", "B", "C");
·方式六
List<String> apples = Collections.nCopies(3, "apple");


★集合的转换
Enumeration<T> e = ...;
ArrayList<T> list = Collections.list(e);







d.Queue
在java5中新增加了java.util.Queue接口，用以支持队列的常见操作。该接口扩展了java.util.Collection接口。
Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优
点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 如果要使用前端而不移出该元素，使用
element()或者peek()方法。
值得注意的是LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。

List staffsList = Arrays.asList(staffs);
Set<String> staffsSet = new HashSet<>(Arrays.asList(staffs));
Object[] result = staffsList.toArray();
Set result = new HashSet(staffsList);


队列        堆栈
offerFirst 头加  push
poll       头删  pop
peek       头返
offer      尾加

poll是队列数据结构实现类的方法，从队首获取元素，同时获取的这个元素将从原队列删除； 
pop是栈结构的实现类的方法，表示返回栈顶的元素，同时该元素从栈中删除，当栈中没有元素时，调用该方法会发生异常



e.Map


                                              Map
                                               |
                   -------------------------------------------------------
                   |                           |                         |
               HashTable                    HashMap                   SortedMap
                   -                           -                         -
                   |                           |                         |
               Properties                LinkedHashMap                 TreeMap








Java为数据结构中的映射定义了一个接口java.util.Map，它有四个实现类，分别是HashMap、HashTable、LinkedHashMap和TreeMap。Map用于存储键值对，根据键得到值，因此不允许键重复，值可以重复。（如果key为引用对象，则比较其hashCode()）
（1）HashMap是一个最常用的Map，它实现了Map接口，根据键的hashCode值存储数据，具有很快的访问速度。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力。
（2）Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，然而，这也导致了Hashtable在写入时会比较慢。
（3）LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的。在遍历的时候会比HashMap慢。有HashMap的全部特性。
（4）TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iteraor遍历TreeMap时，得到的记录是排过序的。TreeMap的键和值都不能为空。

    List<String> list = new ArrayList<String>();  
    list.add("a");
    list.add("b");
    list.add("c");
    list.add("d");
    list.add("e");
    // 插入到指定位置
    list.add(2, "f");


遍历Map有两种方法：
（1）map的keySet()方法获得键的集合，再调用键集合的iterator方法获得键的迭代器，以此迭代地取出Map中的键，用get方法获得键对应的值，便完成了Map的遍历。代码如下所示：
//使用迭代器遍历Map的键，根据键取值
        Iterator it = map.keySet().iterator();
        while (it.hasNext()) {
           key = it.next();
           value = map.get(key);
           System.out.println("key: " + key + "; value: " + value );
        }
（2）使用Map的entrySet方法获得Map中记录的集合，每条对象都是一个Map.Entry对象，使用其getKey方法获得记录的键，使用其getValue方法获得记录的值。代码如下所示：
        //或者使用迭代器遍历Map的记录Map.Entry
        Map.Entry entry = null;
        it = map.entrySet().iterator();
        while (it.hasNext()) {
           //一个Map.Entry代表一条记录
           entry = (Map.Entry)it.next();
           //通过entry可以获得记录的键和值
           //System.out.println("key: " + entry.getKey() + "; value: " + entry.getValue());


Map的putIfAbsent和computeIfAbsent的区别：
都是在key不存在的时候才会建立key和value的映射关系；
putIfAbsent不论传入的value是否为空，都会建立映射（并不适合所有子类，例如HashTable），而computeIfAbsent方法，当存入value为空时，不做任何操作
当key不存在时，返回的都是新的value（为什么不说新插入的value），即使computeIfAbsent在传入的value为null时，不会新建映射关系，但返回的也是null；     
     computeIfPresent和computeIfAbsent
这两个方法正好相反，前者是在key存在时，才会用新的value替换oldValue
当传入的key存在，并且传入的value为null时，前者会remove（key），把传入的key对应的映射关系移除；而后者不论何时都不会remove()；
前者只有在key存在，并且传入的value不为空的时候，返回值是value，其他情况都是返回null；后者只有在key不存在，并且传入的value不为null的时候才会返回value，其他情况都返回null；
     compute
新传入的value不为null就建立映射关系（也就是说不论key是否为null，具体子类再具体分析）
新传入的value为null时：key已存在，且老的对应value不为null，移除改映射关系，返回null；否则，直接返回null



f.Map.Entry
Map.Entry 是一种“单key-value类型”
Map.Entry<String, String> entry = new HashMap<String,String>().entrySet().stream().findFirst().get();


★几种常用的Map
MultiValueMap：一个Key可以存储多个Value值，item.get(key)返回的是一个List。
TreeMap implement SortedMap：自身会按照Key进行排序。
IdentityHashMap：Key-Value可以重复，※※※在IdentityHashMap中，是判断key是否为同一个对象，而不是普通HashMap的equals方式判断。

★HashMap & Hashtable
1 HashMap 和 Hashtable 都是通过链接法解决碰撞
2 HashMap 的hash函数更加牛一些，另外支持null的key（这其实是一个支不支持的问题）
3 javadoc中写道：除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。从具体代码来看，HashMap代码的方法前面没有加synchronized，而Hashtable的方法前面加了synchronized；另外，Hashtable不支持null是“全面”的，key 和 value都不能为null
4 HashMap计算key对应的bucket（桶）所使用取模算法中，HashMap是二进制的 & (table.length - 1)，而Hashtable 是 % table.length，显然HashMap更加牛些
5 HashMap的查找，插入性能更加好，因为它中间会对key的hashCode再做一次hash，使其尽量均匀分布，而Hashtable基本依赖于key的hashCode()
选择的原则：尽量使用HashMap，如果有同步方面的需求，自己可以在外面做控制。

Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。


HashTable不允许null值(key和value都不可以)，HashMap允许null值(key和value都可以)
HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历
HashSet底层是采用HashMap实现的



★HashMap原理
自从jdk8以后，当数量大于8的时候，转为红黑树



f.List与数组转换
（1）List转换为Array
    List<String> list = new ArrayList<String>();  
    list.add("王利虎");  
    list.add("张三");  
    list.add("李四");  
    int size=list.size();  
    String[] array = (String[])list.toArray(new String[size]);  

（2）Array转换为List
    String[] array = new String[3];  
    array[0]="王利虎";  
    array[1]="张三";  
    array[2]="李四";  
    List<String> list = Arrays.asList(array);  



g.Collection与Map
Collection：一组“对立”的元素，通常这些元素都服从某种规则。
（1）Set 存放的是对象的引用，没有重复的对象。（无序，不可重复）
    ①：HashSet：按照哈希算法来存取集合中的对象，存取速度比较快。
    ②：TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。
    ③：LinkedHashSet：具有HashMap的查询速度，且内部使用链表维护元素顺序，因此遍历时返回的是插入次序。
（2）List 以线性方式储存，可以存放重复的数据。（有序，可重复）
    ①：ArrayList 代表长度可以改变的数组，可以对元素进行随机的访问，但插入与删除元素的速度比较慢。
    ②：LinkedList 采用链表数据结构，插入和删除速度快，访问速度慢。
Map：一组成对的“键值对”对象，可以通过“键”找到该键对应的“值”。
（3）Map 存放的是键值对
    ①：HashMap 基于散列表的实现，插入和查询键值对的开销是固定的。
    ②：LinkedHashMap 使用链表维护内部次序，且遍历时取得的键值对是其插入次序。
    ③：TreeMap 基于红黑树数据结构，遍历取得的数据是经过内部排序的，同时也是唯一一个带有subMap方法的Map。
        声明 以下是java.util.TreeMap.subMap()方法的声明。
    
（4）自定义
import java.util.Map;

public class KeyValue<K, V> implements Map.Entry<K, V>
{
    private K key;
    private V value;

    public KeyValue(K key, V value)
    {
        this.key = key;
        this.value = value;
    }

    public K getKey()
    {
        return this.key;
    }

    public V getValue()
    {
        return this.value;
    }

    public K setKey(K key)
    {
        return this.key = key;
    }

    public V setValue(V value)
    {
        return this.value = value;
    }
}


h.CopyOnWriteArrayList
CopyOnWriteArrayList是ArrayList 的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。


i.Iterator与Iterable的区别
// Iterator是一个迭代器：我是一个迭代器
public interface Iterator<E> {
    boolean hasNext();
    E next();
}

// Iterable表示一个对象内部有一个迭代器：我有一个迭代器
public interface Iterable<T> {
  Iterator<T> iterator();
}

ii.Iterator与Enumeration的区别
·Iterator是一个接口，包含三个方法：
hasNext()
next()
remove()
·Enumeration也是一个接口，它是一个遗留类，集合类中只有Vector和HashTable实现了该接口。它包含了两个方法： 
1. hasMoreElements() 
2. nextElement()

∴Enumeration是一种Read-only

8.特殊字符串（分隔符）
public static final String NEW_LINE = System.getProperty("line.separator");             // 换行
File.separator                                                                          //  /
File.pathSeparator                                                                      //  ;

9.Math
Math.round(x)：在数轴上取值最接近的整数，中间值(0.5)向右取。


负数验证如下：
Math.round(-8.49999) :-8
Math.round(-8.5)     :-8
Math.round(-8.50001) :-9
Math.round(-8.59999) :-9
Math.round(-8.6)     :-9





import java.lang.Math.Random;

class Foo {
    public void todo() {
        // 返回结果为double类型的[0.0,1.0)
        double d = Math.random();
    }
}



import java.util.Random;

class Foo {
    public void todo() {
        // new Random()为[0, 1)
        int i = new Random().nextInt(3000);
    }
}




10.类型转换
{
    byte a = 127;
    byte b = 127;
    // 相当于b = (int)a + (int)b，会报错。因为类型不同
    b = a + b;      // error : cannot convert from int to byte
}
Incompatible types. Found: 'int', required: 'byte'








二、类、接口
★类型内部的对象名称与方法名称可以相同

1.构造方法
（1）
static {
}
只有首次实例化（即new Xxx()）的时候才会执行

（2）继承
public class Parent {
    public int age;
    
    public Parent() {
    }
    
    public Parent(int age) {
        this.age = age;
    }
}
public class Son {
    public int age;

    public Son() {
    }

    public Son(int age) {
        super(age);
        this.age = age;
    }
}



如果不显式调用父类有参构造函数，系统会默认调用父类无参构造函数super();
但是父类中没有无参构造函数，那它不是不能调用了。所以编译就无法通过了。
类的初始化，先static，再构造方法，所以不能在static中reference 泛型


（3）顺序
在JAVA中，父类与子类构造方法的调用顺序为：
----子类----|----父类----|
             静态代码
静态代码

构造方法        构造方法
--------]------]成员变量
        ]      ]
        ]      ]
        ]------]
        ]成员变量
        ]
        ]
--------]


静态（如果有多个静态对象，按顺序依次执行）
  1）                    父类静态代码
  2）子类静态代码
动态
  1）                    父类成员变量
  2）                    父类构造方法
  3）                    如在父类构造方法中调用了override的子类方法，会调用该子类方法，如该子类方法中引用了其本身内部的成员变量，并不初始化子类中的成员变量
  4）子类成员变量
  5）子类构造方法

¤多个静态对象，按照定义的先后顺序执行

基本原则：
先静后动，先父后子，先成员后构造



初始化
class Singleton {
    private static Singleton singleton = new Singleton();
    public static int value1;
    public static int value2 = 0;

    private Singleton() {
        value1++;
        value2++;
    }

    public static Singleton getInstance() {
        return singleton;
    }
    
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println("Singleton1 value1:" + Singleton.value1);
        System.out.println("Singleton1 value2:" + Singleton.value2);
    }
}

Singleton1 value1:1
Singleton1 value2:0





2.方法
（1）“值传递”与“引用传递”
从本质上来看：
“值传递”：形参是实参的副本，注意，这里的副本是浅度拷贝的副本。
“引用传递”：实参与形参是指向相同引用地址。
从使用上来看：
形参的对象：无论是“值传递”还是“引用传递”，形参内的对象发生改变，实参都会发生相应的变化。
形参本身：对形参进行重新指向，“值传递”的实参“不发生”变化，“引用传递”的实参发生变化。
※java中只有“值传递”

插曲：
/**
 * String的API中有这么一句话：“their values cannot be changed after they are created”， 
 * 意思是：String的值在创建之后不能被更改。 
 * API中还有一段：
 * String str = "abc"; 
 * 等效于：
 * char data[] = {'a', 'b', 'c'}; 
 * String str = new String(data); 
 */
public static void main(String[] args) {
    String str = "AAA";

    change(str);

    System.out.println(str);
}   
public static void change(String s) {
    s = "abc";
}
result:
AAA


例：
public static void main(String[] args) {                                public static void main(String[] args) {
   ParamTest pt = new ParamTest();                                         ParamTest pt = new ParamTest();
                                                                        
   User hollis = new User();                                               User hollis = new User();
   hollis.setName("Hollis");                                               hollis.setName("Hollis");
   hollis.setGender("Male");                                               hollis.setGender("Male");
   pt.pass(hollis);                                                        pt.pass(hollis);
   System.out.println("print in main , user is " + hollis);                System.out.println("print in main , user is " + hollis);
}                                                                       }
                                                                        
public void pass(User user) {                                           public void pass(User user) {
   user.setName("hollischuang");                                           user = new User();
   System.out.println("print in pass , user is " + user);                  user.setName("hollischuang");
}                                                                          user.setGender("Male");
                                                                           System.out.println("print in pass , user is " + user);
                                                                        }
                                                                        
print in pass , user is User{name='hollischuang', gender='Male'}        print in pass , user is User{name='hollischuang', gender='Male'}
print in main , user is User{name='hollischuang', gender='Male'}        print in main , user is User{name='Hollis', gender='Male'}




2.内部类
●匿名内部类
class MainCls
{
    void main()
    {
        /** 以下三种方式相同 **/
        /* 方式一 */
        ICls minterface = new Cls();
        Cls cls1 = new Cls(minterface);
        /* 方式二 */
        Cls cls2 = new Cls(new Cls());                          // new Cls()匿名对象
        /* 方式三* ※这种方式在C#中是不支持的 */
        Cls cls3 = new Cls(new ICls() {                         // new ICls() { ... }匿名内部类，即接口也可以内部类的方式实例化，但实例化的同时必须实现该接口
            @java.lang.Override
            public void run()
            {
                System.out.println("mmm");
            }
        });
        /* 方式四 */
        Cls cls4 = new AbsCls() {};                             // ¤注意：AbsCls是abstract的，正常不能直接实例化，这里实际是以匿名内部类的形式，
                                                                // 实例化了一个AbsCls的子类
    }
}

public class Cls implements ICls
{
    public void run()
    { }
    public Cls() { }
    public Cls(ICls i) { }
}

public abstract class AbsCls implements ICls
{
    public void run()
    { }
    public Cls() { }
    public Cls(ICls i) { }
}

interface ICls
{
    void run();
}



●内部类
局部变量的生命周期与局部内部类的对象的生命周期的不一致。
内部类里面使用外部类的局部变量时，其实就是内部类的对象在使用它，内部类对象生命周期中都可能调用它，而内部类试图访问外部方法中的局部变量时，外部方法的局部变量很可能已经不存在了，那么就得延续其生命，拷贝到内部类中，而拷贝会带来不一致性，从而需要使用final声明保证一致性，复制保证生命周期延续，final保证引用一致。
（1）
// 当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员
class A {
    /*
     * 创建静态内部类对象的一般形式为：
     * 外部类类名.内部类类名 xxx = new 外部类类名.内部静态类类名()
     * 外部类类名.内部类类名 xxx = new 外部类类名().new 内部类类名()
     * 外部类类名.内部类类名 xxx = 外部对象.new 内部类类名()
     */

    private static void do1() {
        //B b = new B();　　　　　　　　　　　　　　// 编译时错误
        B b = new A().new B();                      // ※内部类属于其外部类的一个实例，而非外部类本身
        b.dynamicDo();

        C c = new A.C();
        c.dynamicDo();
        C.staticDo();
    }

    public void do2() {
        B b1 = new B();
        B b2 = this.new B();
        b2.dynamicDo();

        C c = new A.C();
        c.dynamicDo();
        C.staticDo();
    }

    class B {
        //public static void staticDo() {}        // Inner class cannot have static declarations
        public void dynamicDo() {}
    }

    static class C {
        public static void staticDo() {}
        public void dynamicDo() {}
    }
}


（2）例
public class Test {
    public static void main(String[] args)  {
        Outter outter = new Outter();
        outter.new Inner().print();
    }
}
 
 
class Outter
{
    private int a = 1;
    class Inner {
        private int a = 2;
        public void print() {
            int a = 3;
            System.out.println("局部变量：" + a);
            System.out.println("内部类变量：" + this.a);
            System.out.println("外部类变量：" + Outter.this.a);
        }
    }
}




（3）常见问题
No enclosing instance of type * is accessible 
错误信息：No enclosing instance of type Test_drive is accessible. Must qualify the allocation with an enclosing instance of type Test_drive (e.g. x.new A() where x is an instance of Test_drive).

public class Test_drive {
  
  public static void main(String[] args) {
    A a = new A();　　　　　　　　　　　　　　// 编译时错误
    B b = new B();　　　　　　　　　　　　　　// 编译时错误
    System.out.println(b instanceof A);
  }
  class A{
    int a;
  }
  class B extends A{
  }
}

A和B都是Test_drive的内部类，类似静态方法中不能调用动态方法，类的静态方法不可以直接调用内部类的实例对象，但可以调用外部类的实例对象。在这里，内部类不是静态的内部类，所以，直接赋值（即实例化内部类），所以程序报错。

Test_drive td = new Test_drive();
A a = td.new A();
B b = td.new B();






4.接口
◆default
interface IInterface {
    void MyFunc();
    // 默认方法
    default void haha() {
        System.out.println("hahahaha...");
    }
}
class MyClass implements IInterface {
    @Override
    public void MyFunc();
}
class MainClass {
    //方式一
    MyClass myclass1 = new MyClass();
    //方式二：匿名类（在C#中不允许）
    IInterface myclass2 = new IInterface()
    {
        @Override
        public void MyFunc()
        {
            ...
        }
    }
}



public interface A {
    default void hello() {
        System.out.println("Hello from A");
    }
}
public interface B {
    default void hello() {
        System.out.println("Hello from B");
    }
}
public class C implements B, A { }
// 由于java编译器无法判断该实现哪个接口于是抛出异常 Error: class C inherits unrelated defaults for hello()from types B and A 提示你去实现其中一个方法
public class C implements B, A {
    void hello(){
        B.super.hello();
    }
}



◆字段
接口中可定义字段，但接口中定义的字段会自动具有static和final属性。它们不能是“空白final”，但可初始化成非常数表达式。
public interface RandVals {
  int rint = (int)(Math.random() * 10);
  long rlong = (long)(Math.random() * 10);
  float rfloat = (float)(Math.random() * 10);
  double rdouble = Math.random() * 10;
}

public class TestRandVals {
  public static void main(String[] args) {
    // ※相应字段会转换为static的
    System.out.println(RandVals.rint);
    System.out.println(RandVals.rlong);
    System.out.println(RandVals.rfloat);
    System.out.println(RandVals.rdouble);
  }
}


5.java闭包
--javascript通过function
--C#通过Func
--java通过内部类

public class DemoClass1 {
    private int length =0;

    //private|public
    private class InnerClass implements ILog
    {
        @Override
        public void Write(String message) {
            //DemoClass1.this.length = message.length();
            length = message.length();
            System.out.println("DemoClass1.InnerClass:" + length);
        }
    }
    
    public ILog logger() {
        return new InnerClass();
    }
 
    public static void main(String[] args) {
        DemoClass1 demoClass1 = new DemoClass1();
        demoClass1.logger().Write("abc");
        
        //.new
        DemoClass1 dc1 = new DemoClass1();
        InnerClass ic = dc1.new InnerClass();
        ic.Write("abcde");
    }
}


6.父类
//手机接口
public interface IPhone {
    default void communication() { System.out.println("使用手机进行通讯..."); }
}

//对讲机接口
public interface IInterphone {
    default void communication() { System.out.print("使用对讲机进行通讯..."); }
}

//万能手机，既要实现对讲机接口又要实现手机接口
public class UniversalPhone implements IInterphone, IPhone {
    @Override
    public void communication() {
        IInterphone.super.communication();                                          // 显式指定调用哪一个父接口方法
    }
}





四、修饰符
36、Java 中的final关键字有哪些用法？
答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。


作用域       同类 同包异类 子孙类   其他包
private       √     ×      ×      ×
default       √     √      ×      ×
protected     √     √      √      ×
public        √     √      √      √

1.abstract
（1）
·抽象类不可被实例化，抽象类只能声明引用，不能创建对象
·若子类继承抽象类，并重写了所有的抽象方法，则此类是一个“实体类”，即可以实例化
·若子类继承抽象类，没有重写所有的抽象方法，意味着此类中仍有抽象方法，则此类必须声明为抽象的！
·抽象方法，只有声明，没有实现。具体的执行，交给继承抽象类的子类，由子类重写此抽象方法


三、流操作
1.StreamReader、StreamWriter
StreamReader、StreamWriter
System.in
System.out.println("xxx")
System.err.println("xxx")

2.FileInputStream/FileOutputStream
速记：
len = in.read(buf);
len = in.read(buf, 0, n);
out.write(buf);
out.write(buf, 0, len);

FileInputStream in = new FileInputStream("d:\\myfile.txt");
FileOutputStream out = new FileOutputStream("d:\\downloads\\out.txt");
byte[] buf = new byte[2];
int len = in.read(buf);
while (len > -1) {
    out.write(buf, 0, len);
    len = in.read(buf);
}
String content = new String(buf, 0, len);   //将读取的字节转为字符串对象
//加锁
in.getChannel().tryLock();                  //不能加锁立即返回null
in.getChannel().lock();                     //等待，直到能够加锁

3.InputStream/OutputStream
·String to InputStream

byte[] bytes = "我的文字".getBytes();
byte[] bytes = "我的文字".getBytes("UTF-8");

InputStream in_nocode = new ByteArrayInputStream(bytes);
InputStream in_withcode = new ByteArrayInputStream(bytes);

·InputStream to String 
这里提供几个方法。
方法1：
public String convertStreamToString(InputStream is) {
    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    StringBuilder sb = new StringBuilder();

    String line = null;
    try {    
        while ((line = reader.readLine()) != null) {
            sb.append(line + "/n");
        }    
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    return sb.toString();
}
 
方法2：
public String inputStream2String (InputStream in) throws IOException { 
    StringBuffer out = new StringBuffer(); 
    byte[] b = new byte[4096]; 
    for (int n ; (n = in.read(b)) != -1;) { 
        out.append(new String(b, 0, n)); 
    } 
    return out.toString(); 
} 

方法3：
public static String inputStream2String(InputStream is) throws IOException{ 
    ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
    int i= -1; 
    while ((i = is.read()) != -1) { 
        baos.write(i); 
    } 
    return baos.toString(); 
} 



4.Properties
<!-- 指定配置文件，指定多个可用逗号分隔 -->
<context:property-placeholder     
       location=""    
       file-encoding=""    
       ignore-resource-not-found=""   
       ignore-unresolvable=""    
       properties-ref=""    
       local-override=""    
       system-properties-mode=""   
       order=""    
/>
<context:property-placeholder location="classpath:db.properties"/>
<context:property-placeholder location="classpath:db.properties,classpath:monitor.properties"/>

// 创建Properties
Properties properties = new Properties();
// 从文件加载Properties
properties.load(new FileInputStream(filePath));
// 获取Property
properties.getProperty(key)
// 设置Property
properties.setProperty(pKey, pValue);
// 将Properties写入新文件
properties.store(new FileOutputStream(filePath), "comments");




String configFilePath = "/conf/resources.properties";

Properties properties;

Resource resource;
resource = new FileSystemResource(configFilePath);
resource = new ClassPathResource(configFilePath);
properties = PropertiesLoaderUtils.loadProperties(resource);
// 或
InputStream stream;
stream = new FileInputStream(configFilePath)；
stream = Object.class.getResourceAsStream(configFilePath);
properties = PropertiesLoaderUtils.load(stream);




三、IO操作
Files.copy(Paths.get(html, "index.html"), htmlOutputFile, StandardCopyOption.REPLACE_EXISTING);




三、网络
1.Http
可以使用 Android 集成进来的 apache 中关于联网的API：
  HttpParams ：保存Http请求设定的参数对象
  HttpConnectionParams ：提供对Http连接参数进行设定的方法，比如 连接超时时间 等。
  HttpClient ：发起Http连接请求的对象，
  HttpResponse ：Http 请求返回的响应 
  最后，其实apache还是提供了释放 连接资源的方法的，不过是埋得深了点。
  httpClient.getConnectionManager().shutdown();
  这个shutdown并不是将手机网络断掉，而是将建立Http连接请求时所分配的资源释放掉。
A.基于Apache的HttpClient
<uses-permission android:name="android.permission.INTERNET"></uses-permission>

·pom.xml
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
        <version>4.5.3</version>
    </dependency>


URIBuilder uriBuilder = new URIBuilder("http://www.sogou.com/web");
uriBuilder.addParameter("query","花千骨");

List<NameValuePair> nvps
uriBuilder.addParameters(nvps);

String url = uriBuilder.build();




·HttpClientUtil.java
public class HttpClientUtil {
    public CookieStore cookieStore = new BasicCookieStore();
    public CloseableHttpClient httpCilent = HttpClients.custom().setDefaultCookieStore(cookieStore).build();
    // 配置超时时间
    RequestConfig requestConfig = RequestConfig
            .custom()
            .setConnectTimeout(1000)
            .setConnectionRequestTimeout(1000)
            .setSocketTimeout(1000)
            .setRedirectsEnabled(true)
            .build();

    public static HttpClientBuilder buildHttpClient() {
        HttpClientBuilder builder = HttpClients.custom();
        return builder;
    }

    public static HttpClientBuilder setCookieStore(HttpClientBuilder builder, CookieStore cookieStore) {
        HttpClientBuilder builder = builder.setDefaultCookieStore(cookieStore);
        return builder;
    }

    public static HttpClientBuilder setProxy(HttpClientBuilder builder, HttpHost httpHost) {
        HttpClientBuilder builder = builder.setProxy(httpHost);
        return builder;
    }

    public static HttpClientBuilder setProxy(HttpClientBuilder builder, String hostname, int port, String scheme) {
        HttpHost httpHost = new HttpHost(hostname, port, scheme);
        HttpClientBuilder builder = builder.setProxy(httpHost);
        return builder;
    }

    public static HttpHost buildHostProxy(String hostname, int port, String scheme) {
        return buildHostProxy = new HttpHost(hostname, port, scheme);
    }

    public static String buildUrlEncodedFormEntity(List<BasicNameValuePair> list, String charset) {
        AbstractHttpEntity entity = new UrlEncodedFormEntity(list, charset);                // "UTF-8"
        return entity
    }

    public static String buildJsonEntity(String body, String charset) {
        AbstractHttpEntity entity = new StringEntity(new Gson().toJson(dict), charset);      // "UTF-8"
        entity.setContentType("application/json");
        return entity
    }

    public static String buildJsonEntity(Object body, String charset) {
        AbstractHttpEntity entity = new StringEntity(new Gson().toJson(body), charset);      // "UTF-8"
        entity.setContentType("application/json");
        return entity;
    }

    public static String buildStringEntity(String body, String charset) {
        StringEntity entity = new StringEntity(body, charset);！！！！！！！！
        // entity.setContentEncoding("UTF-8");
        return entity;
    }

    public static HttpResponse httpPost(String url, AbstractHttpEntity entity) {
        HttpPost httpPost = new HttpPost(url);
        httpPost.setConfig(requestConfig);
        httpPost.setEntity(entity);
        HttpResponse response = httpCilent.execute(httpPost);
        return response == null ? null : response;
    }

    public static HttpResponse httpGet(String url, AbstractHttpEntity entity) {
        HttpGet httpGet = new HttpGet(url);
        httpGet.setConfig(requestConfig);
        httpGet.setEntity(entity);
        HttpResponse response = httpCilent.execute(httpGet);
        return response == null ? null : response;
    }

    public static getResult(HttpResponse response) {
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode == 200) {
            Entity！！！！ entity = httpResponse.getEntity();
            return EntityUtils.toString(entity);
        }
        else {！！！！！！
            Entity！！！！ entity = httpResponse.getEntity();
            return EntityUtils.toString(entity);
        }
        
    }
}










package com.easymorse;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

I.HttpGet
JSONObject holder = new JSONObject(); 
holder.put("version", "1.1.0"); 
holder.put("host", "maps.google.com"); 
StringEntity se = new StringEntity(holder.toString()); 


    String urlStr;
    HttpClient client = new DefaultHttpClient();
    //设置代理服务器地址和端口
    //client.getHostConfiguration().setProxy("proxy_host_addr", proxy_port);
    //使用GET方法，如果服务器需要通过HTTPS连接，那只需要将下面URL中的http换成https
    //HttpMethod method = new GetMethod("http://java.sun.com";);

    urlStr = "http://10.192.122.201/grc4-update/handlers/logindb.ashx";
    urlStr += "?username=admin&password=admin";
    HttpGet get = new HttpGet(urlStr);
    try {
		HttpResponse hr = client.execute(get);
		HttpEntity entity = hr.getEntity(); 
		System.out.println(  hr.getStatusLine().getStatusCode()  );
		return EntityUtils.toString(entity);
	}
	catch (Exception e) {
	}


II.HttpPost
    String urlStr;
    HttpClient client = new DefaultHttpClient();
    urlStr = "http://10.192.122.201/grc4-update/handlers/logindb.ashx";
    HttpPost post = new HttpPost(urlStr);
    /* BasicNameValuePair是NameValuePair的子类是键值对 */
    List<NameValuePair> params = new ArrayList<NameValuePair>();
    params.add(new BasicNameValuePair("username", "admin"));
    params.add(new BasicNameValuePair("password", "admin"));
    try {
        post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));
        HttpResponse hr = client.execute(post);
        HttpEntity entity = hr.getEntity(); 
        return EntityUtils.toString(entity));
        BufferedReader br = new BufferedReader(new InputStreamReader(entity.getContent())); 
    }
    catch (Exception e) {
    }


III.HttpClient连接超时
    在以前做一个android的移动项目的时候，想为httpClient对象添加请求超时和读取超时时间，发现httpClient的对象实现的 defaultHttpClient对象中就没有设置超时时间的方法，所以一直郁闷的，觉得怎么回没有，难道defaultHttpClient对象中已经封装了请求超时时间和读取时间，不过这样不是可扩张性不好了，最近在android论坛上面，发现了其实android的httpClient是可以的，不过设置在HttpConnectionParams的静态方法中设置，详细的我写了一段代码提供给大家：
private static final int REQUEST_TIMEOUT = 10*1000;//设置请求超时10秒钟  
private static final int SO_TIMEOUT = 10*1000;  //设置等待数据超时时间10秒钟  //读数据操作时,最多阻塞10秒钟

/**  
 * 添加请求超时时间和等待时间  
 * @author spring sky   
 * Email vipa1888@163.com  
 * QQ: 840950105  
 * My name: 石明政  
 * @return HttpClient对象  
 */ 
public HttpClient getHttpClient() {  
    BasicHttpParams httpParams = new BasicHttpParams();  
    HttpConnectionParams.setConnectionTimeout(httpParams, REQUEST_TIMEOUT);  
    HttpConnectionParams.setSoTimeout(httpParams, SO_TIMEOUT);  
    HttpClient client = new DefaultHttpClient(httpParams);  
    return client;  
} 
上面的方法，可以为每个请求公用，以后维护也很方便！个人建议，把这个方法在写父类让子类继承，这样的话符合面向对象编程！

B.基于原始的java.io包
      URL url = new URL(urlStr);
      HttpURLConnection con=(HttpURLConnection)url.openConnection(); 
      /* 允许Input、Output，不使用Cache */ 
      con.setDoInput(true); 
      con.setDoOutput(true); 
      con.setUseCaches(false); 
      con.setConnectTimeout(10000);
      /* 设置传送的method=POST */ 
      con.setRequestMethod("POST"); 
      /* setRequestProperty */  
      con.setRequestProperty("Connection", "Keep-Alive"); 
      con.setRequestProperty("Charset", "UTF-8"); 
      con.setRequestProperty("Content-Type", "multipart/form-data;boundary=****"); 
      con.setRequestProperty("type", "txt"); 
      con.setRequestProperty("name", "e"); 
      //相当于设置了一个HttpPost  
      DataOutputStream ds = new DataOutputStream(con.getOutputStream()); //准备输出数据 
      /* 取得文件的FileInputStream */ 
      FileInputStream fStream = new FileInputStream(uploadFile); 
      /* 设置每次写入1024bytes */ 
      int bufferSize = 1024; 
      byte[] buffer = new byte[bufferSize]; 
      int length = -1; 
      /* 从文件读取数据至缓冲区 */ 
      while((length = fStream.read(buffer)) != -1) 
      { 
        /* 将资料写入DataOutputStream中 */ 
        ds.write(buffer, 0, length); //在输出流里面写数据 
      } 
      /* close streams */ 
      fStream.close(); 
      ds.flush(); 


2.Ftp
1）上传
private static void FTPUpload() {   
    FTPClient ftpclient = new FTPClient();   
    try {   
        ftpclient.connect("127.0.0.1");   
        ftpclient.login("ftpname", "ftppw");   
        File file = new File("d:" + File.separator + "ToFTP.txt");   
        ftpclient.changeWorkingDirectory("/");   
        ftpclient.setBufferSize(1024);   
        ftpclient.setControlEncoding("UTF-8");   
        ftpclient.setFileType(ftpclient.BINARY_FILE_TYPE);   
        
        FileInputStream fis = new FileInputStream(file);   
        ftpclient.storeFile("file.txt", fis);   
    } catch (IOException e) {   
        // TODO Auto-generated catch block  
        e.printStackTrace();   
    }   
}   


2）下载
private static void FTPDownload() {
    FTPClient ftpclient = new FTPClient();
    try {
        ftpclient.connect("127.0.0.1");
        ftpclient.login("ftpname", "ftppw");
        File file = new File("d:"+File.separator+"ToLocal.txt");
        ftpclient.changeWorkingDirectory("/");
        ftpclient.setBufferSize(1024);
        ftpclient.setControlEncoding("UTF-8");
        ftpclient.setFileType(ftpclient.BINARY_FILE_TYPE);

        FileOutputStream fos = new FileOutputStream(file);
        ftpclient.retrieveFile("file.txt", fos);
    } catch (IOException e) {
        // TODO Auto-generated catch block  
        e.printStackTrace();
    }
}  



3.socket
A.概念
　　所谓socket通常也称作"套接字"，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过"套接字"向网络发出请求或者应答网络请求。 
　　以J2SDK-1.3为例，Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。 

B.重要的Socket API：
　　java.net.Socket继承于java.lang.Object，有八个构造器，其方法并不多，下面介绍使用最频繁的三个方法，其它方法大家可以见JDK-1.3文档。 
　　. Accept方法用于产生"阻塞"，直到接受到一个连接，并且返回一个客户端的Socket对象实例。“阻塞”是一个术语，它使程序运行暂时"停留"在这个地方，直到一个会话产生，然后程序继续；通常"阻塞"是由循环产生的。 
　　. getInputStream方法获得网络连接输入，同时返回一个IutputStream对象实例，。 
　　. getOutputStream方法连接的另一端将得到输入，同时返回一个OutputStream对象实例。 
　　注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。 

C.步骤
双方连接上后，就开始读写了
InputStream in = socket.getInputStream();
OutputStream out = socket.getOutputStream();
out.write(…);
in.read(…);
…
in.close();
out.close();
socket.close();


服务器：
（1）建立服务器socket
ServerSocket serverSocket = new ServerSocket(port);
（2）等待客户端连接
Socket client = serverSocket.accept(); 
（3）流处理
OutputStream outputStream = client.getOutputStream();
InputStream inputstream = getContentResolver().openInputStream(Uri.parse("http://www.baidu.com"));
int len;
while ((len = inputStream.read(buf)) != -1) {
    outputStream.write(buf, 0, len);
    outputStream.flush();
}
（4）关闭连接
inputstream.close();
outputStream.close();
client.close();
serverSocket.slose();

客户端：
（1）建立socket
Socket client = new Socket();
client.bind(null);
（2）连接指定服务器
client.connect((new InetSocketAddress(host, port)), Timeout);
（3）流处理
InputStream inputstream = client.getInputStream();
（4）关闭连接
inputstream.close();
client.close();



D.判断socket服务器端是否断开连接 [经典] 
最近在开发中遇到一个问题，就是如何判断远端服务器是否已经断开连接，如果断开那么需要重新连接。
首先想到socket类的方法isClosed()、isConnected()、isInputStreamShutdown()、isOutputStreamShutdown()等，但经过试验并查看相关文档，这些方法都是本地端的状态，无法判断远端是否已经断开连接。
然后想到是否可以通过OutputStream发送一段测试数据，如果发送失败就表示远端已经断开连接，类似ping，但是这样会影响到正常的输出数据，远端无法把正常数据和测试数据分开。
最后又回到socket类，发现有一个方法sendUrgentData，查看文档后得知它会往输出流发送一个字节的数据，只要对方Socket的SO_OOBINLINE属性没有打开，就会自动舍弃这个字节，而SO_OOBINLINE属性默认情况下就是关闭的，太好了，正是我需要的！
于是，下面一段代码就可以判断远端是否断开了连接：
try{
    socket.sendUrgentData(0xFF);
}catch(Exception ex) {
    reconnect();
}
 
 
 
用ping实现
package com.csdn.test;
　　import java.io.BufferedReader;
　　import java.io.IOException;
　　import java.io.InputStreamReader;
　　public class test {
　　　　static BufferedReader bufferedReader;
　　　　public static void main(String[] args) throws IOException {
　　　　　　try {
　　　　　　Process process = Runtime.getRuntime().exec("ping 192.168.1.104");                        //判断是否连接的IP;
　　　　　　bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
　　　　　　String connectionStr = "";
　　　　　　while ((connectionStr = bufferedReader.readLine()) != null) {
　　　　　　　　System.out.println(connectionStr);
　　　　　　}
　　　　　　} catch (IOException e) {
　　　　　　　　e.printStackTrace();
　　　　　　} finally {
　　　　　　　　bufferedReader.close();
　　　　　　}
　　　　}
　　}

ping的方法有个严重的BUG，就是你只能判断对方是否连接网络，而不能判断客户端是否开启...
我在写聊天室时经常要注意客户端异常退出的问题(比如客户直接调用任务管理器结束程序进程)，
其实在通过socket.getoutstream和socket.getinputstream流对客户端发送、接受信息时如果socket没连接上是会抛出异常的，这也就是为什么Java会要求网络编程都要写在try里面，所以只要在catch里面写入客户端退出的处理就行了，没必要专门去想什么方法



E.例
原理：
　　服务器，使用ServerSocket监听指定的端口，端口可以随意指定（由于1024以下的端口通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于1024的端口），等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。
　　客户端，使用Socket对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话完成后，关闭Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个1024以上的端口。

（1）服务器端
//这个程序建立了一个服务器，它一直监听10000端口，等待用户连接。在建立连接后给客户端返回一段信息，然后结束会话。这个程序一次只能接受一个客户连接。 
import java.net.*;
import java.io.*;

public class Server {
	private ServerSocket ss;
	private Socket socket;
	private BufferedReader in;
	private PrintWriter out;

	public Server() {
		try {
			ss = new ServerSocket(10000);

			while (true) {
				socket = ss.accept();
				in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
				out = new PrintWriter(socket.getOutputStream(), true);

				String line = in.readLine();
				out.println("you input is :" + line);
				out.close();
				in.close();
				socket.close();
			}
			ss.close();
		} catch (IOException e) {
		}
	}

	public static void main(String[] args) {
		new Server();
	}
}

（2）客户端
//这个客户端连接到地址为xxx.xxx.xxx.xxx的服务器，端口为10000，并从键盘输入一行信息，发送到服务器，然后接受服务器的返回信息，最后结束会话。 
import java.io.*;
import java.net.*;

public class Client {
	Socket socket;
	BufferedReader in;
	PrintWriter out;

	public Client() {
		try {
			socket = new Socket("xxx.xxx.xxx.xxx", 10000);
			in = new BufferedReader(new InputStreamReader(
					socket.getInputStream()));
			out = new PrintWriter(socket.getOutputStream(), true);
			BufferedReader line = new BufferedReader(new InputStreamReader(
					System.in));

			out.println(line.readLine());
			line.close();
			out.close();
			in.close();
			socket.close();
		} catch (IOException e) {
		}
	}

	public static void main(String[] args) {
		new Client();
	}
}

（3）多个客户同时连接 
　　在实际的网络环境里，同一时间只对一个用户服务是不可行的。一个优秀的网络服务程序除了能处理用户的输入信息，还必须能够同时响应多个客户端的连接请求。在java中，实现以上功能特点是非常容易的。
　　设计原理：
　　主程序监听一端口，等待客户接入；同时构造一个线程类，准备接管会话。当一个Socket会话产生后，将这个会话交给线程处理，然后主程序继续监听。运用Thread类或Runnable接口来实现是不错的办法。
import java.io.*;
import java.net.*;

public class Server extends ServerSocket {
	private static final int SERVER_PORT = 10000;

	public Server() throws IOException {
		super(SERVER_PORT);

		try {
			while (true) {
				Socket socket = accept();
				new CreateServerThread(socket);
			}
		} catch (IOException e) {
		} finally {
			close();
		}
	}

	// --- CreateServerThread
	class CreateServerThread extends Thread {
		private Socket client;
		private BufferedReader in;
		private PrintWriter out;

		public CreateServerThread(Socket s) throws IOException {
			client = s;

			in = new BufferedReader(new InputStreamReader(
					client.getInputStream(), "GB2312"));
			out = new PrintWriter(client.getOutputStream(), true);
			out.println("--- Welcome ---");
			start();
		}

		public void run() {
			try {
				String line = in.readLine();

				while (!line.equals("bye")) {
					String msg = createMessage(line);
					out.println(msg);
					line = in.readLine();
				}
				out.println("--- See you, bye! ---");
				client.close();
			} catch (IOException e) {
			}
		}

		private String createMessage(String line) 
		{ 
			........; 
		}
	}

	public static void main(String[] args) throws IOException {
		new Server();
	}
}

（4）实现信息共享：在Socket上的实时交流 
　　 网络的伟大之一也是信息共享，Server可以主动向所有Client广播消息，同时Client也可以向其它Client发布消息。下面看看如何开发一个可以实时传递消息的程序。
　　 服务器端接受客户端的连接请求，同时启动一个线程处理这个连接，线程不停的读取客户端输入，然后把输入加入队列中，等候处理。在线程启动的同时将线程加入队列中，以便在需要的时候定位和取出。
import java.io.*;
import java.net.*;
import java.util.*;
import java.lang.*;

public class Server extends ServerSocket {
	private static ArrayList User_List = new ArrayList();
	private static ArrayList Threader = new ArrayList();
	private static LinkedList Message_Array = new LinkedList();
	private static int Thread_Counter = 0;
	private static boolean isClear = true;
	protected static final int SERVER_PORT = 10000;
	protected FileOutputStream LOG_FILE = new FileOutputStream(
			"d:/connect.log", true);

	public Server() throws FileNotFoundException, IOException {
		super(SERVER_PORT);
		new Broadcast();

		// append connection log
		Calendar now = Calendar.getInstance();
		String str = "[" + now.getTime().toString() + "] Accepted a connection\015\012";
		byte[] tmp = str.getBytes();
		LOG_FILE.write(tmp);

		try {
			while (true) {
				Socket socket = accept();
				new CreateServerThread(socket);
			}
		} finally {
			close();
		}
	}

	public static void main(String[] args) throws IOException {
		new Server();
	}

	// --- Broadcast
	class Broadcast extends Thread {
		public Broadcast() {
			start();
		}

		public void run() {
			while (true) {
				if (!isClear) {
					String tmp = (String) Message_Array.getFirst();

					for (int i = 0; i < Threader.size(); i++) {
						CreateServerThread client = (CreateServerThread) Threader
								.get(i);
						client.sendMessage(tmp);
					}

					Message_Array.removeFirst();
					isClear = Message_Array.size() > 0 ? false : true;
				}
			}
		}
	}

	// --- CreateServerThread
	class CreateServerThread extends Thread {
		private Socket client;
		private BufferedReader in;
		private PrintWriter out;
		private String Username;

		public CreateServerThread(Socket s) throws IOException {
			client = s;
			in = new BufferedReader(new InputStreamReader(
					client.getInputStream()));
			out = new PrintWriter(client.getOutputStream(), true);
			out.println("--- Welcome to this chatroom ---");
			out.println("Input your nickname:");
			start();
		}

		public void sendMessage(String msg) {
			out.println(msg);
		}

		public void run() {
			try {
				int flag = 0;
				Thread_Counter++;
				String line = in.readLine();

				while (!line.equals("bye")) {
					if (line.equals("l")) {
						out.println(listOnlineUsers());
						line = in.readLine();
						continue;
					}

					if (flag++ == 0) {
						Username = line;
						User_List.add(Username);
						out.println(listOnlineUsers());
						Threader.add(this);
						pushMessage("[< " + Username + " come on in >]");
					} else {
						pushMessage("<" + Username + ">" + line);
					}

					line = in.readLine();
				}

				out.println("--- See you, bye! ---");
				client.close();
			} catch (IOException e) {
			} finally {
				try {
					client.close();
				} catch (IOException e) {
				}

				Thread_Counter--;
				Threader.remove(this);
				User_List.remove(Username);
				pushMessage("[< " + Username + " left>]");
			}
		}

		private String listOnlineUsers() {
			String s = "-+- Online list -+-\015\012";

			for (int i = 0; i < User_List.size(); i++) {
				s += "[" + User_List.get(i) + "]\015\012";
			}

			s += "-+---------------------+-";
			return s;
		}

		private void pushMessage(String msg) {
			Message_Array.addLast(msg);
			isClear = false;
		}
	}
}







四、包
.classpath

<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="src" path="lib"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
	<classpathentry kind="lib" path="lib/hadoop-common-2.5.1.jar"/>
	<classpathentry kind="lib" path="lib/hadoop-hdfs-2.5.1.jar"/>
	<classpathentry kind="lib" path="lib/hadoop-mapreduce-client-common-2.5.1.jar"/>
	<classpathentry kind="lib" path="lib/hadoop-mapreduce-client-core-2.5.1.jar"/>
	<classpathentry kind="lib" path="lib/hadoop-mapreduce-client-jobclient-2.5.1.jar"/>
	<classpathentry kind="lib" path="lib/hadoop-mapreduce-client-shuffle-2.5.1.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>






五、java中执行linux命令
1、执行linux命令，并得到输出信息
    protected void exCmd(String cmd) {
    	Process process = null;
    	InputStream is = null;
    	InputStreamReader ir = null;
    	LineNumberReader input = null;
    	StringBuffer outInfo = null;
    	
    	try {
    		process = Runtime.getRuntime().exec(cmd);
    		is = process.getInputStream();
    		ir = new InputStreamReader(is);
    		input = new LineNumberReader(ir);   //或LineNumberReader->DataInputStream
    		String line;
    		
    		while ((line = input.readLine()) != null) {
    			outInfo.append(line);
    			System.out.println(line);
    		}
    	} catch (java.io.IOException e) {
    		System.err.println("IOException " + e.getMessage());
    	}
    	finally{
    		try{
    			if (ir != null) {
    				ir.close();
    			}
    			if (is != null) {
    				is.close();
    			}
    			if (process != null) {
    				process.destroy();
    			}
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    	}
    	
    }









六、泛型
A.占位符T和?
T和?都用于泛型中，对确定类型进行占位，所不同的是他们使用的
Class<T>：※代表某一种指定的具体类型，有约束。
  •通常用于“类、接口或方法”的定义，作用于模板上，用于将数据类型进行参数化。
  •可用于“声明对象”，此时T要替换成具体类型。
  •不能用于“直接”“实例化对象”，必须通过反射进行实例化。
Class<?>：※是个通配泛型，代表任何类型，是对T的再一次抽象，没有约束。
  •不可用于“定义类或接口”，因为必须指定一个具体类型，通常用于泛型方法的调用代码和形参上
  •用于“声明对象的过程”时，不确定泛型参数的具体类型时，可以使用通配符进行对象定义。


★返回? 与 <T> 的区别：? 需要显式转换
public <T extends Exception> ArrayList<T> returnByGeneric() {
    return null;
}

public ArrayList<? extends Exception> returnByQMark() {
    return new ArrayList();
}

public void test() {
    ArrayList<Exception> a1 = returnByGeneric();
    ArrayList<Exception> a2 = (ArrayList<Exception>) returnByQMark1();
    // 此行报错：Incompatible types. Found: 'java.util.ArrayList<capture<? extends java.lang.Exception>>', required: 'java.util.ArrayList<java.lang.Exception>'
    ArrayList<Exception> a3 = returnByQMark();
    
    ArrayList<T extends Exception> a4 = new ArrayList<Exception>();
    ArrayList<? extends Exception> a5 = new ArrayList<Exception>();
}


B.约束条件
1.默认约束
默认隐式条件下，两者都extends于Object对象，即：
class Book<T> {} 等同于 class Book<T extends Object> {}
class Book<?> {} 等同于 class Book<? extends Object> {}
也可显式指定约束条件，同普通的类或接口一样，但统一都使用extends，而不用implements，如：
public class Menu<T extends Paper> {}
public Menu<? extends Paper> getMenu() {}


2.上下限约束
<? extends T>上限通配，表示T的一个未知子类。
<? super T>下限通配，表示T的一个未知父类。 
如：
List<? extends Paper> papers = new ArrayList<Book>();               // extends上界通配符，协变
List<? super Book> papers = new ArrayList<Paper>();                 // super下界通配符，逆变

约束可以有多个，但只能有一个class，如：
List<? extends Paper & Water & Gold> papers = new ArrayList<Book>();

3.区别
// ★extends
List<? extends Number> eList = new ArrayList<Integer>();
Number numObject = eList.get(0);                                    // 语句1，正确
Integer intObject = eList.get(0);                                   // 语句2，错误：Type mismatch: cannot convert from capture#3-of ? extends Number to Integer
eList.add(new Integer(1));                                          // 语句3，错误：The method add(capture#3-of ? extends Number) in the type List<capture#3-of ? extends Number> is not applicable for the arguments (Integer)

// ★super
List<? super Integer> sList = new ArrayList<Number>();
Number numObj = sList.get(0);                                       // 语句1，错误：Type mismatch: cannot convert from capture#5-of ? super Integer to Number
Integer intObj = sList.get(0);                                      // 语句2，错误：Type mismatch: cannot convert from capture#6-of ? super Integer to Integer
sList.add(new Integer(1));                                          // 语句3，正确

如
  List<?> unknownList;
  List<? extends Number> unknownNumberList;                         // 向上限制。指明泛型类持有T的导出类，则返回值一定可作为T的协变类型返回
  List<? super Integer> unknownBaseLineIntgerList;                  // 向下限制。逆变指明泛型类持有T的基类，则T肯定可以放入

C.Class和Type
●Class
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {
    ...
}

●Type
public interface Type {
    default String getTypeName() {
        return toString();
    }
}

∴从中可以看出，Type是Class实现的一个接口

User    User.class    User.class.newInstance()
T       Class<T>      t


D.返回值为泛型类型
跟.net一样，如果返回一个泛型对象，需要在“方法名称”中显式指定泛型的类型，而java不但如此，也可以在“方法体”内指定返回的泛型类型，如：
// .net
public T get<T>(){ }

// java
public <T extends Page> T get(T t){ return t; }

// java
public <T> T get(){ return (T)new Object(); }


E.显式指定泛型类型
public <T> void d(String summary, T t) {
    this.debug(summary, t);
}
public static <T> void e(String summary, T t) {
    error(summary, t);
}

public void main() {
    Log log = new Log();
    log.<Book>d("summary", new Book());
    Log.<Book>d("summary", new Book());
}


F.泛型擦除
class Fruit<T> extends Food {
    public T t;
}
class Food<T>{
    public T t;
    public Food(){
        Type genericSuperclass = getClass().getGenericSuperclass();
        System.out.println(genericSuperclass);
    }
}
class Tmp extends Fruit<Teacher>{}
class Teacher{}

public class Container {
    public static void main(){
        new Fruit<Teacher>();                   // getGenericSuperclass of Fruit is com.art.Food
        new Fruit<Teacher>(){};                 // getGenericSuperclass of anonymous class is com.art.Fruit<com.art.Teacher>
        new Tmp();                              // same as above
    }
}

result:
class com.art.Food
com.art.Fruit<com.art.Teacher>
com.art.Fruit<com.art.Teacher>

TypeVariableImpl

※在Java代码运行的时候，它会将泛型类的类型信息T擦除掉，就是说运行阶段，泛型类代码内部完全不知道类型参数的任何信息。
擦除带来的代价：在泛型类或者说泛型方法内部，我们无法获得任何类型信息，所以泛型不能用于显示的引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。



泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。
静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量。
泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。




G.协变和逆变
◆协变
// 虽然ArrayList<MochaCoffee>不是List<? extends Coffee>的子类，但是List<? extends X>这种代码模式是协变的，所以可以赋值
List<? extends Coffee> a = new ArrayList<MochaCoffee>();
List<? extends MochaCoffee> b = new ArrayList<MochaCoffee>();

// 虽然利用协变性，可以将ArrayList<MochaCoffee>赋值给List<? extends Coffee>，但是赋值后，List<? extends Coffee>中不能取出MochaCoffee，同时也只能添加null。因为List跟数组不一样，它在运行时插入元素时，类型信息已经被擦除为Object，无法做类型检测，只能依靠声明在编译时做严格的类型检查，List<? extends Coffee>声明意味着这个容器中的元素类型不确定，可能是Coffee的任何子类，所以往里面添加任何类型都是不安全的，但是可以取出Coffee类型
// 写操作
a = b;
a.add(null);
// 报错：不能添加MochaCoffee
a.add(new MochaCoffee());
// 报错：不能添加Coffee
a.add(new Coffee());
// 读操作
Coffee coffee = a.get(0);


◆逆变
List<? super MochaCoffee> a = new ArrayList<Coffee>();
List<? super Coffee> b = new ArrayList<Coffee>();
a = b;
// 报错
a.add(new Coffee());
//可以添加MochaCoffee
a.add(new MochaCoffee());
// 只能取出Object
Object object = a.get(0);


著名的PECS原则：“Producer Extends，Consumer Super”。生产扩展，消费超类
因为使用<? extends T>后，如果泛型参数作为返回值，用T接收一定是安全的，也就是说使用这个函数的人可以知道你生产了什么东西；
而使用<? super T>后，如果泛型参数作为入参，传递T及其子类一定是安全的，也就是说使用这个函数的人可以知道你需要什么东西来进行消费。
比如Java8新增的函数接口java.util.function.Consumer#andThen方法就体现了Consumer Super这一原则。

总结：
（1）数组是协变的。
（2）extends关键字加持的泛型是协变的。
（3）super关键字加持的泛型是逆变的。
（4）注意数组和泛型容器中添加和获取元素的类型限制。



七、lambda表达式
A.格式
() -> { statements; }               ## 没有参数
parameters -> expression            ## 一条语句的时候
(parameters) -> { statements; }     ## 多条语句的时候，需要return返回值的时候

★
"->"符号的左侧对应的是方法参数，无参数就空括号，一个参数可以省略括号，多参数不能省略，比如(x，y)；
"->"符号的右侧对应的是方法返回值，整体是一个代码块{...}，最终返回值对应方法即可。比如Function<Integer, Integer> function = x -> {return x + 1};当只有一个表达式时，{}、return均可省略。

B.引用外部对象
¤和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：
class Lambda4 {
    static int outerStaticNum;
    int outerNum;
    void testScopes() {
        Converter<Integer, String> stringConverter1 = (from) -> {
            outerNum = 23;
            return String.valueOf(from);
        };

        Converter<Integer, String> stringConverter2 = (from) -> {
            outerStaticNum = 72;
            return String.valueOf(from);
        };
    }
}
如果把int outerNum;移入到方法内部，会提示Variable used in lambda expression should be final or effectively final




八、函数式编程
A.四种基本函数式接口
说明：Predicate<T> 接口：一个T类型参数，返回boolean类型值。
结构：boolean test(T t);
例：Predicate<Integer> predicate = x -> x > 5;


说明：Function<T, R> 功能接口：一个T类型参数，返回R类型值。
结构：R apply(T t);
例：
    // 普通
    public void invokeRule(String input, Function<String, Integer> function) {
        int len = function.apply(input);
        System.out.println(len);
        return result;
    }

    // 传递性
    public Integer fun(Integer num) {
        Function<Integer, Integer> func1 = x -> x * 2;
        Function<Integer, Integer> func2 = x -> x + 2;
        Function<Integer, Integer> funAggreate = func1.andThen(func2).apply(num);
        Integer result = funAggreate.apply(num);
        return result;
    }

说明：Supplier<T> 接口：无参数，返回一个T类型值。
结构：T get();
例：Supplier<Integer> supplier = () -> 1;

    public void invokeRule(Supplier<String> supplier) {
        String word = supplier.get();
        System.out.println(word);
        return result;
    }


说明：Consumer<T> 接口：一个T类型参数，无返回值。
结构：void accept(T t);
例：
Consumer<Integer> consumer = x -> System.out.println(x);
Consumer<Integer> consumer = System.out::println;//方法引用的写法


常见的 Functional Interface 有：
Functional Interface     Parameter   Return Type      Description Types
Supplier<T>              None        T                Supplies a value of type T
Consumer<T>              T           void             Consumes a value of type T
BiConsumer<T, U>         T, U        void             Consumes values of types T and U
Predicate<T>             T           boolean          A Boolean-valued function
ToIntFunction<T>         T           int              An int-, long-, or double-valued function
ToLongFunction<T>        T           long
ToDoubleFunction<T>      T           double
IntFunction<R>           int         R                A function with argument of type int, long, or double
LongFunction<R>          long
DoubleFunction<R>        double
Function<T, R>           T           R                A function with argument of type T
BiFunction<T, U, R>      T, U        R                A function with arguments of types T and U
UnaryOperator<T>         T           T                A unary operator on the type T
BinaryOperator<T>        T, T        T                A binary operator on the type T



B.方法引用Method Reference
双冒号::
* 1. 引用静态方法 ContainingClass::staticMethodName
{
    list.forEach(n -> System.out.println(n));
    可以替换成
    list.forEach(System.out::println);
}

* 2. 引用特定对象的实例方法 containingObject::instanceMethodName
{
    person -> person.getAge();
    可以替换成
    Person::getAge
}

* 3. 引用特定类型的任意对象的实例方法  ContainingType::methodName
{
    name -> name.toString();
    可以替换成
    // 大多只用于常见的基本类型
    String::toString;
}


* 4. 引用构造函数 ClassName::new
{
    () -> new HashMap<>();
    可以替换成
    HashMap::new
}



C.函数式接口
1.定义：接口里只有一个抽象方法，但可以有额外的default方法，通过注解(@FunctionalInterface)可以强制将“接口”转为“函数式接口”
通过函数式接口来引用方法：，Lambda表达式只能针对函数式接口进行替换（函数式接口：接口里只有一个抽象方法），使用注解(@FunctionalInterface)可以强制接口是函数式接口。


2.实例之函数式接口
/**
 * 函数式接口：用FunctionalInterface标识函数式接口，函数式接口只能有一个方法，但可以有额外的default方法.
 */
@FunctionalInterface
interface FunctionalInterfaceCase {
    int foo(int m, int n);

    /**
     * 函数式接口只能有一个方法，但可以有额外的default方法.
     * 扩展方法：用default来定义，有实现体. (本来接口是不允许有实现了的方法的)
     */
    public default void printMsg() {
        String str = getMsg();
        System.out.println(str);
    }
}


3.实例之通过函数式接口来引用方法
--------------------------------------------------------------------------------------------------------------------------
jdk1.8之前的写法（匿名内部类）
public class Lambda {
    public static void main(String[] args) {
        School school = new School() {
            @Override
            public String hello(String name) {
                return "这是jdk" + name + "的特性";
            }
        };
        
        String msg = school.hello("1.7");
        System.out.println(msg);
    }
}

interface School{
    public String hello(String name);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

jdk1.8的写法（lambda表达式）
public class Lambda {
    public static void main(String[] args) {
        School school = (String name) -> { return "这是jdk" + name + "的特性"; };
        
        String msg = school.hello("1.8");
        System.out.println(msg);
    }
}

@FunctionalInterface
interface School{
    public String hello(String name);
}
--------------------------------------------------------------------------------------------------------------------------







六、多线程
A.Thread
1.定义方式
两种方式的差异，其实本质上也是“利用组合代替继承”的关系，golang中就是用“组合”实现了“继承”。
（1）方式一：继承Thread类
public class Machine extends Thread {
    public void run() {
        System.out.println("This is a child thread.");
    }
    public static void main(String[] args) {
        Machine machine = new Machine();
        machine.start();
    }
}
※不要随意覆盖start方法，除非在start方法开头中加上“super.start();”

（2）方式二：实现Runnable接口
与C#类似，不同之处在于：1.new Thread()括号中是对象，而不是方法；2.引用类定义时，需实现Runnable接口的run方法。

public class MyClass {
    Runnable runnable = new Runnable() {
        // 将要执行的操作写在线程对象的run方法当中
        public void run() {  
            System.out.println("this is my Runnable");  
        }  
    };
    public static void main(String[] args) {
        Thread t = new Thread(runnable);
        t.start();
    }
}

（3）方式三：实现Callable接口
Callable<V> oneCallable = new Callable<V>() {
    @Override
    public V call() { return null; }
};
FutureTask<V> futureTask = new FutureTask<V>(oneCallable);
Thread oneThread = new Thread(futureTask);
oneThread.start();
V v = futureTask.get();             // 此处是阻塞的

// Java原生接口定义
{
    // 原生定义
    public interface RunnableFuture<V> extends Runnable, Future<V> {
        void Run();
    }
    public class FutureTask<V> implements RunnableFuture<V> {
        public FutureTask(Callable<V> callable) {
        }
    }
}

（4）差异分析
※Thread中，可以使用this替代Thread.currentThread()获得当前线程。
※区别：
采用实现Runnable接口方式：
（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象（即多个Thread可以共用同一个Runnable），所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。
采用继承Thread类方式：
（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。
所以，从设计意图：
（1）一般认为：实现Runnable接口的对象，其着眼点主要含义是：一个计算任务，它代表一个要被其它线程（如：线程池中的线程）执行的任务。着眼点是：交由其它人去完成的一个计算任务。 ---对应着：要做的工作
（2）一般认为：从Thread类继承的含义主要是：一个能执行其它(或自己)的任务的一个线程对象。着眼点是：线程的功能（通过继承来扩展执行其它计算任务的能力） ---对应着：做工作的工作人员
（3）当然：若一个类已有父类，不能再从Thread类继承，只好实现Runnable接口来达到线程的目的，这是一种选择了。



2.线程周期
a.周期图
                                                                                        Object.notify() Or Object.notifyAll()
                                                                             ----------------------------------------------------------------
                                                                             |                                                              |
                                      Scheduler swap Or Thread.yield()       |                                                              |
                                                                             |                 Object.wait()                                |
                                                                             |      --------------------------------------->   Waiting   ---|
start()    ---->    ready to run    ---------------------------------->   Running              Thread.sleep()                               |
                          |                Chosen by scheduler             | | |    --------------------------------------->   Sleeping  ----
                          |                                                | | |    
                          |                                                | | |    
                          |                                                | | |    
                          |                                                | | |    Blocks for IO Or Enters syncronized code
                          |                                                | | |------------------------------------------->   Blocked
   stop() or run() exits  |                                                | |          Data received Or Lock obtained            |
                          |                                                | <----------------------------------------------------|
                          |                  done                          |                                                      |
                          |<-----------------------------------------------|                                                      |
                          |                                                                                                       |
                          |                                                                                                       |
                          |                                  Another thread closes IO socket                                      |
                        Dead   <---------------------------------------------------------------------------------------------------




一个线程可以有四种状态：(java)
（1） 新建（New）：线程对象已经创建，但尚未启动，所以它还不能运行。
（2） 可运行（Runnable）：这种状态下，只要调试程序把时间片分给线程，线程就可以运行。因此，在任意时刻，线程可能在、也可能不在运行当中，只要调试程序能分配时间片给线程，它就可以运行，这不同于死亡和阻塞状态——它既没有“死亡”，也没有被“阻塞”。
（3） 死亡（Dead）：通常是从run()方法中返回。（java2前，可调用stop()令其死掉，但会让程序处于不稳定状态，所以不建议使用stop()。 1.2则是坚决反对）。另外还有一个destroy()方法（它永远不会实现），应该尽可能地避免调用它，因为它非常武断，根本不会解除对象的锁定。
（4） 阻塞（Blocked）：线程能够运行，但有某个条件阻止了它的运行。当线程处于阻塞状态，调度机制将忽略线程，不会给它分配任何CPU时间。直到线程再次进入“Runnable”状态，否则不会执行任何操作。


b.线程状态切换：
当一个线程被阻塞时，必然存在某种原因使其不能继续运行。一个线程进入阻塞状态，可能有如下原因：
（1）你通过调用sleep()或yield()使线程进入休眠状态，在这种情况下，线程在指定的时间内不会运行。
（2）你
（3）线程在等待某个输入/输出完成。
（4）线程试图在某个对象上调用其同步控制方法，但是对象锁不可用。在较早的代码中，你也可能看到suspend()和resume()用来阻塞和唤醒线程，但是在Java 2 中这些方法被废止了（因为可能导致死锁）。



3.ThreadLocal
ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。
1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。
3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。
4、ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值

ThreadLocal：ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。
public class ThreadLocalBank implements Bank {
    ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            return 0;
        }
    };

    public Integer get() {
        return threadLocal.get();
    }

    public void increase() {
        Integer integer = threadLocal.get();
        threadLocal.set(integer + 10);
    }
}


4.InheritableThreadLocal


3.常用方法
// 状态切换
.yield()                    // 让步
.sleep()                    // 休眠
                            // 通过调用wait() 使线程挂起。直到线程得到了notify() 或 notifyAll( )消息，线程才会进入就绪状态。我们将在下一节验证这一点。
.isAlive() == true          // 当着线程状态
.start();                   // 启动线程
.interrupt();
--------------------------------------------
    Thread.currentThread().interrupt();
    System.out.println("是否停止1？=" + Thread.isInterrupted());     // true
    System.out.println("是否停止2？=" + Thread.isInterrupted());     // false
--------------------------------------------


// 设置线程优先级，JDK有10个级别
.setPriority(n);
.getPriority(n);
.setPriority(MAX_PRIORITY|NORM_PRIORITY|MIN_PRIORITY);

// 守护线程
.setDaemon(true|false)      // 设置线程是否为守护线程。应在.start()之前设置，否则会跑出一个IllegalThreadStateException异常，不能把正在运行的常规线程设置为守护线程。
.getDaemon()
.isDaemon()
※在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)。
“用户线程”：主程序会等待所有“用户线程”结束，它才会结束，否则一直处于等待状态。
“守护线程”：主程序的“用户线程”一旦结束，“守护线程”也会结束。因为没有了被守护者，守护线程也就没有工作可做了。
※ Thread 默认是“非守护线程”，通过Thread的setDaemon(true)方法可将其设置为“守护线程”；通过isDaemon()方法可判断其是否为守护线程。

// 加入线程
.join()                     // 意思是等待一段时间直到这个线程死亡，当前线程阻塞n秒，以等待目标线程
原理：
看JDK代码：
    /**
     * Waits at most <code>millis</code> milliseconds for this thread to 
     * die. A timeout of <code>0</code> means to wait forever. 
     *
     * @param      millis   the time to wait in milliseconds.
     * @exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
     */
    public final synchronized void join(long millis) throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
    其实Join方法实现是通过wait（小提示：Object 提供的方法）。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。
    这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁，如果拿不到它是无法wait的，刚开的例子t.join(1000)不是说明了main线程等待1秒，如果在它等待之前，其他线程获取了t对象的锁，它等待时间可不就是1毫秒了。






4.线程安全
a.锁
●独占锁
（1）对象锁
lockobj.notifyAll                       // 唤醒所有当前对象上的等待线程
lockobj.notify                          // 唤醒当前对象上的等待线程
lockobj.wait                            // 使当前线程进入等待状态，同时，wait()也会让当前线程“释放它所持有的锁”。
※对象锁不属于Thread类，而是属于Object基础类，也就是说每个对像都有这三个方法。因为都个对像都有锁，锁是每个对像的基础，当然操作锁的方法也是最基础了。
public class ThreadTest {
    public static void main(String[] args) {
        Object object = new Object();
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (object) {                      // 可以通过同步锁来获得对象控制权，例如：synchronized 代码块。否则会报IllegalMonitorStateException
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (object) {
                    try {
                        object.notify();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}



（2）synchronized（相当于C#中的lock）
当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 
    1）当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
    2）然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
    3）尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。
    4）第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。
    5）以上规则对其它对象锁同样适用。
常见三种使用方法：　
    1）synchronized(expression) {statement_block}                    // 对于同步代码块，锁是synchronized括号里配置的对象;
    2）public synchronized void sale() {statement_block}             // 普通同步方法，锁是当前实例；
    3）public static synchronized void sale() {statement_block}      // 静态同步方法，锁是当前类的Class实例，Class数据存在永久代中，是该类的一个全局锁；




对象结构：
长度          内容                          说明
32/64bit      Mark Word                     存储对象的hash值或锁信息等
32/64bit      Class MetaData Address        存储到对象类型数据的指针
32/64bit      Array Length                  数组的长度（如果当前对象是数组）

Mark Word结构：
锁状态      25bit                          4bit                1bit是否是偏向锁      2bit锁标志位
无锁状态    对象的hashcode                 对象分代年龄        0                     01
轻量级锁    指向栈中锁记录的指针                                                     00
重量级锁    指向互斥量（重量级锁）的指针                                             10
GC标记      空                                                                       11
偏向锁      线程ID Epoch                   对象分代年龄        1                     01


无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁
       （线程id）  （乐观锁）  （悲观锁）


1）偏向锁（首次进入同步块时将对象标记“偏向锁”，当相同线程再次进入该同步块时，不需要加乐观锁或悲观锁，只需要检测到“偏向锁”标记即可进入）
加锁
大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。
当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步块时，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，而不需要进行CAS操作来加锁和解锁。如果检测成功，表示线程已经获得了锁。如果检测失败，则需要再测试一下Mark Word中偏向锁的标识是否设置为1（表示指向当前进程）：如果没有，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前进程。
解锁
※偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

2）轻量级锁
轻量级锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

3）重量级锁
Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。






例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
public class Thread1 implements Runnable {
    public void run() {
        synchronized(this) {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " synchronized loop " + i);
            }
        }
    }
    public static void main(String[] args) {
        Thread1 t1 = new Thread1();
        Thread ta = new Thread(t1, "A");
        Thread tb = new Thread(t1, "B");
        ta.start();
        tb.start();
    }
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


（3）ReentrantLock（重入互斥锁）
与synchronized的不同：
synchronized是java关键字，基于JVM；
  ReentrantLock它是JDK1.5之后提供的API层面的互斥锁。
synchronized不能手动释放锁；
  ReentrantLock需要lock()和unlock()方法配合try/finally语句块来完成手动释放锁

这个ReentrantLock之所以用Reentrant打头，意思就是他是一个可重入锁。
可重入锁的意思，就是你可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入加锁。

类似于C#中的Monitor，其接口为java.util.concurrent.locks.Lock

Lock lock = new ReentrantLock(true);     // 公平锁
Lock lock = new ReentrantLock(false);    // 默认，非公平锁
公平锁指的是线程获取锁的顺序是按照加锁顺序来的，而非公平锁指的是抢锁机制，先lock的线程不一定先获得锁。


Lock lock = new ReentrantLock();
lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}

方法解析：
lock()                                  获得锁
getHoldCount()                          查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数
getQueueLength()                        返回正等待获取此锁的线程估计数，比如启动10个线程，1个线程获得锁，此时返回的是9
getWaitQueueLength(Condition condition) 返回等待与此锁相关的给定条件的线程估计数。比如10个线程，用同一个condition对象，并且此时这10个线程都执行了condition对象的await方法，那么此时执行此方法返回10
hasWaiters(Condition condition)         查询是否有线程等待与此锁有关的给定条件(condition)，对于指定contidion对象，有多少线程执行了condition.await方法
hasQueuedThread(Thread thread)          查询给定线程是否等待获取此锁
hasQueuedThreads()                      是否有线程等待此锁
isFair()                                是否公平锁
isHeldByCurrentThread()                 当前线程是否保持锁锁定，线程的执行lock方法的前后分别是false和true
isLock()                                此锁是否有任意线程占用
lockInterruptibly()                     如果当前线程未被中断，获取锁
tryLock()                               尝试获得锁，仅在调用时锁未被线程占用，获得锁
tryLock(long timeout TimeUnit unit)     如果锁在给定等待时间内没有被另一个线程保持，则获取该锁
newCondition()                          通过创建Condition对象使线程被wait（阻塞）、signal（唤醒），必须先执行lock.lock方法获得锁。wait、signal必须是同一个Condition对象才能相互起到联动控制作用



    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void testMethod() {
        try {
            lock.lock();
            System.out.println("开始wait");
            condition.await();
            for (int i = 0; i < 5; i++) {
                System.out.println("ThreadName=" + Thread.currentThread().getName()
                        + (" " + (i + 1)));
            }
        } catch (InterruptedException e) {
            // TODO 自动生成的 catch 块
            e.printStackTrace();
        }
        finally
        {
            lock.unlock();
        }
    }

    public void signal()
    {
        try
        {
            lock.lock();
            condition.signal();
        }
        finally
        {
            lock.unlock();
        }
    }

（4）ReentrantReadWriteLock（重入读写锁）
1）与scnchronized的区别
    所谓互斥锁，指的是一次最多只能有一个线程持有的锁。在jdk1.5之前，我们通常使用synchronized机制控制多个线程对共享资源的访问。而现在，Lock提供了比synchronized机制更广泛的锁定操作，Lock和synchronized机制的主要区别:
    synchronized机制提供了对与每个对象相关的隐式监视器锁的访问，并强制所有锁获取和释放均要出现在一个块结构中，当获取了多个锁时，它们必须以相反的顺序释放。synchronized机制对锁的释放是隐式的，只要线程运行的代码超出了synchronized语句块范围，锁就会被释放。而Lock机制必须显式的调用Lock对象的unlock()方法才能释放锁，这为获取锁和释放锁不出现在同一个块结构中，以及以更自由的顺序释放锁提供了可能。
    synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。
    说到这里，还是想提一下这2中机制的具体区别。据我所知，synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。
    而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。

2）使用方法
public class CacheDemo {
    private Map<String, Object> cache = new HashMap<String, Object>();
    public static void main(String[] args) {
        // TODO Auto-generated method stub
    }
    
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    public Object getData(String key) {
        lock.readLock().lock();                          // 添加读锁
        Object value = null;
        try{
            value = cache.get(key);
            if(value == null) {
                lock.readLock().unlock();                // 释放读锁
                lock.writeLock().lock();                 // 添加写锁
                try{
                    if(value == null) {
                        value = "aaaa";                 // 去查数据库queryDB();
                    }
                } finally{
                    lock.writeLock().unlock();
                }
                lock.readLock().lock();                  // 降级
            }
        } finally{
            lock.readLock().unlock();
        }
            return value;
        }
    }


<1>读锁->读锁   √   多个线程可以同时添加读锁
<2>读锁->写锁   ╳   添加读锁后，（在该读锁释放之前）不能再添加写锁，因为会导致读值发生变化
<3>写锁->读锁   √   用于降级
<4>写锁->写锁   ╳   同“读锁->写锁”

锁定降级：
重入还允许从写入锁定降级为读取锁定，其实现方式是：先获取写入锁定，然后获取读取锁定，最后释放写入锁定。但是，从读取锁定升级到写入锁定是不可能的。




●共享锁
（1）CountDownLatch计数器（一次性线程池，await多个线程）
★Semaphore是放行数量，在放行一定数量的线程后，便不再放行。
★CountDownLatch表示阻塞数量，在阻塞一定数量线程后，才“一起”放行。是递减方式，每执行countDown()就计减一次，直到为零便放行。
void await()                                            // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。
boolean await(long timeout, TimeUnit unit)              // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。 
void countDown()                                        // 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。 
boolean releaseShared(int count)                        // 同countDown，只不过可以放行指定数量
long getCount()                                         // 返回当前计数。 
String toString()                                       // 返回标识此锁存器及其状态的字符串。 

例：
public class Main {
    static int MAX = 100;
    static CountDownLatch latch = new CountDownLatch(MAX);
    public static void main(String[] args) throws InterruptedException {
        for(int i=0 ; i < MAX ; i++) {
            new Thread(new MyRunnable(i, latch)).start();
        }

        latch.await();                                  // 关键方法，阻塞直到计数器被放光才被通行
        System.out.println("finish!");
    }
}
class MyRunnable implements Runnable {
    CountDownLatch latch;
    int id;
    MyRunnable(int id, CountDownLatch latch) {
        this.id = id;
        this.latch = latch;
    }

    @Override
    public void run() {
        System.out.println(id);
        latch.countDown();                              // 关键方法
    }
}



（2）CyclicBarrier（循环栅栏）
★CyclicBarrier表示阻塞数量，在阻塞一定数量线程后，才“一起”放行。是递减方式，每执行await()就计减一次，直到所指定值计减为零便放行。
构造方法：
CyclicBarrier(int parties)
      创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。 
CyclicBarrier(int parties, Runnable barrierAction)
      创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。 
类方法：
int await()
          在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。 
int await(long timeout, TimeUnit unit)
          在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。 
int getNumberWaiting()
          返回当前在屏障处等待的参与者数目。 
int getParties()
          返回要求启动此 barrier 的参与者数目。 
boolean isBroken()
          查询此屏障是否处于损坏状态。 
void reset()
          将屏障重置为其初始状态。 

public class Main {
    static int max = 100;
    // static CountDownLatch latch = new CountDownLatch(max);
    public  static  void main(String[] args) throws InterruptedException {
        CyclicBarrier barrier = new CyclicBarrier(10);                                      // 屏障点 集结点
        for(int i = 0 ; i < 10 ; ++i) {
            new Thread() {
                @Override
                public void run() {
                    try {
                        System.out.println(Thread.currentThread()+" is ready!");
                        barrier.await();                                                    // 关键点
                        System.out.println(Thread.currentThread()+" is doing!");
                    } catch (Exception e) {
                        e.printStackTrace();
                    } 
                }
            }.start();
        }
    }
}


★CountDownLatch 与 CyclicBarrier 的区别
两者都强调的是协同性，即多个线程完成后才放行，区别在行放行点不同
·CountDownLatch关注的放行点是在多线程外部
·CyclicBarrier关注的放行点是在多线程内部

（3）Semaphore
★Semaphore是放行数量，在“同时”放行一定数量的线程后，便阻塞。不像CountDownLatch是单纯的计数器，Semaphore可以动态浮动，acquire()与release()，一个加一，一个减一。

// 创建一个计数阈值为5的信号量对象，只能5个线程同时访问  
Semaphore semp = new Semaphore(5);  
  
try {  
    // 申请许可  
    semp.acquire();  
    try {  
        // 业务逻辑  
    } catch (Exception e) {  
  
    } finally {  
        // 释放许可  
        semp.release();  
    }  
} catch (InterruptedException e) {  
  
} 




●锁相关
（1）volatile
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

// 正常排序
memory = allocate();    // 1：分配对象的内存空间
initInstance(memory);   // 2：初始化对象
instance = memory;      // 3：设置instance指向刚分配的内存地址

// 经优化后，重排序
memory = allocate();    // 1：分配对象的内存空间
instance = memory;      // 3：设置instance指向刚分配的内存地址（此时对象还未初始化）
ctorInstance(memory);   // 2：初始化对象

（2）CAS
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果发现值被修改了，可以再次重试。CAS机制（Compare And Swap）就是一种乐观锁。
在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的

CAS：一种有名的无锁（lock-free）算法。也是一种现代 CPU 广泛支持的“CPU指令级”的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。
CAS有三个操作参数：
·内存位置V（它的值是我们想要去更新的）
·预期原值A（上一次从内存中读取的值）
·新值B（应该写入的新值）
CAS的操作过程：将内存位置V的值与A比较（compare），如果相等，则说明没有其它线程来修改过这个值，所以把内存V的的值更新成B（swap），如果不相等，说明V上的值被修改过了，不更新，而是返回当前V的值，再重新执行一次任务再继续这个过程。
所以，当多个线程尝试使用CAS同时更新同一个变量时，其中一个线程会成功更新变量的值，剩下的会失败。失败的线程可以重试或者什么也不做。（一般情况下是一个自旋操作，即失败会不断的重试。）
    // +1操作
    public final long getAndIncrement() {
        while (true) {
            long current = get();
            long next = current + 1;
            //当+1操作成功的时候直接返回，退出此循环
            if (compareAndSet(current, next))
                return current;
        }
    }

    // 调用JNI实现CAS
    public final boolean compareAndSet(long expect, long update) {
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
    }
¤JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。在jdk1.8后getAndIncrement()方法已经看不到具体代码了，而是封装在unsafe类里面。
●缺点：
CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。
1）ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
2）循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
3）只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。
4）比较花费CPU资源，即使没有任何争用也会做一些无用功。
5）会增加程序测试的复杂度，稍不注意就会出现问题。




（3）AQS（AbstractQueuedSynchronizer）
AbstractQueuedSynchronizer内包含两个核心变量，初始状态为：
·state=0
·加锁线程=null

            ┌—————————————————┐
            │state = 0                         │
            │加锁线程 = null                   │
            └—————————————————┘
                            │
线程1加锁                   ↓
            ┌—————————————————┐
            │state = 1                         │
            │加锁线程 = 线程1                  │
            └—————————————————┘
                            │
线程1加锁                   ↓
            ┌—————————————————┐
            │state = 2                         │
            │加锁线程 = 线程1                  │
            └—————————————————┘
                            │
线程2加锁                   ↓
            ┌—————————————————————————┐
            │state = 2                   等待队列：线程2       │
            │加锁线程 = 线程1                                  │
            └—————————————————————————┘
                            │
线程3加锁                   ↓
            ┌—————————————————————————┐
            │state = 2                   等待队列：线程2|线程3 │
            │加锁线程 = 线程1                                  │
            └—————————————————————————┘
                            │
线程1释放                   ↓
            ┌—————————————————————————┐
            │state = 1                   等待队列：线程2|线程3 │
            │加锁线程 = 线程1                                  │
            └—————————————————————————┘
                            │
线程1释放                   ↓
            ┌—————————————————————————┐
            │state = 0                   等待队列：线程2|线程3 │
            │加锁线程 = null                                   │
            └—————————————————————————┘
                            │
线程2出队列加锁             ↓
            ┌—————————————————————————┐
            │state = 1                   等待队列：线程3       │
            │加锁线程 = 线程2                                  │
            └—————————————————————————┘
                            │
线程2释放                   ↓
            ┌—————————————————————————┐
            │state = 0                   等待队列：线程3       │
            │加锁线程 = null                                   │
            └—————————————————————————┘
                            │
线程3出队列加锁             ↓
            ┌—————————————————————————┐
            │state = 1                   等待队列：            │
            │加锁线程 = 线程3                                  │
            └—————————————————————————┘
                            │
线程3释放                   ↓
            ┌—————————————————————————┐
            │state = 0                   等待队列：            │
            │加锁线程 = null                                   │
            └—————————————————————————┘























B.Executor
ThreadPoolTaskExecutor是springframework包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。
1.ThreadPoolTaskExecutor
@Configuration
@EnableAsync
public class ExecutorConfig {
    private int corePoolSize;
    private int maxPoolSize;
    private int queueCapacity;
    private String threadNamePrefix;

    @Bean(name = "asyncServiceExecutor")
    public Executor asyncServiceExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 配置核心线程数
        executor.setCorePoolSize(corePoolSize);
        // 配置最大线程数
        executor.setMaxPoolSize(maxPoolSize);
        // 配置队列大小
        executor.setQueueCapacity(queueCapacity);
        // 配置线程池中的线程的名称前缀
        executor.setThreadNamePrefix(threadNamePrefix);

        // rejection-policy：当pool已经达到max size的时候，如何处理新任务
        // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // 执行初始化
        executor.initialize();
        return executor;
    }
}





2.线程池创建方式
ExecutorService tp = new ThreadPoolExecutor(5, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10));
corePoolSize：核心池的大小，构建线程池后，并不会创建线程，当前线程数如果小于corePoolSize时，当要执行任务时，创建一个线程。当当前线程数等于corePoolSize，会将任务放入队列中
maximumPoolSize：线程池最大数，也就是线程最多能创建的线程
keepAliveTime：工作线程空闲后，保持存活的时间。默认情况下，如果当前线程数大于corePoolSize，那么一个线程如果没有任务，当空闲的时间大于keepAliveTime时，会终止该线程，直到线程数不超过corePoolSize
workQueue：存储任务的队列，有几种种类型队列ArrayBlockingQueue（有界缓冲区，基于数组的队列，先进先出，必须指定大小，可以设置是否保持公平，以FIFO顺序访问），LinkedBlockingQueue（基于链表的队列，如果没有指定大小，默认为Integer.MAX_VALUE），SynchronousQueue(无界线程池，不管多少任务提交进来，直接运行)
ThreadFactory：线程工厂，用来创建线程,通过线程工厂可以给创建的线程设置名字
rejectedExecutionHandler：拒绝处理任务的策略AbortPolicy（直接放弃任务，抛出RejectedExecutionException异常），DiscardPolicy（放弃任务，不抛出异常），DiscardOldestPolicy（放弃最旧的未处理请求，然后重试 execute；如果执行程序已关闭，则会丢弃该任务），CallerRunsPolicy（它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务）



3.Executors类，返回的其实都是ThreadPoolExecutor实例对象
Executors类，提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。
•public static ExecutorService newFixedThreadPool(int nThreads)
创建固定数目线程的线程池。
•public static ExecutorService newCachedThreadPool()
创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
•public static ExecutorService newSingleThreadExecutor()
创建一个单线程化的Executor。
•public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。

3.执行线程
★无返回值（通过Runnable执行）
executor.execute(new Runnable() {
    ...
})

★取得返回值（通过Callable与Future执行并取得各线程返回值）
    Callable 与 Future 两功能是Java在后续版本中为了适应多并法才加入的，Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其他线程执行的任务。
Callable的接口定义如下；
public interface Callable<V> { 
    V call() throws Exception;
} 
Callable和Runnable的区别如下：
I    Callable定义的方法是call，而Runnable定义的方法是run。
II   Callable的call方法可以有返回值，而Runnable的run方法不能有返回值。
III  Callable的call方法可抛出异常，而Runnable的run方法不能抛出异常。  
Future 介绍
Future表示异步计算的结果，它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。Future的cancel方法可以取消任务的执行，它有一布尔参数，参数为 true 表示立即中断任务的执行，参数为 false 表示允许正在运行的任务运行完成。Future的 get 方法等待计算完成，获取计算结果

Future<String> future = executor.submit(new Callable<String>() {
    @Override
    public String call() {
        ...
    }
}

★排日程（可以是Runnable，也可以是Callable）
格式：Unchecked invocation schedule(Callable command, int initialDelay, TimeUnit unit)
  ScheduledFuture future1 = executor.schedule(task1, 10, TimeUnit.SECONDS);
格式：ScheduledFuture<?> java.util.concurrent.ScheduledExecutorService.scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
  ScheduledFuture future2 = executor.scheduleAtFixedRate(task2, 5, 1, TimeUnit.SECONDS);                  // 首次延迟5s，周期间隔1s执行

future2.cancel(true);



4.步骤
// 线程载体ExecutorService
ExecutorService executor = Executors.newCachedThreadPool();
// 无返回值模式
executor.execute(new Runnable() {
	@Override
	public void run() {
		// TODO Auto-generated method stub
		System.out.println("execute mode");
	}
});


// 有返回值模式
List<Future<String>> futures;
for(int i = 0 ; i < 10 ; i++)
{
    Future<String> future = executor.submit(new Callable() {
        @Override
        public String call() {
            // TODO Auto-generated method stub
            return "submit mode" + i;
        }
    });
    futures.add(future);
}
executor.shutdown();
while (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
    //此处阻塞
    System.out.println("线程池没有关闭");
}
for(Future<String> future : futures)
{
    System.out.println( future.get() );                                             // get方法会发生阻塞
    // future.isDone()                                                              // 可判断future是否完成
}


// 排日程模式1--Timer
ScheduledFuture future1 = new Timer().scheduleAtFixedRate(
    new Runnable() {
        @Override
        public void run() {
            // TODO Auto-generated method stub
            System.out.println("scheduleAtFixedRate mode");
        }
    }, 5, 1, TimeUnit.SECONDS);

// 排日程模式2--ExecutorService
ScheduledFuture future2 = executor.schedule(
    new Callable() {
        @Override
        public String call() {
            // TODO Auto-generated method stub
            future1.cancel(true);
            System.out.println("future1 stop");
            return "schedule mode";
        }
    }, 10, TimeUnit.SECONDS);
String future2Result = future2.get();


C.java.util.Timer
　　这个方法应该是最常用的，不过这个方法需要手工启动你的任务：
    java.util.Timer定时器，实际上是个线程，定时调度所拥有的TimerTasks。 
一个TimerTask实际上就是一个拥有run方法的类，需要定时执行的代码放到run方法体内，TimerTask一般是以匿名类的方式创建。 
Timer timer = new Timer();   
timer.schedule(new ListByDayTimerTask(),10000,86400000);   
这里的ListByDayTimerTask类必须extends TimerTask里面的run()方法。 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

TimerTask task = new TimerTask() {
    public void run() { 
    ... //每次需要执行的代码放到这里面。 
    } 
}; 
java.util.Timer timer = new java.util.Timer(true);      // true 说明这个timer以daemon方式运行（优先级低，程序结束timer也自动结束），
                                                        // 注意，javax.swing 包中也有一个Timer类，如果import中用到swing包，要注意名字的冲突。 
timer.schedule(task, delay);                            // 指定时间执行一次，delay单位为毫秒
timer.schedule(task, time);                             // 
timer.schedule(task, delay, period);                    // 指定时间周期性执行
timer.schedule(task, firstTime, period);                // 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例





六、异常

1.分类

┌—┐
│  │
└—┘

                           ┌VirtulMachineError — StackOverFlowError
          ┌—— Error ——┤                   — OutOfMemoryError
          │               └AWTError
          │    
          │    
Throwable ├    
          │    
          │                                         ┌ SQLException
          │                                         │ 
          │              ┌ Unchecked Exception ——┤                  ┌ EOFException
          │              │                         │ IOException  ——┤ FileNotFoundException
          │              │                         │                  └ ...
          └—— Exception┤                         └  ...
                          │                                             ┌ ArrithmeticException
                          └ Checked Exception ———— RuntimeException ┤ MissingResourceException
                                                                         │ ClassNotFoundException
                                                                         │ NullPointerException
                                                                         │ IllegalArgumentException
                                                                         │ ArrayIndexOutOfBoundsException
                                                                         │ UnkownTypeException
                                                                         └ ...



RuntimException 更接近我们日常生活中的“意外”。
Exception 这个更接近我们日常生活中所说的“常见错误”。
Error 更像是”见鬼，看来周末国庆不加班是搞不定的“。





1）error都是继承自父类java.lang.Error，而exception都继承自java.lang.Exception。
2）
java.lang.Error: An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. 
即：Error是Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。
java.lang.Exception: The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch。
即：Exception 是Throwable的一种形式的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。
3）Error和RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的Exception类都是检查了的异常（checked exceptions）. checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException, ParseException等。 unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。

一些主要子类对应的异常处理功能简要说明如下：
ArithmeticException——由于除数为0引起的异常； 
ArrayStoreException——由于数组存储空间不够引起的异常； 
ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常； 
IllegalMonitorStateException——监控器状态出错引起的异常； 
NegativeArraySizeException—一数组长度是负数，则产生异常； 
NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； java.lang.NullPointerException 的Message为null 
SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常； 
IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常； 
IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常； 
ClassNotFoundException——未找到指定名字的类或接口引起异常； 
CloneNotSupportedException——一程序中的一个对象引用Object类的clone方法，但 此对象并没有连接Cloneable接口，从而引起异常； 
InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述； 
NoSuchMethodException一所调用的方法未找到，引起异常； 
Illega1AccessExcePtion—一试图访问一个非public方法； 
StringIndexOutOfBoundsException——访问字符串序号越界，引起异常； 
ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常； 
NumberFormatException——字符的UTF代码数据格式有错引起异常； 
IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常； 
FileNotFoundException——未找到指定文件引起异常； 
EOFException——未完成输入操作即遇文件结束引起异常。






1.Error和Exception的区别
Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError。对于这类错误，Java编译器不去检查他们。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。
Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

2.自动释放
try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("p1.obj"))) {
            System.out.println(Person.class.hashCode());
            Person person = (Person) in.readObject();
            System.out.println(person.staticString);
}
/**
 * 不需要
 * finally{
 *     in.close();
 * }
 */



七、数据库
O、例：
public void main() {
    Connection con = null ;
    PreparedStatement ps = null ;
    Student stu = null ;
    ResultSet rs = null;
    try
    {
        con = JDBCUtils.getConnection();
        String sql = "select stuName,stuAge,stuTel,stuAddress,groupId from student where stuName =?";
        ps = con.prepareStatement(sql);
        ps.setString(1, name);
        
        rs = ps.executeQuery();
        stu = new Student();
        while(rs.next())
        {
            stu.setStuName(rs.getString(1));
            stu.setStuAge(rs.getInt(2));
            stu.setStuTel(rs.getString(3));
            stu.setStuAddress(rs.getString(4));
            stu.setGroupId(rs.getInt(5));
        }
    }
}


A、利用JDBC连接数据库
1、Android平台下与服务器数据库通信的方法
    在Android平台下，连接电脑服务器的MySQL、PostgreSQL、Oracle、Sybase、Microsoft SQLServer等数据库管理系统DBMS(database management system)，主要有以下两种方法：
方法1、直接连接
在Android工程中引入JDBC驱动，直接连接。（本文主要介绍此种方法）
方法2、间接连接
在服务器上用PHP+DBMS做服务器端,PHP将DBMS中的数据用json或者xml进行封装。然后再发封装好的数据返回给Android平台。
注意：
    采用JDBC方法主要问题是安全性不高，而且一旦要访问的数据量过多，容易出问题。另外，Android系统本身有对json或者xml直接解析的api，所以建议采用第二种方法，实用性与安全性都提高了。
2、JDBC简介
    JDBC是Java Data Base Connectivity的缩写，意思为"java数据库连接"，由一组用Java语言编写的类和接口组成，为java层直接操作关系型数据库提供了标准的API。原理很简单，主要是先服务器DBMS发送SQL（结构化查询语言）指令。实现各种数据库的操作。
3、如何在Android中使用JDBC与服务器数据库通信
    在Android工程使用JDBC连接数据库的主要步骤如下：
    加载JDBC驱动程序------->建立连接--------->发送SQL语句
（1）加载JDBC驱动程序
1）导入JDBC驱动
    在eclipse选择工程，右键---->Properties---->在左侧选项"Java Build Path"---->切换到"Libraries"---->选择"Add External JARs"---->选中jtds的jar包---->完毕
然后在java代码的开始处 import JDBC的包，这一步根据不同的驱动，目录可能不一样，找到Driver的路径即可。如：import net.sourceforge.jtds.jdbc.Driver;
2）加载JDBC驱动
    来在java代码中使用以下语句，加载jdbc驱动。
Class.forName("net.sourceforge.jtds.jdbc.Driver");// 加载驱动程序 
3）建立连接
    每种DBMS的JDBC驱动是不一样的，同一个DBMS也会有几种JDBC驱动，如Microsoft SQL Server的JDBC驱动主要有两种，Microsoft官方提供的JDBC驱动和民间开源的JDBC驱动（JTDS），推荐JTDS，bug少，而且是完全开放源代码的。目前JTDS只能支持Microsoft SQL Server和Sybase。
    由于DBMS与JDBC驱动的不同，所以每种JDBC连接数据库的字符串书写方法也是不一样的。
    下面给出几种常见的JDBC与DBMS建立连接的字符串书写格式：
//1. MySQL(http://www.mysql.com)mm.mysql-2.0.2-bin.jar   
Connection con = null;  
Class.forName( "org.gjt.mm.mysql.Driver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:mysql://DbComputerNameOrIPAddr:3306/DatabaseName", UserName, Password );  
  
  
//2. PostgreSQL(http://www.de.postgresql.org)pgjdbc2.jar   
Connection con = null;  
Class.forName( "org.postgresql.Driver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:postgresql://DbComputerNameOrIPAddr/DatabaseName", UserName, Password );  
  
  
//3. Oracle(http://www.oracle.com/ip/deploy/database/oracle9i/)classes12.zip   
Connection con = null;  
Class.forName( "oracle.jdbc.driver.OracleDriver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:oracle:thin:@DbComputerNameOrIPAddr:1521:DatabaseName", UserName, Password );  
  
  
//4. Sybase(http://jtds.sourceforge.net)jconn2.jar   
Connection con = null;  
Class.forName( "com.sybase.jdbc2.jdbc.SybDriver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:sybase:Tds:DbComputerNameOrIPAddr:2638/DatabaseName", UserName, Password );  
//(Default-Username/Password: "dba"/"sql")   
  
  
//5. Microsoft SQLServer(http://jtds.sourceforge.net)   
Connection con = null;  
Class.forName( "net.sourceforge.jtds.jdbc.Driver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:jtds:sqlserver://DbComputerNameOrIPAddr:1433/DatabaseName", UserName, Password );  
  
  
//6. Microsoft SQLServer(http://www.microsoft.com)   
Connection con = null;  
Class.forName( "com.microsoft.jdbc.sqlserver.SQLServerDriver" );// 加载驱动程序   
con = DriverManager.getConnection( "jdbc:microsoft:sqlserver://DbComputerNameOrIPAddr:1433;databaseName=master", UserName, Password );  


4）发送SQL语句
    当成功连接数据库之后，就可以发送操作数据库的语句并处理结果了。
    在发送SQL语句之前，首先要创建一个Statement对象，Statement主要工作是把SQL语句发送给 DBMS。
    Statement stmt = con.createStatement();//创建Statement
    然后发送SQL语句。对于SELECT操作，使用的是Statement对象的executeQuery(sql)方法，对于一些创建table和修改table的操作，使用的是Statement对象的executeUpdate(sql)方法。如：
String sql = "SELECT * FROM table_test";//查询表名为"table_test"的所有内容   
Statement stmt = con.createStatement();//创建Statement   
ResultSet rs = stmt.executeQuery(sql);  
    由于要联网，所以要在AndroidManifest.xml里面加入连接网络的权限：
<uses-permission android:name="android.permission.INTERNET" />
4、实例
package com.conowen.sqlserver;  
  
import java.sql.Connection;  
import java.sql.DriverManager;  
import java.sql.ResultSet;  
import java.sql.Statement;  
  
import android.app.Activity;  
import android.database.SQLException;  
import android.os.Bundle;  
  
public class Android_connect_sqlserverActivity extends Activity {  
    /** Called when the activity is first created. */  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        String UserName = "test";//用户名   
        String Password = "test";//密码   
        Connection con = null;  
  
        try { // 加载驱动程序   
            Class.forName("net.sourceforge.jtds.jdbc.Driver");  
            con = DriverManager.getConnection(  
                    "jdbc:jtds:sqlserver://192.168.1.2:1433/testDB", UserName,  
                    Password);  
        } catch (ClassNotFoundException e) {  
            System.out.println("加载驱动程序出错");  
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } catch (Exception e) {  
            System.out.println(e.getMessage());  
  
        }  
        try {  
            testConnection(con);//测试数据库连接   
        } catch (java.sql.SQLException e) {  
            // TODO Auto-generated catch block   
            e.printStackTrace();  
        }  
    }  
  
    public void testConnection(Connection con) throws java.sql.SQLException {  
  
        try {  
  
            String sql = "SELECT * FROM table_test";//查询表名为"table_test"的所有内容   
            Statement stmt = con.createStatement();//创建Statement   
            ResultSet rs = stmt.executeQuery(sql);//ResultSet类似Cursor   
  
            while (rs.next()) {//<CODE>ResultSet</CODE>最初指向第一行   
                System.out.println(rs.getString("test_id"));//输出第n行，列名为"test_id"的值   
                System.out.println(rs.getString("test_name"));  
                  
            }  
  
            rs.close();  
            stmt.close();  
        } catch (SQLException e) {  
            System.out.println(e.getMessage().toString());  
        } finally {  
            if (con != null)  
                try {  
                    con.close();  
                } catch (SQLException e) {  
                }  
        }  
    }  
}  


B、操作本地SQLite
/data/data/<application package name>/databases/<databasename>
import android.database.sqlite.SQLiteDatabase;
import android.content.ContentValues;
1、表操作
（1）新建
SQLiteDatabase md;
md = openOrCreateDatabase("mydb.db", SQLiteDatabase.CREATE_IF_NECESSARY, null);
final String CREATE_AUTHOR_TABLE = "CREATE TABLE tbl_authors(id INTEGER PRIMARY KEY AUTOINCREMENT, firstname TEXT, lastname TEXT)";
md.execSQL(CREATE_AUTHOR_TABLE);
（2）删除
this.deleteDatabase("mysqlite.db")  

2、行操作
（1）插入
ContentValues valuesInsert = new ContentValues();
valuesInsert.put("aStr", "aaa");
long newAuthorID = md.insert("tbl_authors", null, valuesInsert);//返回新创建记录id
（2）更新
ContentValues valuesUpdate = new ContentValues();
valuesUpdate.put("title", "ss");
md.update("tbl_authors", valuesUpdate, "id=?", new String[]{bookId.toString()});
（3）删除
md.delete("tbl_authors", null, null);
md.delete("tbl_authors", "id=?", new String[]{bookId.toString()});
（4）查询
public Cursor query (String table, String[] columns, String selection,  String[] selectionArgs, String groupBy, String having, String orderBy, String limit)
table————要查询数据的表名
columns————要返回列的列名数组
selection————可选的where子句 ，如果为null，将会返回所有的行
selectionArgs————当在selection中包含"?"时，如果selectionArgs的值不为null，则这个数组中的值将依次替换selection中出现的"?"
groupBy————可选的group by子句，如果其值为null，将不会对行进行分组
having————可选的having子句，如果其值为null，将会包含所有的分组
orderBy————可选的order by子句，如果其值为null，将会使用默认的排序规则
limit————可选的limit子句，如果其值为null，将不会包含limit子句
Cursor cr=db.query("pic", null, null, null, null, null, null);//查询数据库的所有数据  


3、
SQLite数据类型
一般数据采用的固定的静态数据类型，而SQLite采用的是动态数据类型，会根据存入值自动判断。SQLite具有以下五种常用的数据类型：
NULL: 这个值为空值
VARCHAR(n)：长度不固定且其最大长度为 n 的字串，n不能超过 4000。
CHAR(n)：长度固定为n的字串，n不能超过 254。
INTEGER: 值被标识为整数，依据值的大小可以依次被存储为1,2,3,4,5,6,7,8.
REAL: 所有值都是浮动的数值，被存储为8字节的IEEE浮动标记序号.
TEXT: 值为文本字符串，使用数据库编码存储(TUTF-8, UTF-16BE or UTF-16-LE).
BLOB: 值是BLOB数据块，以输入的数据格式进行存储。如何输入就如何存储，不改变格式。
DATA ：包含了 年份、月份、日期。
TIME：包含了 小时、分钟、秒。

SQLiteDatabase的常用方法 
方法名称                                                                            方法描述
openOrCreateDatabase(String path, SQLiteDatabase.CursorFactory factory)             打开或创建数据库
insert(String table, String nullColumnHack, ContentValues values)                   添加一条记录
delete(String table, String whereClause, String[] whereArgs)                        删除一条记录
query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy)                    查询一条记录
update(String table, ContentValues values, String whereClause, String[] whereArgs)  修改记录
execSQL(String sql)                                                                 执行一条SQL语句
close()                                                                             关闭数据库

Cursor游标常用方法
方法名称                                                                        方法描述
getCount()                                                                      获得总的数据项数
isFirst()                                                                       判断是否第一条记录
isLast()                                                                        判断是否最后一条记录
moveToFirst()                                                                   移动到第一条记录
moveToLast()                                                                    移动到最后一条记录
move(int offset)                                                                移动到指定记录
moveToNext()                                                                    移动到下一条记录
moveToPrevious()                                                                移动到上一条记录
getColumnIndexOrThrow(String columnName)                                        根据列名称获得列索引
getInt(int columnIndex)                                                         获得指定列索引的int类型值
getString(int columnIndex)                                                      获得指定列缩影的String类型值





例：
class data{
		String user_sql = "select \"limit\", user_name, password from grc_user_manage where user_name = ? and password=?";
		Connection connection = null;
		PreparedStatement statement = null;
		boolean flax = false;
		int in = -3;
		try {
			connection = connectPostgreSqlUtils.connect_db();
			if (BuildConfig.DEBUG) {
				System.out.println("---------connection------------" + connection);
			}
			if (connection != null) {
				statement = connection.prepareStatement(user_sql);
				statement.setString(1, user_name);
				statement.setString(2, password);
				ResultSet user_rs = statement.executeQuery();
				if (user_rs.next()) {
					in = (int) user_rs.getDouble("limit");
					flax = true;
				}
				user_rs.close();
			}
			;
		} catch (SQLException e) {
			e.printStackTrace();

		} finally {
			connectPostgreSqlUtils.close_con(connection, statement);
		}
		return in;
}



4、
（1）相对于封装过的ContentProvider而言，使用原始SQL语句执行效率高，比如使用方法rawQuery、execSQL的执行效率比较高。
（2）对于需要一次性修改多个数据时，可以考虑使用SQLite的事务方式批量处理，我们定义SQLiteDatabase db对象，执行的顺序为
  db.beginTransaction();
  // 处理数据添加，删除或修改的SQL语句。这里设置处理成功
  db.setTransactionSuccessful();
  db.endTransaction(); //这句很重要，告诉数据库处理完成了，这时SQLite的底层会执行具体的数据操作。




八、反射
1、介绍
    在运行时环境，能否根据一个类的名字，来得到这个类的属性和方法？对于任何一个运行时的对象能否动态调用这个对象的方法？答案是可以的。这种动态的获取类的信息以及动态调用一个对象的方法的机制叫做反射。
2、功能
反射提供的主要功能：
    1.在运行时判断任意一个对象所属的类
    2.在运行时构造一个类的对象
    3.在运行时判断一个类所具有的属性和方法
    4.在运行时调用一个对象的方法


4、步骤
    实现反射的过程：
    1.生成一个类加载器ClassLoader
        /*
         * Bootstrap ClassLoader       $JAVAHOME/jre/lib/rt.jar
         * Extension ClassLoader       $JAVAHOME/jre/lib/ext/*.jar
         * App ClassLoader             $CLASSPATH
         */
        ClassLoader classLoader;
        classLoader = this.getClass.getClassLoader();                     // 使用当前类的ClassLoader  
        classLoader = Thread.currentThread().getContextClassLoader();     // 使用当前线程的ClassLoader  
        classLoader = ClassLoader.getSystemClassLoader();                 // 使用系统ClassLoader

------------------------------------------------------------------------
System.out.println(classLoader1.getParent().getParent().getParent());
System.out.println(classLoader1.getParent().getParent());
System.out.println(classLoader1.getParent());
System.out.println(ClassLoader.getSystemClassLoader());
System.out.println(classLoader1 );


null
sun.misc.Launcher$ExtClassLoader@60e53b93
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$AppClassLoader@18b4aac2
com.mythsman.test.Main$1@5e2de80c
------------------------------------------------------------------------
public class CustomClassLoader {
    @Override
    public Class<?> loadClass(String s) throws ClassNotFoundException {
        try {
            if (s.equals("com.mythsman.test.Hello")) {
                byte[] classBytes = Files.readAllBytes(Paths.get("/home/myths/Desktop/test/Hello.class.1"));
                return defineClass(s, classBytes, 0, classBytes.length);
            }else{
                return super.loadClass(s);
            }
        }catch (IOException e) {
            throw new ClassNotFoundException(s);
        }
    }
}
------------------------------------------------------------------------
    2.加载一个类（Java中Class相当于C#中的Type）
        //加载类的四种方法
        Class<?> clazz = loader.loadClass("com.ls.reflecttest.Person");
        Class<?> clazz = Class.forName("com.ls.reflecttest.Person");
        Class<?> clazz = Class.forName("外部类完整路径$内部私有类类名");
        Class<?> clazz = void.class;                    // 编译时
        Class<?> clazz = new Person().getClass();       // 运行时
        Class<?> clazz = Person.class;                  // 运行时
        
        Class<?> _clazz = new Person<Student>() {}.getClass();                              // 得到匿名内部类：XXXX$1类型。相当于class _XXXX extends Person<T>
        Class<?> clazz = _clazz.getSuperclass();                                            // 得到父类：得到Person类型
        Type genericClazz = _clazz.getGenericSuperclass();                                  // 得到带泛型的父类：得到Person<Student>类型
        Type type = ((ParameterizedType) genericClazz).getActualTypeArguments()[0];         // 得到父类的泛型Type：得到Student类型Type
        Class<?> clazz = ((ParameterizedType) genericClazz).getActualTypeArguments()[0];    // 得到父类的泛型Class：得到Student类型Class。※此处的泛型必须是
                                                                                            // 具体类型，如Student，
        // 如果当前类为内部类，获取声明内部类的外部类，如果当前类不是内部类，返回null
        Class<?> clazz = clazz.getEnclosingClass();
        // 得到内部类
        Class[] innerClazz = clazz.getDeclaredClasses();
        // 得到内部类
        Class.forName("外部类完整路径$内部私有类类名");
        // 是否成员内部类
        Boolean isMember = innerClazz.isMemberClass()
        // 是否局部内部类
        Boolean isLocal = innerClazz.isLocalClass()
        // 是否匿名内部类
        Boolean isAnonymous = innerClazz.isAnonymousClass()

        
        ClassUtils.getShortName() //获取短类名，如上例中的：Required
        ClassUtils.getClassFileName() //获取类文件名，如上例中的：Required.class
        ClassUtils.getPackageName() //获取包，如上例中的：cps.apm.util.fileprocessor.annotation
        ClassUtils.getQualifiedName() //获取包名+类名，如上例中的：cps.apm.util.fileprocessor.annotation.Required



    3.创建实例
        //实例化，通过不带参数的构造函数
        Object instance = clazz.newInstance();
        //实例化，通过带参数的构造函数
        Constructor constructor = clazz.getConstructor(new Class[] {int.class, String.class, int.class}); 
        Object instance = constructor.newInstance(new Object[] {88, "mytext", 88});
        
        // 或
        Object instance = org.springframework.beans.BeanUtils.instantiateClass(clazz);
        
        
        for (Class clz : innerClazz) {
            int mod = clz.getModifiers();
            String modifier = Modifier.toString(mod);
            
            if (modifier.contains("static")) {
                // 静态内部类实例
                Object obj = clz.newInstance();
                
            } else {
                // 成员内部类实例
                Constructor constructor = clz.getDeclaredConstructor(clazz);
                constructor.setAccessible(true);
                Object obj = constructor.newInstance(instance);
            }
        }
    4.得到实例方法
        //得到sayHello(String s)方法
        Method sayHelloMethod = clazz.getMethod("sayHello", new Class[]{String.class});
    5.调用实例方法
        //1、sayHelloMethod是得到的方法   2、instance是Person类的实例   3、new Object[]是参数值
        sayHelloMethod.invoke(instance, new Object[] {"mytext"});
    6.得到实例字段
        // getDeclaredFields()获得某个类的所有声明的字段，即包括public、private和proteced，“但是不包括继承到的字段”
        // getFields()获得某个类的所有的公共（public）的字段，包括继承到的字段
        Field[] fields = clazz.getDeclaredFields();
        for(int i=0; i < fields.length; i++) {
            System.out.println(fields[i].getName());
            // 如果该字段是私有的，要加上此句fields[i].setAccessible( true );
            // 打破封装：实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问  
            // 由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的  
            fields[i].set(instance, "abc");
        }
    7.得到实例PropertyDescriptor（内省类库）
        // PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(Person.class).getPropertyDescriptors();
        // PropertyDescriptor[] propertyDescriptors = PropertyUtils.getPropertyDescriptors(Person.class)
        PropertyDescriptor prop = new PropertyDescriptor("id", Person.class);
        Class propClazz = prop.getPropertyType();
        String propName = prop.getName();
        Object propVal1 = prop.getReadMethod().invoke(person);
        Object propVal2 = prop.getWriteMethod().invoke(person, "123456");
    8.其他
        // 得到类名
        public class OutClass {
            public class Inner {
            }
            public static void main(String[] args) {
                String name1 = clazz.getTypeName();             // 如果是一个内部类，名称格式类似于a.b.c.Cls&Inner
                String name2 = clazz.getCanonicalName();        // 如果是一个内部类，名称格式类似于a.b.c.Cls.Inner

                Class clazz = new Inner[]{}.getClass();
                String name1 = clazz.getSimpleName();           // Inner[]
                String name2 = clazz.getTypeName();             // com.test.Main$Inner[] only since 1.8
                String name3 = clazz.getName();                 // [Lcom.test.Main$Inner;
                // 便于理解的名称
                String name4 = clazz.getCanonicalName();        // com.test.Main.Inner[]
            }
        }

    // Apache开发了一套简单、易用的API来操作Bean的属性——BeanUtils工具包
    BeanUtils.setProperty(userInfo, "userName", "peida");









else if ((List.class).isAssignableFrom(subClazz))
    b = matchList((List)subMatch, (List)subBean);








5、例
（1）例1
在JAVA中我还没有见过类似Javascript中eval的这种功能除非自己写一个组件来实现,我说的用反射进行就是下面的代码.
import java.lang.reflect.*;
public class ReflactTest{
    public static void main(String[] args) {
        try{
            Class addClass = Class.forName("AddTest");                              //或Class addClass = new AddTest();
            Method[] method = addClass.getMethods();
            //或Method[] method = new Method[] { addClass.getClass().getMethod("add", new Class[] {Integer.TYPE, Integer.TYPE})  };
            System.out.println(method[0].invoke(new AddTest(), new Object[]{3, 4}));
        } catch (Exception e) {
            e.getMessage();
        }
    } 
}
 
class AddTest{
    private int add1;
    private int add2;

    public AddTest() {}

    public int add(int add1, int add2) {
        return add1 + add2; 
    }
} 

（2）例2
wifimanager.getClass()//取得类的实例
WifiManager.Class()//取得类

  private int a(boolean paramBoolean, WifiConfiguration paramWifiConfiguration)
  {
    WifiManager wifimanager = ((WifiManager)paramContext.getSystemService("wifi"))
    Class localClass = wifimanager.getClass();
    Class[] arrayOfClass = new Class[2];
    arrayOfClass[0] = WifiConfiguration.class;
    arrayOfClass[1] = Boolean.TYPE;
    Method localMethod = localClass.getMethod("setWifiApEnabled", arrayOfClass);
    
    WifiManager localWifiManager = wifimanager;
    Object[] arrayOfObject = new Object[2];
    arrayOfObject[0] = paramWifiConfiguration;
    arrayOfObject[1] = Boolean.valueOf(paramBoolean);
    localMethod.invoke(localWifiManager, arrayOfObject);
    return a();
  }

6、加载数据库驱动
有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？
Class.forName("");的作用是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码 段。而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBC Driver的 Driver类的代码都必须类似如下：
  public class MyJDBCDriver implements Driver {
    static {
      DriverManager.registerDriver(new MyJDBCDriver());
    }
  }
 既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。
¤其实跟把DriverManager.registerDriver(new MyJDBCDriver());做成单例的效果是一样的。



   static {
      // 1.7之后可以直接调用close方法关闭打开的jar，需要判断当前运行的环境是否支持close方法，如果不支持，需要缓存，避免卸载模块后无法删除jar
      try {
         URLClassLoader.class.getMethod("close");
         canCloseJar = true;
      } catch (NoSuchMethodException e) {
      } catch (SecurityException e) {
      }
   }





九、Resource资源
常用种类：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource

ByteArrayResource代表byte[]数组资源，对于 getInputStream() 操作将返回一个ByteArrayInputStream。ByteArrayResource可多次读取数组资源，即 isOpen() 永远返回false。
InputStreamResource代表java.io.InputStream字节流，对于getInputStream() 操作将直接返回该字节流，因此只能读取一次该字节流，即 isOpen() 永远返回true。
FileSystemResource代表java.io.File资源，对于 getInputStream() 操作将返回底层文件的字节流，isOpen() 将永远返回false，从而表示可多次读取底层文件的字节流。

◆
classpath：只会在class路径中查找文件。 
classpath*：不仅在class路径中查找，还在jar文件中(class路径)查找。
程序部署到tomcat后，src目录下的配置文件会和class文件一样，自动copy到应用的WEB-INF/classes目录下；classpath:与classpath*:的区别在于，前者只会从第一个classpath中加载，而后者会从所有的classpath中加载。

比如：
resource1.jar中的package 'com.test.rs' 有一个 'jarAppcontext.xml' 文件,内容如下:
<bean name="ProcessorImplA" class="com.test.spring.di.ProcessorImplA" />
resource2.jar中的package 'com.test.rs' 也有一个 'jarAppcontext.xml' 文件,内容如下:
<bean id="ProcessorImplB" class="com.test.spring.di.ProcessorImplB" />
通过使用下面的代码则可以将两个jar包中的文件都加载进来
ApplicationContext ctx = new ClassPathXmlApplicationContext( "classpath*:com/test/rs/jarAppcontext.xml");
而如果写成下面的代码,就只能找到其中的一个xml文件(顺序取决于jar包的加载顺序)
ApplicationContext ctx = new ClassPathXmlApplicationContext( "classpath:com/test/rs/jarAppcontext.xml");

classpath*:的加载使用了classloader的 getResources() 方法



◆UrlResource
UrlResource urlResource = new UrlResource("http://www.slience.com/book.xml");
urlResource.getFilename()
urlResource.getDescription()
urlResource.getInputStream()


◆
// 从该类的根路径开始寻找某个resource，底层是调用了clazz.getResource方法
ClassPathResource classPathResource = new ClassPathResource("countries.xml");
classPathResource.getInputStream();


◆资源目录
java.net.URL url = Test.class.getResource("");

/**
  * <1>如果Resource存在于“文件夹”中，对应资源前缀为“file:/d:/....”或“file:/....”；如果Resource存在于“jar包”中，对应资源前缀为“jar:file:/D:/....”或“jar:file:/....”
  * <2>类Resource的位置是，存在于“文件夹或jar包”中“当前包”对应的目录下，其根目录为“编译输出目录的根目录”；ClassLoader的Resource的位置是根目录，但ClassLoader.getSystemResource()或ClassLoader.getResource()不能用"/"，会报java.lang.NullPointerException异常。即 
  * Class.getResource("")获取的是相对于当前类的相对路径   
  * Class.getResource("/")获取的是classpath的根路径       √
  * ClassLoader.getResource("")获取的是classpath的根路径  √
  */

// class.getResource("")：当前类所在目录
com.yixin.taoche.op.bean.Test.class.getResource("");                // file:/D:/.../xxproject/target/classes/com/yixin/taoche/op/bean
                                                                    // jar:file:/D:/.../xxproject/target/classes/com/yixin/taoche/op/bean
// class.getResource("/")：classpath根目录√
com.yixin.taoche.op.bean.Test.class.getResource("/");               // file:/D:/.../xxproject/target/classes/
                                                                    // jar:file:/D:/.../xxproject/target/classes/


// ClassLoader.getResource("")：classpath根目录√
Test.class.getClassLoader().getResource("");                        // file:/D:/.../xxproject/target/classes/
// ClassLoader.getResource("/")：classpath根目录
Test.class.getClassLoader().getResource("/");                       // null
Thread.currentThread().getContextClassLoader().getResources("")     // file:/D:/.../xxproject/target/classes/

// ClassLoader.getSystemResource("")：classpath根目录√
ClassLoader.getSystemResource("");                                  // file:/D:/.../xxproject/target/classes/
// ClassLoader.getResource("/")：null
ClassLoader.getSystemResource("/");                                 // null

// 获取jar文件中的资源√
URL url = new URL("jar:file:/D:/Project/art/art-1.0-SNAPSHOT.jar!/com/art/Book.class");
InputStream inputStream = url.openStream();
InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("com/art/Book.class");

// ResourceUtils√
ResourceUtils.getURL("").toExternalForm();                          // file:/D:/.../xxproject/，实际是调用了new File("").toURI().toURL()
ResourceUtils.getURL("classpath:");                                 // file:/D:/.../xxproject/xxmodule/target/classes/
ResourceUtils.getURL("classpath:static/static.html");               // file:/D:/.../xxproject/xxmodule/target/classes/static/static.html


new File("").getPath();                                             // D:\...\xxproject
// new File，（如当前的路径为 C:/test）
File directory = new File("abc");
directory.getCanonicalPath();                                       // 得到的是C:/test/abc
directory.getAbsolutePath();                                        // 得到的是C:/test/abc
direcotry.getPath();                                                // 得到的是abc

File directory = new File(".");                         
directory.getCanonicalPath();                                       // 得到的是C:/test，相当于StringUtil.cleanPath(directory.getAbsolutePath())
directory.getAbsolutePath();                                        // 得到的是C:/test/.
direcotry.getPath();                                                // 得到的是.

File directory = new File("..");                        
directory.getCanonicalPath();                                       // 得到的是C:/，相当于StringUtil.cleanPath(directory.getAbsolutePath())
directory.getAbsolutePath();                                        // 得到的是C:/test/..
direcotry.getPath();                                                // 得到的是..

// 其他
System.getProperty("user.dir");                                    // D:\...\xxproject
System.getProperty("java.version")                                  // Java 运行时环境版本
System.getProperty("java.vendor")                                   // Java 运行时环境供应商
System.getProperty("java.vendor.url")                               // Java 供应商的 URL
System.getProperty("java.home")                                     // Java 安装目录
System.getProperty("java.vm.specification.version")                 // Java 虚拟机规范版本
System.getProperty("java.vm.specification.vendor")                  // Java 虚拟机规范供应商
System.getProperty("java.vm.specification.name")                    // Java 虚拟机规范名称
System.getProperty("java.vm.version")                               // Java 虚拟机实现版本
System.getProperty("java.vm.vendor")                                // Java 虚拟机实现供应商
System.getProperty("java.vm.name")                                  // Java 虚拟机实现名称
System.getProperty("java.specification.version")                    // Java 运行时环境规范版本
System.getProperty("java.specification.vendor")                     // Java 运行时环境规范供应商
System.getProperty("java.specification.name")                       // Java 运行时环境规范名称
System.getProperty("java.class.version")                            // Java 类格式版本号
System.getProperty("java.class.path")                               // Java 类路径
System.getProperty("java.library.path")                             // 加载库时搜索的路径列表
System.getProperty("java.io.tmpdir")                                // 默认的临时文件路径
System.getProperty("java.compiler")                                 // 要使用的 JIT 编译器的名称
System.getProperty("java.ext.dirs")                                 // 一个或多个扩展目录的路径
System.getProperty("os.name")                                       // 操作系统的名称
System.getProperty("os.arch")                                       // 操作系统的架构
System.getProperty("os.version")                                    // 操作系统的版本
System.getProperty("file.separator")                                // 文件分隔符（在 UNIX 系统中是“/”）
System.getProperty("path.separator")                                // 路径分隔符（在 UNIX 系统中是“:”）
System.getProperty("line.separator")                                // 行分隔符（在 UNIX 系统中是“/n”）
System.getProperty("sun.boot.class.path")                           // bootstrapclassloader加载的.jar文件集合
System.getProperty("user.name")                                     // 用户的账户名称
System.getProperty("user.home")                                     // 用户的主目录
System.getProperty("user.dir")                                      // 用户的当前工作目录


◆如何得到jar包的运行路径？
(1)
> cd E:\workspace4svn\Demorun\
> java -jar Demorun_fat.jar
(2)
> java -jar  E:\workspace4svn\Demorun\Demorun_fat.jar
如果直接取相对路径就会得到两个结果，前者会是“E:\workspace4svn\Demorun\”，后者是当前目录，如“E:”。
-----------------------------------------------------------------------------------
this.getClass().getProtectionDomain().getCodeSource().getLocation().getPath()：
在eclipse里运行(不打包)的结果是：“/E:/workspace/Demorun/bin/”
在cmd里运行jar包的结果是：“/E:/workspace/Demorun/Demorun_fat.jar”

this.getClass().getProtectionDomain().getCodeSource().getLocation()：
不打包运行结果："file:/E:/workspace/Demorun/bin/"
打包运行结果："file:/E:/workspace/Demorun/Demorun_fat.jar"




--------------------------------------------------------------------------------------------------------------------
// 百度 getResource jar包内
--1.new ClassPathResource("1.properties").getFile().toString()
java.io.FileNotFoundException: class path resource [1.properties] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/data1/services/park/lib/swiss-1.1.4-SNAPSHOT.jar!/1.properties
	at org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:217)
	at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:131)
	at com.york.portable.park.ParkApplication.main(ParkApplication.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)
	at org.springframework.boot.loader.PropertiesLauncher.main(PropertiesLauncher.java:593)
--2.ResourceUtils.getFile("classpath:1.properties")
java.io.FileNotFoundException: class path resource [1.properties] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/data1/services/park/lib/swiss-1.1.4-SNAPSHOT.jar!/1.properties
	at org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:217)
	at org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:180)
	at com.york.portable.park.ParkApplication.main(ParkApplication.java:62)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)
	at org.springframework.boot.loader.PropertiesLauncher.main(PropertiesLauncher.java:593)
--3.ResourceUtils.getURL
jar:file:/data1/services/park/lib/swiss-1.1.4-SNAPSHOT.jar!/1.properties
--4.ParkApplication.class.getResource("/1.properties").getFile()
file:/data1/services/park/lib/swiss-1.1.4-SNAPSHOT.jar!/1.properties
--5.ParkApplication.class.getResource("1.properties").getFile()
java.lang.NullPointerException
	at com.york.portable.park.ParkApplication.main(ParkApplication.java:92)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)
	at org.springframework.boot.loader.PropertiesLauncher.main(PropertiesLauncher.java:593)
--6.LogKafkaProperties.class.getResource("/1.properties").getFile()
file:/data1/services/park/lib/swiss-1.1.4-SNAPSHOT.jar!/1.properties
--7.LogKafkaProperties.class.getResource("1.properties").getFile()
java.lang.NullPointerException
	at com.york.portable.park.ParkApplication.main(ParkApplication.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)
	at org.springframework.boot.loader.PropertiesLauncher.main(PropertiesLauncher.java:593)
--------------------------------------------------------------------------------------------------------------------













十、ClassLoader
1.三种类加载器
·Bootstrap ClassLoader（启动类加载器）：用于加载$JAVA_HOME/jre/lib/*.jar和$JAVA_HOME/jre/classes下的核心库，由C++实现，不是ClassLoader子类，也可Xbootclasspath选项手动指定。
--------------------------------------------------------------------
URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
for (int i = 0; i < urls.length; i++) {  
    System.out.println(urls[i].toExternalForm());  
}  
或者
System.out.println(System.getProperty("sun.boot.class.path"));

result:
/Java/jdk1.6.0_22/jre/lib/resources.jar
/Java/jdk1.6.0_22/jre/lib/rt.jar
/Java/jdk1.6.0_22/jre/lib/sunrsasign.jar
/Java/jdk1.6.0_22/jre/lib/jsse.jar
/Java/jdk1.6.0_22/jre/lib/jce.jar
/Java/jdk1.6.0_22/jre/lib/charsets.jar
/Java/jdk1.6.0_22/jre/classes/
--------------------------------------------------------------------

·Extension ClassLoader（扩展类加载器）：用于加载$JAVA_HOME/jre/lib/ext/*.jar或-Djava.ext.dirs指定目录下的jar包，默认有以下文件：access-bridge-64.jar、cldrdata.jar、dnsns.jar、jaccess.jar、jfxrt.jar、localedata.jar、meta-index、nashorn.jar、sunec.jar、sunjce_provider.jar、sunmscapi.jar、sunpkcs11.jar、zipfs.jar，也可Djava.ext.dirs选项手动指定。
--------------------------------------------------------------------
URLClassLoader extClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader().getParent();
URL[] urls = extClassLoader.getURLs();
System.out.println(extClassLoader);
for (int i = 0; i < urls.length; i++) {
    System.out.println(urls[i].toExternalForm());
}
result:
sun.misc.Launcher$ExtClassLoader@3e389405
扩展类加载器 的加载路径: 
file:/C:/jdk1.7.0_01/jre/lib/ext/dnsns.jar
file:/C:/jdk1.7.0_01/jre/lib/ext/localedata.jar
file:/C:/jdk1.7.0_01/jre/lib/ext/sunec.jar
file:/C:/jdk1.7.0_01/jre/lib/ext/sunjce_provider.jar
file:/C:/jdk1.7.0_01/jre/lib/ext/sunmscapi.jar
file:/C:/jdk1.7.0_01/jre/lib/ext/zipfs.jar
--------------------------------------------------------------------

·Application ClassLoader（应用程序类加载器）：用于加载classpath、-classpath、-cp、Manifest，也可Djava.class.path手动指定。
可通过System.getProperty("java.class.path")获得这些路径
--------------------------------------------------------------------
//取得应用(系统)类加载器 
URLClassLoader appClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader();
URL[] urls = appClassLoader.getURLs();  
System.out.println(appClassLoader);
for(URL url : urls)  
    System.out.println(url);
result:
sun.misc.Launcher$AppClassLoader@a200d0c
应用(系统)类加载器 的加载路径: 
file:/E:/JAVA/JVM_Class_Reflect_Thread/ClassPath_of_Bootstrap_Ext_AppClassL
--------------------------------------------------------------------


·Custom ClassLoader
属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。

※加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

2.相同类型条件
判断两个类型是否相同的条件是：包名 + 类名 + ClassLoader相同，只要三者相同，既使在不同.class或.jar中，也算相同。


3.URLClassLoader加载器
URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL("file:/D:/Project/art/art-1.0-SNAPSHOT.jar")});
URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL("file:/D:/Project/art/target/classes/com/art/Book.class")});
Class<Book> clazz = urlClassLoader.loadClass("com.art.Book");
Book book = clazz.newInstance();


jar:file:/C:/test.jar!/a.txt 








九、安全性
A、对称加密
private static byte[] iv = {1,2,3,4,5,6,7,8};

	public static String encryptDES(String encryptString, String encryptKey) throws Exception {
//		IvParameterSpec zeroIv = new IvParameterSpec(new byte[8]);
		IvParameterSpec zeroIv = new IvParameterSpec(iv);
		SecretKeySpec key = new SecretKeySpec(encryptKey.getBytes(), "DES");
		Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
		cipher.init(Cipher.ENCRYPT_MODE, key, zeroIv);
		byte[] encryptedData = cipher.doFinal(encryptString.getBytes());
	 
		return Base64.encode(encryptedData);            //byte[]转换为String
	}

	public static String decryptDES(String decryptString, String decryptKey) throws Exception {
		byte[] byteMi = new Base64().decode(decryptString);         //String转换为byte[]
//		IvParameterSpec zeroIv = new IvParameterSpec(new byte[8]);
		IvParameterSpec zeroIv = new IvParameterSpec(iv);
		SecretKeySpec key = new SecretKeySpec(decryptKey.getBytes(), "DES");
		Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
		cipher.init(Cipher.DECRYPT_MODE, key, zeroIv);
		byte decryptedData[] = cipher.doFinal(byteMi);
	 
		return new String(decryptedData);
	}

B、非对称加密

C.MD5
String md5 = org.apache.commons.codec.digest.DigestUtils.md5Hex(text);

// 或
public static String md5Enocde(String text) {
    MessageDigest md5MessageDigest = MessageDigest.getInstance("MD5");
    byte[] bytes = md5MessageDigest.digest(text.getBytes("utf-8"));
    return byteArrayToHex(bytes);
}

public static String byteArrayToHex(byte[] byteArray){
    char[] hexDigits = "0123456789abcdef".toCharArray();
    char[] resultCharArray =new char[byteArray.length * 2];
    int index = 0;

    for (byte b : byteArray) {
        resultCharArray[index++] = hexDigits[b>>> 4 & 0xf];
        resultCharArray[index++] = hexDigits[b& 0xf];
    }
    return new String(resultCharArray);
}

D.base64
String base64 = new BASE64Encoder().encode((username + ":" + password).getBytes());
org.springframework.util.Base64Utils.decodeFromString("base64==")


十、JNI
　　JAVA通过JNI调用本地方法，而本地方法是以库文件的形式存放的（在WINDOWS平台上是DLL文件形式，在UNIX机器上是SO文件形式）。通过调用本地的库文件的内部方法，使JAVA可以实现和本地机器的紧密联系，调用系统级的各接口方法。 
1.JAVA中所需要做的工作 
　　在JAVA程序中，首先需要在类中声明所调用的库名称，如下：
public class testdll 
{ 
    static 
    { 
        System.loadLibrary("goodluck"); 
    } 
    public native static int get(); 
    public native static void set(int i); 
    public static void main(String[] args) 
    { 
        testdll test = new testdll(); 
        test.set(10); 
        System.out.println(test.get()); 
    } 
} 
    用javac testdll.java编译它，会生成testdll.class。 
    再用javah testdll，则会在当前目录下生成testdll.h文件，这个文件需要被C/C++程序调用来生成所需的库文件。 
2.C/C++中所需要做的工作 
    对于已生成的.h头文件，C/C++所需要做的，就是把它的各个方法具体的实现。然后编译连接成库文件即可。再把库文件拷贝到JAVA程序的路径下面，就可以用JAVA调用C/C++所实现的功能了。
（1）testdll.h文件的内容：
/* DO NOT EDIT THIS FILE - it is machine generated */ 
#include 
/* Header for class testdll */ 
#ifndef _Included_testdll 
#define _Included_testdll 
#ifdef __cplusplus 
extern "C" { 
#endif 
    /* 
    * Class: testdll 
    * Method: get 
    * Signature: ()I 
    */ 
    JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 
    /* 
    * Class: testdll 
    * Method: set 
    * Signature: (I)V 
    */ 
    JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint); 
#ifdef __cplusplus 
} 
#endif 
#endif 
在具体实现的时候，我们只关心两个函数原型：
    JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 和 
    JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint); 
    这里JNIEXPORT和JNICALL都是JNI的关键字，表示此函数是要被JNI调用的。而jint是以JNI为中介使JAVA的int类型与本地的int沟通的一种类型，我们可以视而不见，就当做int使用。函数的名称是JAVA_再加上java程序的package路径再加函数名组成的。参数中，我们也只需要关心在JAVA程序中存在的参数，至于JNIEnv*和jclass我们一般没有必要去碰它。 

（2）testdll.cpp
#include "testdll.h" 
int i = 0; 
JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass) 
{ 
    return i; 
} 
JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint j) 
{ 
    i = j; 
}
    编译连接成库文件，本例是在WINDOWS下做的，生成的是DLL文件。并且名称要与JAVA中需要调用的一致，这里就是goodluck.dll 。把goodluck.dll拷贝到testdll.class的目录下，java testdll运行它，就可以观察到结果了。




十一、回收











十二、常见错误











十三、序列化
1.xml
●读取xml
@SuppressWarnings("unchecked")
public static Map<String, String> parseXml(HttpServletRequest request) throws Exception {
        // 将解析结果存储在HashMap中
        Map<String, String> map = new HashMap<String, String>();
 
        // 从request中取得输入流
        InputStream inputStream = request.getInputStream();
        // 读取输入流
        SAXReader reader = new SAXReader();
        Document document = reader.read(inputStream);

        // 得到xml根元素
        Element root = document.getRootElement();
        // 得到根元素的所有子节点
        List<Element> elementList = root.elements();
 
        // 遍历所有子节点
        for (Element e : elementList)
            map.put(e.getName(), e.getText());
 
        // 释放资源
        inputStream.close();
        inputStream = null;
        return map;
}

2.json
（1）Gson
public static <T> T fromJson(String jsonstr) {
    Gson gson = new Gson();
    T t = gson.fromJson(jsonstr,  new TypeToken<T>() {  }.getType());
    return t;
}

public static void main() {
    List<Menu> list = fromJson<List<Menu>>("...");
}



（2）apache.common.lang
String str = "{\\\"name\\\":\\\"spy\\\",\\\"id\\\\":\\\"123456\\\"}";
System.out.println("原始 str = " + str);
String str1 = StringEscapeUtils.unescapeJava(str);
System.out.println("目标 str1 = " + str1);
//对应方法的StringEscapeUtils.escapeJava(str1);
//可将str1转义回str

控制台输出：

原始 str = {\"name\":\"spy\",\"id\":\"123456\"}
目标 str1 = {"name":"spy","id":"123456"}


（3）jackson
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.9.5</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml -->
        <!-- 可添加对xml格式的支持 -->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
            <version>2.9.5</version>
        </dependency>



spring:
  jackson:
      date-format: yyyy-MM-dd HH:mm:ss
      joda-date-time-format: yyyy-MM-dd HH:mm:ss
      default-property-inclusion: use_defaults
      time-zone: GMT+8
      serialization:
        write_dates_as_timestamps: false
      deserialization:
        fail-on-unknown-properties: false




    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonRootName("FriendDetail")
    @JsonIgnoreProperties({"uselessProp1", "uselessProp3"})
    public class Friend {
        @JsonProperty("NickName")
        private String name;
        
        @JsonProperty("Age")
        private int age;
        private String uselessProp1;
        
        @JsonIgnore
        private int uselessProp2;
        private String uselessProp3;
        
        // 将Date转换成String，一般前台给后台传值时用，com.fasterxml.jackson.annotation
        @JsonFormat(pattern="yyyy/MM/dd'T'HH:mm:ss.SSSZ", timezone="GMT+8")     // '2088/08/08T11:11:11.000+0800'
        @JsonFormat(pattern="yyyy/MM/dd'T'HH:mm:ss.SSSz", timezone="GMT+8")     // '2018-11-05T15:13:44.000GMT+08:00'
        @DateTimeFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")                 // 将String转换成Date，一般后台传值给前台时，org.springframework.format.annotation
        @JSONField(format="yyyy/MM/dd HH:mm:ss")                                // fastjson
        private Date createTime;
    }

    public ObjectMapper getMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        // 默认序列化与反序列化是通过get/set方法。可指定通过字段的方式代替get/set方法
        objectMapper.setVisibility(JsonMethod.SETTER, Visibility.NONE);
        objectMapper.setVisibility(JsonMethod.GETTER, Visibility.NONE);
        // 开启反射时访问所有访问修饰符的字段，就可以直接访问private字段，而不需要get/set
        objectMapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);

        // 接受只有一个元素的数组的反序列化
        objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
        // 接受null值的反序列化
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);
        // 对象中存在未知的属性时，报异常
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 允许出现特殊字符和转义符，默认false
        objectMapper.configure(Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);
        // 将日期格式序列化成时间戳，默认true
        .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        // 是否要缩进，默认false
        .configure(SerializationFeature.INDENT_OUTPUT, Include.NON_NULL);
        // 当Bean为空时会报：com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class JUnitTest$Man and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)，默认true
        .configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);


        // 序列化器
        objectMapper.getSerializationConfig().getDateFormat();
        // 反序列化器
        objectMapper.getDeserializationConfig().setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        // Include.Include.ALWAYS 默认 
        // Include.NON_DEFAULT 属性为默认值不序列化
        // Include.NON_EMPTY 属性为 "" 或者为 NULL 都不序列化
        // Include.NON_NULL 属性为NULL 不序列化
        objectMapper.setSerializationInclusion(Include.NON_NULL);

        // 设置过滤器
        FilterProvider filterProvider = new SimpleFilterProvider();
        SimpleBeanPropertyFilter fieldFilter = SimpleBeanPropertyFilter.serializeAllExcept("name");
        filterProvider.addFilter("fieldFilterName", fieldFilter);
        objectMapper.setFilters(filterProvider);


        // 反序列化：复杂类型
        // 方式一
        {
            JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, User.class);
            List<User> userList = (List<User>)mapper.readValue(jsonStr, javaType);
        }
        {
            JavaType javaType = mapper.getTypeFactory().constructParametricType(HashMap.class, String.class, User.class);
            Map<String, User> userList = (Map<String, User>)mapper.readValue(jsonStr, javaType);
        }

        // 方式二
        {
            List<User> userList3 = mapper.readValue(jsonStr, new TypeReference<List<User>>() {
                });
        }



    }

    public void test() {
        Friend friend;
        ObjectMapper mapper = getMapper();
        friend = objectMapper.readValue(text, Friend.class);
        friend = objectMapper.readValue(bytes, Friend.class);
        friend = objectMapper.readValue(new File("friend.json"), Friend.class);
    }






方法一:

String jsonString="[{'id':'1'}, {'id':'2'}]";
ObjectMapper mapper = new ObjectMapper();
JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, Bean.class);
//如果是Map类型  mapper.getTypeFactory().constructParametricType(HashMap.class,String.class, Bean.class);
List<Bean> lst =  (List<Bean>)mapper.readValue(jsonString, javaType); 

方法二:
String jsonString="[{'id':'1'},{'id':'2'}]";
ObjectMapper mapper = new ObjectMapper();




1）序列化对象注解
@JsonIgnoreType                                                                     // 指定忽略该类的序列化
@JsonIgnoreProperties({"description1", "description2", "description3"})             // 指定忽略的字段，可用于代理类
@JsonNaming(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class)          // 指定序列化命名策略
@JsonPropertyOrder(alphabetic = true,value = {"c","b"})                             // 指定序列化顺序
public class Book {
    @JsonProperty("description_1")                  // 显式标明对该项进行序列化
    private String description1;

    
    private String description2;

    @JsonIgnore                                     // 忽略
    private String description3;

    private List<Book> referBookList;
    // 解决循环引用
    // 在parentNode属性或者在相应的getter和setter上加@JsonBackReference
    // 在children属性或者在相应的getter和setter上加@JsonManagedReference
    @JsonManagedReference
    public List<Book> getReferBookList() {...}

    private Book parent;
    @JsonBackReference
    public Book getParent() {
        return parent;
    }

    public class DateToTimestamp extends JsonSerializer<Date> {
        @Override
        public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
            jsonGenerator.writeNumber(date.getTime() / 1000);
        }
    }


    @JsonSerialize(using = DateToTimestamp.class)
    private Date createTimestamp;


    // 将Date转换成String，一般前台给后台传值时用，com.fasterxml.jackson.annotation
    @JsonFormat(pattern="yyyy/MM/dd'T'HH:mm:ss.SSSZ", timezone="GMT+8")     // '2088/08/08T11:11:11.000+0800'
    @JsonFormat(pattern="yyyy/MM/dd'T'HH:mm:ss.SSSz", timezone="GMT+8")     // '2018-11-05T15:13:44.000GMT+08:00'
    private Date createTime;

    // 把成员对象中的属性提升到其容器类，并添加给定的前缀，比如上例中: User类中有name和age两个属性，
    // 不使用此注解则序列化为：
    // ... "user": { "name": "xxx", "age": 22 } ...
    // 使用此注解则序列化为：
    // ... "user_name": "xxx", "user_age": 22, ...
    @JsonUnwrapped(prefix = "user_")
    private User user;

    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class,property = "id") 
    // 作用于类或属性上，被用来在序列化/反序列化时为该对象或字段添加一个对象识别码，通常是用来解决循环嵌套的问题
}




2）序列化枚举注解

import com.fasterxml.jackson.annotation.JsonValue;

@JsonFormat(shape = JsonFormat.Shape.OBJECT)            // 会把枚举当成普通对象来做序列化
public enum Gender {
    MALE(0, "男"),               // ※jackson对枚举序列化，默认是序列化成“枚举名称”，即此处会序列化成“MALE”，如果要换成其他，可以通过@JsonValue来实现
    FEMALE(1, "女"),
    UNKOWN(2, "未知");
    
    private Integer id;
    private String des;
    
    private Gender(Integer id, String des) {
        this.id = id;
        this.des = des;
    }
    
    public String getDes() {
        return des;
    }
    public void setDes(String des) {
        this.des = des;
    }

    @JsonValue                  // 重点
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
}

3）序列化时间
// Serialize Date to ISO-8601
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
objectMapper.setDateFormat(new ISO8601DateFormat());

SimpleDateFormat df = new SimpleDateFormat("dd-MM-yyyy hh:mm");
df.setTimeZone(TimeZone.getTimeZone("UTC"));
Date date = df.parse("01-01-1970 02:30");










十五、正则表达式
A.

B.

    // 静态
    boolean isMatch = Pattern.matches(regex, content);

    // 动态
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(content);
    if (matcher.find( )) {
       System.out.println("Found value: " + matcher.group(0) );
       System.out.println("Found value: " + matcher.group(1) );
       System.out.println("Found value: " + matcher.group(2) );
       System.out.println("Found value: " + matcher.group(3) ); 

       // 替换
       String INPUT = matcher.replaceAll(REPLACE);
    } else {
       System.out.println("NO MATCH");
    }




    String regex = "\\$\\{(na.+?)\\}-(ba.+?)";
    String input = "${name}-babalala-${age}-${address}++${name}-babalala";


    int i = -1;
    StringBuffer sb = new StringBuffer();

    Matcher matcher = Pattern.compile(regex).matcher(input);
    // 每一次find是一个匹配项
    while(matcher.find()) {
        // ${name}-baba
        matcher.group(0)
        // name
        matcher.group(1)
        // baba
        matcher.group(2)
        
        matcher.appendReplacement(sb, replacement[++i]);
    }
    
    1lala-${age}-${address}++2










（3）Replace
    string input = "[1][2][3][4]";
    //静态方式：string output = Regex.Replace(input, @"\[(\d+)\]", "<img src='$1.gif'/>");               //关键在于(\d+)，一定要加()。即()=>$1、$2、$3...
    string output = new Regex(@"\[(\d+)\]").Replace(input, "<img src='$1.gif'/>");
Result:
<img src='1.gif'/><img src='2.gif'/><img src='3.gif'/><img src='4.gif'/>

（4）Replace
通过YouTube的API获取的视频，视频的时长格式是诸如 PT21H4M6S 这种格式，但这种格式不方便用户查看。所以我们可以使用正则表达式转换YouTube视频的时间格式。

 Regex reg = new Regex(@"^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$");
 var time = reg.Replace("PT21H4M6S", new MatchEvaluator(match =>
 {
     if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
     {
         return string.Format("{0}:{1}:{2}",match.Groups[1].Value,match.Groups[2].Value,match.Groups[3].Value);
     }
     return string.Format("{0}:{1}",match.Groups[2].Value,match.Groups[3].Value);
 }));
 Console.WriteLine(time);




十五、gralde
通俗的说：gradle是打包用的。
你觉得解决你的问题了吗？如果没解决，那是你的问题提得不够好。比如我猜你应该提：为什么要打包发布，打包发布有几种常见方法，为什么这些常见方法中要选gradle，等等。
针对我猜的这些内容，通俗的讲是这样的：
以在eclipse里面写java程序为例
为什么需要打包：
最初写完了，直接右键run就可以了。但是程序写完了毕竟是要发布到服务器上或者给别人用的，你第一不可能让所有要运行的人都装个eclipse，第二不可能把源代码公布给所有人。所以你需要把你的代码发布成二进制形式，让其它环境方便运行，这就是打包。
为什么用ant打包的时候要做很多事，比如说配置文件中的用户名和密码，你本地开发和程序实际运行时的内容肯定不一致，所以需要有两个文件，开发的时候用一个，实际运行的时候用一个。这样每次打包的时候都要重复的做这些事，ant可以让你用xml的形式把这些事情写成脚本，然后自动运行。
为什么用maven
你的项目要用很多jar包，比如你写日志要用个log4j吧，连数据库要用个connector吧。这年头写程序不用个spring都不好意思出门，下载下来的spring包打开一看，密密麻麻的好几十个jar，不知道用哪个不用哪个。而且，即便是你一狠心把这些jar包都放进来，很大可能性还是不能运行，因为还要依赖其它的jar包。哪天想升级个spring小版本，所有jar包都要重来一遍，你也不记得哪些是由于spring引进来的jar包了。
所以有了maven，你只要配置一下说我要用spring 3，所有jar包都给你下载好了，你直接运行就行了。赶明儿想升级版本，直接把3改成4，新的jar包也给你下载好了。
然后？
用了maven，jar包是方便了，但我打包的时候还是有好多事要做啊，然后你会发现maven实在是不知道怎么做这些事，于是开始怀念ant。gradle就是又能干maven的活，又能干ant的活，用groove语言写脚本，表达能力还更强。
就这意思。
===
我也是这两天才看了两眼gradle，了解不深。简化版如下：
ant可以自动化打包逻辑。
maven也可以自动化打包，相比于ant，它多做的事是帮你下载jar包。
但是maven的打包逻辑太死板，定制起来太麻烦，不如ant好用。gradle就是又能自动下jar包，又能自己写脚本，并且脚本写起来还比ant好用的这么个东西。













十六、stream
我们首先列出stream的如下三点特性，在之后我们会对照着详细说明
1.stream不存储数据
2.stream不改变源数据
3.stream的延迟执行特性
通常我们在数组或集合的基础上创建stream，stream不会专门存储数据，对stream的操作也不会影响到创建它的数组和集合，对于stream的聚合、消费或收集操作只能进行一次，再次操作会报错，如下代码：
在collect方法执行之前，filter、sorted、map方法还未执行，只有当collect方法执行时才会触发之前转换操作

A.常用操作
<1>定位
List<int> arr = new List<int>() { 1, 2, 6, 4, 5, 6, 3 };
加上OrDefault后缀表示如为空，则返回该类型的默认值（null或0）
•findFirst
用法：Optional<int> t = stream.findFirst();
说明：返回第一条断言等于true的记录

•findAny
用法：Optional<int> t = stream.findAny();
说明：返回任意一条断言等于true的记录

<2>判断
•allMatch
用法：bool b = stream.allMatch( a -> a > 2 );
说明：当所有断言为ture时，返回true

•anyMatch
用法：bool b = stream.anyMatch( a -> a > 2 );
说明：当任意断言为true时，返回true

•noneMatch
用法：bool b = stream.noneMatch( a -> a > 2 );
说明：当任意断言为true时，返回true

•Contains
用法：bool b = stream.Contains(2);
说明：当包含目标对象时，返回true

•SequenceEqual
用法：bool b = stream.SequenceEqual(arr);
说明：当与目标对象以相同顺序匹配时，返回true

•DefaultIfEmpty
用法：List<int> emptyScores = new List<int>(); 
      foreach( int score in emptyScores.DefaultIfEmpty() ) {};
      或foreach( int score in emptyScores.DefaultIfEmpty(50) ) {};
说明：当目标对象为空时，返回Default集合

<3>排序
•sort
用法：stream.sorted(Comparator.comparing(c -> c.Category));
    ：list.sort(Comparator.reverseOrder());
说明：先以sort顺序正序
String[] arr1 = {"abc","a","bc","abcd"};
// 按照字符长度排序
Stream<String> stream1 = Arrays.stream(arr1).sorted((x, y) -> {
        if (x.length() > y.length())
            return 1;
        else if (x.length() < y.length())
            return -1;
        else
            return 0;
    });

Stream<String> stream2 = Arrays.stream(arr1).sorted(Comparator.comparing(String::length).reversed());
Stream<String> stream3 = Arrays.stream(arr1).sorted(Comparator.comparing(String::length), Comparator.nullsLast(Date::compareTo)).reversed());
Stream<String> stream4 = Arrays.stream(arr1).sorted(Comparator.comparing(Apple::getWeight).reverseOrder());
# 大小写不敏感
Stream<String> stream5 = Arrays.stream(arr1).sorted(String.CASE_INSENSITIVE_ORDER);
# 
Stream<String> stream6 = Arrays.stream(arr1).sorted(Comparator.naturalOrder());


// 双重排序

    public void doubleSorted() {
        List<String> list = Arrays.asList("B2", "B1", "A1", "A3", "A2");
        
        // 编译错误，要分开写
        // Comparator<String> comparator = Comparator.comparing(c -> c.charAt(0)).thenComparing(c -> c.charAt(1));
        Comparator<String> comparator = Comparator.comparing(c -> c.charAt(0));
        comparator = comparator.thenComparing(c -> c.charAt(1));
        List<String> result = list.stream().sorted(comparator).collect(Collectors.toList());
    }

        Comparator<String> comparator = Comparator.comparing(LeadsSourceAndCatogory::getCategorycode());
        comparator = comparator.thenComparing(LeadsSourceAndCatogory::getCategorycode());
        list.stream().sorted(comparator).collect(Collectors.toList());



<3>筛选
List<int> arr = new List<int>() { 1, 2, 3, 4, 5, 6, 7 };
•filter
用法：List<int> arr_new = stream.filter(a -> { return a > 3; })
说明：返回满足给定条件的子集

※LINQ to Entities 不识别方法“Boolean Contains(Int32)”
IQueryable<int> TestTables=...;
//或IList<int> TestTables=...;
IList<int> ids = new List<int> { 2, 3, 4 };
var list = TestTables.filter(a -> ids.Contains(a.RID)).ToList();
然而，运行发现系统会抛出如下异常：
LINQ to Entities 不识别方法“Boolean Contains(Int32)”，因此该方法无法转换为存储表达式。 
究其原因，是Contains是IList类型的扩展方法而linq无法转换过来。所以上述办法就无法得到我们想要的结果（虽然编译不会有错）。 
解决方法：
IEnumerable<HR> HRList = ...;
IList<int> ids = new List<int> { 2, 3, 4 };
var list = HRList.AsEnumerable().filter(a -> ids.Contains(a.RID)).ToList();

•OfType
用法：stream.OfType<int>();
说明：根据指定类型，筛选集合中的元素
•Cast
用法：stream.Cast<string>();
说明：将非IEnumerable(非泛型)的派生对象转换成IEnumerable<T>对象，比OfType少了一层过滤的功能
•limit
用法：List<T> t = stream.limit(2).collect(Collectors.toList());
说明：返回前N条记录，丢弃剩余部分，SQL对应语法为Where ROW_NUMBER()或者TOP n子查询
•TakeWhile
用法：stream.TakeWhile( a -> a > 2 );
TakeWhile：返回输入序列中的所有元素直到断言等于true，无SQL对应语法
•skip
用法：Stream<T> ts = stream.skip(2);
说明：跳过前N条记录，返回剩余部分，SQL对应语法为Where ROW_NUMBER()或者NOT IN(Select Top N…)
•SkipWhile
用法：Stream<T> ts = stream.SkipWhile( a -> a > 2 );
说明：跳过输入序列中的元素直到断言等于true，返回剩下的所有元素，无SQL对应语法
•distinct
用法：Stream<T> ts = stream.distinct();
说明：返回无重复的集合元素，SQL对应语法为Select Distinct

    public static  <T> List<T> distinctBy(List<T> list, Function<? super T, ?> getPropertyFunction) {
        List<T> collect = list.parallelStream().filter(falseIfRepeat(getPropertyFunction)).collect(Collectors.toList());
        return collect;
    }


    private static  <T> Predicate<T> falseIfRepeat(Function<? super T, ?> getPropertyFunction) {
        Set<Object> seen = ConcurrentHashMap.newKeySet();
        return t -> seen.add(getPropertyFunction.apply(t));
    }

<4>计算
•count
用法：stream.count( c -> c > 2 );
说明：返回符合条件的记录数
•max
用法：Stream.of(2,1,4,5,3).max(Integer::compare).get();
说明：返回符合条件的记录中的最大值
•min
用法：Stream.of(2,1,4,5,3).min(Integer::compare).get();
说明：返回符合条件的记录中的最小值

Stream.of(1,2,4,5,3).mapToInt(i -> i).max().getAsInt()

•Sum
用法：stream.Sum( c -> c.Age );
说明：返回符合条件的记录之和
List<int> arr = new List<int>() { 1, 2, 3, 4, 5, 6, 7 };
var result = stream.filter(a -> { return a > 3; }).Sum();
//同(from v in arr where v > 3 select v).Sum();
•Average
用法：stream.Average( c -> c.Age );
说明：返回符合条件的记录的平均值
•Agregate
用法：
说明：

<5>投影
•说明样例
class School
{
  public IList<Class> Classes = new List<Class>();
}
class Class
{
  public IList<Student> Students = new List<Student>();
}
class Student
{
  public string Name;
  public int Sex;
}

School s = new School();
for(int i=0;i<5;i++)
{
  s.Classes.Add(new Class());
}
s.Classes[0].Students.Add(new Student( 1, "a0" ));
s.Classes[1].Students.Add(new Student( 0, "b0" ));
s.Classes[2].Students.Add(new Student( 0, "c0" ));
s.Classes[2].Students.Add(new Student( 0, "c1" ));
s.Classes[2].Students.Add(new Student( 1, "c2" ));

•map
用法：stream.map<int, string>(a -> a.ToString());
说明：将“序列”投影到新序列中。上例中：新序列是一个IEnumerable<String>的集合
结果：
IEnumerable<<IList>Student> x = s.Classes.map(item -> item.Students);    //映射“多个班级”中的“同学群”
即:IEnumerable<Students> x = s.Classes.map(item -> item.Students);       //返回List<Students>类型

var rows = list.map(s -> new                                           //此处可使用new {}匿名类型，也可使用new xxClass {}已知类型
    {
        Id = s.Id,
        s.Title,
        s.Author,
        Trade = GetTradeNames(s.Trade),
        s.ReleaseState,
        s.ReleaseDate,
        s.CancelReleaseDate,
        FirstCategory = s.Category.Level == 2 ? s.Category.Parent.Name : "",
        SecondCategoryName = s.Category.Level == 2 ? s.Category.Name : "",
    });


•flatMap
用法：
说明：将“序列中的所有子元素”投影到新序列中，最终把所有子元素合并
区别：两者都是被一个“父集合”调用，用于“父集合”包含“子集合”的情况，Select的返回值是“子集合”，SelectMany的返回值是“子集合”内的各元素
{{1, 2}, {3, 4}, {5, 6}}  - > flatMap  - > {1, 2, 3, 4, 5, 6}
{{'a', 'b'}, {'c', 'd'}, {'e', 'f'}}  - > flatMap  - > {'a', 'b', 'c', 'd', 'e', 'f'}
--------------------------------------------------------------------------------------------------------
// {{"1", "2", "3", "4", "5", "6", "7", "8"}, {"A", "B", "C", "D", "E", "F", "G", "H"}}
List<String> arr1 = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8");
List<String> arr2 = Arrays.asList("A", "B", "C", "D", "E", "F", "G", "H");
List<List<String>> arr = Arrays.asList(arr1, arr2);

// {{"1", "2", "3", "4", "5", "6", "7", "8"}, {"A", "B", "C", "D", "E", "F", "G", "H"}}
List<List<String>> ret1 = arr.stream().map(c -> c).collect(Collectors.toList());
// {"1", "2", "3", "4", "5", "6", "7", "8", "A", "B", "C", "D", "E", "F", "G", "H"}
List<String> ret2 = arr.stream().flatMap(c -> c.stream()).collect(Collectors.toList());
--------------------------------------------------------------------------------------------------------


•reduce
用法：网上翻译为规约，它将数据流缩减为一个值
说明：
int total = tasks.stream().map(Task::getTitle).reduce((sum, element) -> sum + element).get();
int total = tasks.stream().map(Task::getTitle).reduce(first, (sum, element) -> sum + element).get();
int total = tasks.stream().map(Task::getTitle).reduce(0, Integer::sum).get();

•concat
用法：合并
说明：Stream stream3 = Stream.concat(Stream.of(str1), Stream.of(str2))

<6>分组
•groupingBy/groupingByConcurrent
用法：stream.collect(Collectors.groupingBy( c -> c.Category );
说明：按给定条件分组返回记录，groupingBy是延迟加载
返回值类型：IEnumerable<IGrouping<TKey, TSource>>
例：
    List<MA> list = new ArrayList<MA>();
    list.add(MA.instance("A", 1));
    list.add(MA.instance("A", 2));
    list.add(MA.instance("A", 3));
    list.add(MA.instance("A", 3));
    list.add(MA.instance("B", 11));
    list.add(MA.instance("B", 12));
    list.add(MA.instance("B", 13));
    list.add(MA.instance("C", 22));
    list.add(MA.instance("C", 22));
    Map<MA, Long> map1 = list.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));                  // Function.identity()相当于c -> c
    Map<String, Long> map2 = list.stream().collect(Collectors.groupingBy(MA::getKey, Collectors.counting()));
    Map<String, Integer> map2 = list.stream().collect(Collectors.groupingBy(MA::getKey, Collectors.summingInt(MA::getValue)));
    Map<String, Set<Integer>> map3 = list.stream().collect(Collectors.groupingBy(MA::getKey, Collectors.mapping(MA::getValue, Collectors.toSet()));
      list的结构是A---(1)
                   |--(2)
                   |--(3)
                  B---(11)
                   |--(12)
                   |--(13)
                  C---(22)
    Map<String, List<String>> map4 = list.stream().collect(Collectors.groupingBy(MA::getKey, Collectors.mapping(MA::getKey, Collectors.toList())));


    IEnumerable<IGrouping<string, MA>> listG = list.groupingBy(p -> p.ma001);
    /*
      list的结构是A---(A, 1)
                   |--(A, 2)
                   |--(A, 3)
                   |--(A, 3)
                  B---(B, 11)
                   |--(B, 12)
                   |--(B, 13)
                  C---(C, 22)
                   |--(C, 22)
    */






Map<Boolean, List<Integer>> collectGroup= Stream.of(1, 2, 3, 4)
            .collect(Collectors.groupingBy(it -> it > 3));
System.out.println("collectGroup : " + collectGroup);
// 打印结果
// collectGroup : {false=[1, 2, 3], true=[4]}








•ToLookUp
用法：stream.ToLookUp( c -> c.Category );
说明：按给定条件分组返回记录，与groupingBy唯一的不同，ToLookUp是非延迟加载

•Join（类似于T-SQL中的inner join）
用法：var newT = t1s.Join(t2s, item1 -> item1.pKey, item2 -> item2.pKey, (item1, item2) -> new { t2 = item1.c1, t3 = item2.c2 }).ToList();
说明：组合两个集合的字段，并映射为新的集合
List<T1> t1s = new List<T1>() { new T1() { pKey = "t", c1 = "t1", c2 = "t2" } };
List<T2> t2s = new List<T2>() { new T2() { pKey = "t", c1 = "t1", c2 = "t2" } };
var newT = t1s.Join(                                                                //第一个集合
                t2s,                                                                //第二个集合
                item1 -> item1.pKey,                                                //第一个集合的主键
                item2 -> item2.pKey,                                                //第二个集合的主键
                (item1, item2) -> new { t2 = item1.c1, t3 = item2.c2 }              //映射为新集合的方式
        ).ToList();



<7>操作
•Concat
用法：arr1.Concat(arr2);
说明：连接，不去重
Stream.concat(stream1,stream2).distinct();

•Union
用法：arr1.Union(arr2);
说明：并集，去重

•Intersect
用法：arr1.Intersect(arr2);
说明：取交集

•Except
用法：arr1.Except(arr2);
说明：从arr1中排除arr2中的元素，arr2可以大于arr1，差集
★arr1.Except(arr2) 与 arr2.Except(arr1) 结果不同

•Aggregate
用法：arr1.Aggregate("AggregateValue：", (current, next) -> current.key + "," + next.key);    //["key1", "key2", "key3", "key4"] -> "key1, key2, key3, key4"
说明：取得聚合值

•forEach（并行时不保证顺序）
用法：arr1.stream().parallel().forEach(p -> p.Name = p.Name + "Mother");
说明：遍历集合中的每个元素，并进行指定的操作

•forEachOrdered（并行时保证顺序）
用法：arr1.stream().parallel().forEachOrdered(p -> p.Name = p.Name + "Mother");
说明：遍历集合中的每个元素，并进行指定的操作

•TrueForAll
用法：arr1.TrueForAll(p -> p.Name == p.Name);
说明：

•forEach、forEachOrdered
用法：list2.stream().forEach(string -> { System.out.println(string); });
说明：遍历操作

<8>转换
•toArray
用法：String[] arr = stream.toArray(String[]::new);
说明：将集合转换为数组；不延迟

•collect
用法：List<String> list = stream.collect(Collectors.toList());
说明：

•asList
String[] arrays = {"aa","bb","cc"};
List<String> strlist = Arrays.asList(arrays);
List<String> strs = Arrays.asList("11212","dfd","2323","dfhgf");

•parallelStream
用法：Stream<String> stream1 = arr.parallelStream();               // 相当于Stream<String> stream1 = arr.stream().parallel();
说明：创建并行流

<9>生成集合
•Stream.iterate
用法：List<Integer> list = Stream.iterate(0, item -> item + 1).limit(10).collect(Collectors.toList());
说明：使用Range操作符来生成从0到9的整数序列

•empty
用法：Stream<Integer> stream  = Stream.empty();
说明：创建一个空的stream

•Arrays.stream
用法：IntStream stream = Arrays.stream(new int[]{1, 3, 4});
说明：

•Stream.of
用法：其实就是对Arrays.stream的封装
Stream<Integer> stream = Stream.of(1, 2, 3);
Stream<Integer> stream = Stream.of(new Integer[]{1, 2, 3});
说明：生成

•stream
用法：Stream<String> stream  = arr.stream();
说明：

•Stream.generate
用法：Stream<String> echos = Stream.generate(() -> "echo");
说明：


•
用法：x.stream().parallel()
说明：



B.Optional
Optional 不是函数是类，这是个用来防止NullPointerException的辅助类型。

public void reduceTest() {  
    Integer testInt[]={};  
    Optional<Integer> sum = Stream.of(testInt).reduce(Integer::sum);  
    System.out.println(sum);
    sum.ifPresent(val -> {});                               // Optional.ifPresent：如果存在则执行lambda表达式
    
    if (sum.isPresent()) {  
        System.out.println(sum.get());                      // Optional.get：如果为null则抛异常NoSuchElement
    } else if () {
    }
    else {  
        System.out.println(sum.empty());                    // Optional.empty
    }
    
    System.out.println(sum.orElse(0));                      // Optional.orElse：如果为null则返回0
    System.out.println(sum.orElseGet(() -> 0));             // 0 Optional.orElseGet：如果为null则执行lambda表达式

    try {
        sum.orElseThrow(Exception::new);
    } catch (Exception e) {
        e.printStackTrace();
    }

    Optional<String> optional = Optional.<String>empty();   // 返回一个空Optional<String> 
}


C.Collectors收集器
格式
list1 = stream.collect(Collectors.toList());  
list2 = stream.collect(Collectors.toCollection(ArrayList::new));
list2 = stream.collect(Collectors.groupingBy(Product::getSubjectId, Collectors.toList()));

转换种类：

•Collectors.toList()：转换成List集合。
•Collectors.toSet()：转换成Set集合。
•Collectors.toCollection(TreeSet::new)：转换成特定的set集合。
 TreeSet<Integer> collect2 = Stream.of(1, 3, 4).collect(Collectors.toCollection(TreeSet::new));
•Collectors.joining(",")：使用','将字符串拼接起来。
•Collectors.toMap(x -> x, x -> x + 1)：转换成map。
// 普通
Map<Integer, Integer> collect1 = Stream.of(1, 3, 4).collect(Collectors.toMap(x -> x, x -> x + 1));
// 普通
Map<String, String> carPropertySelector = list.stream().collect(Collectors.toMap(c -> c.getName(), c -> c.getGender()));
// 为空：_map为HashMap::new，_entity为数据源（当value为null时，报java.lang.NullPointerException异常）
Map<String, String> carPropertySelector = list.stream().collect(
    Collector.of(HashMap::new, (_map, _entity) -> _map.put(_entity.getKey(), _entity.getValue()), (k, v) -> v));
    // 或
    .collect(HashMap::new, (_map, _entity)->_map.put(_entity.getKey(), _entity.getValue()), HashMap::putAll);
    // 或
    .collect(Collectors.toMap(e -> e.getKey(), e -> Optional.ofNullable(e.getValue()).orElse("")));
// 重复（当key重复时，报java.lang.IllegalStateException: Duplicate key异常）
Collectors.toMap(keyMapper, valueMapper, mergeFunction)
★前两个参数都是与之前一样 key 和 value 的取值属性，第三个参数是当 key 值发生重复时处理的方法，注释上的解释为：一种合并函数，用于解决两者之间的冲突与提供的相同键相关联的值到{@link Map#merge(Object, Object, BiFunction)}，该合并函数有两个参数，第一个参数为当前重复key 之前对应的值，第二个为当前重复key 现在数据的值。
java8处理思路：即两个key相同时只能有一个key存在，那对应的value如何处理？我们自己来定义方法体处理。
eg.
    List<Student> list = new ArrayList<>();
    list.add(new Student("一年级二班", "小明"));
    list.add(new Student("一年级二班", "小芳"));
    list.add(new Student("一年级二班", "小华"));
    list.add(new Student("一年级三班", "翠花"));
    list.add(new Student("一年级三班", "香兰"));

    // {一年级三班=香兰, 一年级二班=小华}
    Map<String, String> map = list.stream().collect(Collectors.toMap(Student :: getClassName, Student :: getStudentName, (key1 , key2)-> key2 ));
    // {一年级三班=翠花, 香兰, 一年级二班=小明, 小芳, 小华}
    Map<String, String> map = list.stream().collect(Collectors.toMap(Student :: getClassName, Student :: getStudentName, (val1 , val2)-> val1 + "," + val2 ));

•Collectors.minBy(Integer::compare)：求最小值，相对应的当然也有maxBy方法。
•Collectors.minBy(Comparator.comparingInt(o -> o))：
•Collectors.averagingInt(x->x)：求平均值，同时也有averagingDouble、averagingLong方法。
•System.out.println(Stream.of(1, 2, 3).collect(Collectors.averagingInt(x->x)));
•Collectors.summingInt(x -> x))：求和。
•Collectors.summarizingDouble(x -> x)：可以获取最大值、最小值、平均值、总和值、总数。
•DoubleSummaryStatistics summaryStatistics = Stream.of(1, 3, 4).collect(Collectors.summarizingDouble(x -> x));
•summaryStatistics.getAverage()；//平均值
•Collectors.groupingBy(x -> x)有三种方法，查看源码可以知道前两个方法最终调用第三个方法，第二个参数默认HashMap::new 第三个参数默认Collectors.toList()，参考SQL的groupBy。
 Map<Integer, List<Integer>> map = Stream.of(1, 3, 3, 4).collect(Collectors.groupingBy(x -> x));
 Map<Integer, Long> map = Stream.of(1, 3, 3, 4).collect(Collectors.groupingBy(x -> x, Collectors.counting()));
 HashMap<Integer, Long> hashMap = Stream.of(1, 3, 3, 4).collect(Collectors.groupingBy(x -> x, HashMap::new, Collectors.counting()));
•Collectors.partitioningBy(x -> x > 2)，把数据分成两部分，key为ture/false。第一个方法也是调用第二个方法，第二个参数默认为Collectors.toList()。
•Map<Boolean, List<Integer>> collect5 = Stream.of(1, 3, 4).collect(Collectors.partitioningBy(x -> x > 2));
•Map<Boolean, Long> collect4 = Stream.of(1, 3, 4).collect(Collectors.partitioningBy(x -> x > 2, Collectors.counting()));
•Collectors.joining(",")：拼接字符串。
•System.out.println(Stream.of("a", "b", "c").collect(Collectors.joining(",")));
•Collectors.reducing(0, x -> x + 1, (x, y) -> x + y))：在求累计值的时候，还可以对参数值进行改变，这里是都+1后再求和。跟reduce方法有点类似，但reduce方法没有第二个参数。
•System.out.println(Stream.of(1, 3, 4).collect(Collectors.reducing(0, x -> x + 1, (x, y) -> x + y)));
•Collectors.collectingAndThen(Collectors.joining(","), x -> x + "d")：先执行collect操作后再执行第二个参数的表达式。这里是先拼接字符串，再在最后+ "d"。
•String str= Stream.of("a", "b", "c").collect(Collectors.collectingAndThen(Collectors.joining(","), x -> x + "d"));
•Collectors.mapping(...)：跟map操作类似，只是参数有点区别。
•System.out.println(Stream.of("a", "b", "c").collect(Collectors.mapping(x -> x.toUpperCase(), Collectors.joining(","))));





    public static <T, U> List<U> convertList(List<T> from, Function<T, U> func) {
        return from.stream().map(func).collect(Collectors.toList());
    }
    public static <T, U> U[] convertArray(T[] from, Function<T, U> func, IntFunction<U[]> generator) {
        return Arrays.stream(from).map(func).toArray(generator);
    }
    List<String> stringList = Arrays.asList("1", "2", "3");
    List<Integer> integerList = convertList(stringList, s -> Integer.parseInt(s));
    String[] stringArr = {"1","2","3"};
    Double[] doubleArr = convertArray(stringArr, Double::parseDouble, Double[]::new);





十七、文件操作
1.判断文件是否存在
import java.io.File;
import java.io.IOException;

public class Main {

    public static void main(String[] args) {

        File file = new File("d:\\test_file.txt");
        Main.judeFileExists(file);

        File dir = new File("d:\\test_dir");
        Main.judeDirExists(dir);
    }

    // 判断文件是否存在
    public static void judeFileExists(File file) {

        if (file.exists()) {
            System.out.println("file exists");
        } else {
            System.out.println("file not exists, create it ...");
            try {
                file.createNewFile();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }

    // 判断文件夹是否存在
    public static void judeDirExists(File file) {

        if (file.exists()) {
            if (file.isDirectory()) {
                System.out.println("dir exists");
            } else {
                System.out.println("the same name file exists, can not create dir");
            }
        } else {
            System.out.println("dir not exists, create it ...");
            file.mkdir();
        }

    }

}

2.文件读取

//读取文件
    public static Stream<String> readFile(String file)　{
        Stream<String> stringStream = Files.lines(Paths.get(file), Charset.defaultCharset());
        return stringStream
}

3.读取properties配置
InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("com/styspace/config.properties");  

     public static void main(String[] args) { 
         Properties prop = new Properties();     
         try{
             //读取属性文件a.properties
             InputStream in = new BufferedInputStream (new FileInputStream("a.properties"));
             prop.load(in);     ///加载属性列表
             Iterator<String> it = prop.stringPropertyNames().iterator();
             while(it.hasNext()) {
                 String key = it.next();
                 System.out.println(key+":"+prop.getProperty(key));
             }
             in.close();
             
             ///保存属性到b.properties文件
             FileOutputStream oFile = new FileOutputStream("b.properties", true);//true表示追加打开
             prop.setProperty("phone", "10086");
             prop.store(oFile, "The New properties file");
             oFile.close();
         }
         catch(Exception e) {
             System.out.println(e);
         }
     } 






十八、annotation注解
1.四种元注解
●
@Retention(RetentionPolicy.SOURCE)                                          // 注解仅存在于源码中，在class字节码文件中不包含
@Retention(RetentionPolicy.CLASS)                                           // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，
@Retention(RetentionPolicy.RUNTIME)                                         // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。※※通常必须加项才能取到值
●
@Target(ElementType.TYPE)                                                   // 接口、类、枚举、注解
@Target(ElementType.FIELD)                                                  // 字段、枚举的常量
@Target(ElementType.METHOD)                                                 // 方法
@Target(ElementType.PARAMETER)                                              // 方法参数
@Target(ElementType.CONSTRUCTOR)                                            // 构造函数
@Target(ElementType.LOCAL_VARIABLE)                                         // 局部变量
@Target(ElementType.ANNOTATION_TYPE)                                        // 注解
@Target(ElementType.PACKAGE)                                                // 包
●
@Inherited                                                                  // 一个标注了@Inherited的自定义注解，在标注在父类上时，子类可以继承父类中的该注解
●
@Documented                                                                 // 说明该注解将被包含在javadoc中
●
@Repeatable                                                                 // java1.8加进来的，表示的是可重复

// 示例：通过反射取得注解
public @interface Flag {
    boolean isMaster() default false;
    // ※org.springframework.core.annotation.AliasFor 是spring的特性，因此只有通过spring的方式（AnnotationUtils、AnnotationElementUtils）获取注解才会生效
    // 如果使用jdk内置方法获取注解是无法使用别名特性的，如Class.getDeclaredAnnotation
    @AliasFor("age")
    int age() default 18;
}

@Flag(isMaster = true, age = 22)
public class Anno {
}

public class Main {
    public static void main(String[] args) throws IOException {
        Class<?> clazz = Anno.class;
        Flag flag = clazz.getAnnotation(Flag.class);        // 前面必须加<?>，否则此处异常Incompatible types. Found: 'java.lang.annotation.Annotation', required: 'xxxx.Flag'
}





十九、动态编译
https://blog.csdn.net/lmy86263/article/details/59742557
https://my.oschina.net/u/2343729/blog/830936

















二十一、tomcat
1.安装并配置
TOMCAT_HOME=D:\Tomcat\apache-tomcat-9.0.0.M1-windows-x64\apache-tomcat-9.0.0.M1
CATALINA_HOME=D:\Tomcat\apache-tomcat-9.0.0.M1-windows-x64\apache-tomcat-9.0.0.M1
path=%CATALINA_HOME%\bin
CLASSPath=%CATALINA_HOME%\lib\servlet-api.jar

2.部署（冷部署）
Step 1:
将项目的springmvcsample.war包或目录springmvcsample放到webapps目录下。
Step 2:
通过server.xml配置，可手动指定项目的映射路径：
  <Service name="Catalina">
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
    <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
      <!-- 
           可以在配置中添加自定义映射
           如果是“通过目录”部署，docBase指向项目目录（需绝对路径）；
           如果是“通过war包”部署，docBase指向war包解压后的目录（需绝对路径）
      -->
      <!-- 通过目录 -->
      <Context path="/springmvcsample" docBase="D:\Program Files\Code\apache-tomcat-9.0.5\webapps\springmvcsample" reloadable="true" />
      <!-- 通过war包 -->
      <Context path="/springmvcsample" docBase="D:\Program Files\Code\apache-tomcat-9.0.5\webapps\springmvcsample.war" reloadable="true" />
    </Host>
  </Service>

Step 3:
输入“startup.bat”或“service install Tomcat9”，启动tomcat

Step 4:
localhost:8080/springmvcsample

3.部署（热部署）
此种部署方式不需要重启tomcat，但前提是webapps下有其他项目，否则会提示“org.springframework.web.servlet.PageNotFound.noHandlerFound No mapping found for HTTP request with URI [/springmvcsample/] in DispatcherServlet with name 'dispatcher'”后退出。
Step 1:
新建\conf\Catalina\localhost\springmvcsample.xml文件：
<Context docBase="D:\Program Files\Code\apache-tomcat-9.0.5\mywebapps\springmvcsample-0.0.1-SNAPSHOT.war" />

Step 2:
输入“startup.bat”或“service install Tomcat9”，启动tomcat

Step 3:
localhost:8080/springmvcsample



¤参考Tomcat服务器文档：
    In individual files (with a ".xml" extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application's META-INF directory.
    意思就是：在tomcat服务器的\conf\Catalina\localhost目录下添加一个以xml作为扩展名的文件，xml文件的名字可以任意取，比如下面的aa.xml，注意这一句话"The context path and version will be derived from the base name of the file"，这一句话的意思翻译过来就是"context元素的path属性源自于是这个xml文件的名字"，上面提到过，Context元素的path属性是用来配置虚似目录的名称的，所以虚似目录的名称就是这个xml文件的名称。
    $CATALINA_BASE指的就是tomcat服务器根目录，[enginename]指的是Tomcat服务器使用的引擎名称，Tomcat使用的引擎是Catalina
    在aa.xml文件中添加Context元素映射JavaWeb应用，代码如下：
    <Context docBase="F:\JavaWebDemoProject" />
    注意：在Context元素中并没有指明path属性来设置虚拟目录的名称，那么"F:\JavaWebDemoProject"映射的虚拟目录名称是神马呢，就是当前正在编辑的这个xml文件的名称aa。
    使用这种方式映射虚拟目录的最大好处是修改了配置文件后不用重启Tomcat服务器，比如将aa.xml修改成bb.xml，Tomcat服务器会自动Undeploying context [/aa]，然后自动信息: Deploying configuration descriptor D:\apache-tomcat-7.0.53\conf\Catalina\localhost\bb.xml


4.设置Application context
选择Run/Debug Configurations，通过Deployment/Application context设置网站地址的前缀，如"/mvc"，如不设置前缀可为"/"



5.
Error:(80, 23) java: 无法访问org.apache.commons.logging.Log
  找不到org.apache.commons.logging.Log的类文件

<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging-api</artifactId>
    <version>1.1</version>
</dependency>





二十二、动态代理
A.JDK代理
/**
 * 代理生成器
 */
public class JDKProxy implements InvocationHandler {

    private UserDao userDao;

    public JDKProxy(UserDao userDao) {
        this.userDao = userDao;
    }

    public UserDao createProxy() {
        ClassLoader classLoader = userDao.getClass().getClassLoader();
        Class<?>[] userDaoInterfaces = userDao.getClass().getInterfaces();
        UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance(classLoader, userDaoInterfaces, this);
        return userDaoProxy;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("update".equals(method.getName())) {
            System.out.println("权限校验");
            return method.invoke(userDao, args);
        }
        return method.invoke(userDao, args);
    }
}

B.Cglib（Code Generation Library）
public class Dao {
    public Dao() {
        System.out.println("Dao initial:");
        delete();
        System.out.println();
    }

    public void select() {
        System.out.println("Print select");
    }

    public void update() {
        System.out.println("Print update");
    }

    public void delete() {
        System.out.println("Print delete");
    }
}

public class DaoProxyA implements MethodInterceptor {
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy proxy) throws Throwable {
        System.out.println("DaoProxyA: Before Method Invoke");
        proxy.invokeSuper(object, objects);
        // 或
        proxy.invoke(object, objects);
        // 又或
        method.invoke(object, objects);
        System.out.println("DaoProxyA: After Method Invoke");
        System.out.println();
        return object;
    }
}
/**
 * 可选
 */
public class DaoFilter implements CallbackFilter {
    public int accept(Method method) {
        if ("select".equals(method.getName())) {
            return 0;
        }
        return 1;
    }
}

public class DaoTest {
    public static void caseDo() {
        DaoProxyA daoProxyA = new DaoProxyA();
        DaoProxyB daoProxyB = new DaoProxyB();

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Dao.class);
        enhancer.setCallbacks(new Callback[]{daoProxyA, daoProxyB, NoOp.INSTANCE});         // 分别对应Filter的0位、1位
        enhancer.setCallbackFilter(new DaoFilter());                                        // 可选
        enhancer.setInterceptDuringConstruction(false);                                     // 在构造方法中调用方法时，是否也启用

        Dao dao = (Dao)enhancer.create();
        dao.select();
        dao.update();
    }
}






public class BeanTest {
    public void testImmutableBean() throws Exception {
        class SampleBean {
            private String value;

            public SampleBean() {
            }

            public SampleBean(String value) {
                this.value = value;
            }

            public String getValue() {
                return value;
            }

            public void setValue(String value) {
                this.value = value;
            }
        }

        SampleBean bean = new SampleBean();
        bean.setValue("Hello world");
        SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean); //创建不可变类


        //Assert.assertEquals("Hello world",immutableBean.getValue());
        bean.setValue("Hello world, again"); //可以通过底层对象来进行修改
        //Assert.assertEquals("Hello world, again", immutableBean.getValue());
        //immutableBean.setValue("Hello cglib"); //直接修改将throw exception
    }

    public void testBeanGenerator() throws Exception {
        BeanGenerator beanGenerator = new BeanGenerator();
        beanGenerator.addProperty("value", String.class);
        Object bean = beanGenerator.create();
        Method setter = bean.getClass().getMethod("setValue", String.class);
        setter.invoke(bean, "Hello cglib");

        Method getter = bean.getClass().getMethod("getValue");
        //Assert.assertEquals("Hello cglib",getter.invoke(myBean));
    }
}






二十四、数据访问
1.获取数据源

    @Autowired
    private DataSource dataSource;

    @Autowired
    DataSourceProperties dataSourceProperties;
    @Autowired
    ApplicationContext applicationContext;
    DataSource dataSource = applicationContext.getBean(DataSource.class);

    @Autowired
    private Environment env;
    env.getProperty("spring.datasource.url");



    public void case() {
        String val;
        
        //@Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class);
        

        //如果加载spring-context.xml文件：
        //ApplicationContext context = new ClassPathXmlApplicationContext("spring-context.xml");
        Environment env = context.getEnvironment();
        val = env.getProperty("spring.datasource.url");
    }




二十五、正则表达式
A.
    public final static List<List<String>> matches(String regex, String input) {
        Matcher matcher = Pattern.compile(regex).matcher(input);
        List<List<String>> matches = new ArrayList<>();
        while (matcher.find()) {
            List<String> matchesInOneLine = new ArrayList<>();
            for (int ii = 1; ii <= matcher.groupCount(); ii++) {
                matchesInOneLine.add(matcher.group(ii));
            }
            matches.add(matchesInOneLine);
        }
        return matches;
    }

        private static void regex() {
            String input = "${name}-babalala-${age}-${address}++${name}-babalala";
            String regex = "\\$\\{(.+?)\\}-(ba.+?)";
            List<List<String>> matches = RegexSugar.matches(regex, input);

        }

B.
        String regex = "\\$\\{(na.+?)\\}-(ba.+?)";
        String input = "${name}-babalala-${age}-${address}++${name}-babalala";


        int i = -1;
        StringBuffer sb = new StringBuffer();

        Matcher matcher = Pattern.compile(regex).matcher(input);
        while(matcher.find()) {
            // ${name}-baba
            matcher.group(0)
            // name
            matcher.group(1)
            // baba
            matcher.group(2)
            
            matcher.appendReplacement(sb, replacement[++i]);
        }
        
        1lala-${age}-${address}++2





二十六、字节码增强
A.

    public static void premain(String agentOps, Instrumentation inst) {
        // 定义拦截方法
        AgentBuilder.Transformer transformer = new AgentBuilder.Transformer() {
            @Override
            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,
                                                    TypeDescription typeDescription,
                                                    ClassLoader classLoader,
                                                    JavaModule javaModule) {
                builder = builder.method().intercept()
                                 .method( ElementMatchers.<MethodDescription>any() )
                                     .intercept( MethodDelegation.to(CustomInterceptor.class) )
                                 .method( ElementMatchers.named("statichello") )
                                     .intercept( MethodDelegation.to(CustomInterceptor.class) )
                                 .method( ElementMatchers.named("dynamichello") )
                                     .intercept( MethodDelegation.to(CustomInterceptor.class).andThen(MethodDelegation.to(MonitorInterceptor.class)) )
                                 .method( ElementMatchers.named("statichello") )
                                     .intercept( MethodDelegation.to(CustomInterceptor.class).filter(ElementMatchers.named("intercept")) )
                                 ;
                return builder;
            }
        };
        
        
        // 定义拦截类
        new AgentBuilder.Default()
            .type().transform()
            .type( ElementMatchers.named("com.mysql.cj.jdbc.ConnectionImpl") ).transform( transformer )
            .type( ElementMatchers.nameStartsWith("java.sql") ).transform( transformer )
            .type( ElementMatchers.isAnnotatedWith(JavaAgentInterceptor.class) ).transform( transformer )
            
            .with( new AgentBuilder.Listener() )
            .installOn(inst);
}

public @interface JavaAgentInterceptor {
}




/**
 * @Argument       绑定单个参数
 * @AllArguments   绑定所有参数的数组
 * @This           当前被拦截的、动态生成的那个对象
 * @DefaultCall    调用默认方法而非super的方法
 * @SuperCall      用于调用父类版本的方法
 * @RuntimeType    可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查
 * @Super          当前被拦截的、动态生成的那个对象的父类对象
 * @FieldValue     注入被拦截对象的一个字段的值
 */
public class MonitorInterceptor {
    @RuntimeType
    public static Object intercept(@This Object proxy,
                                   @AllArguments Object[] arguments,
                                   @Origin Class clazz,
                                   @Origin Method method,
                                   @SuperCall Callable<?> callable) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return callable.call();
        } finally {
            long end = System.currentTimeMillis();
            long during = end - start;

            if (during >= Config.THRESHOLD) {
                System.out.println(prefix(Config.THRESHOLD));
                System.out.println("    " + method + ": took " + during + "ms");
            }
        }
    }

    @RuntimeType
    public static Object staticIntercept(@AllArguments Object[] arguments,
                                         @Origin Class clazz,
                                         @Origin Method method,
                                         @SuperCall Callable<?> callable) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return callable.call();
        } finally {
            long end = System.currentTimeMillis();
            long during = end - start;

            if (during >= Config.THRESHOLD) {
                System.out.println(prefix(Config.THRESHOLD));
                System.out.println("    " + method + ": took " + during + "ms");
            }
        }
    }
}



MethodDelegation.to(ToStringInterceptor.class)
                
















九十六、CodeManage
A.git


10.常见问题
IntelliJ IDEA 的 .idea 目录加入.gitignore无效的解决方法
无效的原因是：对应的目录或者文件已经被git跟踪，此时再加入.gitignore后就无效了，
解决办法：
先执行
[文件夹]  git rm -r --cached .idea
[文件]     git rm --cached demo-project.iml
git commit -m '这是移除测试文件操作'
再重新加入.gitignore文件



九十七、Idea Intellij
O.
YZVR7WDLV8-eyJsaWNlbnNlSWQiOiJZWlZSN1dETFY4IiwibGljZW5zZWVOYW1lIjoiamV0YnJhaW5zIGpzIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifV0sImhhc2giOiIxMTA1NzI3NC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-rsJR5mlJcjibqRu1gQAMUCngMe8i+AOWIi+JZkNFYPET2G1ONcLPcIzoATTRi6ofkDm5l+3Y4HXjBPjVU6bHDdMBAzCnUqpXKsCknwSYyPSU0Y5pzuLvw6O9aPlQ46UBoTEC2BL5W6f11S7NlAq7tTbDuvFUynqSGAmTEfuZtKmzRmp20ejTPuMlSO7UqSkZvkg6YvSTrax1d2K+P9SAmVGZ9iC7AzBs4AwTf84QB9qHvE/Nh0oELSHWGG9hsZZ7sVghI/39/jPQFTp8GLFsl36ZPybPhGDam721zxS9H++/eJk23Jz3nxaRluE4dWmpHrDg1qBHp8qVpSFejg2QYw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==


A.
# idea历史版本
https://www.jetbrains.com/idea/download/previous.html

B.快捷键
# 编辑
Alt+Insert              构造属性等
Ctrl+Alt+t              try catch包裹
Ctrl+Shift+Alt+t        重构一切
Ctrl+Alt+l              格式化
Ctrl+Alt+f              抽取当前语句的返回值，为“类”的私有对象
Ctrl+Alt+v              抽取当前语句的返回值，为“语句块”的私有对象
Ctrl+Alt+c              抽取当前语句的返回值，为“类”的常量
Ctrl+Alt+m              抽取当前语句，为“类”的私有方法
Ctrl+Alt+o              优化导入的类和包
Shift+F6                重命名
Alt+鼠标                列选择
Alt+Shift+Insert        列模式
Ctrl+Alt+Shift+t        重构
Ctrl+k                  git commit
Ctrl+Shift+k            push
Ctrl+Shift+Space        自动提示
F6                      Move inner class to upper level
                        提取内部类成外部类

# 查看
Ctrl+F12                查看当前文件结构
Ctrl+Alt+F12            资源管理器打开文件夹
Ctrl+"-/+"              展开/折叠当前方法
Ctrl+Shift+"-/+"        展开/折叠所有方法
Ctrl+h                  显示类结构
Ctrl+o                  override重写当前类的方法
Ctrl+i                  implements实现当前类的方法
Ctrl+p                  查看方法参数
Ctrl+q                  查看方法注释
Ctrl+Shift+Alt+D        查看本地修改列表

# 定位
F2                      跳至高亮错误
Alt+F3                  逐个往下查找相同文本，并高亮显示
Ctrl+F7                 查找当前对象在“在当前文件中”的引用
Alt+F7                  查找当前对象在“所有”引用
Ctrl+Shift+F7           高亮显示当前对象在“在当前文件中”的引用
Ctrl+Alt+F6             0%classes,0%lines covered
Ctrl+Alt+F7             查找所有引用
Ctrl+Alt+left/right     返回至上次浏览的位置
Ctrl+Shift+Up/Down      上/下移动语句
Alt+Shift+Up/Down       上/下移动语句
Alt+Up/Down             在方法间移动
Ctrl+Alt+b              跳到方法实现处
Ctrl+f                  查找
Ctrl+Shift+f            查找所有
Ctrl+u                  跳到接口类
Ctrl+b                  跳到对象的类定义
Ctrl+Shift+b            跳到对象的类定义
Ctrl+Shift+t            create new test
Shift+Shift             查找
Ctrl+e                  查看最近打开过的文件
Ctrl+n                  类名搜索
Ctrl+shift+n            查找文件
Alt+F1
Ctrl+Shift+Num          定义书签
Ctrl+Num                定位书签


# 调试运行
Alt+Shift+C             最近的更改
Alt+Shift+F9            弹出Debug 的可选择菜单
Alt+Shift+F10           弹出Run 的可选择菜单
Ctrl+Shift+F8           设置断点条件 
Ctrl+F8                 切换断点
Ctrl+Shift+F9           Recompile，或者叫做手动编译。（自动编译：File-Settings-Compiler-Build Project automatically）
Ctrl+F2                 停止运行
Alt+F9                  执行到当前执行点
Alt+F10                 跳转到当前断点



# 
.field
.var
.notnull
.for
.fori
.return
.lambda


C.Project视图
a.module名称加粗
idea左边project视图中的结构树，加粗的module表示该module为（某一聚合module下的）子module。

b.Mark Directory as
1. Source roots (or source folders)
By assigning a folder to this category, you tell IntelliJ IDEA that this folder and its subfolders contain source code that should be compiled as part of the build process.
¤标记为此标记后：多级folder会被识别为package，import时才会通过package定位到对应的类。否则类会提示找不到引用，package目录也不会出现合并的效果。

2. Test source roots (or test source folders; shown as rootTest)
These roots are similar to source roots but are for code intended for testing (e.g. for unit tests). Test source folders let you keep the code related to testing separate from the production code.
Compilation results for sources and test sources, normally, are placed into different folders.

3. Resource roots
are for resource files used in your application (images, various configuration XML and properties files, etc.).
During the build process, all the contents of the resource folders are copied to the output folder as is.
Similarly to sources, you can specify that your resources are generated. You can also specify which folder within the output folder your resources should be copied to.

4. Test resource roots
(or test resource folders; shown as rootTestResourceIJ; available only in Java modules) are for resource files associated with your test sources. In all other respects, these folders are similar to resource folders.

**5. Excluded roots (shown as rootExcluded) are ones that IntelliJ IDEA 
"almost ignores".**
Very limited coding assistance is provided for files in excluded folders. Classes contained in excluded folders don’t appear in code completion suggestion lists, references to such classes are shown in the editor as unresolved. When searching, IntelliJ IDEA doesn’t look in excluded folders, etc.




D.jar包管理
a.idea通过maven下载jar包
1.idea配置maven
通过File -> Setting -> Maven 的Maven Home Directory指向maven所在目录（如{idea}/plugins/maven/lib/maven3），当然，idea默认自带了maven，也可使用默认自带maven。

2.File -> Setting -> Maven -> Importing
选中Automatically download:Source   Documentation，即可自动下载源码

3.选择Project Structure -> Libraries -> + -> From Maven
搜索需要的jar包，并选择下载


b.web引入jar包
web项目有时会找不到jar包，这时可进行以下操作：
选择Project Structure -> Artifacts -> + -> Output Layout -> Available Elements -> 移入到WEB-INF\lib
※注意：此处是通过idea对lib进行了复制，而并不是通过maven进行复制，因此该部分lib只有进行idea的run/debug操作后才会复制到“输出目录”，而进行maven的package操作并不会复制到“输出目录”。


c.包的展示形式
Project窗体右上角点击齿轮，Flatten Packages（显示全包名）, Hide Empty Middle Packages（隐藏中间的空包）


d.强制更新本地库的jar包
有时候maven本地库的某一个依赖也许没有下载完全，可通过以下方式强制重新更新：
idea中的maven，goal，使用以下命令可重新下载jar包
-U idea:idea


E.调试
a.如何在IDEA启动多个Spring Boot工程实例
一个工程启动多个实例，分别占用不同的端口，其设置步骤如下：
step 1
在IDEA上点击Application右边的下三角，弹出选项后，点击Edit Configuration
step 2
打开配置后，将默认的Single instance only(单实例)的钩去掉。 
step 3
通过修改application文件的server.port的端口，启动。多个实例，需要多个端口，分别启动。


b.远程调试
step 1
Edit Configuration -> Remote -> Host / Port，（填写端口不能与项目启动端口相同）
把Command line arguments for remote JVM内容粘贴出来，加入启动命令行，如：
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8088
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8088

step 2
命令行：
$ java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8088 -jar xxxx.jar

# 远程端
Listening for transport dt_socket at address: 8088
# 本地端idea出现：
Connected to the target VM, address: '10.37.253.250:8088', transport: 'socket'
Disconnected from the target VM, address: '10.37.253.250:8088', transport: 'socket'


F.artifact
artifact是一个项目资源的组合体。例如，一个已编译的java类的集合，一个已打包的java应用。它可以是一个archive文件，也可以是一个包含以下结构元素的目录结构。
★定义artifact
Project Structure -> Artifacts ->
Type : Web Application: Exploded 生成文件夹，包括jsp页面、classes等，移到  部署文件夹下进行部署
       Web Application: Archive 打成war包，进行部署

★使用artifact
Run/Debug Configurations -> Tomcat Server -> Deployment -> + -> 选择一个已定义的artifact






Facets和Artifacts的区别：
Facets：表示这个module有什么特征，比如 Web，Spring和Hibernate等； 
Artifact：是maven中的一个概念，表示某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式；一个module有了 Artifacts 就可以部署到应用服务器中了！











Facets：(某一面，包含一些特性)
Facets表述了在Module中使用的各种各样的框架、技术和语言。这些Facets让Intellij IDEA知道怎么对待module内容，并保证与相应的框架和语言保持一致。
使用Facets能让我们下载并配置framework所必须的组件，会自动生成各种各样的描述符，并存储在适当的位置，等等。
大多数Facets可以无冲突得添加到Module中。
也有一些Facets是继承其他Facets的，这些Facets的添加就必须先添加他们的父Facets，这些Facets也要依赖Intellij IDEA的相关插件是否开启.
目前可用Facets列表(包含存在依赖关系的Facets)



Artifacts：
artifact是一个项目资源的组合体。例如，一个已编译的java类的集合，一个已打包的java应用。
artifact可以是一个archive文件，也可以是一个包含以下结构元素的目录结构：
-- （一个或多个）module的编译Output；
--  包含在module的依赖中的Libraries；
--  资源的集合，如web页面，图片，decriptor文件；
--  其他artifacts；
--  个别文件、目录和archives；







G.Settings
a.导包时，import不带*号
打开设置>Editor>Code Style>Java>Scheme Default>Imports

① 将Class count to use import with "*"改为99（导入同一个包的类超过这个数值自动变为 * ）
② 将Names count to use static import with "*"改为99（同上，但这是静态导入的）
③ 将Package to Use import with "*"删掉默认的这两个包（不管使用多少个类，只要在这个列表里都会变为 * ）









H.代码管理
a.SVN
本地工程关联到SVN：VCS -> Import into Version Control -> Share project   (Import into 是将代码上传到svn并不关联工程)
取消关联：Settings -> Version Control -> Directory 选择现有的关联删除即可。


I.插件
// 在线插件方式：可以通过 File > Settings > Plugins 安装lombok插件并重启。然后 File > Settings > Build, Execution, Deployment > Compiler > Annotation Processors > Enable annotation processing选中。
// 离线插件下载方式：在http://plugins.jetbrains.com/中搜索Lombok Plugin，网站会为罗列出所搜索的插件列表，然后选择要与idea对应的版本进行下载，否则会出现版本不兼容无法安装的问题，最后把下载好的文件解压并放在\IntelliJ IDEA 2018.1.2\plugins文件夹下，重启。
http://plugins.jetbrains.com/plugin/6317-lombok-plugin


GsonFormat
Free Mybatis plugin
maven helper
Rainbow Brackets
GenerateAllSetter
ignore
AceJump
free-idea-mybatis
idea-gitignore
ideajad
lombok-plugin
String Manipulation
MyBatis Log Plugin
Alibaba Cloud Toolkit
RestfulToolkit

CamelCase
Key promoter X




K.xml
misc.xml
----------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="JavaScriptSettings">
    <option name="languageLevel" value="ES6" />
  </component>
  <!-- 当普通项目添加maven支持后，会添加以下内容 -->
  <component name="MavenProjectsManager">
    <option name="originalFiles">
      <list>
        <option value="$PROJECT_DIR$/pom.xml" />
        <option value="$PROJECT_DIR$/src/main/java/webapi/pom.xml" />
        <option value="$PROJECT_DIR$/src/main/java/rpc/java/yixin.platform.passportrpc/yixin.platform.passportrpc/pom.xml" />
        <option value="$PROJECT_DIR$/src/main/java/rpc/java/yixin.platform.passportrpc/yixin.platform.passportrpc.client/pom.xml" />
        <option value="$PROJECT_DIR$/src/main/java/rpc/java/yixin.platform.passportrpc/pom.xml" />
      </list>
    </option>
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_9" project-jdk-name="9" project-jdk-type="JavaSDK" />
  <!-- default：表示当前配置是否为idea添加上的默认值：如果未在“maven-compiler-plugin”中显式指定，首次打开项目，无此项（即默认为true），此时idea中的Language Level内容为空 -->
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="false" project-jdk-name="1.8" project-jdk-type="JavaSDK">
</project>
----------------------------------------------------------------------------------------------


projectname.iml
----------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_1_5">
    <output url="file://$MODULE_DIR$/target/classes" />
    <output-test url="file://$MODULE_DIR$/target/test-classes" />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
----------------------------------------------------------------------------------------------



workspace.xml
----------------------------------------------------------------------------------------------
  <!-- 以下为快速添加tomcat8 和 tomcat9 -->
  <component>
    <configuration name="Tomcat8" type="#com.intellij.j2ee.web.tomcat.TomcatRunConfigurationFactory" factoryName="Local" APPLICATION_SERVER_NAME="Tomcat 8.0.18" ALTERNATIVE_JRE_ENABLED="false">
      <option name="UPDATING_POLICY" value="restart-server" />
      <deployment />
      <server-settings>
        <option name="BASE_DIRECTORY_NAME" value="Unnamed_cas-overlay_3" />
      </server-settings>
      <predefined_log_file id="Tomcat" enabled="true" />
      <predefined_log_file id="Tomcat Catalina" enabled="true" />
      <predefined_log_file id="Tomcat Manager" enabled="false" />
      <predefined_log_file id="Tomcat Host Manager" enabled="false" />
      <predefined_log_file id="Tomcat Localhost Access" enabled="false" />
      <RunnerSettings RunnerId="Debug">
        <option name="DEBUG_PORT" value="58387" />
      </RunnerSettings>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Cover">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Debug">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Run">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <method>
        <option name="Make" enabled="false" />
      </method>
    </configuration>
    <configuration name="Tomcat9" type="#com.intellij.j2ee.web.tomcat.TomcatRunConfigurationFactory" factoryName="Local" APPLICATION_SERVER_NAME="Tomcat 9.0.8" ALTERNATIVE_JRE_ENABLED="false">
      <option name="UPDATING_POLICY" value="restart-server" />
      <deployment />
      <server-settings>
        <option name="BASE_DIRECTORY_NAME" value="Unnamed_cas-overlay_4" />
      </server-settings>
      <predefined_log_file id="Tomcat" enabled="true" />
      <predefined_log_file id="Tomcat Catalina" enabled="true" />
      <predefined_log_file id="Tomcat Manager" enabled="false" />
      <predefined_log_file id="Tomcat Host Manager" enabled="false" />
      <predefined_log_file id="Tomcat Localhost Access" enabled="false" />
      <RunnerSettings RunnerId="Debug">
        <option name="DEBUG_PORT" value="58387" />
      </RunnerSettings>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Cover">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Debug">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Run">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <method>
        <option name="Make" enabled="false" />
      </method>
    </configuration>
    <configuration default="true" type="#com.intellij.j2ee.web.tomcat.TomcatRunConfigurationFactory" factoryName="Local" APPLICATION_SERVER_NAME="Tomcat 8.0.18" ALTERNATIVE_JRE_ENABLED="false">
      <option name="UPDATING_POLICY" value="restart-server" />
      <deployment />
      <server-settings>
        <option name="BASE_DIRECTORY_NAME" value="_cas-overlay" />
      </server-settings>
      <predefined_log_file id="Tomcat" enabled="true" />
      <predefined_log_file id="Tomcat Catalina" enabled="true" />
      <predefined_log_file id="Tomcat Manager" enabled="false" />
      <predefined_log_file id="Tomcat Host Manager" enabled="false" />
      <predefined_log_file id="Tomcat Localhost Access" enabled="false" />
      <RunnerSettings RunnerId="Debug">
        <option name="DEBUG_PORT" value="58387" />
      </RunnerSettings>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Cover">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Debug">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
      <ConfigurationWrapper VM_VAR="JAVA_OPTS" RunnerId="Run">
        <option name="USE_ENV_VARIABLES" value="true" />
        <STARTUP>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </STARTUP>
        <SHUTDOWN>
          <option name="USE_DEFAULT" value="true" />
          <option name="SCRIPT" value="" />
          <option name="VM_PARAMETERS" value="" />
          <option name="PROGRAM_PARAMETERS" value="" />
        </SHUTDOWN>
      </ConfigurationWrapper>
    </configuration>
    <list>
      <item itemvalue="Tomcat Server.Tomcat9" />
      <item itemvalue="Tomcat Server.Tomcat8" />
    </list>
  </component>
----------------------------------------------------------------------------------------------


L、测试
a.添加测试类
idea中新建测试类的方法
src/main
src/test

（1）首先是test的位置放置，放在src目录文件夹下边，Make Directory as Test Resources Root.
（2）Alt+Ctrl+S，打开设置窗口，点击进入Plugins.从插件资源库中搜索JunitGenerator V2.0版本，重启；
（3）IntelliJ IDEA JUnit Generator自动创建测试用例到指定test目录
（4）在class上，ctrl+shift+t，测试类的包名称是和被测试类同包名，并且在之前创建的Test文件夹中
1.打开File->Settings
2.参考http://www.cnblogs.com/winner-0715/p/5597259.html，与http://www.jianshu.com/p/c37753b6dbd6



九十七、Java命令
A.命令

1.java
# java启动参数共分为三类：
其一是标准参数（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容；
其二是非标准参数（-X），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；
其三是非Stable参数（-XX），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；
其四是springboot参数（--），是springboot独有的方式，详见源码SimpleCommandLineArgsParser.class中的public CommandLineArgs parse(String... args) {}

# 环境变量
## 环境变量--（※注意参数顺序-D -jar --）
$ java -jar xxx.jar --spring.profiles.active=prod
$ java -jar xxx.jar --spring.config.location=application.properties


## 环境变量-D（※注意参数顺序-D -jar --）
$ java -Dserver.port=9090 -Dserver.context-path=/test -jar target/xxx.jar


## 通过-jar，运行jar包
·打包时已指定main-class，默认在jar包中的META-INF/MANIFEST.MF中，有一个叫Main-Class的参数，指定程序的入口类
$ java -jar xxx.jar

·打包时没指定main-class，可显式指定
$ java -jar xxx.jar packagename.com.classname                   # 会寻找当前目录下packagename/com/classname.class文件，等同于java -cp $CLASSPATH packagename.com.classname


## 通过-Dloader.path
格式：java -Dloader.path=<lib_directory> -jar <jarfile>
例：
$ java -Dloader.path=".,lib/,demo.jar" -jar demo.jar --spring.profiles.active=dev


## 通过-Dloader.main
$ java -cp "yourBoot.jar" -Dloader.path=plugins/ -Dloader.main=your.mainClass org.springframework.boot.loader.PropertiesLauncher


## 通过-Djava.ext.dirs
$ java -Djava.ext.dirs=


## 通过-classpath，运行jar包中指定Class的main方法，支持通配符
格式：java -classpath(-cp) <classpath> mainclass
※<classpath>是“依赖lib所在目录”、“mainclass所在根目录”
java指令默认在寻找class文件的地址是通过CLASSPATH环境变量中指定的目录中寻找的。
我们直接在CLASSPATH环境变量中加入的“.;”即表示的是搜索当前目录：
例：windows用;分割
> java -cp ".;lib/*;demo.jar" packagename.com.mainclass [args]
例：linux用:分割
$ java -cp ".:lib/*:demo.jar" packagename.com.mainclass [args]


## 通过-Xbootclasspath，
-Xbootclasspath:<path>    指定bootstrapclassloader的jar包。
-Xbootclasspath/a:<path>  在系统class加载后加载。一般用这个。
-Xbootclasspath/p:<path>  在系统class加载前加载，注意使用，和系统类冲突就不好了。
例：windows用;分割
$ java -Xbootclasspath/a: some.jar;some2.jar; -jar test.jar 
例：linux用:分割
$ java -Xbootclasspath/a: some.jar:some2.jar: -jar test.jar 
win32系统每个jar用分号隔开，unix系统下用冒号隔开


## 设置常态参数
set JAVA_OPTS=-javaagent:F:\skywalking\skywalking-agent\skywalking-agent.jar


2.jar
用法：jar {ctxu}[vfm0Mi] [jar-文件] [manifest-文件] [-C 目录] 文件名 ... 
    选项： 
    -c 创建新的存档
    -t 列出存档内容的列表
    -x 展开存档中的命名的（或所有的〕文件
    -u 更新已存在的存档
    -v 生成详细输出到标准输出上
    -f 指定存档文件名
    -m 包含来自标明文件的标明信息
    -0 只存储方式；未用zip压缩格式
    -M 不产生所有项的清单（manifest〕文件
    -i 为指定的jar文件产生索引信息
    -C 改变到指定的目录，并且包含下列文件

# 替换
$ jar uf xxx.jar BOOT-INF/classes/application-dev.yml
$ jar -xvf xxx.jar 


# 创建一个JAR文件
$ jar cf jar-file input-file(s)

$ jar cmf manifest-addition jar-file input-file(s)
$ jar umf manifest-addition jar-file input-file(s)

# 查看JAR文件的内容
$ jar tf jar-file
# 导出JAR文件
$ jar xf jar-file


# 运行JAR文件中的应用
$ jre -cp app.jar MainClass
# 运行用JAR格式打包的应用
$ java -jar app.jar


·/META-INF/MANIFEST.MF
Implementation-Title: gs-consuming-rest  
Implementation-Version: 0.1.0  
Archiver-Version: Plexus Archiver  
Built-By: exihaxi  
Implementation-Vendor-Id: org.springframework  
Spring-Boot-Version: 1.5.3.RELEASE  
Implementation-Vendor: Pivotal Software, Inc.  
Main-Class: org.springframework.boot.loader.JarLauncher  
Start-Class: com.ericsson.ramltest.MyApplication  
Class-Path: servlet.jar infobus.jar acme/beans.jar
Spring-Boot-Classes: BOOT-INF/classes/  
Spring-Boot-Lib: BOOT-INF/lib/  
Created-By: Apache Maven 3.5.0  
Build-Jdk: 1.8.0_131 



·/META-INF/MANIFEST.MF
Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Built-By: PPC
Start-Class: com.qding.cloud.paasresourcecore.PaasResourceApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Spring-Boot-Version: 2.1.7.RELEASE
Created-By: Apache Maven 3.6.1
Build-Jdk: 1.8.0_20
Main-Class: org.springframework.boot.loader.JarLauncher


Manifest-Version: 1.0
Premain-Class: com.sandbox.javaagent.PreMain
Can-Redefine-Classes: true
















九十八、JVM虚拟机
A.类加载
1.类加载器
1.1 加载流程
                                         非热点
                 字节码文件            ┌——→ 解释器 ————→ 执行
源码文件       （与平台无关）          │
.java  ————→  .class  ——————┤
         编译器             classloader│热点
                                       └——→ 即时编译器 ——→ 机器码 ——→ 执行

1.2 解释器
JVM可以加载字节码即.class文件，然后边翻译边执行，因而被称为解释型编程语言（但是解释的过程就是编译一条机器码执行一条，且JVM中存在即时编译器编译热点代码，所以也被成为半解释半执行的编程语言）
是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快。
-Xint           强制虚拟机运行于＂解释模式＂，这时编译器完全不介入工作，全部代码都使用解释方式执行

1.3 即时编译(Just-in-time compilation: JIT)
又叫实时编译、及时编译。是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。这项技术是被用来改善虚拟机的性能的，他会检测代码中的热点代码（即多次调用的方法或循环的代码块），这些代码如果每次都通过解释器解释执行无疑大大降低了运行效率，因此Jit编译器将他们编译成本地代码，则下次调用时就不需要解释器再次解释执行。HotSpot中的即时编译器分为client模式与server模式，又称为c1、c2编译器（jdk1.7默认server模式）。
Jit编译器检测热点代码（Hot Spot Code）：
（1）方法计数器（Invocation Counter）：记录方法调用的次数。被多次调用的方法 – 这是由方法调用触发的编译，因此编译器理会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。
（2）回边计数器（Back Edge Counter）：记录代码块循环次数。被多次执行的循环体 – 尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。
当计数器数值大于默认阈值或指定阈值时，方法或代码块会被编译成本地代码。
JIT编译器是JRE的一部分。原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。

-Xcomp          强制虚拟机运行于＂编译模式＂，这时将优先采用编译方式执行程序
参数-XX:CompileThreshold
当不启用分层编译的情况下，方法的调用次数 + 循环回边的次数和超过-XX:CompileThreshold指定的值时，就会触发即时编译(C1默认1500，C2默认10000)。

·VM：一种能够运行Java字节码（Java bytecode）的虚拟机。
·字节码：字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。
·Java字节码：是Java虚拟机执行的一种指令格式。



B.JVM内存模型
1.内存模型
·JDK6
┌———┬——————————┬————┬—————————————————┬——————————————┐
│      │                    │        │    Young Generation(Minor GC)    │  Old Generation(Major GC)  │字面量  静态
│      │        Heap        │   线   ├———┬——————┬——————┼——————————————┤
│      │                    │   程   │ Eden │ Survivor 1 │ Survivor 2 │       Tenured Space        │
│      │                    │   共   │伊甸园│  生存区 1  │  生存区 2  │                            │
│      ├——————————┤   享   ├—————————————————┴——————————————┤
│      │       Method       │        │永久代(PermGen for VM)                                          │
│ JVM  │        Area        │        │方法区也是所有线程共享。JDK6中使用永久代，主要用于存储类的信息、│
│      │                    │        │常量池、静态变量、静态方法数据、静态方法代码等。                │
│      ├——————————┼————┼————————————————————————————————┤
│      │                    │        │每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种│
│  内  │         VM         │        │叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表│
│      │        Stack       │        │（基本数据类型和对象引用）、操作数栈、方法出口等信息。          │
│      │                    │   非   │                                                                │
│  存  ├——————————┤        ├————————————————————————————————┤
│      │       Native       │   线   │                                                                │
│      │       Method       │        │                                                                │
│  区  │       Stack        │   程   │                                                                │
│      ├——————————┤        ├————————————————————————————————┤
│      │       Program      │   共   │                                                                │
│      │       Counter      │        │PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都  │
│      │       Register     │   享   │有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中   │
│      │(仅用于JVM方法，而不│        │保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中   │
│      │支持native方法）    │        │为空。                                                          │
│      │                    │        │                                                                │
└———┴——————————┴————┴————————————————————————————————┘
¤由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen
它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？


·JDK7 JDK8
┌———┬——————————┬————┬————————————————————————————————┐
│      │                    │        │JVM8中把运行时常量池、静态变量也移到堆区进行存储。              │
│      │                    │        │                                                                │
│      │                    │        ├—————————————————┬——————————————┤
│      │        Heap        │   线   │    Young Generation(Minor GC)    │  Old Generation(Major GC)  │字面量（字符串常量）  静态变量√
│      │                    │        ├———┬——————┬——————┼——————————————┤
│ JVM  │                    │   程   │ Eden │ Survivor 1 │ Survivor 2 │       Tenured Space        │
│      │                    │        │伊甸园│  生存区 1  │  生存区 2  │                            │
│      ├——————————┤   共   ├—————————————————┴——————————————┤
│  内  │         VM         │        │每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种│
│      │        Stack       │   享   │叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表│
│      │                    │        │（基本数据类型和对象引用）、操作数栈、方法出口等信息。          │
│  存  ├——————————┼————┼————————————————————————————————┤
│      │       Native       │   非   │                                                                │
│      │       Method       │        │                                                                │
│  区  │       Stack        │   线   │                                                                │
│      ├——————————┤        ├————————————————————————————————┤
│      │       Program      │   程   │                                                                │
│      │       Counter      │        │PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都  │
│      │       Register     │   共   │有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中   │
│      │(仅用于JVM方法，而不│        │保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中   │
│      │支持native方法）    │   享   │为空。                                                          │
│      │                    │        │                                                                │
├———┼——————————┼————┼————————————————————————————————┤
│      │                    │        │元空间（Metaspace in native memory）                            │ 
│      │       Method       │        │方法区也是所有线程共享。JDK8中使用元空间，主要用于存储类的信息、│
│      │        Area        │        │静态方法代码等。                                                │
│      │                    │        │（字符串常量、类的静态变量已转移到了Heap中）                    │
└———┴——————————┴————┴————————————————————————————————┘
Metaspace in native memory
（1）方法区是规范层面的东西，规定了这一个区域要存放哪些东西
（2）永久代或者是metaspace是对方法区的不同实现，是实现层面的东西。

那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常：java.lang.OutOfMemoryError: Java heap space
线程请求的栈深度大于虚拟机锁允许的最大深度：StackOverflowError



·分代的概念
由于不同对象的生命周期不同，根据其自己的特点采取不同的收集方式可以大幅提高回收效率。比如与业务相关的对象一般生命周期较长，而临时变量生命周期很短，通过分代，可以避免长生命周期的对象被遍历，以此来减少消耗。
·如何分代
虚拟机分为年轻代(Young Generation)、老年代(Old Generation)和持久代(Permanent Generation)，其中持久代在JDK8之后已。所有新生成的对象首先是放在年轻代中，该代的目标就是尽快回收那些短生命周期的对象，其分为3个区，一个Eden伊甸园区，两个Survivor生存区。大部分对象在Eden区生成，当该区满时，将存活对象复制到Survivor区（两个中的一个），当该区也满了时，将存活对象复制到另一个Survivor，当这个Survivor也满了时，将从第一个Survivor区复制过来的并且还存活的对象复制到年老区Tenured，因此在年老区中主要存放生命周期较长的对象。而持久代，用于存放静态文件，如Java类、方法等。持久代对垃圾回收无显著影响，但App使用较多反射时，需要增加持久代的大小，通过设置-XX:MaxPermSize=<N>。接下来通过一张图，对该部分有个宏观的了解。


2.垃圾回收
2.1 垃圾回收算法
2.1.1 标记-清除算法（Mark-Sweep）
标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
2.1.2 复制算法(Copying)
复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。
2.1.3 标记-整理算法(Mark-compact)
标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图：
2.1.4 分代收集算法
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

2.1.4.1 年轻代（Young Generation）的回收算法 (回收主要以Copying为主)
a) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
b) 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，如此往复。
c) 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。
d) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。
2.1.4.2 年老代（Old Generation）的回收算法（回收主要以Mark-Compact为主）
a) 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
b) 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。
2.1.4.3 持久代（Permanent Generation）的回收算法
用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。


2.2 垃圾回收触发
·判断是否回收的标准
无用类的回收：
1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
2.该类对应的java.lang.Class没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
3.加载该类的ClassLoader已经被回收；

·垃圾回收算法的触发
由于对象进行了分代处理，因此垃圾回收的区域和时间也有了不同，主要包括如下两种类型的GC：
Scavenge GC：一般当新对象生成，并且在Eden申请空间失败时触发。将清除Eden区的非存活对象，并把存货对象移动到Survivor，然后整理两个Survivor区。该方式不会影响到老年代，此外，该GC推荐使用速度快，效率高的算法，使Eden区尽快空闲出来。
Full GC：对整个堆进行整理，包括Young、Tenured和Perm，因此为了提高系统性能，需要减少FullGC的次数。发生FullGC的场景有：
a)年老代被写满，
b)持久代被写满
c)System.gc()被显式调用
d)上一次GC后Heap各域分配策略动态变化。










分层编译模式
HotSpot虚拟机包含多个即时编译器C1、C2
C1
编译效率快，对应参数 -client，针对执行时间较短、或者对启动性能有要求的程序
目的是使程序尽快进入编译执行阶段，所以没有收集很多，所以编译速度很快
C2
生成代码执行效率快，对应参数 -server，针对执行时间长的、对峰值性能有要求的程序。
将编译成机器代码的时候需要收集大量的统计信息以便在编译的时候优化，所以编译出来的代码执行效率快
Java 7引入了分层编译（对应参数 -XX：+TieredCompilation），综合了C1的启动性能优势和C2的峰值性能优势
分层编译将Java虚拟机的执行状态分为了五个层次：
解析执行
执行不带profiling的C1代码
执行仅带方法调用次数以及循环回边执行次数profilling的C1代码
执行带所有profiling的C1代码
执行C2代码
profiling说指程序执行过程中，收集能够反映程序执行状态的数据。profile是收集运行时状态信息，用于编译器优化，当然，收集信息也是耗性能的，所以，也是有前提条件的，当存在优化的可能性时才去费劲收集相关信息
1.8是默认开启分层编译，如果关闭Java虚拟机直接选择C2







判断对象是否可以回收（存活）有两种方法：
------------------------------------------------------------
public class GCDemo {
    public static void main(String[] args) {
        GCObject objA = new GCObject();         // step 1
        GCObject objB = new GCObject();         // step 2
        
        objA.instance = objB;                   // step 3
        objB.instance = objA;                   // step 4
        
        objA = null;                            // step 5
        objB = null;                            // step 6
        
        System.gc();                            // 执行 GC
    }
}

class GCObject {
    public Object instance = null;
}
------------------------------------------------------------
1）引用计数算法
给对象添加一个引用计数器，当有一个地方引用它，计数器值加 1；当引用失效时，计数器值减 1。任何时刻计数器值为 0 表示这个对象可以被回收了。
优点：
判断效率高，实现简单。
不足之处：
难以解决对象之间相互循环引用的问题。如：
----------------------------------------------------------------
┌————————┐    ┌—————————————————┐
│stack           │    │heap                              │
│ ┌—————┐ │ 2  │    ┌———————————┐    │
│ │   objB   ├-┼——┼—→┤ GCObject objB        │    │
│ └—————┘ │    │    │┌———————┐    │    │
│                │    │    ││   instance   │    │    │
│                │    │    │└———┬———┘    │    │
│                │    │    └————┼——————┘    │
│                │    │            4 ↓  ↑ 3            │
│ ┌—————┐ │ 1  │    ┌——————┼————┐    │
│ │   objA   ├-┼——┼—→┤    ┌———┴———┐│    │
│ └—————┘ │    │    │    │   instance   ││    │
│                │    │    │    └———————┘│    │
│                │    │    │ GCObject objA        │    │
│                │    │    └———————————┘    │
│                │    │                                  │
└————————┘    └—————————————————┘
----------------------------------------------------------------

2）可达性分析算法
通过一系列称为 "GC Roots" 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。
可作为 GC Roots 的对象有：
虚拟机栈中的引用的对象
方法区的静态变量和常量引用的对象
本地方法栈中 JNI 引用的对象
在上面的例子中，当执行第 5、6 步后，内存堆栈结构如下图。虽然实例 A 和实例 B 相互引用，但是它们到 GC Roots 都是不可达的了，所以它们都会被判定成可回收对象。
----------------------------------------------------------------
┌————————┐    ┌—————————————————┐
│stack           │    │heap                              │
│ ┌—————┐ │    │    ┌———————————┐    │
│ │   objB   │ │    │    │ GCObject objB        │    │
│ └—————┘ │    │    │┌———————┐    │    │
│                │    │    ││   instance   │    │    │
│                │    │    │└———┬———┘    │    │
│                │    │    └————┼——————┘    │
│                │    │            4 ↓  ↑ 3            │
│ ┌—————┐ │    │    ┌——————┼————┐    │
│ │   objA   │ │    │    │    ┌———┴———┐│    │
│ └—————┘ │    │    │    │   instance   ││    │
│                │    │    │    └———————┘│    │
│                │    │    │ GCObject objA        │    │
│                │    │    └———————————┘    │
│                │    │                                  │
└————————┘    └—————————————————┘
----------------------------------------------------------------



  接下来通过一个表格来连接不同的收集器的优缺点：
┌———————┬————————————————————————————————————————————————————————————┐
│  收集器类型  │                                                 诠释                                                                   │
├———————┼————————————————————————————————————————————————————————————┤
│  串行收集器  │  使用单线程处理所有垃圾回收，简单高效，适合数据量小的场景。通过-XX：+UseSerialGC打开                                   │
├———————┼————————————————————————————————————————————————————————————┤
│              │  对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间，使用-XX:+UseParallelGC打开。                                      │
│              │  可以对老年代进行并行收集，默认使用单线程垃圾回收，使用-XX:+UseParallelOldGC打开                                       │
│  并行收集器  │  使用-XX:ParallelGCThreads=<N>设置并行垃圾回收的线程数，此值可以和机器处理器数相等                                     │
│              │  通过-XX:MaxGCPauseMillis=<N>设置最大垃圾回收暂定时间                                                                  │
│              │  通过-XX:GCTimeRatio=<N>垃圾回收时间与非垃圾回收时间的比值，那么1/(1+N)即为当先系统的吞吐量，N默认值为99，即1%时间     │
│              │    用于垃圾回收                                                                                                        │
├———————┼————————————————————————————————————————————————————————————┤
│              │  前两者在垃圾回收时，应用会有明显的暂停，该方式可以减少该影响，保证大部分工作并发进行（应用不停止），适合中大规模应用，│
│              │  使用-XX:+UseConcMarkSweepGC打开，由于并发收集比较复杂，接下来介绍几个基本概念。                                       │
│              │                                                                                                                        │
│              │  浮动垃圾：由于在应用运行时进行垃圾回收，所有有些垃圾可能在垃圾回收进行完成时产生，这样就造成了"Floating Garbage"，这些│
│  并发收集器  │  垃圾需要在下次垃圾回收周期才能回收，所以并发收集器需要保留20%的预留空间用于这些浮动垃圾。                             │
│              │                                                                                                                        │
│              │  Concurrent Mode Failure:由于在垃圾回收时系统运行，需要保证有足够空间给程序使用，否则堆满时，会发生"并发模式失败"，整个│
│              │  应用暂停，进行垃圾回收。可以通过设置-XX:CMSInitiatingOccupancyFraction=<N>指定还有多少神域堆空间时开始执行并发收集    │
│              │                                                                                                                        │
└———————┴————————————————————————————————————————————————————————————┘



3.3 垃圾回收器
（1）分类
评价垃圾回收质量的两个指标：
·停顿时间
·吞吐量

●Serial收集器（复制算法)
新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。
●ParNew收集器(停止-复制算法)　
新生代收集器，可以认为是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。
●Parallel Scavenge收集器(停止-复制算法)
新生代收集器，并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%，吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。
●Serial Old收集器(标记-整理算法)
老年代单线程收集器，Serial收集器的老年代版本。
●Parallel Old收集器(停止-复制算法)
●Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。
●CMS
-------------------------------------------------------------------------------------------------------------------------------------------------------------
CMS全称 Concurrent Mark Sweep，是一款“以获取最短回收停顿时间”为目标的“并发、标记-清除”算法垃圾回收器，如果老年代使用CMS垃圾回收器，需要添加虚拟机参数-"XX:+UseConcMarkSweepGC"。（STW 即 stop the world）
回收过程：
（1）初始标记（STW）：JVM停顿正在执行的任务，即STW(Stop The Word官方叫法)。标记GC Roots能直接关联到的“存活对象”，所以这个过程虽然暂停了整个JVM，但是很快就完成了。
（2）并发标记：在初始标记的基础上继续向下追溯标记从root可达的所有对象，即进行GC Roots Tracing。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。
（2.5）并发预清理（可选）：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。
（3）重新标记（STW）：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。该阶段用于修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
（4）并发清理：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。
（5）并发重置：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。

优点：
    高并发低停顿，吞吐量高。适合内存、cpu资源充裕，对停顿比较敏感、对时延要求较高的服务，用户线程不允许长时间的停顿。
缺点：
    1. 内存碎片：基于标记清除，长时间运行，造成内存碎片化。
    2. cpu敏感：由于并发执行，占用一定的内存cpu，吞吐量会下降
    3. 浮动垃圾：由于并发处理，用户线程正在使用垃圾无法收集，因此比较早(68%)就要启动收回，回收失败会导致降级为串行收集，有比较大的STW。
-------------------------------------------------------------------------------------------------------------------------------------------------------------
●G1回收器
-------------------------------------------------------------------------------------------------------------------------------------------------------------
G1把堆内存分为年轻代和老年代。年轻代分为Eden和Survivor两个区，老年代分为Old和Humongous两个区。代和区都是逻辑概念。G1把堆内存分为大小相等的内存分段，默认情况下会把内存分为2048个内存分段Region，单个Region的大小在1-32MB之间，可以用-XX:G1HeapRegionSize调整内存分段的个数。每个内存分段都可以被标记为Eden区，Survivor区，Old区，或者Humongous区。这样属于不同代，不同区的内存分段就可以不必是连续内存空间了。
新分配的对象会被分配到Eden区的内存分段上，每一次年轻代的回收过程都会把Eden区存活的对象复制到Survivor区的内存分段上，把Survivor区继续存活的对象年龄加1，如果Survivor区的存活对象年龄达到某个阈值（比如15，可以设置），Survivor区的对象会被复制到Old区。复制过程是把源内存分段中所有存活的对象复制到空的目标内存分段上，复制完成后，源内存分段没有了存活对象，变成了可以使用的空的Eden内存分段了；而目标内存分段的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。Humongous区用于保存大对象，如果一个对象占用的空间超过内存分段的一半（比如上面的8M），则此对象将会被分配在Humongous区。如果对象的大小超过一个甚至几个分段的大小，则对象会分配在物理连续的多个Humongous分段上。Humongous对象因为占用内存较大并且连续会被优先回收。

如果一个对象占用的空间超过内存分段的一半（比如上面的8M），则此对象将会被分配在Humongous区。如果对象的大小超过一个甚至几个分段的大小，则对象会分配在物理连续的多个Humongous分段上。Humongous对象因为占用内存较大并且连续会被优先回收。


                          存活年龄
          回收            达到阈值
┌———┐    ┌—————┐    ┌———┐    ┌——————┐
│ Edge ├—→┤ Survivor ├—→┤ Old  ├—→┤ Humongous  │
└———┘    └—————┘    └———┘    └——————┘
                  │  ↑
                  └—┘
                 存活年龄+1


优点：
    1. 可根据用户设置停顿时间，制定回收计划(但是也可能存在超出用户的停顿时间).
    2. 无内存碎片：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。

-------------------------------------------------------------------------------------------------------------------------------------------------------------






3.4 回收分类
从年轻代空间（包括Eden和 Survivor 区域）回收内存被称为 Minor GC，对老年代GC称为Major GC，而Full GC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收（JDK8中无永生带了），出现Full GC的时候经常伴随至少一次的Minor GC，但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。
Heap用于存放实例，而永久代用于存放Class和Method Meta信息




3.5 垃圾回收启动参数
## 内存分配
-Xms512m        设置JVM Heap初始内存，默认为物理内存1/64。当最小堆占满后，会尝试进行GC，如果GC之后还不能得到足够的内存(GC未必会收集到所有当前可用内存)，分配新的对象，那么就会扩展堆，如果-Xmx设置的太小，扩展堆就会失败，导致OutOfMemoryError错误提示
-Xmx512m        设置JVM Heap最大内存，默认为物理内存1/4。
-Xmn200m        设置JVM Heap年轻代内存，整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
-Xss128k        设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
-XX:+DisableExplicitGC      禁止调用System.gc()；但jvm的gc仍然有效

## 内存回收
### 针对年轻代
-XX:+UseSerialGC            Young：Serial 回收算法
                            Old：Serial 回收算法
                            Client模式下的默认GC方式，串行GC。
-XX:+UseParallelGC          Young：Parallel Scavenge 回收算法
                            Old：由 -XX:+UseParallelOldGC 指定
                            Server模式下的默认GC方式，并行GC，可以同时并行多个垃圾收集线程，但此时用户线程必须停止。可以以-XX:+UseParallelGC=x的方式指定并行的线程数。（不能与CMS收集器配合工作）（关注吞吐量）
-XX:MaxGCPauseMillis=100    配合-XX:+UseParallelGC，设置每次年轻代垃圾回收的最长时间
-XX:+UseParNewGC            Young：针对新生代采用并行回收器，相当于：ParNew + Serial Old。（可与CMS收集同时使用）（关注响应时间）
### 针对老年代

-XX:+UseSerialOldGC         Old：Serial 回收算法
-XX:+UseParallelOldGC       针对老年代使用并行回收器：ParallelOld。即在young generation中采用ParNew，多线程处理；在tenured generation中使用CMS，以求得到最低的暂停时间，但是，采用CMS有可能出现“Concurrent Mode Failure”（这个后面再说），如果出现了，就只能采用“SerialOld”模式。
  打印出的GC会带PSYoungGen、ParOldGen关键字：
  [Full GC [PSYoungGen: 4032K->0K(145920K)] [ParOldGen: 164500K->138362K(246272K)] 168532K->138362K(392192K) [PSPermGen: 67896K->67879K(136192K)], 1.006

-XX:+UseConcMarkSweepGC     并发标记清理收集器。针对老年代采用并行回收器，相当于：ParNew + CMS。使用CMS是为了减少GC执行时的停顿时间，垃圾回收线程和应用线程同时执行。缺点是消耗较多CPU资源，会造成内存碎片。
  -XX:ParallelGCThreads=n指定并发线程数。CMS每次回收只停顿很短的时间，分别在开始的时候（Initial Marking），和中间（Final Marking）的时候，第二次时间略长。具体CMS的过程可以参考相关文档。JStat中将Initial Mark和Remark都统计成了FGC。CMS一个比较大的问题是碎片和浮动垃圾问题（Floating Gabage）。碎片是由于CMS默认不对内存进行Compact所致，可以通过-XX:+UseCMSCompactAtFullCollection。
  -XX:+UseCMSCompactAtFullCollection      整理内存。仅在使用CMS收集器时生效。
  -XX:CMSFullGCsBeforeCompaction=1        配置进行了多少次Full GC之后执行一次内存压缩。

★Concurrent Mode Failure：由于CMS在执行过程中是与应用程序并发执行的，如果在此过程中，应用程序需要在老年代分配空间来存放对象，而老年代此时没有足够的空闲空间，此时会触发Concurrent Mode Failure，之后会进行一次Full GC，老年代降级为使用Serial Old垃圾回收器，此时会暂停所有的应用线程的执行。


## 内存回收配置
-XX:SurvivorRatio           新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survior = 8:1，即Eden:Survior1:Survior2 = 8:1:1
-XX:+UseLargePages          使用大页面内存
-XX:+PrintGCApplicationStoppedTime      参数可以记录应用在每次GC事件中的暂停时间
-XX:+PrintReferenceGC                   参数可以记录回收了多少不同引用类型的引用
-XX:+UseAdaptiveSizePolicy              JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。
    73366.460: [Full GC (Ergonomics)  350113K->118280K(523264K), 0.3413982 secs]


参数及其默认值                      描述
-XX:MaxGCPauseMillis=100            设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值
-XX:MaxTenuringThreshold            晋升到老年代的对象年龄，每次Minor GC之后，年龄就加1，当超过这个参数的值时进入老年代
-XX:PretenureSizeThreshold          直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配
-XX:LargePageSizeInBytes=4m         设置用于Java堆的大页面尺寸
-XX:MaxHeapFreeRatio=70             GC后java堆中空闲量占的最大比例
-XX:MaxNewSize=size                 新生成对象能占用内存的最大值
-XX:MaxPermSize=64m                 老生代对象能占用内存的最大值
-XX:MinHeapFreeRatio=40             GC后java堆中空闲量占的最小比例
-XX:NewRatio=2                      新生代内存容量与老生代内存容量的比例
-XX:NewSize=2.125m                  新生代对象生成时占用内存的默认值
-XX:ReservedCodeCacheSize=32m       保留代码占用的内存容量
-XX:ThreadStackSize=512             设置线程栈大小，若为0则使用系统默认值
-XX:MetaspaceSize=21807104          初始空间大小(也是初始的阈值，即初始的high-water-mark)，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize=512m           元空间最大值，默认没有上限，也就是系统内存上限是多少它就是多少。
-XX:MinMetaspaceFreeRatio           在GC之后，最小的Metaspace剩余空间容量的百分比(即元数据在当前分配大小的最大占用大小)，如果空闲比小于这个参数(即超过了最大占用大小)，那么将对meta space进行扩容。
-XX:MaxMetaspaceFreeRatio           在GC之后，最大的Metaspace剩余空间容量的百分比(即元数据在当前分配大小的最小占用大小)，如果空闲比大于这个参数(即小于最小占用大小)，那么将对meta space进行缩容。
---------------------------------------------------------------------------------------------------------------------------------------
建议：
MetaspaceSize和MaxMetaspaceSize设置一样大；
具体设置多大，建议稳定运行一段时间后通过jstat -gc pid确认且这个值大一些，对于大部分项目256m即可。

MetaspaceSize表示metaspace首次使用不够而触发FGC的阈值，只对触发起作用，原因是：垃圾搜集器内部是根据变量_capacity_until_GC来判断metaspace区域是否达到阈值。GC收集器会在发生对metaspace的回收会，会计算新的_capacity_until_GC值，以后发生FGC就跟MetaspaceSize没有关系了。
---------------------------------------------------------------------------------------------------------------------------------------
-XX:ParallelGCThreads=n             设置并行收集器收集时使用的线程数。
-XX:MaxGCPauseMillis=n              设置并行收集最大暂停时间


-Xloggc:log/gc.log                  # 输出回收日志
-XX:HeapDumpBeforeFullGC
-XX:HeapDumpPath=. 
-XX:+PrintGCTimeStamps              # 回收日志中，输出回收时间，以启动时间为起点的时间戳
0.185: [GC 66048K->53077K(251392K), 0.0977580 secs]
0.323: [GC 119125K->114661K(317440K), 0.1448850 secs]
0.603: [GC 246757K->243133K(375296K), 0.2860800 secs]
-XX:+PrintGCDateStamps              # 回收日志中，输出回收时间，以标准时间格式
2014-01-03T12:08:38.102-0100: [GC 66048K->53077K(251392K), 0.0959470 secs]
2014-01-03T12:08:38.239-0100: [GC 119125K->114661K(317440K), 0.1421720 secs]
2014-01-03T12:08:38.513-0100: [GC 246757K->243133K(375296K), 0.2761000 secs]



-XX:+PrintGC                        # 与-verbose:gc 相同
[GC 246656K->243120K(376320K), 0.0929090 secs]
[Full GC 243120K->241951K(629760K), 1.5589690 secs]


-XX:+PrintGCDetails                 # 输出回收详情
[GC [PSYoungGen: 142816K->10752K(142848K)] 246648K->243136K(375296K), 0.0935090 secs ] [Times: user=0.55 sys=0.10, real=0.09 secs]

Java HotSpot(TM) 64-Bit Server VM (24.80-b11) for windows-amd64 JRE (1.7.0_80-b15), built on Apr 10 2015 11:26:34 by "java_re" with unknown MS VC++:1600
Memory: 4k page, physical 4184440k(958020k free), swap 8367040k(3884064k free)
CommandLine flags: -XX:InitialHeapSize=805306368 -XX:MaxHeapSize=805306368 -XX:MaxNewSize=536870912 -XX:NewSize=536870912 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
2016-01-22T01:49:18.778+0800: 7.315: [GC [PSYoungGen: 393216K->60678K(458752K)] 393216K->60686K(720896K), 0.1241514 secs] [Times: user=0.13 sys=0.05, real=0.12 secs] 
2016-01-22T01:49:27.794+0800: 16.332: [GC [PSYoungGen: 453894K->45567K(458752K)] 453902K->45583K(720896K), 0.1833980 secs] [Times: user=0.22 sys=0.00, real=0.18 secs] 
2016-01-22T01:49:39.641+0800: 28.179: [GC [PSYoungGen: 438783K->53967K(458752K)] 438799K->53983K(720896K), 0.1683523 secs] [Times: user=0.31 sys=0.00, real=0.17 secs] 


-XX:+HeapDumpOnOutOfMemoryError     # 
-XX:HeapDumpPath=gc.hprof
-XX:CMSInitiatingOccupancyFraction=75
-XX:CMSFullGCsBeforeCompaction=2
-XX:+UseCMSCompactAtFullCollection

Old区还远远达不到70%（-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70）





-XX:+UseG1GC                            使用 G1 (Garbage First) 垃圾收集器
-XX:MaxGCPauseMillis=n                  设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽量去达成这个目标.
-XX:InitiatingHeapOccupancyPercent=n    启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示"一直执行GC循环". 默认值为 45.
-XX:NewRatio=n                          新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.
-XX:SurvivorRatio=n                     eden/survivor       空间大小的比例(Ratio). 默认值为 8.
-XX:MaxTenuringThreshold=n              提升年老代的最大临界值(tenuring threshold). 默认值为 15.
-XX:ParallelGCThreads=n                 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.
-XX:ConcGCThreads=n                     并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.
-XX:G1ReservePercent=n                  设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.
-XX:G1HeapRegionSize=n                  使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.








●GC日志
2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K->2K(948864K), 0.0059180 secs] 2186589K->1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
其含义大概如下：
                              当前时间戳             单线程Serial年轻代GC
2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K（年轻代垃圾回收前占用大小）->2K（年轻代回收后占用大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）]
当前时间                                Young GC
————————————————————————————————————————————————————————————————————————————
2186589K（整个堆回收前的大小）->1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]




JVM调优工具
工具名称                                  主要作用
jps（JVM Process Status Tool）            显示指定系统中所有的HotSpot虚拟机进程
jstat（JVM Statistics Monitoring Tool）   收集HotSpot虚拟机各方面的运行数据
jinfo（Configuration Info for Java）      显示虚拟机配置信息
jmap（Memory Map for Java）               生成虚拟机的内存转储快照（heapdump文件）
jhat（JVM Heap Dump Browser）             分析内存转储快照，不推荐使用，消耗资源而且慢
jstack（Stack Trace for Java）            显示虚拟机的线程快照
JConsole                                  JMX的可视化管理工具
VisualVM                                  多合一故障管理工具


●jps
# 查看进程
$ jps -l
8002 com.yixin.crm.usedcar.rabbitmq.CrmOrderConsumerApplication
32053 com.taoche.crm.erpconsumer.Application
7686 com.yixin.crm.usedcar.UsedcarCrmStoreConsumerApplication
9306 com.yixin.crm.usedcar.rabbitmq.CrmBssConsumerApplication
20027 sun.tools.jps.Jps
3691 com.yixin.crm.usedcar.rabbitmq.CrmC1ConsumerApplication
15421 ./eureka-server.jar
20317 com.yixin.crm.usedcar.rabbitmq.CrmClueConsumerApplication
12973 com.yixin.basicservice.authconsumer.AuthConsumerApplication
18926 /data1/services/usedcar-crm-c1-core/usedcar-crm-c1-core.jar
19471 com.yixin.crm.usedcar.rabbitmq.CrmCarConsumerApplication

●jinfo
# 查看和调整虚拟机各项参数
$ jinfo -flags 26482
# 查看启动时MetaspaceSize所设参数值
$ jinfo -flag MetaspaceSize 26482
-XX:MetaspaceSize=21807104
# 任何一个JVM参数的默认值可以通过java -XX:+PrintFlagsFinal -version |grep JVMParamName获取
$ java -XX:+PrintFlagsFinal -version |grep MetaspaceSize


●jstack
jstack 是sun JDK 自带的工具，通过该工具可以看到JVM 中线程的运行状况，包括锁等待，线程是否在运行
执行 jstack [pid] ，线程的所有堆栈信息
"http-8080-10" daemon prio=10 tid=x0a949bb60 nid=0x884  waiting for monitor entry [...]
"http-8080-10" 这个线程处于等待状态。 waiting for monitor entry 如果在连续几次输出线程堆栈信息都存在于同一个或多个线程上时，则说明系统中有锁竞争激烈，死锁，或锁饿死的想象。
“http-8080-11” daemon prio=10 tix=xxx nid=xxx in object.wait() [...]
 java.lang.Thread.State:waiting (on object monitor)
该表示http-8080-11的线程处于对象的Wait 上，等待其他线程的唤醒，这也是线程池的常见用法。
“Low Memory Detector”daemon prio=10 tix=xx nid=xxx runnable [...] java.lang.Thread.State:runnable
表示“Low Memory Detector” 的线程处于Runable状态，等待获取ＣＰＵ的使用权.

# 查看线程
$ top -p <pid> -H
# 查看线程
$ jstack -l <pid>
# 生成线程堆文件
$ jstack -l <pid> > 1.tdump
-------------------------------------------------------------------------------------------------------------------------------
C:\Users\PPC>jstack -l 11696
2019-07-23 19:00:37
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.20-b23 mixed mode):

"Service Thread" #10 daemon prio=9 os_prio=0 tid=0x00000000193de000 nid=0x8c4 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"C1 CompilerThread2" #9 daemon prio=9 os_prio=2 tid=0x000000001938d800 nid=0x2cb0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"C2 CompilerThread1" #8 daemon prio=9 os_prio=2 tid=0x000000001932a800 nid=0x3260 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"C2 CompilerThread0" #7 daemon prio=9 os_prio=2 tid=0x000000001932a000 nid=0x9fc waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x0000000019326000 nid=0x42a0 runnable [0x000000001972e000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.read(SocketInputStream.java:150)
        at java.net.SocketInputStream.read(SocketInputStream.java:121)
        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
        - locked <0x00000000d6f5dc98> (a java.io.InputStreamReader)
        at java.io.InputStreamReader.read(InputStreamReader.java:184)
        at java.io.BufferedReader.fill(BufferedReader.java:161)
        at java.io.BufferedReader.readLine(BufferedReader.java:324)
        - locked <0x00000000d6f5dc98> (a java.io.InputStreamReader)
        at java.io.BufferedReader.readLine(BufferedReader.java:389)
        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)

   Locked ownable synchronizers:
        - None

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000000017cef000 nid=0x2654 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x0000000017d3e800 nid=0x3d1c runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x0000000003332800 nid=0x3db4 in Object.wait() [0x000000001902f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00000000d6c06280> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142)
        - locked <0x00000000d6c06280> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

   Locked ownable synchronizers:
        - None

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000000000332f000 nid=0x44c in Object.wait() [0x0000000018f2e000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00000000d6c05cf0> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:502)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)
        - locked <0x00000000d6c05cf0> (a java.lang.ref.Reference$Lock)

   Locked ownable synchronizers:
        - None

"main" #1 prio=5 os_prio=0 tid=0x0000000003243800 nid=0x220 waiting on condition [0x0000000002fff000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at sandbox.console.Main.main(Main.java:28)

   Locked ownable synchronizers:
        - None

"VM Thread" os_prio=2 tid=0x0000000017ca6800 nid=0x5250 runnable

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x0000000003259000 nid=0x52e4 runnable

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x000000000325a800 nid=0x4ae8 runnable

"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x000000000325c000 nid=0x288c runnable

"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x000000000325d800 nid=0x2814 runnable

"VM Periodic Task Thread" os_prio=2 tid=0x00000000193e1000 nid=0x3df8 waiting on condition

JNI global references: 20
-------------------------------------------------------------------------------------------------------------------------------




●jmap
jmap命令主要用于生成java 堆dump文件，如果不使用这个命令，也可以使用-XX：+HeapDumpOnOutOfMemoryError参数让虚拟机出现OOM(Out Of Memory)时，自动生成dump文件。
jmap的主要功能：查询Java堆和永久代的详细信息，使用率，使用大小，查询finalize执行队列的信息。
jmap的用法：jmap [option] <pid>   用来连接运行的进程
            jmap [option] <executable <core>> 用来连接一个core文件
            jmap [option] [server_id@]<remote server IP or hostname> 用来连接一个远程ip或主机
            [option]:      选项参数是互斥的，不能同时使用
                -heap: 显示java堆的详细信息，to print java heap summary. 可分别查看 eden +from + to +old 的内存
                -histo: 显示堆中对象的统计信息，to print histogram of java object heap; if the "live"
                -clstats: 显示类加载统计
                -finalizerinfo: 显示在F-QUEUE中等待执行Finalizer线程执行finalizer方法的对象
                -dump: 生成堆转存文件
                -F: 当-dump没有响应时，强制生成dump快照
-------------------------------------------------------------------------------------------------------------------

# 查看内存
$ jmap -histo <pid>
$ jmap -heap 6913
$ jmap -histo:live 6913


# 保存dump文件
$ jmap -dump:live,format=b,file=/dump.dat 1570 
Dumping heap to /dump.dat ...
Heap dump file created


# 显示heap堆的详细信息
$ jmap -heap 1570
Attaching to process ID 1570, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.151-b12
 
using thread-local object allocation.
Parallel GC with 4 thread(s) // GC的方式
 
Heap Configuration:   // 堆内存的初始化配置信息
   MinHeapFreeRatio         = 0     // 对应jvm启动参数 -XX:MinHeapFreeRatio jvm最小空闲内存比率
   MaxHeapFreeRatio         = 100   // 对应jvm启动参数 -XX:MaxHeapFreeRatio jvm最大空闲内存比率
   MaxHeapSize              = 1996488704 (1904.0MB)   // 对应jvm启动参数 -XX:MaxHeapSize jvm堆的最大堆大小
   NewSize                  = 41943040 (40.0MB)       // 对应jvm启动参数 -XX:NewSize jvm堆新生代默认大小
   MaxNewSize               = 665321472 (634.5MB)     // 对应jvm启动参数 -XX:MaxNewSize jvm堆新生代最大大小
   OldSize                  = 83886080 (80.0MB)       // 对应jvm启动参数 -XX:OldSize jvm堆的老年代大小
   NewRatio                 = 2  // 对应jvm启动参数 -XX:NewRatio '新生代'和'老年代'的大小比率
   SurvivorRatio            = 8  // 对应jvm启动参数 -XX:SurvivorRatio 设置年轻代中Eden区与Survivor区大小比率
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)
 
Heap Usage:  //堆内存使用情况
PS Young Generation
Eden Space:  // Eden区内存分布
   capacity = 306184192 (292.0MB)  //Eden区总容量
   used     = 197876024 (188.70928192138672MB)  //Eden区已使用
   free     = 108308168 (103.29071807861328MB)  //Eden区剩余容量
   64.62646641143381% used    //Eden区使用比率
From Space:   //其中一个Survivor区的内存分布
   capacity = 16777216 (16.0MB)
   used     = 524288 (0.5MB)
   free     = 16252928 (15.5MB)
   3.125% used
To Space:     //另一个Survivor区的内存分布
   capacity = 15728640 (15.0MB)
   used     = 0 (0.0MB)
   free     = 15728640 (15.0MB)
   0.0% used
PS Old Generation  //当前的old区内存分布
   capacity = 127926272 (122.0MB)
   used     = 34253488 (32.66667175292969MB)
   free     = 93672784 (89.33332824707031MB)
   26.775960453221057% used
 
25017 interned Strings occupying 3208280 bytes.
-------------------------------------------------------------------------------------------------------------------
-histo 打印堆的对象统计，包括对象数，内存大小等。jmap -histo:live 这个命令执行时，jvm会先触发gc，然后再统计信息。所以这个命令要慎用。这个可能会显示很多，所以一次显示100条
[root@localhost ~]# jmap -histo:live 1570 | more 100
------------------------------------------------------------------------------------------------------------------- 
 num     #instances         #bytes  class name
----------------------------------------------
   1:         74296        9697928  [C
   2:         68201        2182432  java.util.concurrent.ConcurrentHashMap$Node
   3:         23969        2109272  java.lang.reflect.Method
   4:         72884        1749216  java.lang.String
   5:         12003        1331608  java.lang.Class
   6:          4333        1053184  [B
   7:         21255        1020240  org.aspectj.weaver.reflect.ShadowMatchImpl
   8:         23157         926280  java.util.LinkedHashMap$Entry
   9:           367         785712  [Ljava.util.concurrent.ConcurrentHashMap$Node;
  10:          9937         694520  [Ljava.util.HashMap$Node;
  11:         12237         685272  java.util.LinkedHashMap
  12:         21255         680160  org.aspectj.weaver.patterns.ExposedState
  13:          5530         671240  [I
  14:         11241         601016  [Ljava.lang.Object;
  15:         30008         480128  java.lang.Object
  16:         13388         428416  java.util.HashMap$Node
  17:         11460         242936  [Ljava.lang.Class;
  18:          6168         197376  java.lang.ref.WeakReference
  19:          1836         176256  org.springframework.beans.GenericTypeAwarePropertyDescriptor
  20:          4032         161280  java.lang.ref.SoftReference
  21:          4866         155712  java.util.LinkedList
  22:          4263         154088  [Ljava.lang.String;
  23:          5719         137256  java.util.ArrayList
  24:          1561         124880  java.lang.reflect.Constructor
  25:          2469         118512  java.util.HashMap
  26:          4785         114840  java.beans.MethodRef
  27:          2687         107480  java.util.TreeMap$Entry
  28:          2671         106840  java.util.WeakHashMap$Entry
  29:          1459         105048  org.springframework.core.annotation.AnnotationAttributes
  30:          1317          84288  org.springframework.core.MethodParameter
  31:           474          79632  org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition
  32:          4876          78016  java.util.LinkedHashSet
  33:          3082          73968  java.util.LinkedList$Node
  34:            54          70432  [J
  35:          2414          57936  sun.reflect.generics.tree.SimpleClassTypeSignature
-------------------------------------------------------------------------------------------------------------------










































●jhat
# 分析dump.dat文件
$ jhat ./dump.dat

jhat是sun 1.6及以上版本中自带的一个用于分析JVM 堆DUMP 文件的工具，基于此工具可分析JVM HEAP 中对象的内存占用情况
jhat -J-Xmx1024M [file]
执行后等待console 中输入start HTTP server on port 7000 即可使用浏览器访问 IP：7000
# 默认端口号7000
$ jhat dump.dat
http://127.0.0.1:7000
$ jhat -port 9998 dump.dat








●jstat
# 查看heap的使用情况，以及gc相关信息

option              Displays…
class               class loader的性能统计信息
compiler            HotSopt Just-In-Time编译器的性能统计信息
gc                  heap上的gc统计信息
gccapacity          不同年代内存区域的使用情况统计信息
gccause             垃圾回收的汇总信息(这一点和-gcutil)类似，会展示最近一次垃圾回收事件的详细信息
gcnew               新生代的统计信息
gcnewcapacity       新生代的空间大小和内存使用情况
gcold               老年代和持久代的统计信息
gcoldcapacity       老年代的空间大小和内存使用情况
gcpermcapacity      持久代的空间大小和内存使用情况
gcutil              垃圾回收事件汇总
printcompilationl   垃圾回收事件汇总


$ jstat
 -gcutil 查看gc信息
 -class 查看加载的类
 -compiler 查看JVM实时编译的数量
 -printcompilation 当前VM执行的信息
 [-h<lines>] 几行输出一次表头，当输出的数据行数过多时，为了方便阅读，可以让其每几行输出一次表头。通常使用–h3 或–h5
 <vmid> 需要监控的进程的pid
 [<interval> [<count>]] 输出间隔 输出的次数

# 显示加载class的数量，及所占空间等信息
jstat -class <pid>

# eg.    每1000ms输出一次，共输出10次
$ jstat -gcutil -h3 5801 1000 10

# 统计gc信息
$ jstat -gcutil 5801
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
 81.25   0.00  48.09  39.21  92.83  90.09    222    1.623     4    0.657    2.280

$ jstat -gccause 5801
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
 81.25   0.00  85.36  39.21  92.83  90.09    222    1.623     4    0.657    2.280 Allocation Failure   No GC   

# 相关的堆信息
$ jstat -gc -t 5801
Timestamp  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
200.0     512.0  1024.0 416.0   0.0   130560.0 65404.6   153600.0   60227.8   98560.0 91492.6 11648.0 10493.9    222    1.623   4      0.657    2.280

# VM内存中三代（young,old,perm）对象的使用和占用大小
$ jstat -gccapacity 5801

# 年轻代信息
$ jstat -gcnew <pid>

# 老年代信息
$ jstat -gcold <pid>

※此处的M占比没有意义



S0C：年轻代中第一个survivor（幸存区）的容量 (kb)
S1C：年轻代中第二个survivor（幸存区）的容量 (kb)
S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (kb)
S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (kb)
EC：年轻代中Eden（伊甸园）的容量 (kb)
EU：年轻代中Eden（伊甸园）目前已使用空间 (kb)
OC：Old代的容量 (kb)
OU：Old代目前已使用空间 (kb)
PC：Perm(持久代)的容量 (kb)
PU：Perm(持久代)目前已使用空间 (kb)
YGC：从应用程序启动到采样时年轻代中gc次数
YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)
FGC：从应用程序启动到采样时old代(全gc)gc次数
FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)
GCT：从应用程序启动到采样时gc用的总时间(s)
NGCMN：年轻代(young)中初始化(最小)的大小 (kb)
NGCMX：年轻代(young)的最大容量 (kb)
NGC：年轻代(young)中当前的容量 (kb)
OGCMN：old代中初始化(最小)的大小 (kb)
OGCMX：old代的最大容量 (kb)
OGC：old代当前新生成的容量 (kb)
PGCMN：perm代中初始化(最小)的大小 (kb)
PGCMX：perm代的最大容量 (kb)
PGC：perm代当前新生成的容量 (kb)
S0：年轻代中第一个survivor（幸存区）已使用占百分比
S1：年轻代中第二个survivor（幸存区）已使用占百分比
E：年轻代中Eden（伊甸园）已使用占百分比
O：old代已使用占百分比
P：perm代已使用占百分比
M：MetaspaceSize已使用占百分比
CCS：压缩类已使用占百分比
S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (kb)
S1CMX：年轻代中第二个survivor（幸存区）的最大容量 (kb)
ECMX：年轻代中Eden（伊甸园）的最大容量 (kb)
DSS：当前需要survivor（幸存区）的容量 (kb)（Eden区已满）
TT：持有次数限制
MTT ：最大持有次数限制


·YGC和FGC是什么 
   YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
   FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。
·什么时候执行YGC和FGC
   a.edn空间不足，执行 young gc
   b.old空间不足，perm空间不足，调用方法System.gc()，ygc时的悲观策略，dump live的内存信息时(jmap –dump:live)，都会执行full gc









D.动态代理/java探针/javaagent
·MANIFEST.MF
Manifest-Version: 1.0
Premain-Class: com.sandbox.javaagent.PreMain
Can-Redefine-Classes: true


·pom.xml
<project>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <archive>
                        <manifestFile>src/main/resources/META-INF/MANIFEST.MF</manifestFile>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>


·PreMain.java
public class PreMain {
    public static void premain(String agentOps, Instrumentation inst)
    {
        System.out.println("Hello World! PreMain.premain 方法");
        System.out.println(agentOps);
    }

    public static void premain(String agentOps)
    {
        System.out.println("Hello World! PreMain.premain 方法2");
        System.out.println(agentOps);
    }
}


idea VM options:
-javaagent:E:\NutDisk\Program\Resource\Library\Java\_solution\Project\sandbox\sandbox-javaagent\target\sandbox-javaagent-0.0.1-SNAPSHOT.jar=Hello
Command:
$ java -javaagent:myagent.jar -jar myprogram.jar






Q.常见异常：
1.Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
对应GC日志如下：
75127.643: [Full GC (Ergonomics)  323522K->296752K(736256K), 1.1222409 secs]
75129.488: [GC (Allocation Failure)  499504K->498716K(635904K), 0.3282923 secs]
75129.816: [Full GC (Ergonomics)  498716K->494759K(649216K), 1.3988424 secs]
75131.446: [Full GC (Ergonomics)  582823K->577736K(649216K), 1.8312594 secs]
75133.347: [Full GC (Ergonomics)  612041K->612017K(649216K), 1.2995203 secs]
75134.647: [Full GC (Ergonomics)  612041K->612029K(649216K), 1.2998460 secs]
75135.948: [Full GC (Ergonomics)  612041K->612039K(649216K), 1.6322560 secs]
75137.580: [Full GC (Ergonomics)  612041K->612039K(649216K), 1.6304641 secs]
75139.211: [Full GC (Ergonomics)  612041K->612039K(649216K), 1.2837125 secs]
75140.495: [Full GC (Ergonomics)  612041K->612039K(649216K), 1.6371532 secs]
75142.133: [Full GC (Ergonomics)  612041K->612039K(649216K), 1.3148236 secs]

●java.lang.OutOfMemoryError: GC overhead limit exceeded：
内存溢出。通常原因都是因为old区占用过多导致频繁Full GC，最终导致GC overhead limit exceed。
“if too much time is being spent in garbagecollection: if more than 98% of the total time is spent in garbagecollection and less than 2% of the heap is recovered, anOutOfMemoryError will be thrown.”
意思是如果有98%的时间用来回收小于2%的堆空间时，会出现这个错误。
●Allocation Failure：
表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了
●Full GC (Ergonomics)：
Full GC是stop-the-world。
FGC的触发条件：
（1）System.gc()方法的调用
此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc
（2）老年代空间不足
老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space
避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
（3）永生代或者元数据空间不足
（4）CMS GC时出现promotion failed和concurrent mode failure对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。
（5）YoungGC时晋升老年代的内存平均值大于老年代剩余空间
（6）堆中分配连续的大对象
所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。
为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。


3.
强引用、软引用、弱引用和虚引用




4.
Conflicting collector combinations in option list; please refer to release the notes for the combinations allowed
  if (UseSerialGC)                       i++;  
  if (UseConcMarkSweepGC || UseParNewGC) i++;  
  if (UseParallelGC || UseParallelOldGC) i++;  
  if (UseG1GC)                           i++;  
  if (i > 1) {  
    jio_fprintf(defaultStream::error_stream(),  
                "Conflicting collector combinations in option list; "  
                "please refer to the release notes for the combinations "  
                "allowed\n");  
    status = false;  
  }










九十八、maven

A.介绍
1.安装部署
MAVEN_HOME=D:\apache-maven-3.0.2
path=%MAVEN_HOME%\bin
测试：mvn -version

2.settings.xml配置文件
a.maven\conf\settings.xml
找到Idea的安装目录下面的Maven：如C:\Program Files (x86)\JetBrains\IntelliJ IDEA 2016.3\plugins\maven\lib\maven3\conf\settings.xml
·可指定本地仓库位置
<!-- 本地仓库位置 -->
<!-- localRepository
 | The path to the local repository maven will use to store artifacts.
 |
 | Default: ${user.home}/.m2/repository
<localRepository>/path/to/local/repo</localRepository>
-->
修改为
<localRepository>D:/java/maven_repo</localRepository>
本地仓就建完了，这时需要加入我们自已的JAR

·可指定maven源地址
<mirrors>
    <mirror>
        <id>nexus-osc</id>
        <name>Nexus osc</name>
        <url>http://maven.oschina.net/content/groups/public/</url>
        <mirrorOf>central</mirrorOf>
    </mirror>
</mirrors>


B.命令
1.mvn
格式：
mvn <phase> <args>

●phase
# 清理项目目录
$ mvn clean                             # 清除taget文件夹中内容
$ mvn clean compile -Pdevelopment
$ mvn clean compile -Pproduction

# 编译
$ mvn compile                           # 将依赖下载到本地仓库（一般是~/.m2/repository），并编译源码和资源输出到target/classes目录下。
$ mvn compile                           # 未生成target/class
$ mvn compiler:compile                  # 生成target/class
※ 当compiler:compile可以编译出classes，而compile编译不出时，可能是因为pom.xml中<packing>pom<packing>；当二者都编译不出时，可能是目录结构不对，要遵从src/main/java的目录结构

# 测试
$ mvn test-compile                      # 编译测试源码，同上，但输出到target/test-classes目录下。
$ mvn test
$ mvn test -Dtest=***Test               # 其中“***Test”为被测试用例的类名

# 运行
## 通过spring-boot-maven-plugin启动，前提是所有module的pom.xml必须声明了spring-boot-maven-plugin引用，而且必须用默认的tomcat，否则会报找不到sevelet
$ mvn spring-boot:run
$ mvn spring-boot:run -Dspring-boot.run.profiles=test
$ mvn spring-boot:run -Drun.arguments="--server.port=8888"

# 打包
$ mvn package                           # 编译、测试并按指定格式打包。运行命令后工程根目录下生成target文件夹，文件夹内存放jar包，class文件夹等内容。
$ mvn package -Pdev                     # 以“指定环境”进行操作
$ mvn package -Dmaven.test.skip=true
$ mvn -f pom.xml                        # 指定pom文件

# 安装到本地仓库
$ mvn install                           # “打包”并“将包安装到本地仓库中”。运行命令后工程根目录下生成target文件夹，文件夹内存放jar包，class文件夹等内容。本地仓库repo中生成工程jar包目录。

# 部署到远程仓库
$ mvn deploy                            # “打包”并“将包安装到远程仓库中”。在对一个包含<parent/>的module进行deploy时，那么在其他项目中引用此依赖包时，也要引用该<parent/>：否则会报Inspects a Maven model for resolution problems.

# 联级
$ mvn spring-boot:run -pl dubbo-admin-server -am

# 依赖
$ mvn dependency:tree                                               # 查看依赖项树，
$ mvn dependency:tree -Dverbose -Dincludes=<groupId>:<artifactId>   # 支持通配符
$ mvn dependency:tree -Dverbose -Dincludes=*spring*:*spring*        # 支持通配符
$ mvn dependency:tree -P pom.xml -e                                 # 查看依赖项树
$ mvn dependency:tree -Dverbose                                     # 查看详细依赖项树，包括所有传递依赖
$ mvn dependency|tree                                               # 查看树结构
$ mvn dependency:purge-local-repository                                                             # 清理项目本地仓库（会清理pom.xml中的包，并重新下载，但是并不清理不在pom.xml中的依赖包）
$ mvn dependency:purge-local-repository -DmanualInclude="<groupId>:<artifactId>.<version>,..."      # 清理项目本地仓库中的指定依赖包
$ mvn dependency:purge-local-repository clean install
$ mvn dependency:purge-local-repository -DgroupId="com .york.portable" -DartifactId="swiss" -Dversion="1.1.2" -Puat

# idea
$ mvn idea:module                       # 当module的iml文件被删除，可使用该命令恢复，或在idea中reimport。前提是“父模块”中包括该“子模块”


------------------------------------------------------------------------------------------------------
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building springmvcsample 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ springmvcsample ---
[INFO] com.spring.mvcsample:springmvcsample:war:0.0.1-SNAPSHOT
[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.8.11:compile
[INFO] +- com.fasterxml.jackson.core:jackson-core:jar:2.8.11:compile
[INFO] +- com.fasterxml.jackson.core:jackson-annotations:jar:2.8.11:compile
[INFO] +- javax.servlet:javax.servlet-api:jar:4.0.0:provided
[INFO] +- commons-io:commons-io:jar:2.4:compile
[INFO] +- commons-fileupload:commons-fileupload:jar:1.3.1:compile
[INFO] +- org.springframework:spring-web:jar:4.3.13.RELEASE:compile
[INFO] |  +- org.springframework:spring-aop:jar:4.3.13.RELEASE:compile
[INFO] |  +- org.springframework:spring-beans:jar:4.3.13.RELEASE:compile
[INFO] |  +- org.springframework:spring-context:jar:4.3.13.RELEASE:compile
[INFO] |  \- org.springframework:spring-core:jar:4.3.13.RELEASE:compile
[INFO] |     \- commons-logging:commons-logging:jar:1.2:compile
[INFO] +- org.springframework:spring-webmvc:jar:4.3.13.RELEASE:compile
[INFO] |  \- org.springframework:spring-expression:jar:4.3.13.RELEASE:compile
[INFO] \- com.alibaba:fastjson:jar:1.2.45:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 01:13 min
[INFO] Finished at: 2018-03-23T14:06:36+08:00
[INFO] Final Memory: 16M/191M
[INFO] ------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------

# 版本号管理
$ mvn versions:set -DnewVersion=1.0.1-SNAPSHOT      # 递归更新版本号。※仅是向下递归，即在聚合模块中，会更新全部模块的版本号；在子模块中，会更新全部模块对该子模块引用的版本号，※在引入依赖时，也要和正常依赖一样，指明依赖包的版本号
$ mvn -N versions:update-child-modules              # 会自动把子POM的<parent>标签中的version更新为和父POM一致
$ mvn versions:commit



●arguments
·mvn -v, -version
显示版本信息；
·mvn -V, -show-version
显示版本信息后继续执行Maven其他目标；
·mvn -h, -help
显示帮助信息；
·mvn -e, -errors
控制Maven的日志级别，产生执行错误相关消息；
·mvn -X, -debug
控制Maven的日志级别，产生执行调试信息；
·mvn -q, -quiet
控制Maven的日志级别，仅仅显示错误；
·mvn -Pxxx（Profiles配置文件）
-Pxxx
激活 id 为 xxx 的profile (如有多个，用逗号隔开)；
-Pname=value
激活<property>中name=value的profile
---------------------------
<profile>
  <id>testid</id>
  <activation>
    <property>
      <name>env</name>
      <value>test</value>
    </property>
  </activation>
  ...
</profile>

$ mvn test -Ptestid
 或
$ mvn test -Penv=test
---------------------------

·mvn -Dxxx=yyy
指定Java全局属性；
如果pom.xml中不存在此Property，该属性变量将会被设置；若存在，将会被覆盖。多个属性用空格分开，例：
$ mvn -DpropA=valueA -DpropB=valueB -DpropC=valueC clean package
--------------------------------------------------------------------------------------------------------------------------------------------------
$ mvn package -DskipTests                             # 跳过测试阶段，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下
<!-- 也可以在pom.xml中利用maven-surefire-plugin实现-->
<!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-surefire-plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.5</version>
    <configuration>
        <skipTests>true</skipTests>
    </configuration>
</plugin> 


$ mvn package -Dmaven.test.skip=true                  # 跳过测试代码的编译，不执行测试用例，也不编译测试用例类
<!-- 也可以在pom.xml中利用maven-compiler-plugin实现-->
<!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-compiler-plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.7.0</version>
    <configuration>
        <skip>true</skip>
    </configuration>
</plugin>


$ mvn package -Dexec.mainClass="com.mycompany.app.App"
--------------------------------------------------------------------------------------------------------------------------------------------------

·mvn -o, --offline
运行offline模式，不联网更新依赖；
·mvn -N, --non-recursive
Build projects without recursive
仅在当前项目模块执行命令，不递归构建子模块；
·mvn -pl <module_name>， --projects
 Build specified reactor projects instead of all projects 
 在指定模块上执行命令，选项后可跟随{groupId}:{artifactId}或者所选模块的相对路径(多个模块以逗号分隔)；
·mvn -am, --also-make 
 If project list is specified, also build projects required by the list
 同时处理选定模块所依赖的模块
·mvn -amd, --also-make-dependents
 If project list is specified, also build projects that depend on projects on the list
 同时处理依赖选定模块的模块
·mvn -ff, --fail-fast 遇到构建失败就直接退出；
·mvn -fn, --fail-never 无论项目结果如何，构建从不失败；
·mvn -fae, --fail-at-end 仅影响构建结果，允许不受影响的构建继续；
·mvn -C, --strict-checksums 如果校验码不匹配的话，构建失败；
·mvn -c, --lax-checksums 如果校验码不匹配的话，产生告警；
·mvn -U, --update-snapshots 强制用“远程仓库”更新“本地仓库”的snapshot类型的<plugin>或<dependency>(否则maven一天只会更新一次snapshot依赖)；
·mvn -npu, --no-plugin-updates 对任何相关的注册插件，不进行最新检查(使用该选项使Maven表现出稳定行为，该稳定行为基于本地仓库当前可用的所有插件版本)；
·mvn -cpu, --check-plugin-updates 对任何相关的注册插件，强制进行最新检查(即使项目POM里明确规定了Maven插件版本，还是会强制更新)；
·mvn -up, --update-plugins [mvn -cpu]的同义词；
·mvn -B, --batch-mode 在非交互（批处理）模式下运行(该模式下，当Maven需要输入时，它不会停下来接受用户的输入，而是使用合理的默认值)；
·mvn -f, --file 强制使用备用的POM文件；
·mvn -s, --settings 用户配置文件的备用路径；
·mvn -gs, --global-settings 全局配置文件的备用路径；
·mvn -emp, --encrypt-master-password 加密主安全密码，存储到Maven settings文件里；
·mvn -ep, --encrypt-password 加密服务器密码，存储到Maven settings文件里；
·mvn -npr, --no-plugin-registry 对插件版本不使用~/.m2/plugin-registry.xml(插件注册表)里的配置



★操作指定Module
例1：A,B,P的继承关系为 
P 
| 
—– A 
| 
—– B 
Q: P包含A,B的module，每次打包P都会将A,B都打包。假如只修改A模块，那么每次都要将B都一块打包吗？
A: 
当然不是，maven提供了自定义参数：
-pl, --projects
        Build specified reactor projects instead of all projects
-am, --also-make
        If project list is specified, also build projects required by the list

所以进入P目录，输入指令：
$ mvn install -pl A -am
即可

例2：
dailylog-parent
|-dailylog-common
|-dailylog-web

三个文件夹处在同级目录中：
dailylog-web依赖dailylog-common
dailylog-parent管理dailylog-common和dailylog-web。

1. 在dailylog-parent目录运行`mvn clean install -pl org.lxp:dailylog-web -am`，结果
•dailylog-common成功安装到本地库
•dailylog-parent成功安装到本地库
•dailylog-web成功安装到本地库
该命令等价于`mvn clean install -pl ../dailylog-web -am`

2. 在dailylog-parent目录运行`mvn clean install -pl ../dailylog-common -am`，结果
•dailylog-common成功安装到本地库
•dailylog-parent成功安装到本地库

3. 在dailylog-parent目录运行`mvn clean install -pl ../dailylog-common -amd`，结果
•dailylog-common成功安装到本地库
•dailylog-web成功安装到本地库
由于dailylog-parent并不依赖dailylog-common模块，故没有被安装

4. 在dailylog-parent目录运行`mvn clean install -pl ../dailylog-common,../dailylog-parent -amd`，结果
•dailylog-common成功安装到本地库
•dailylog-parent成功安装到本地库
•dailylog-web成功安装到本地库

5. 在dailylog-parent目录运行`mvn clean install -N`，结果
•dailylog-parent成功安装到本地库
-N表示不递归，那么dailylog-parent管理的子模块不会被同时安装

6. 在dailylog-parent目录运行`mvn clean install -pl ../dailylog-parent -N`，结果
•dailylog-parent成功安装到本地库

7. 在dailylog-parent目录运行`mvn clean install -rf ../dailylog-common`，结果
•dailylog-common成功安装到本地库
•dailylog-web成功安装到本地库





$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar




●调用plugin
格式：
$ mvn groupId:artifactId:version:goal

我们知道，调用自定义的plugin时一般是通过mvn groupId:artifactId:version:goal这种固定格式来进行调用，例如我们调用spring-boot-maven-plugin的某个goal，命令为
mvn org.springframework.boot:spring-boot-maven-plugin:1.5.2.RELEASE:start，如果我们要通过别名来进行调用，比如mvn idea:clean命令，那么我们就必须在maven的settings.xml文件中的pluginGroups标签下加入我们自定义的plugin的groupId，如
<pluginGroups>  
       <pluginGroup>org.springframework.boot</pluginGroup>  
</pluginGroups>

一个工程，如果pom中未指定plugin包含spring-boot-maven-plugin，那么使用mvn spring-boot:repackage等命令进行打包的时候，不会去下载spring-boot-maven-plugin.jar文件，会提示找不到plugin即如下错误：
[ERROR] No plugin found for prefix 'spring-boot' in the current project and in the plugin groups [org.apache.maven.plugins, org.codehaus.mojo] available from the repositories [local (/Users/gaozengrong/repository), tbmirror (http://mvnrepo.alibaba-inc.com/mvn/repository), tbmirror-snapshots (http://mvnrepo.alibaba-inc.com/mvn/repository)
(原因：默认情况下Maven只会在org.apache.maven.plugins和org.codehaus.mojo两个groupId下搜索插件，所以我们要将插件的groupId放在Maven默认的插件搜寻范围之内。)
但是实际情况下，我们没有在settings.xml文件中加入spring-boot-maven-plugin的groupId，那么我们是如何通过别名来运行mvn spring-boot:repackage等命令的呢？
我们从仓库下载并解压spring-boot-maven-plugin-1.5.2.RELEASE.jar文件，找到它的pom文件(本质上spring-boot-maven-plugin也是一个maven工程)，发现pom中指定了属性<goalPrefix>spring-boot</goalPrefix>，既然指定了前缀，那么肯定可以通过mvn spring-boot来进行调用了。





C.pom.xml
0.内置变量
${project.xxx}                          # 当前pom文件的任意节点的内容
${project.groupId}                      # 项目的groupId
${project.artifactId}                   # 项目的artifactId
${project.packaging}                    # 打包类型，缺省为jar
${project.basedir}                      # 项目根目录，即包含pom.xml文件的目录
${basedir}                              # 同${project.basedir};
${project.version}                      # 表示项目版本
${version}                              # 项目的version，与${project.version} 等价
${project.parent.version}               # 聚合模块版本号
${maven.build.timestamp}                # 表示项目构件开始时间
${maven.build.timestamp.format}         # 表示属性${maven.build.timestamp}的展示格式，默认值为yyyyMMdd-HHmm，可自定义其格式，其类型可参考
${env.JAVA_HOME}                        # 表示JAVA_HOME环境变量的值
${user.home}                            # 表示用户目录


${project.build.directory}              # 构建目录，缺省为target
${project.build.outputDirectory}        # 构建过程输出目录，缺省为target/classes
${project.build.sourceDirectory}        # 主源码目录，默认为src/main/java
${project.build.scriptSourceDirectory   # 脚本目录，默认为src/main/scripts
${project.build.testSourceDirectory}    # 项目的测试源码目录，默认为src/test/java
${project.testOutputDirectory}          # 项目测试主代码输出目录，默认为target/testclasses
${project.build.finalName}              # 打包输出的文件名称，缺省为${project.artifactId}-${project.version}
${project.build.sourceEncoding}         # 表示主源码的编码格式


1.基本结构
D:\workspace>mvn archetype:generate -DgroupId=com.sogou.mavendemo -DartifactId=mavendemo-create2 -Dversion=1.0.0SNAPSHOT -Dpackage=mavendemo_create2
groupId         是帮助项目对象在仓库中定位的
artifactId      决定了生成的项目文件夹目录的名称
version         是项目版本号
package         是项目source文件下最顶层的包名

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 0.基本内容 -->
    <!-- 指定了当前POM的版本 -->
    <modelVersion>4.0.0</modelVersion>
    <!-- groupID是“项目组织”唯一的标识符，比如我的项目叫test001，那么GroupID应该是 com.lixiaoming.test001，即域名.公司名.项目名 -->
    <groupId>com.example</groupId>
    <!-- artifactID就是项目的唯一的标识符，一般是 项目名-xxx，比如test001-model -->
    <artifactId>springbootdemo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <!-- 项目打包方式 默认jar，可以是war jar pom zip -->
    <!-- 注意：如果是pom则该module不会被compile -->
    <packaging>jar</packaging>
    <name>round1</name>
    <description>Demo project for Spring Boot</description>

    <organization>
        <name>公司名称</name>
        <url>http://blog.csdn.net/u010475041</url>
    </organization>

    <developers>
        <developer>
            <name>York</name>
            <email>york@foxmail.com</email>
            <roles>
                <role>architect</role>
                <role>developer</role>
            </roles>
            <organization>开发者所属公司</organization>
        </developer>
    </developers>

    <!-- 父类依赖 -->
    <parent>
        <groupId>org.test</groupId>
        <artifactId>test-parent</artifactId>
        <version>1.0.0.Beta</version>
        <!-- 默认值是继承自../pom.xml 也就是Maven默认父pom在上一层目录下；<relativePath/>设定一个空值将始终从仓库中获取，不从本地路径获取 -->
        <!-- 查找顺序：relativePath元素中的地址–本地仓库–远程仓库，<relativePath/>设定一个空值将始终从仓库中获取，不从本地路径获取 -->
        <!-- 如果是设为<relativePath/>表示使用当前module下的pom.xml -->
        <relativePath>../pom.xml</relativePath>
    </parent>

    <!-- 父类依赖，spring boot 1.5.2，其中核心依赖：spring-boot-starter，包括自动配置，日志和yaml -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <moudules>
        <moudule>openapi1</moudule>
        <moudule>openapi2</moudule>
        <moudule>openapi3</moudule>
    </moudules>

    <properties>
        <!--“maven编码gbk的不可映射字符”解决办法 -->
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
        <!-- 可在application.properties中通过@nodex@引用该值 -->
        <nodex>xxxx</nodex>
        <!--
            This is a feature of Spring Boot. Main-Class defines that Spring Boot's org.springframework.boot.loader.JarLauncher class will be launched in a first step. In a second step, org.springframework.boot.loader.JarLauncher will launch the main method of the class that is given to the Start-Class property - in this case, com.xxx.Application.
        -->
        <start-class>com.xx.xx</start-class>
    </properties>

    <!-- 用于版本管理，仅仅是作了声明，并没有实际引用jar。被其他pom继承后，再<dependency>时可省略<version><scope> -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <...>
            </dependency>
            <!-- 导入dependencyManagement -->
            <dependency>
                <groupId />
                <artifactId />
                <version />
                <type>pom</type>
                <!-- 将此artifactId中的dependencyManagement导入到当前dependencyManagement中 -->
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <!-- 1.依赖项 -->
    <dependencies>
        <dependency>
            <groupId>taobao-sdk</groupId>
            <artifactId>taobao-sdk-java-auto</artifactId>
            <version>1.0</version>
        </dependency>

        <!-- spring boot的web依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- 排除依赖项中的依赖项 -->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <!--
              测试->编译->打包
              1. test：测试范围有效，不编译、打包
              2. compile：编译、打包范围有效，不测试（默认）
              3. provided依赖：在测试、编译的过程有效，不打包，诸如：servlet-api，因为servlet-api，tomcat等web服务器已经存在了，如果再打包会冲突 
              4. runtime：在运行的时候依赖，在编译的时候不依赖
              5. import：只能用在<dependencyManagement/>里面，且仅用于<type>pom</type>。自从maven 2.0.9，在<dependencyManagement>管理下的dependencies多了一种scope——import。这种scope仅用于type为"pom"的dependency，其意义为引入该dependency的pom中定义的所有dependency定义。
            -->
            <scope>test</scope>
            <!-- optional=true 表示依赖不会传递。devtools只对当前项目启用，而其他依赖该项目的项目，需要时需重新引入 -->
            <optional>true</optional>
        </dependency>

        <!-- 配置spring热部署之方式一：代码修改编译后1到2秒就会被重新加载，不过控制台没有log。但不支持增加class -->
        <!-- 这里需要注意的是每次类文件更改后需要重新编译方可触发服务重新启动 -->
        <!--
            spring.devtools.restart.enabled=true
            # 设置重启的目录
            spring.devtools.restart.additional-paths=src/main/java
            # 设置排除的目录
            spring.devtools.restart.exclude=WEB-INF/**
        -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>provided</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

★scope的分类
·compile
默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。
·test
scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。
·runtime
runtime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runtime。另外runtime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。
·provided
provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。
·system
从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合<systemPath>属性使用。


    <!-- 2.profile -->
    <profiles>
        <profile>
            <id>dev</id>
            <properties>
                <env>dev</env>
            </properties>
            <activation>
                <!-- 指明默认使用该profile -->
                <activeByDefault>true</activeByDefault>
                <!-- 根据项目中某个文件存在与否来决定是否激活profile -->
                <file>  
                    <missing>x.properties</missing>  
                    <exists>y.properties</exists>  
                </file>
                <!-- 根据操作系统类型激活 -->
                <os>
                    <!-- 不必指定所有信息 -->
                    <name>linux</name>
                    <family>unix</family>
                    <arch>amd64</arch>
                    <version>3.19.0-30-generic</version>
                </os>
                <!-- 根据jdk版本激活 -->
                <jdk>1.8</jdk>
            </activation>
        </profile>
        <profile>
            <id>prd</id>
            <properties>
                <env>prd</env>
            </properties>
        </profile>
    </profiles>

    <!-- 3.发起build操作时的行为：※放在外面表示全局build，也可放在profile中 -->
    <build>
        <finalName>springmvc2</finalName>
        
        <!-- 执行build任务时，如果没有指定目标，将使用的默认值。此配置：在命令行中执行mvn，则相当于执行mvn install -->
        <defaultGoal>install</defaultGoal>
        <!-- build目标文件的存放目录，默认在${basedir}/target目录 -->
        <directory>${basedir}/target</directory>
        <!-- build目标文件的名称，默认情况为${artifactId}-${version} -->
        <finalName>${artifactId}-${version}</finalName> 

        <!-- 指定filter（之后可在resource中通过<filtering>开启此功能）：定义在filter文件中的properties文件，resource中的配置文件中的${name}值会被“环境变量、pom中的properties、filter中的值”替代。maven的默认filter文件夹为${basedir}/src/main/filters -->
        <filters>
            <filter>resources/application-${spring.profiles.active}.properties</filter>
        </filters> 
        
        
        <!-- 将指定目录下的resource文件复制到classes根目录下 -->
        <resources>
            <!-- 将src/main/resources/dev这个文件夹下的所有的配置文件打包到classes根目录下 -->
            <resource>
                <directory>src/main/resources/${env}</directory>
            </resource>
            <!-- 不指明，默认是包括<directory/>下所有内容，可通过excludes进行排除 -->
            <!-- 多数情况下，使用<include>和<exclude>是为了配合<filtering>实现替换文件中的变量的需要，
                 若同一个<resource>内的<include>与<exclude>划定的范围存在冲突，则以<exclude>配置为准；
                 若多个<resource>内的<include>与<exclude>划定的范围存在冲突，则后面的会叠加掉前面的，
                 即，取两者的交集
            -->
            <resource>
                <directory>src/main/resources</directory>
                <filtering>false</filtering>
                <excludes>
                    <exclude>dev/*</exclude>
                    <exclude>prd/*</exclude>
                </excludes>
            </resource>
            <!-- 指定的目录也可以是非resources下面的 -->
            <resource>
                <directory>src/main/java</directory>
                <!-- 开启过滤，使用环境变量、pom文件里定义的属性和指定配置文件里的属性替换属性文件里的占位符${变量名称} -->
                <filtering>true</filtering>
                <includes>
                    <include>*.xml</include>
                    <include>**/*TestSuit.java</include>   <!-- 两个星号**用来匹配任意路径，一个星号*用来获取除路径风格符外的0个或多个字符 -->
                </includes>
            </resource>
            
            <resource>
                <!-- 定义resource文件所在位置，默认为${basedir}/src/main/resources -->
                <directory>${basedir}/src/main/plexus</directory>
                <!--
                    指定build后的resource存放位置，默认是basedir。
                    通常被打包在jar中的resources的目标路径是META-INF
                -->
                <targetPath>META-INF/plexus</targetPath>
                <filtering>true</filtering>
            </resource>
        </resources>

        <!--
            外层可加 <pluginManagement>，以被继承
        -->
        <pluginManagement>
            <plugins>
            </plugins>
        </pluginManagement>

        <!-- plugin -->
        <plugins>
            <!-- 插件，使用mvn进行打包，打包成一个jar文件 -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${springboot.version}</version>
                <!-- 是否可被继承：比如child使用parent标签继承其它的pom.xml，parent的pom.xml可以将插件的inherited设置为false，从而避免child继承某个插件。 -->
                <inherited>true</inherited>
                <configuration>
                    <mainClass>org.springframework.boot.loader.WarLauncher</mainClass>
                </configuration>
                <excludeGroupIds>
                    org.hibernate,net.bytebuddy,net.sourceforge.htmlunit,org.eclipse.jetty
                </excludeGroupIds>
                <excludes>
                    
                </excludes>
                
                
                <!-- 引入plugin所需要的依赖 -->
                <dependencies>
                    <!-- 配置spring热部署之方式二：JVM在运行中重新加载class -->
                    <!-- 如果不加，也可以配置VM option：“-javaagent:D:/springloaded-1.2.7.RELEASE.jar -noverify” -->
                    <!-- -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 -->
                    <dependency>
                        <groupId>org.springframework</groupId>
                        <artifactId>springloaded</artifactId>
                        <version>1.2.7.RELEASE</version>
                    </dependency>
                </dependencies>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <version>3.1.0</version>
                <configuration>
                    <warName>cas</warName>
                    <failOnMissingWebXml>false</failOnMissingWebXml>
                    <recompressZippedFiles>false</recompressZippedFiles>
                    <archive>
                        <compress>false</compress>
                        <manifestFile>
                            ${project.build.directory}/war/work/org.apereo.cas/cas-server-webapp-tomcat/META-INF/MANIFEST.MF
                        </manifestFile>
                    </archive>
                    <overlays>
                        <overlay>
                            <groupId>org.apereo.cas</groupId>
                            <artifactId>cas-server-webapp-tomcat</artifactId>
                            <!--<excludes>-->
                            <!--<exclude>WEB-INF/classes/services/*</exclude>-->
                            <!--<exclude>WEB-INF/classes/application.*</exclude>-->
                            <!--</excludes>-->
                        </overlay>
                    </overlays>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <!-- 指定远程仓库 -->
    <repositories>
        <!-- 示例：易鑫内部maven -->
        <repository>
            <!-- 远程仓库唯一标识符 -->
            <id>yixincapital</id>
            <name>yixincapital</name>
            <!-- 远程仓库url -->
            <url>http://192.168.145.246:8081/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <!-- 可选：快照版本库两个小时检查更新一遍，也可设为always（仅支持snapshots） -->
                <updatePolicy>interval:120</updatePolicy>
                <updatePolicy>always</updatePolicy>
            </snapshots>
        </repository>

        <!-- SpringBoot 官方Maven仓库 -->
        <repository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/libs-milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>

        <!-- 示例 -->
        <repository>
            <id>maven2-release</id>
            <url>http://uk.maven.org/maven2/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>
        <repository>
            <id>oss-snapshots</id>
            <url>http://repository.jboss.org/nexus/content/groups/public/</url>
            <snapshots>
                <enabled>true</enabled>
                <!-- 快照版本库两个小时检查更新一遍（仅支持snapshots） -->
                <updatePolicy>interval:120</updatePolicy>
            </snapshots>
        </repository>
    </repositories>

    <!-- 示例：镜像 -->
    <mirrors>
        <mirror>
            <id>nexus-osc</id>
            <name>Nexus osc</name>
            <url>http://maven.oschina.net/content/groups/public/</url>
            <mirrorOf>central</mirrorOf>
        </mirror>
    </mirrors>

    <!-- 示例：易鑫内部maven -->
    <distributionManagement>
        <repository>
            <id>nexus-release</id>
            <url>http://192.168.145.246:8081/nexus/content/repositories/releases/</url>
        </repository>
        <snapshotRepository>
            <id>nexus-snapshot</id>
            <url>http://192.168.145.246:8081/nexus/content/repositories/snapshots/</url>
        </snapshotRepository>
    </distributionManagement>

    <!-- 指定远程plugin仓库 -->
    <pluginRepositories>
        <pluginRepository>
            <id>spring-plugins</id>
            <name>spring-plugins</name>
            <url>http://repo.spring.io/plugins-release/</url>
        </pluginRepository>
    </pluginRepositories>

</project>




2.分模块讲解
◆plugin
http://maven.apache.org/plugins/index.html
（1）介绍
本地存放路径为：%本地仓库%\org\apache\maven\plugins

（2）相关概念
·lifecycle
lifecycle（生命周期），这是maven最高级别的的控制单元，它是一系列的phase组成，也就是说，一个生命周期，就是一个大任务的总称，不管它里面分成多少个子任务，反正就是运行一个lifecycle，就是交待了一个任务，运行完后，就得到了一个结果，中间的过程，是phase完成的，自己可以定义自己的lifecycle，包含自己想要的phase。
Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。

·phase
phase（阶段），可以理解为任务单元，lifecycle是总任务，phase就是总任务分出来的一个个子任务，但是这些子任务是被规格化的，它可以同时被多个lifecycle所包含，一个lifecycle可以包含任意个phase，phase的执行是按顺序的，一个phase可以绑定很多个goal，至少为一个，没有goal的phase是没有意义的。

1.1 clean生命周期
    pre-clean：执行清理前的工作；
    clean：清理上一次构建生成的所有文件；
    post-clean：执行清理后的工作
1.2 default生命周期
default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。
    validate
    initialize
    generate-sources
    process-sources
    generate-resources
    process-resources：复制和处理资源文件到target目录，准备打包；
    compile：编译项目的源代码；
    process-classes
    generate-test-sources
    process-test-sources
    generate-test-resources
    process-test-resources
    test-compile：编译测试源代码；
    process-test-classes
    test：运行测试代码；
    prepare-package
    package：打包成jar或者war或者其他格式的分发包；
    pre-integration-test
    integration-test
    post-integration-test
    verify
    install：将打好的包安装到本地仓库，供其他项目使用；
    deploy：将打好的包安装到远程仓库，供其他项目使用；
1.3 site生命周期
    pre-site
    site：生成项目的站点文档；
    post-site
    site-deploy：发布生成的站点文档

·goal
goal（目标），这是执行任务的最小单元，goal表示一个特定的任务，它可以绑定到任意个phase中，一个phase有一个或多个goal，goal也是按顺序执行的，一个phase被执行时，绑定到phase里的goal会按绑定的时间被顺序执行，不管phase己经绑定了多少个goal，你自己定义的goal都可以继续绑到phase中。

（3）常用plugin
<!-- ★maven-compiler-plugin -->
<!-- 可配置编译时的一些行为 -->
<plugin>
    <!-- 指定maven编译的jdk版本，如果不指定，maven3默认用jdk 1.5 maven2默认用jdk1.3 -->
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.1</version>
    <configuration>
        <!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中不能使用低版本jdk中不支持的语法)，会存在target不同于source的情况 -->
        <source>1.8</source>                                <!-- 源代码使用的JDK版本 -->
        <target>1.8</target>                                <!-- 需要生成的目标class文件的编译版本 -->
        <encoding>UTF-8</encoding>                          <!-- 字符集编码 -->
        <skipTests>true</skipTests>                         <!-- 跳过测试 -->
        <verbose>true</verbose> 
        <showWarnings>true</showWarnings>   
        <fork>true</fork>                                   <!-- 要使compilerVersion标签生效，还需要将fork设为true，用于明确表示编译版本配置的可用 -->
        <executable><!-- path-to-javac --></executable>     <!-- 使用指定的javac命令，例如：<executable>${JAVA_1_4_HOME}/bin/javac</executable> -->
        <compilerVersion>1.3</compilerVersion>              <!-- 指定插件将使用的编译器的版本 -->
        <meminitial>128m</meminitial>                       <!-- 编译器使用的初始内存 -->
        <maxmem>512m</maxmem>                               <!-- 编译器使用的最大内存 -->
        <compilerArgument>-verbose -bootclasspath ${java.home}\lib\rt.jar</compilerArgument>
                                                            <!-- 这个选项用来传递编译器自身不包含但是却支持的参数选项 -->
        <skip>true</skip>
    </configuration>
</plugin>

demo-0.0.1-SNAPSHOT.jar


<!-- ★spring-boot-maven-plugin -->
https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/maven-plugin/run-mojo.html
Spring Boot Maven plugin的5个Goals
·spring-boot:repackage，默认goal。在mvn package之后，再次打包可执行的jar/war，同时保留mvn package生成的jar/war为.origin
·spring-boot:run，运行Spring Boot应用
·spring-boot:start，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理
·spring-boot:stop，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理
·spring-boot:build-info，生成Actuator使用的构建信息文件build-info.properties


打包结构：
◆ spring-boot-maven-plugin 打包
com
  ∟yixin.crm.usedcar
               ∟UsedCarCRMCoreApplication.class
json
  ∟
META-INF
  ∟


◆ maven-jar-plugin 打包
BOOT-INF
      ∟classes
            ∟com.yixin.crm.usedcar
            ∟json
META-INF
      ∟maven
      ∟MANIFEST.MF
org



<!-- springboot的打包方式：
    https://docs.spring.io/spring-boot/docs/current/maven-plugin/usage.html 
    https://docs.spring.io/spring-boot/docs/current/maven-plugin/repackage-mojo.html
    https://docs.spring.io/spring-boot/docs/current/maven-plugin/repackage-mojo.html#layout
-->
<!-- 加入后打包时，会直接生成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行。默认继承spring-boot-starter-parent即会自动使用此plugin。 -->
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <mainClass>${start-class}</mainClass>

        <!-- 
          当时用spring-boot-maven-plugin插件时，Maven首先在package阶段打包生成*.jar文件；然后执行spring-boot:repackage重新打包，
          将之前的*.jar包重命名为*.jar.original，然后生成新的springboot的可执行jar包命名为*.jar文件，其目录结构与原jar包不同：
          ①原生jar包*.jar.original结构：
          /META-INF
          /com/a/b/c/...
          /lib
          
          ②springbootjar包*.jar结构：
          /META-INF
          /BOOT-INF/classes/com/a/b/c/
          /BOOT-INF/lib
          /org/springframework/boot/loader

          默认行为下，spring-boot-maven-plugin方式打出的springboot包，①是springboot结构，②带有Launcher启动器，且需在Start-Class中定义一个入口方法main(String[] args)，③将相关依赖包也打进了jar包。基于以上三点，spring-boot-maven-plugin打包出来的jar是不可被module直接依赖的：
          ·使用NONE选项，从springboot包中剔除JarLauncher，避免了②
          ·使用<includes><include><groupId>nothing</groupId><artifactId>nothing</artifactId></include></includes>，从springboot包中剔除了相关依赖，避免了③
          ※所以，要打成普通jar包，可有两种方式：
          第一种：通过<classifier>exec</classifier>方式打包，使用其中的*.jar，而不是*-exec.jar
          第二种：通过mvn package -Dspring-boot.repackage.skip=true，跳过repackage，只生成普通的*.jar
         -->

        <!-- 这种方式会阻止原生spring-boot-maven-plugin打包的重命名*.jar.original和*.jar的行为，而是在将原生包命名为*.jar后，将springboot包命名为*-exec.jar -->
        <classifier>exec</classifier>

        <!-- 常见启动方式有以下几种:
            <mainClass>org.springframework.boot.loader.JarLauncher</mainClass>
            <mainClass>org.springframework.boot.loader.WarLauncher</mainClass>
            <mainClass>org.springframework.boot.loader.PropertiesLauncher</mainClass>
        -->
        <!-- 将所有的依赖库打包，但是不打包Spring Boot的任何Launcher -->
        <!-- 默认行为下，module需存在一个入口方法main(String[] args)，否则打包时会报异常：repackage failed: Unable to find main class，指定此选项后，可不存在入口方法正常通过打包 -->
        <layout>NONE</layout>

        <!-- 将所有的依赖库打包（scope为provided的除外），但是不打包Spring Boot的任何Launcher -->
        <layout>MODULE</layout>

        <!-- 打成jar包（默认行为），Main-Class: org.springframework.boot.loader.JarLauncher -->
        <layout>JAR</layout>

        <!-- 打成war包，需要的servlet容器依赖位于WEB-INF/lib-provided，Main-Class: org.springframework.boot.loader.WarLauncher -->
        <layout>WAR</layout>

        <!-- 打成DIR，Main-Class: org.springframework.boot.loader.PropertiesLauncher -->
        <!--
            Launcher for archives with user-configured classpath and main class via a properties file. This model is often more flexible and more amenable to creating well-behaved OS-level services than a model based on executable jars. loader.path: a comma-separated list of directories (containing file resources and/or nested archives in *.jar or *.zip or archives) or archives to append to the classpath. BOOT-INF/classes,BOOT-INF/lib in the application archive are always used loader.main: the main method to delegate execution to once the class loader is set up. No default, but will fall back to looking for a Start-Class in a MANIFEST.MF, if there is one in ${loader.home}/META-INF.
            PropertiesLauncher会从其被启动加载路径的指定路径下：BOOT-INF/classes和BOOT-INF/lib，加载内部classes和lib，同时还提供了通过配置系统变量从外部加载classes和lib的能力。而默认的JarLauncher只能从其被启动加载路径的指定路径下：BOOT-INF/classes和BOOT-INF/lib，加载内部classes和lib。
            eg. java -Dloader.path=E:/tmp/test/lib -jar gps-server-1.0-SNAPSHOT.jar
            会从 gps-server-1.0-SNAPSHOT.jar(JarFileArchive)中的BOOT-INF/classes和BOOT-INF/lib 加载，同时还从loader.path指定位置加载
            ※如果要打成依赖包分离的形式，需要此选项，到jar包外部去寻找需要的类文件，否则会找不到很多jar包，如java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext
         -->
        <layout>ZIP</layout>

        <!-- 将 src/main/resources 内的内容添加到 classpath。 -->
        <addResources>true</addResources>

        <!-- 跳过，可不生成BOOT-INF目录 -->
        <skip>true</skip>

        <includes> 
            <!-- lib/下不打包任何依赖 -->
            <include>
                <groupId>nothing</groupId>
                <artifactId>nothing</artifactId>
            </include>
            <!-- 只打包 -->
            <include>
                <groupId>non-exists</groupId>
                <artifactId>non-exists</artifactId>
            </include>
        </includes>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>repackage</goal>
            </goals>
        </execution>
    </executions>

</plugin>
----------------------------------------------------
普通MANIFEST.MF
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: com.example.springbootmaster.SpringbootmasterApplication
----------------------------------------------------
加<layout>NONE</layout>的MANIFEST.MF
Main-Class: com.example.springbootmaster.SpringbootmasterApplication
----------------------------------------------------

<!-- 指定Main-Class，方式一：通过继承spring-boot-starter-parent -->
<properties>
    <!-- The main class to start by executing java -jar -->
    <start-class>com.company.xxx</start-class>
</properties>

<!-- 指定Main-Class，方式二：显式声明spring-boot-maven-plugin -->
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <mainClass>com.company.xxx</mainClass>
    </configuration>
</plugin>


maven-jar-plugin方式打包的jar包目录结构为：
•  ├── com
•  │ └── example
•  │    └── SpringBootDemoApplication.class
•  ├── lib
•  │ ├── aopalliance-1.0.jar
•  │ ├── spring-beans-4.2.3.RELEASE.jar
•  │ ├── ...
•  ├── META-INF
•  │ ├── maven
•  │ └── MANIFEST.MF
•  ├── application.properties
•  └── org
•     └── springframework
•        └── boot
•           └── loader
•              ├── ExecutableArchiveLauncher.class
•              ├── JarLauncher.class
•              ├── JavaAgentDetector.class
•              ├── LaunchedURLClassLoader.class
•              ├── Launcher.class
•              ├── MainMethodRunner.class
•              ├── ... 




spring-boot-maven-plugin方式打包的jar包目录结构为：
•  ├── BOOT-INF
•  │ └── classes  
•  │    └── com.example
•  │       ├── SpringBootDemoApplication.class
•  │       └── lib
•  │          ├── aopalliance-1.0.jar
•  │          ├── spring-beans-4.2.3.RELEASE.jar
•  │          ├── ...
•  ├── META-INF
•  │ ├── maven
•  │ └── MANIFEST.MF
•  ├── application.properties
•  └── org
•     └── springframework
•        └── boot
•           └── loader
•              ├── ExecutableArchiveLauncher.class
•              ├── JarLauncher.class
•              ├── JavaAgentDetector.class
•              ├── LaunchedURLClassLoader.class
•              ├── Launcher.class
•              ├── MainMethodRunner.class
•              ├── ... 



·MANIFEST.MF
•  Manifest-Version: 1.0
•  Start-Class: com.example.SpringBootDemoApplication
•  Implementation-Vendor-Id: com.example
•  Spring-Boot-Version: 1.3.0.RELEASE
•  Created-By: Apache Maven 3.3.3
•  Build-Jdk: 1.8.0_60
•  Implementation-Vendor: Pivotal Software, Inc.
•  Main-Class: org.springframework.boot.loader.JarLauncher

                        <manifestEntries>
                            <Project-name></Project-name>
                            <Project-version></Project-version>
                            <Premain-Class></Premain-Class>
                            <Can-Redefine-Classes></Can-Redefine-Classes>
                        </manifestEntries>

•  Project-name1                   项目名称
•  Premain-Class                   agent启动类
•  Can-Redefine-Classes     false  是否允许重新定义class
•  Can-Retransform-Classes  false  是否允许重置Class，重置后相当于class从classLoader中清除，下次有需要的时候会重新装载，也会重新走Transformer流程。
•  Boot-Class-Path                 agent所依赖的jar路径。多个用空格分割






★★★
Q：如果spring-boot项目，打包成可执行jar，项目内有两个带有main方法的类并且都使用了@SpringBootApplication注解（或者另一种情形：你有两个main方法并且所在类都没有使用@SpringBootApplication注解），便会提示：
    org.springframework.boot:spring-boot-maven-plugin:2.0.3.RELEASE:repackage failed: Unable to find main class
A：但是，其实在打好的jar包中，其中的 MANIFEST.MF文件，可以发现 Main-Class 指定的值是 org.springframework.boot.loader.JarLauncher，而 Start-Class 指向的才是我们的 Application 这个class，即我们的主类。

如果你的pom继承自spring-boot-starter-parent（注意此前提），也可以直接在<properties>配置<start-class>，直接指定mainClass。
<properties>
    <start-class>com.xx.webapps.api.main.WebappsApiBidMain</start-class>
</properties>



demo-0.0.1-SNAPSHOT.jar.original
<!-- ★maven-jar-plugin -->
<!-- maven默认打包plugin，只可将本项目编译后的内容打成jar包，不能将相关的依赖包打入其中。可以设定manifest的行为，如Main-class、Class-Path -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>3.0.2</version>
    <executions>
        <execution>
            <!-- 显式指明使用原jar包名称进行打包 -->
            <id>default-jar</id>
            <phase>package</phase>
            <goals>
                <goal>jar</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <!--
            如果配置了<goal>jar</goal>，会出现以上提示：You have to use a classifier to attach supplemental artifacts to the project
            此时，需指定<classifier/>，以额外生成名称类似deploy-0.0.1-SNAPSHOT-bak.jar的jar包。除非指定了<id>default-jar</id>。
        -->
        <classifier>aio</classifier>
        <!-- 可选：显式指定要打包的class所在目录 -->
        <classesDirectory>${project.basedir}/target/classes</classesDirectory>
        <!-- 打包行为。默认生成jar包格式：<artifactId>-<version>，如helloword-0.0.1-SNAPSHOT -->
        <archive>
            <!-- 配置jar包内META-INF/MANIFEST.MF文件的内容 -->
            <manifest>
                <addClasspath>true</addClasspath>
                <!-- 在MANIFEST.MF中添加Class-Path项，如Class-Path: /lib/sqljdbc4-4.0.jar -->
                <classpathPrefix>/lib</classpathPrefix>
                <!-- 在MANIFEST.MF中添加Main-Class项，如Main-Class: com.art.Main -->
                <mainClass>com.zhang.spring.App</mainClass>
            </manifest>
            <!-- 可选：是否压缩 -->
            <compress>false</compress>
            
            <!-- 或者使用自定义MANIFEST.MF -->
            <manifestFile>src/main/resources/META-INF/MANIFEST.MF</manifestFile>
        </archive>
        <!-- 排除，※以编译结果classes为根目录 -->
        <excludes>
            <!--注意这玩意从编译结果目录开始算目录结构-->
            <exclude>/*.properties</exclude>
            <exclude>/*.xml</exclude>
        </excludes>
    </configuration>
</plugin>



<!-- ★maven-resources-plugin -->
<!-- 资源配置 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-resources-plugin</artifactId>
            <executions>
                <execution>
                    <id>dev</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>copy-resources</goal>
                    </goals>
                    <configuration>
                        <!-- 覆盖原有文件 -->
                        <overwrite>true</overwrite>
                        <!-- 继承springboot的spring-boot-starter-parent包，会将resources下的application.properties中默认的${*}方式修改成@*@，通过以下插件配置可将改回${*}的形式 -->
                        <!-- 因为application.yaml属于springboot范畴，pom.xml属于maven范畴。因此，在.java中读取的当前环境是根据application.yaml的spring.profiles.active确定，而不是根据pom.xml中的${profiles.active}，但可以通过在application.yaml中设定spring.profiles.active=@profiles.active@的方式，将此值从pom.xml传递到application.yml -->
                        <delimiters>
                            <delimiter>${*}</delimiter>
                        </delimiters>
                        <useDefaultDelimiters>false</useDefaultDelimiters>
                        <!-- 或者 -->
                        <useDefaultDelimiters>true</useDefaultDelimiters>
                        <!--
                            或者自定义以覆盖默认的占位符风格
                            <properties><resource.delimiter>${}</resource.delimiter></properties>
                        -->
                        
                        <outputDirectory>src/main/resources</outputDirectory>
                        <resources>
                            <resource>
                                <directory>src/main/resources/</directory>
                                <filtering>true</filtering>
                            </resource>
                        </resources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>





<!-- ★maven-dependency-plugin -->
<!-- 用于复制依赖的jar包到指定的文件夹里 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>2.10</version>
    <executions>
        <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
            <configuration>
                <outputDirectory>${project.build.directory}/lib</outputDirectory>
                <!-- 表示是否不包含间接依赖的包 -->
                <excludeTransitive>false</excludeTransitive>
                <!-- 表示复制的jar文件去掉版本信息 -->
                <stripVersion>true</stripVersion>
            </configuration>
        </execution>
    </executions>
</plugin>
命令行形式：
mvn dependency:copy-dependencies -DoutputDirectory=C:\Users\lwn\Desktop\tt\lib  -DincludeScope=runtime  



<!-- ★maven-assembly-plugin -->
<!-- 支持定制化打包：http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html -->
<plugin>
    <artifactId>maven-assembly-plugin</artifactId>
    <version>2.6</version>
    <executions>
        <execution>
            <id>make-zip</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>

            <configuration>
                <finalName>${project.name}</finalName>
                <descriptors>
                    <!-- 指定打包配置文件，在该配置文件内指定打包操作 -->
                    <descriptor>${project.basedir}/src/main/assembly/assembly.xml</descriptor>
                </descriptors>
                <!-- 将项目依赖包和项目打为一个包 -->
                <descriptorRefs>
                     <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
                <archive>
                    <!-- 定义主类，即main-class -->
                    <manifest>
                        <mainClass>com.xxg.Main</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </execution>
    </executions>
</plugin>


·assembly.xml
<assembly>
  <!-- 默认打出来的包文件名是${project.build.finalName}-${assembly.id}.jar -->
  <id>${activeProfile}</id>
  <!-- 打包格式 -->
  <formats>
      <format>dir</format>
      <format>tar.gz</format>
      <format>tar.gz2</format>
      <format>tar</format>
      <format>jar</format>
      <format>war</format>
      <format>zip</format>
  </formats>
  <!-- 当includeBaseDirectory为true时候，prefix为artifact的finalName，如果为false，则设置为""，而这个finalName就是分发包的最外层。所以，当我们吧includeBaseDirectory设置为false，就没有包装层了 -->
  <!-- 是否打包到压缩包下和项目名相同的根目录 -->
  <includeBaseDirectory>false</includeBaseDirectory>
  <fileSets>
    <fileSet>
      <directory>${project.basedir}</directory>
      <outputDirectory>/</outputDirectory>
      <includes>
        <include>README*</include>
        <include>application.yml</include>
        <include>application-${activeProfile}.yml</include>
      </includes>
    </fileSet>
    <fileSet>
      <directory>${project.build.directory}</directory>
      <outputDirectory>/</outputDirectory>
      <includes>
        <include>*.jar</include>
      </includes>
    </fileSet>
    <fileSet>
        <directory>${project.basedir}/src/main/scripts</directory>
        <outputDirectory>/bin</outputDirectory>
        <includes>
            <include>startup.sh</include>
        </includes>
        <!-- 指定文件权限 -->
        <fileMode>755</fileMode>
        <!-- 过滤文件中的maven变量为maven值 -->
        <filtered>true</filtered>
    </fileSet>
  </fileSets>
  <files>
    <file>
      <source>README.txt</source>
      <outputDirectory>/</outputDirectory>
      <destName>README.txt</destName>
    </file>
  </files>

  <!-- 添加依赖：把项目依赖的所有包都打包输出到某个路径(本例中为lib目录) -->！！！！！！！！！
  <dependencySets>
      <dependencySet>
          <!--是否把本项目添加到依赖文件夹下-->
          <useProjectArtifact>false</useProjectArtifact>
          <outputDirectory>lib</outputDirectory>
          <!-- 包含依赖 -->
          <includes>
            <include>..</include>
          </includes>
          <!-- 排除依赖 -->
          <excludes>
            <exclude>..</exclude>
          </excludes>
      </dependencySet>
  </dependencySets>
</assembly>





<!-- ★maven-shade-plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>2.4.3</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <filters>
                    <filter>
                        <artifact>*:*</artifact>
                        <excludes>
                            <exclude>META-INF/*.SF</exclude>
                            <exclude>META-INF/*.DSA</exclude>
                            <exclude>META-INF/*.RSA</exclude>
                        </excludes>
                    </filter>
                </filters>
                <transformers>
                    <transformer
                            implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                        <resource>META-INF/spring.handlers</resource>
                    </transformer>
                    <transformer
                            implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                        <resource>META-INF/spring.schemas</resource>
                    </transformer>
                    <transformer
                            implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                        <resource>META-INF/spring.tooling</resource>
                    </transformer>
                    <transformer
                            implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                        <mainClass>com.xxx.xxxInvoke</mainClass>
                    </transformer>
                </transformers>
                <minimizeJar>true</minimizeJar>
                <shadedArtifactAttached>true</shadedArtifactAttached>
            </configuration>
        </execution>
    </executions>
</plugin>




<!-- ★maven-antrun-plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-antrun-plugin</artifactId>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>run</goal>
            </goals>
            <configuration>
                <target>
                    <property name="dist">target/distribution</property>
                    <property name="dist-tmp">target/distribution/tmp</property>
                    <property name="app-name">${project.artifactId}-${project.version}</property>
                    <mkdir dir="${dist-tmp}" />
                    <copy file="target/${app-name}.jar" tofile="${dist-tmp}/${app-name}.jar" />
                    <unzip src="${dist-tmp}/${app-name}.jar" dest="${dist-tmp}" />
                    <delete file="${dist-tmp}/${app-name}.jar" />

                    <zip destfile="${dist}/${app-name}-pages.jar">
                        <zipfileset dir="${dist-tmp}/META-INF" prefix="META-INF" />
                        <zipfileset dir="target/classes/static" prefix="static" />
                        <zipfileset dir="target/classes/templates" prefix="templates" />
                    </zip>

                    <move file="target/${app-name}-classes.jar" todir="${dist}" />
                    <move todir="${dist}/3rd-lib">
                        <fileset dir="target/lib" />
                    </move>

                    <delete dir="${dist-tmp}" />

                    <copy todir="${dist}">
                        <fileset dir="target/classes">
                            <include name="**/*.properties" />
                            <include name="**/*.xml" />
                            <include name="**/*.yml" />
                        </fileset>
                    </copy>
                </target>
            </configuration>
        </execution>
    </executions>
</plugin>






<!-- ★maven-surefire-plugin -->
<!-- 在构建执行到特定生命周期阶段的时候，通过插件来执行JUnit或者TestNG的测试用例。默认情况下，surefire会执行文件名以Test开头或结尾的测试用例，或者是以TestCase结尾的测试用例。
    这组模式为：
    **/Test*.java：任何子目录下所有命名以Test开关的Java类。
    **/*Test.java：任何子目录下所有命名以Test结尾的Java类。
    **/*TestCase.java：任何子目录下所有命名以TestCase结尾的Java类。
 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.5</version>
    <dependencies>
        <dependency>
            <groupId>org.apache.maven.surefire</groupId>
            <artifactId>surefire-junit47</artifactId>
            <version>2.19</version>
        </dependency>
    </dependencies>
    <configuration>
        <includes>
            <include>**/*Tests.java</include>
        </includes>
        <excludes>
            <exclude>**/*ServiceTest.java</exclude>
            <exclude>**/TempDaoTest.java</exclude>
        </excludes>
        <!-- 很多情况下我们希望测试用例没有失败的才能打包,如果出现打包失败,需要立刻停止执行其他测试用例.为满足这个要求,我们需要增加一些配置设定 -->
        <skipAfterFailureCount>1</skipAfterFailureCount>
        <!-- 当我们的一个测试用例测试的是一个远程服务,在某些情况下可能由于环境问题(比如网络)导致测试用例执行失败,但这并不是程序问题.换句话说,当一个测试用例执行N次,有一次执行成功就认为成功.这个时候我们就需要配置一个参数,运行执行失败的此时用例重新执行 -->
        <rerunFailingTestsCount>1</rerunFailingTestsCount>
    </configuration>
</plugin>


<!-- ★maven-deploy-plugin -->
<!-- 主要用来将artifactId部署到远程库 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-deploy-plugin</artifactId>
    <version>2.8.2</version>
    <configuration>
        <skip>true</skip>
    </configuration>
</plugin>


<!-- ★docker-maven-plugin -->
<!-- 采用插件一步打包发布本地的Maven项目为远程主机的Docker镜像，之前的docker-maven-plugin已经被废弃， dockerfile-maven-plugin是其替代，我们将采用最新的dockerfile-maven-plugin插件 -->
<plugin>
    <groupId>com.spotify</groupId>
    <artifactId>docker-maven-plugin</artifactId>
    <version>1.0.0</version>
    <configuration>
        <!-- 指定镜像的唯一标志,这里使用maven的groupId和artifactId来设定 -->
        <imageName>192.168.1.10:5000/${project.groupId}/${project.artifactId}:latest</imageName>
        <!-- 指定镜像的父类镜像，这里指定的是java8的镜像 -->
        <baseImage>192.168.1.10:5000/org.itkk/java:8</baseImage>
        <maintainer>wangkangit@163.com</maintainer>
        <exposes>${server.port}</exposes>
        <cmd></cmd>
        <entryPoint>["java","-jar","/${project.build.finalName}.jar"]</entryPoint>
        <resources>
            <resource>
                <directory>${project.build.directory}</directory>
                <include>${project.build.finalName}.jar</include>
            </resource>
        </resources>
    </configuration>
</plugin>




3.继承与聚合
※当多个module中都存在pom.xml时，各自的module的pom.xml都生效。
※当多个module中都存在application.properties时，只有当前编译的module的application.properties生效。

◆继承
·pom.xml(aggregator-module)
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.test</groupId>
    <artifactId>aggregator-module</artifactId>
    <version>1.0.0.Beta</version>

    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>15.0</version>
        </dependency>
    </dependencies>
</project>


·pom.xml(sub-module)
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 在此继承 -->
    <parent>
        <groupId>org.test</groupId>
        <artifactId>aggregator-module</artifactId>
        <version>1.0.0.Beta</version>
        <relativePath>../pom.xml</relativePath>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>sub-module</artifactId>
</project>

◆聚合
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.test</groupId>
    <artifactId>aggregator-module</artifactId>
    <version>1.0.0.Beta</version>

    <modules>
        <module>sub-module</module>
    </modules>
</project>


★聚合与继承的关系
（1）聚合主要是为了方便快速构建项目，继承主要是为了消除重复配置；
（2）对于聚合模块而言，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在；对于继承的父pom而言，它不知道有哪些子模块继承它，但那些子模块都知道自己的父POM是什么；
（3）聚合POM与继承中的父POM的packaging都必须是pom；同时，聚合模块与继承中的父模块除了POM外，都没有实际的内容。
※并不是parent-module有<modules>，sub-module就必须通过<parent>引用parent-module，因为这种依赖关系有可能是单向的。例如：一个mybatis-generator的module需要parent于一个parent-module，但parent-module并不需要这个mybatis-generator，因为mybatis-generator只是一个辅助的代码生成工具，并非项目本身的需求。



4.依赖传递
（1）在工程的依赖树上，深度越浅，越被有限选择。
（2）若两个依赖包处于依赖树上的同一层，则谁在前选择谁。




D.maven的各种第三方依赖配置
1.mysql
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 指定了当前POM的版本 -->
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
      </dependency>
      <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
      </dependency>
    </dependencies>
</project>



E.部署
1.springboot部署jar包
Step 1:
# 可通过application.properties对部署配置进行修改：
# EMBEDDED SERVER CONFIGURATION (ServerProperties)
# 服务器对外暴露端口，默认为8080
server.port=8010

# 对外暴露地址，这样启动项目通过http://localhost:8080/helloboot即可访问到项目
server.context-path=/helloboot
# springboot2
server.servlet.context-path=/helloboot

# 该服务绑定IP地址，启动服务器时如本机不是该IP地址则抛出异常启动失败，只有特殊需求的情况下才配置
#server.address=192.168.16.11

# session最大超时时间(分钟)，默认为30
server.session-timeout=60


# 错误页：指定发生错误时，跳转的URL。请查看BasicErrorController。
server.error.path=/error

# tomcat最大线程数，默认为200。当应用部署在docker中时，由于多个容器共享了系统内核，当宿主机为高数量核心服务器时，会开启大量线程，可通过此设置控制开启的线程数
server.tomcat.max-threads=0

# tomcat的URI编码
server.tomcat.uri-encoding=UTF-8

# 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹（如：C:\Users\Angel\AppData\Local\Temp）
server.tomcat.basedir=target/tomcat

# 日志文件目录
logging.path=H:/springboot-tomcat-tmp

# 日志文件名称，默认为spring.log
logging.file=myapp.log

Step 2:
pom.xml
<project>
    <packaging>jar</packaging>
</project>

Step 3:
双击Maven projects/Lifecycle/package生成jar包
or
用命令行生成jar包：mvn clean package -Dmaven.test.skip=true

Step 4:
java -jar xxx.jar --spring.profiles.active=prod
java -jar xxx.jar -Dspring.config.location=application.properties
nohup java -jar xxx.jar &

¤自定义端口不能小于1024，因为这部分端口已被系统征用
According to w3.org doc ports below 1024 are priviledged on Linux. Only root can bind to such ports. You should either use ports >1024 or run under root account (not recommended).

¤不能部署为war包，Tomcat7里面为防止内存泄漏的机制
严重: The web application [/ssm] registered the JDBC driver [com.alibaba.druid.proxy.DruidDriver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered.







2.springmvc部署war/war exploded
Step 1:
pom.xml
<project>
    <packaging>war</packaging>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>4.3.13.RELEASE</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>4.3.13.RELEASE</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <version>3.0.0</version>
                <configuration>
                    <!-- 可选，排除部分.class文件 -->
                    <!-- 在Maven中使用maven-war-plugin插件打war包，但有时会将classes文件另外打成jar包，classes文件不再需要，可将它从war包中去除 -->
                    <packagingExcludes>WEB-INF/classes/**/**</packagingExcludes>
                    <!-- 二者选其一 -->
                    <!-- 1.配置WEB资源 -->
                    <webResources>
                        <!-- 指定WebContent/WEB-INF/web.xml文件所在目录 -->
                        <resource>
                            <!- 即web\WEB-INF, web\index.jsp, web\applicationContext.xml, web\dispatcher-servlet.xml, web\web.xml等文件所在的目录 ->
                            <directory>web</directory>
                        </resource>
                        <!-- 可选，排除部分资源 -->
                        <excludes>
                            <exclude>**/**</exclude>
                        </excludes>
                    </webResources>
                    <!-- 2.如果WebContent/WEB-INF/web.xml文件不存在 -->
                    <failOnMissingWebXml>false</failOnMissingWebXml>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

Step 2:
和编译jar一样，mvn clean package -Dmaven.test.skip=true，会在.\target下生成war文件

Step 3:
（1）将war包放入tomcat\webapps 目录下
（2）tomcat的conf目录下server.xml文件<Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true">节点下添加：<Context path="/springmvcsample" docBase="D:\Program Files\Code\apache-tomcat-9.0.5\webapps\springmvcsample_war_exploded" reloadable="true" />
（3）输入“startup.bat”或“service install Tomcat9”，启动tomcat

Step 4:
访问：
http://localhost:8080/springmvcsample/






3.springboot部署war
Step 1:
pom.xml
<project>
    <packaging>war</packaging>
    <dependencies>
        <!-- 排除tomcat -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- 移除tomcat插件 -->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!-- 或替换为以下：构建一个即是可执行的，又能部署到一个外部容器的war文件，你需要标记内嵌容器依赖为"provided" -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
        </dependency>
        
        <!-- 或替换为以下：undertow容器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-undertow</artifactId>
            <scope>provided</scope>
        </dependency>
        
        <!-- 移除之后会报错，加入下面的依赖 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- 移除之后会报错，加入jetty -->
        <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>
    </dependencies>

</project>


Step 2:
修改SpringBootApplication启动类
@SpringBootApplication
// ★加SpringBootServletInitializer继承类
public class SpringbootdemoApplication extends SpringBootServletInitializer {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootdemoApplication.class, args);
    }

    // ★重写configure方法
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        // TODO Auto-generated method stub
        //return super.configure(builder);
        return builder.sources(this.getClass());
    }
}

Step 3:
和编译jar一样，mvn clean package -Dmaven.test.skip=true，会在.\target下生成war文件

Step 4:
（1）将war包放入tomcat\webapps 目录下
（2）tomcat的conf目录下server.xml文件<Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true">节点下添加：<Context path="/springmvcsample" docBase="D:\Program Files\Code\apache-tomcat-9.0.5\webapps\springmvcsample_war_exploded" reloadable="true" />
（3）输入“startup.bat”或“service install Tomcat9”，启动tomcat













D.idea中的maven
通过Maven Projects窗口/Reimport All Maven Projects，会自动引入并下载 taobao-sdk/taobao-sdk-java-auto/1.0/taobao-sdk-java-auto-1.0.jar



E.私有仓库
maven中的仓库分为两种，snapshot快照仓库和release发布仓库：
·snapshot：快照仓库，适用于保存开发过程中的不稳定版本，在mvn deploy时会自动发布到快照版本库中，会覆盖老的快照版本。在不修改版本号时，默认情况下，编译打包时maven会自动从镜像服务器上下载最新的快照版本。
·release：正式仓库，适用于保存稳定的发行版本，在mvn deploy时会自动发布到正式版本库中，会覆盖老的正式版本。在不修改版本号时，默认情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。

定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写)，如：
<project>
    <groupId>org.quinn</groupId>  
    <artifactId>accounts</artifactId>  
    <version>0.0.1-SNAPSHOT</version>  
    <packaging>jar</packaging> 
</project>
maven


·pom.xml
    <!-- 分为三种：repositories、distributionManagement 和 pluginRepositories -->
    <!-- repositories：指定库文件的下载库地址 -->
    <repositories>
        <repository>
            <id>public-bak</id>
            <url>http://192.168.145.246:8081/nexus/content/repositories/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <!-- always(实时更新)   daily（每天更新）   interval:xxx（隔xxx分钟更新一次）   never（从不更新）   默认为daily  -->
                <updatePolicy>interval:30</updatePolicy>
                <!-- 
                    如果设为always，则在每次编译时，都会提示下载
                    Downloading: http://192.168.145.246:8081/nexus/content/repositories/public/com/york/portable/swiss/1.1.3-SNAPSHOT/maven-metadata.xml
                    Downloaded: http://192.168.145.246:8081/nexus/content/repositories/public/com/york/portable/swiss/1.1.3-SNAPSHOT/maven-metadata.xml (772 B at 3.0 KB/sec) 
                 -->
            </snapshots>
        </repository>
    </repositories>

    <!-- distributionManagement：指定库文件的上传库地址 -->
    <distributionManagement>
        <repository>
            <id>nexus-release</id>
            <url>http://192.168.145.246:8081/nexus/content/repositories/releases/</url>
        </repository>
        <snapshotRepository>
            <id>nexus-snapshot</id>
            <url>http://192.168.145.246:8081/nexus/content/repositories/snapshots/</url>
        </snapshotRepository>
    </distributionManagement>

    <!-- pluginRepositories：指定插件的下载库地址 -->
    <pluginRepositories>
        <pluginRepository>
            <id>spring-plugins</id>
            <name>spring-plugins</name>
            <url>http://repo.spring.io/plugins-release/</url>
        </pluginRepository>
    </pluginRepositories>



·maven3/conf/setting.xml
<!-- 不加会提示Return code is: 401, ReasonPhrase:Unauthorized. 注意：id要与pom.xml中对应 -->
<servers>
    <server>
      <id>nexus-release</id>
      <username>public</username>
      <password>public</password>
    </server>
    <server>
      <id>nexus-snapshot</id>
      <username>public</username>
      <password>public</password>
    </server>
</servers>









Q.
1.
Q：dependency为什么会有type为pom，默认的值是什么？
A：dependency中type默认为jar即引入一个特定的jar包。那么为什么还会有type为pom呢?当我们需要引入很多jar包的时候会导致pom.xml过大，我们可以想到的一种解决方案是定义一个父项目，但是父项目只有一个，也有可能导致父项目的pom.xml文件过大。这个时候我们引进来一个type为pom，意味着我们可以将所有的jar包打包成一个pom，然后我们依赖了pom，即可以下载下来所有依赖的jar包

Q：Maven编译时候报错，并且pom.xml文件也报错Cannot create resource output directory 路径名
A：我按照后面路径找下去(targer/classes)发现classes文件夹打不开，删除也删除不掉，说删除文件需要adminpc权限，于是更改成管理员权限，删除文件夹，重新打包即可。


Z.market
http://download.eclipse.org/mpc/indigo/
http://download.eclipse.org/mpc/luna/
http://download.eclipse.org/mpc/mars/




九十六、常用工具
1.retrofit

2.okhttp

3.BeanUtils
·pom.xml
<!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils -->
<dependency>
    <groupId>commons-beanutils</groupId>
    <artifactId>commons-beanutils</artifactId>
    <version>1.9.3</version>
</dependency>

·Test.java
public class Test {
    public void todo() {
        String typeName = People.class.getTypeName();
        Class clazz = Class.forName(typeName);
        Object people = clazz.newInstance();
        ConvertUtils.register(new DateLocaleConverter(), java.util.Date.class);
        /*
         * org.apache.commons.beanutils.BeanUtils
         * /
        // setProperty
        BeanUtils.setProperty(people, "age", 18);
        Integer age = BeanUtils.getProperty(people, "age");
        People target1 = new People();

        // Bean -> Bean
        BeanUtils.copyProperties(target1, people);

        // Bean -> Map
        Map<String, String> map = new HashMap<String, String>();
        map = BeanUtils.describe(target1);

        // Map -> Bean
        map.put("age", "10");
        BeanUtils.populate(target1, map);

        /*
         * org.springframework.beans.BeanUtils
         * /
        People target2 = new People();
        BeanUtils.copyProperties(people, target1);
    }
}

4.net.sf.cglib.beans.BeanCopier
// net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter)


九十七、jwt
A.介绍


B.

C.
·pom.xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.1.0</version>
</dependency>




·JWTToken
public class JWTToken {
    public static String createToken() throws Exception {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("alg", "HS256");
        map.put("typ", "JWT");
        String token = JWT.create()
                .withHeader(map)                        // header
                .withClaim("name", "zwz")               // payload
                .withClaim("age", "18")
                .sign(Algorithm.HMAC256("secret"));     // 加密
        return token;
    }

    public static void verifyToken(String token, String key) throws Exception {
        JWTVerifier verifier = JWT.require(Algorithm.HMAC256(key))
                .build();
        DecodedJWT jwt = verifier.verify(token);
        Map<String, Claim> claims = jwt.getClaims();
        Claim claim = claims.get("name");
        System.out.println(claim.asString());
    }

}



E.例
public class TokenUtils {
    private Logger logger = LoggerFactory.getLogger(this.getClass());
    /**
     * 签名秘钥
     */
    public static final String SECRET = "token";

    /**
     * 生成token
     * @param id 一般传入userName
     * @return
     */
    public static String createJwtToken(String id){
        String issuer = "";
        String subject = "";
        long ttlMillis = 30*60*1000; 
        return createJwtToken(id, issuer, subject, ttlMillis);
    }

    /**
     * 生成Token
     * 
     * @param id
     *            编号
     * @param issuer
     *            该JWT的签发者，是否使用是可选的
     * @param subject
     *            该JWT所面向的用户，是否使用是可选的；
     * @param ttlMillis
     *            签发时间
     * @return token String
     */
    public static String createJwtToken(String id, String issuer, String subject, long ttlMillis) {

        // 签名算法 ，将对token进行签名
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        // 生成签发时间
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);

        // 通过秘钥签名JWT
        byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(SECRET);
        Key signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());

        // Let's set the JWT Claims
        JwtBuilder builder = Jwts.builder().setId(id)
            .setIssuedAt(now)
            .setSubject(subject)
            .setIssuer(issuer)
            .signWith(signatureAlgorithm, signingKey);
        
        // if it has been specified, let's add the expiration
        if (ttlMillis >= 0) {
            long expMillis = nowMillis + ttlMillis;
            Date exp = new Date(expMillis);
            builder.setExpiration(exp);
        }

        // Builds the JWT and serializes it to a compact, URL-safe string
        return builder.compact();

    }

    // Sample method to validate and read the JWT
    public static Claims parseJWT(String jwt) {
        // This line will throw an exception if it is not a signed JWS (as expected)
        Claims claims = Jwts.parser()
            .setSigningKey(DatatypeConverter.parseBase64Binary(SECRET))
            .parseClaimsJws(jwt).getBody();
        return claims;
    }

    public static void main(String[] args) {
        System.out.println(TokenUtils.createJwtToken("admin"));
        System.out.println(TokenUtils.parseJWT("eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJhZG1pbiIsImlhdCI6MTUxNzg4NDU0OCwic3ViIjoiIiwiaXNzIjoiIiwiZXhwIjoxNTE3ODg2MzQ4fQ.AxGGAOiwOmnp5oKaSdlmny-zgZigsqgZY8fG_UxVLKs"));
    }
}







九十八、其它
A.for的调用顺序：
for(int i=1; s("D") && i<1; s("B"))
{
	System.out.println("a");
	i++;
}

public static boolean s(String s)
{
	System.out.println(s);
	return true;
}

分析：
i=1
s("D")
i<1
System.out.println("a");
i++
s("B")

B.JMS
jms即Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。


C.java中的Thread.sleep
// 与Thread.sleep()相同效果的代码: 
public static void amethod(long x) throws InterruptedExcetion{ 
    if (x != 0) { 
        Object o = new Object(); 
        synchronized (o) { 
            o.wait(x); 
        } 
    } 
} 


D.JNDI（命名服务与目录服务）
JNDI（Java Naming and Directory Interface）- Java命名和目录接口，是一组在Java应用中访问命名和目录服务的API。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。
命名服务将名称和对象联系起来，可以用名称访问对象。目录服务是一种命名服务，在这种服务里，对象不但有名称还有属性。
（1）命名服务：作为一种基础设施出现在众多的计算机系统，其意义在于提供根据名称关联对象和通过对象匹配相应的命名服务。命名服务允许你通过名称找到一个与之对应的对象。例如在Internet上的域名服务（domain namingservice，DNS）就是提供将域名映射到IP地址的命名服务，在打开网站时一般都是在浏览器中输入名字，通过DNS找到相应的IP地址，然后打开。
ZooKeeper的命名服务有两个应用方向： 
·ZooKeeper提供类似JNDI服务，都能够帮助应用系统通过一个资源引用的方式来实现对资源的定位与实用。 
·利用ZooKeeper顺序节点（或节点版本号）的特性，制作分布式的ID生成器。
（2）目录服务：是一种特殊类型的数据库，与SQLServer、Access、Oracle等关系数据库管理系统相反，构造目录服务的目的是为了处理基于行为的事务，并且使用一种关系信息模型。
目录服务将命名服务的概念进一步引申为提供具有层次结构的信息库，这一信息库除了包含一对一的关系外，还有信息的层次结构。对目录服务而言，这种层次结构通常用于优化搜索操作，并且也可以按实际情况进行分布或者跨网络复制。
目录服务是命名服务，命名服务不需要是目录服务。
命名和目录服务把标识符和资源关联起来。

JNDI程序包
javax.naming：命名操作
javax.naming.direcotry：目录操作
javax.naming.event：在命名目录服务器中请求事件通知
javax.naming.ldap：提供LDAP支持
javax.naming.spi：允许动态插入不同实现
利用JNDI的命名与服务功能来满足企业级API对命名与服务的访问，诸如EJB、JMS、JDBC 2.0以及IIOP上的RMI通过JNDI来使用CORBA的命名服务
---------------------------------------------------------------------------------------------------
例
Properties env = new Properties();
env.setProperty("java.naming.factory.initial","weblogic.jndi.WLInitialContextFactory");
env.setProperty("java.naming.provider.url","t3:192.2.256.102:7001");
env.setproperty("java.naming.securiry.principal","system");
env.setProperty("java.naming.security.credentials","PaSsWoRd");
Context ctx = new InitialContext(env);
---------------------------------------------------------------------------------------------------









一百、常见问题
1.“Usage of API documented as @since 1.6+……”的解决办法
Q: Usage of API documented as @since 1.6+ This inspection finds all usages of methods that have @since tag in their documentation. This may be useful when development is performed under newer SDK version as the target platform for production
A:
方式一
File -> Project Structure -> Project Settings -> Modules -> （需要修改的工程名称） -> Sources -> Language Level -> 选6以上的版本。
File -> Project Structure -> Project Settings -> Project -> Project JDK
File -> Project Structure -> Project Settings -> Project -> Project language level
方式二
pom.xml
    <build>
        <!--插件，使用mvn进行打包，打包成一个jar文件-->
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
                <configuration>
                    <source>1.7</source>
                    <target>1.7</target>
                    <encoding>utf-8</encoding>
                </configuration>
            </plugin>
        </plugins>
    </build>


2.org.apache.catalina.LifecycleException: Failed to start component [Connector[HTTP/1.1-8080]]
Q:
项目启动时，报告“org.apache.catalina.LifecycleException: Failed to start component [Connector[HTTP/1.1-8080]]
”
A: 端口被占用


3.net.sf.json.JSONException: There is a cycle in the hierarchy!
循环引用


4.
Spring Configuration Check
Unmapped Spring configuration files found.  Please configure Spring facet or use 'Create Default Context' to add one including all unmapped files.


5.
当大家第一次听说default方法，通常会问：“如果一个类实现了两个接口，而这两个接口中各自定义了一个同名的default方法，会怎么样？”
java: com.a.a.MyInterface inherits unrelated defaults for foo() from types com.a.a.A and com.a.a.B
如：
com.qding.ops.zipkinparser.business.neo4j.entity.TraceNodeNeo inherits unrelated defaults for tail() from types com.york.portable.swiss.bean.node.relation.tiled.TiledRelationNode and com.york.portable.swiss.bean.node.next.tiled.TiledNextNode


6.
Q：
Description:

An attempt was made to call a method that does not exist. The attempt was made from the following location:

    org.apache.catalina.authenticator.AuthenticatorBase.startInternal(AuthenticatorBase.java:1178)

The following method did not exist:

    javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String;

The method's class, javax.servlet.ServletContext, is available from the following locations:

    jar:file:/data1/services/park/lib/servlet-api-2.3.jar!/javax/servlet/ServletContext.class
    jar:file:/data1/services/park/lib/tomcat-embed-core-9.0.21.jar!/javax/servlet/ServletContext.class

It was loaded from the following location:

    jar:file:/data1/services/park/lib/servlet-api-2.3.jar!/


Action:

Correct the classpath of your application so that it contains a single, compatible version of javax.servlet.ServletContext


A：
maven打包时，会把.m2\repository\javax\servlet\servlet-api\2.3\servlet-api-2.3.jar复制到项目中，与spingboot中的tomcat-embed-core.jar存在冲突。
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
            <optional>true</optional>
        </dependency>

可通过以下方式排除maven中的依赖：
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.3</version>
            <scope>provided</scope>
        </dependency>



7.
Q：启动时，异常：
  java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext
A：
  通过spring-boot-maven-plugin打包，如果打的是thin jar包，即<include><groupId>nothing</groupId><artifactId>nothing</artifactId></include>，而没有指定<layout>ZIP</layout>，则不会加载外层目录lib下的jar包，则会缺少相关jar包中的类，会报上面的错误。





*************************************************************************结束符**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



AnnotationConfigEmbeddedWebApplicationContext







类加载器的顺序 
1）加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 
2）在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。 
3）Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。



AQS
https://www.jianshu.com/p/2a874d758113













