つづく
Sean Parker
acronis true image
ucbrowser://flags/
chrome://flags/
chrome://extensions/
QEMM386.SYS
https://npm.taobao.org/
http://wttr.in/
https://www.apayun.cn/
git.oschina.net/mirrors

经济学理性人假定
全国人格障碍治疗与研究进展协会
全国边缘型人格障碍教育联盟
kanzhu.com?kan=com-blocker1-interview

bat 并购 参股 山寨
江湖见
之所以失败，是因为这个世界与你想象的不一样
之所以成功，是因为这个世界就是你想想的那样

%localappdata%\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets

序
文档结构：一、A、1、（1）、1）、<1>、I
※·•▲◆★●̑∵∴®¤≈……┌┐└┘∟「」⊥┼┤┴├┬↑↓→←↖↗↘↙♀♂≠╳√╱╲—│∞
παβγδζεθλμξνρσφ※∽≈≌≠≤≥≦≧ʤ‰∈∑
α β Γ γ Δ δ ζ η Θ θ ι κ Λ λ μ ν Ξ ξ ο Π π ρ Σ σ τ Υ υ Φ χ Ψ ψ Ω ω
├─bin
├─config
│  ├─static
│  └─templates
├─docker
└─lib

aliez

㊣①②③④⑤⑥⑦⑧⑨⑩
┌--┐  ┌—┐
│  │  │  │
└--┘  └—┘



时间复杂度o(1)
09.04.14 league member
一、基本符号及综合概念
.NET Framework: 就是微软Web Services 引擎 
    有许多程序设计师和使用者，非常渴望有一个完善而且透明清楚的基础架构，来建立WebServices（因特网服务）。.NET Framework 就是为了这个需求，而提供的基础架构。.NETFramework 提供了应用程序模型及关键技术，让开发人员容易以原有的技术来产生、布署，并可以继续发展具有高安全、高稳定，并具高延展的Web Services。对于.NET Framework 而言，所有的组件都可以成为Web Services，Web Services 只不过是另一种型态的组件罢了。微软将COM 的优点整合进来，它可以不用像COM 那么严谨的来栓锁两个对象，.NET Framework 以松散的方式来栓锁Web Services 这种型态的组件。这样的结果让开发人员非常容易的发展出强而有力的Web 服务组件，提高了整体的安全及可靠性，并且大大的增加系统的延展性。 

.NET Framework: 由三个部分组成：
第一个部分是Common Language Runtime（CLR，所有.NET 程序语言公用的执行时期组件）
第二部分是共享对象类别库（提供所有.NET 程序语言所需要的基本对象）
第三个部分是重新以组件的方式写成的ASP.NET（旧版本则是以asp.dll提供ASP 网页所需要的对象）。


A、基本符号
1、转义符@
（1）C# string 字符串的前面可以加 @（称作“逐字字符串”）将转义字符（\）当作普通字符对待，比如以下两个语句的作用是一样的：
1）string str=@"c:\windows\system32";
2）string str="c:\\windows\\system32";
（2）@ 字符串中，我们用两个连续英文双引号表示一个英文双引号，如下字符串的实际内容为="=，字符串长度为3。
string str = @"=""=";
（3）@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。
string str = @"<script type=""text/javascript"">
    <!--
    -->
    </script>";
（4）@ 只在连续一段字符串中有效，用 + 将两个字符串连接起来，第二个字符串中没有用 @ 标识，其中的 \ 就成为转义字符。
string str=@"abc" + "\\";

（5）在C#规范中，@可以作为标识符(类名、变量名、方法名等)的第一个字符，以允许C#中保留关键字作为自己定义的标识符。
public static void @static(bool @bool)
{
    if (@bool)
        System.Console.WriteLine("true");
    else
        System.Console.WriteLine("false"); 
} 

2、转义符\
\' 符号'
\" 符号"
\\ 符号\
\0 空字符
\a 感叹号
\b 退格
\f 换页
\n 新行(下移一格)
\r 回车
\t 水平tab
\u 使用数字指定的Unicode 字符，如\u2000
\v 垂直tab
\x 使用十六进制数指定的Unicode 字符，如\xc8

另外
string.Format("{{0}}", "abc")会出现问题，可通过{{的方式对{进行转义，即：
string.Format("{{{0}}}", "abc")
Result:
{abc}

System.Text.RegularExpressions.Regex.Unescape(s)        //可反转义\\,\"等；也可以反转义\u4e00等unicode
System.Text.RegularExpressions.Regex.Escape(s)

3、编码
（1）HtmlCode
·Html解码函数：Server.HtmlDecode()
将Html代码转化为普通文本显示，如<H1></H1>不会被当作功能性文字被使用，而是普通文本。将"<"转换为"&lt;"，">"转换为"&gt;"等
·Html编码函数：Server.HtmlEncode()
同HtmlEncode相反

（2）UrlCode(core中System.Text.Encodings.Web.UrlEncoder)
·Url解码函数：System.Web.HttpUtility.UrlDecode或Server.UrlDecode()（MVC中是HttpUtility.UrlDecode()）
将Url代码转化为普通文本显示，如?&不会当作网址的连接字符，而是普通文本。将符号转换为16进制表示，如"&"转换为"%26"，"/"转换为"%2F"，":"转换为"%3A"，"="转换为"%3D"，"?"转换为"%3F"等
·Url编码函数：System.Web.HttpUtility.UrlEncode或Server.UrlEncode()（MVC中是HttpUtility.UrlEncode()）
同UrlEncode相反
★把这两个放到一起说是因为这两个方法在绝大多数情况下是一样的。它们的区别是HttpUtility.UrlEncode默认使用UTF8格式编码，而Server.UrlEncode是使用系统预设格式编码，Server.UrlEncode使用系統预设编码做为参数调用HttpUtility.UrlEncode编码，所以如果系统全局都用UTF8格式编码，这两个方法就是一样的。

Uri.EscapeUriString：用于对网址编码（不包含参数），对冒号“:、/、#”不编码
Uri.EscapeDataString：用于对网址参数进行编码（不包含网址）

HttpUtility.ParseQueryString可用于解析类似abc=111&bcd=22&cde=33格式字符串

（3）BASE64
 1）传输信道只支持ASCII字符，不方便传输二进制流的场合。
 2）含有非ASCII字符，容易出现编码问题的场合。
 3）简易的掩人耳目。至少非开发人一眼看不出来是啥。
·BASE64编码（string-byte[]-base64）
byte[] bytes=Encoding.Default.GetBytes("要转换的字符串");
string ret = Convert.ToBase64String(bytes);
·BASE64解码（base64-byte[]-string）
byte[] outputb = Convert.FromBase64String("ztKwrsTj");//"ztKwrsTj"是“我爱你”的base64编码
string ret = Encoding.Default.GetString(outputb);

（4）UNICODE
\u开头就代表了是unicode编码：
可用Encoding.Unicode.GetString(Encoding.Unicode.GetBytes("\u4e00-\u9fa5"))   //一-龥
System.Text.RegularExpressions.Regex.Unescape("\u4e00-\u9fa5")               //一-龥
HttpUtility.UrlDecode("%u67f3_abc123")                                       //柳_abc123
HttpUtility.UrlEncodeUnicode("柳_abc123")                                    //%u67f3_abc123
unicode_js_0("柳_abc123")                                                    //%u67f3_abc123

/// <summary>
/// 中文转unicode（符合js规则的）
/// </summary>
/// <returns></returns>
public static string unicode_js_0(string str)
{
    string outStr = "";
    string a = "";
    if (!string.IsNullOrEmpty(str))
    {
        for (int i = 0; i < str.Length; i++)
        {
            if (Regex.IsMatch(str[i].ToString(), @"[\u4e00-\u9fa5]")) { outStr += "\\u" + ((int)str[i]).ToString("x"); }
            else { outStr += str[i]; }
        }
    }
    return outStr;
} 


4、运算符
=赋值
==等于(值)
===完全等于（值+类型）
|或
||完全或
&与
&&

C# 运算符优先级表（从高到低）
优先级	类型	运算符
1	基元	.（成员，如x.y）、( )（函数，如f(x)）、[ ]（数组，如a[i]）、++（后缀增，如i++）、--（后缀减，如i--）、new（创建对象，如new MyClass）、typeof（类型，如typeof(x)）、checked（已检验，如checked(x*y)）、unchecked（未检验，如unchecked(x*y)）
2	一元	+（正，如+x）、-（负，如-x）、！（逻辑非，如!x）、~（求补，如~x）、++（前缀加，如++i）、--（前缀减，如--i）、()（强制类型转换，如(int)x）
3	乘性	*（乘，如x*y）、/（除，如x/y）、%（模，如x%y）
4	加性	+（加，如x+y）、-（减，如x-y）
5	位移	<<（左移，如i<<4）、>>（右移，如i>>4）
6	关系和
类型测试	<（小于，如x<y）、>（大于，如x>y）、<=（小于等于，如x<=y）、>=（大于等于，如x>=y）、is（是，如x is int）、as（转为，如x as int）
7	等性	==（相等，如x==y）、!=（不等，如x!=y）
8	位与	&（位与，如x&4）
9	位异或	^（位异或，如x^y）
10	位或	|（位或，如x|y）
11	逻辑与	&&（逻辑与，如x&&y）
12	逻辑或	||（逻辑或，如x||y）
13	空接合	??（空接合，如a??b）
14	条件	?:（条件，如x?a:b）
15	赋值	=（等于，如x=y）、*=（乘等于，如x*=y）、/=（除等于，如x/=y）、+=（加等于，如x+=y）、-=（减等于，如x-=y）、<<=（左移等于，如x<<=y）、>>=（右移等于，如x>>=y）、&=（位与等于，如x&=y）、^=（位异或等于，如x^=y）、|=（位或等于，如x|=y）

★运算符的重写
public static bool operator !=(Type left, Type right);
public static bool operator ==(Type left, Type right);

5、注释
#region
#endregion
c#：
   //行注释
   /* 块注释 */
html：
   <!-- 块注释 -->
css：
   //行注释
   /** 块注释 */
javascript：
   //行注释
   /** 块注释 */
masm：
   ;行注释


B、关键词
1、base
（1）base常用于，在派生类对象初始化时和基类（不论几次继承）进行通信。 
（2）base可以访问基类的public成员和protected成员，私有成员是不可访问的。 
（3）this指代类对象本身，用于访问本类的所有常量、字段、属性和方法成员，而且不管访问元素是任何访问级别。因为，this仅仅局限于对象内部，对象外部是无法看到的，这就是this的基本思想。另外，静态成员不是对象的一部分，因此不能在静态方法中引用this。 
（4）在多层继承中，base可以指向的父类的方法有两种情况：一是有重载存在的情况下，base将指向直接继承的父类成员的方法，例如Audi类中的ShowResult方法中，使用base访问的将是Car.ShowResult()方法，而不能访问Vehicle.ShowResult()方法；而是没有重载存在的情况下，base可以指向任何上级父类的公有或者受保护方法，例如Audi类中，可以使用base访问基类Vehicle.Run()方法。

2、this
（1）this是指当前对象自己
当在一个类中要明确指出使用对象自己的的变量或函数时就应该加上this引用，即当前实例。
一般来说，this.x中的x是类里定义的公共变量。
而等号后面的x会是调用方法传进来的参数。

成员变量和形参名相同时，用this.区分

class T
{ 
  int x; 

  T(int x)
   { 
    this.x = x; 
   } 
} 

此时this才有作用，区分是实例变量x，还是构造方法参数中的局部变量x；区分是公共变量，还是参数；方便理解和区分
如果此时不用this，即 x = x；此时两个x都为局部变量，其实例变量x并没有被赋值
this指向初始化后这个类的具体对象，这个对象里面可以有很多的成员变量，例如你程序中的x成员变量，如果初始化通过构造方法进行赋值，并且构造方法里面的参数和这个成员变量重名，那么就可以使用this.x来区分局部变量x

改为以下代码会更清晰：
class T
{
  int t;
  T(int a) 
  {
    this.t = a;
  }
}


（2）把this作为参数传递
当你要把自己作为参数传递给别的对象时，也可以用this。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    public class A
    {
        public A()
        {
            new B(this).print();
        }
        public void print()
        {
            Console.WriteLine("Hello from A!");
        }
    }
    public class B
    {
        A a;
        public B(A a)
        {
            this.a = a;
        }
        public void print()
        {
            a.print();
            Console.WriteLine("Hello from B!");
        }
    }
result:
Hello from A!
Hello from B!
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
在这个例子中，对象A的构造方法中，用new B(this)把对象A自己作为参数传递给了对象B的构造方法。

（3）在构造方法中，通过this可以调用同一class中别的构造方法。（仅在JAVA中适用）
public class mytest {

    /**
     * @param args
     */
    public static void main(String[] args) {
        //System.out.println(myI.rr);
        my m = new my(22, "11112222");
    }
}



class my{
    my(String s)
    {
        System.out.println(s);
    }
    my(int i, String s)
    {
        this(s);
    }
}


（4）注重匿名类和内部类中的中的this（仅在JAVA中适用）
有时候，我们会用到一些内部类和匿名类。当在匿名类中用this时，这个this则指的是匿名类或内部类本身。这时假如我们要使用外部类的方法和变量的话，则应该加上外部类的类名。
class my{
    my()
    {
        new my(){
        public void show()
        {
            System.out.println("limian")  ;
            my.this.show();//waimian
            this.show();//limian
        }
        };
    }

    private void show() {
        // TODO Auto-generated method stub
        System.out.println("waimian")  ;
        
    }
}

（5）子类与父类中的this
1）子类的对象内存布局包括两部分：父类和子类派生部分，所以执行子类中父类部分的构造方法，只不过是在构造子类对象的父类部分。因此子类对象的父类部分的this指针当然是指向子类对象自己了。
2）this永远指向你所创建的类的对象，这是this指针的定义，即使在子类中调用父类，此时父类中的this也仍然指向子类。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    class bases
    {
        protected object ff()
        {
            return this;
        }
    }
    class A:bases
    {
        public object fff()
        {
            return base.ff();
        }
    }
    A a = new A();
    a.fff();

result:
A
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



（6）扩展方法
    扩展方法使您能够“向现有类型添加方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型”。扩展方法是一种特殊的静态方法，但可以像扩展类型上的实例方法一样进行调用。对于用 C# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。 （其形式类似js中，String.StrContain = function (sSource, Str) {...}的写法）
    扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。仅当您使用 using 指令将命名空间显式导入到源代码中之后，扩展方法才位于范围中。
定义和调用扩展方法：
<1>定义一个“静态类”以包含扩展方法。该类必须对客户端代码可见。有关可访问性规则的更多信息，请参见访问修饰符（C# 编程指南）。
<2>将该扩展方法实现为“静态方法”，并使其至少具有与包含类相同的可见性。
<3>该方法的第一个参数指定方法所操作的类型；该参数必须以 this 修饰符开头。
<4>在调用代码中，添加一条 using 指令以指定包含扩展方法类的命名空间。
<5>照与调用类型上的实例方法一样的方式调用扩展方法。
　　请注意，第一个参数不是由调用代码指定的，因为它表示正应用运算符的类型，并且编译器已经知道对象的类型。您只需通过 n 为这两个形参提供实参。
例：
　　下面的示例演示为 System.String 类定义的一个扩展方法。请注意，它是在非嵌套、非泛型静态类内部定义的：
     namespace ExtensionMethods
     {
         public static class MyExtensions
         {
             public static int WordCount(this string str)
             {
                 return str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
             }
         }   
     }
★可使用以下 using 指令将 WordCount 扩展方法放入范围中，而且，可以在应用程序中使用以下语法对该扩展方法进行调用：
using ExtensionMethods;
string s = "Hello Extension Methods";
int i = s.WordCount();
在代码中，可以使用实例方法语法调用该扩展方法。但是，编译器生成的中间语言 (IL) 会将代码转换为对静态方法的调用。因此，并未真正违反封装原则。实际上，扩展方法无法访问它们所扩展的类型中的私有变量。



2.5、base与this区别
•尽量少用或者不用base和this。除了决议子类的名称冲突和在一个构造方法中调用其他的构造方法之外，base和this的使用容易引起不必要的结果。 
•在静态成员中使用base和this都是不允许的。原因是，base和this访问的都是类的实例，也就是对象，而静态成员只能由类来访问，不能由对象来访问。 
•base是为了实现多态而设计的。 
•使用this或base关键字只能指定一个构造方法，也就是说不可同时将this和base作用在一个构造方法上。 
•简单的来说，base用于在派生类中访问重写的基类成员；而this用于访问本类的成员，当然也包括继承而来公有和保护成员。 
•除了base，访问基类成员的另外一种方式是：显示的类型转换来实现。只是该方法不能为静态方法。 


3、const define readonly
（1）const 与 readonly 区
1）const 与 readonly 本质的区别是，const 是编译时常量，readonly 是运行时常量。
2）效率：const 效率略高于 readonly。 
3）类型：const 只用于数字和字符串；readonly 用于任何类型。 
4）作用范围：const 用于全局变量、局部变量或 class 的 field；readonly 只用于 class 的 field，比如函数中就不能用 readonly，这就示上述示例中 readonly 为什么要放在 class 中的原因了。
5）共享：const 修饰的 class 的 field，为该类的所有实例共享；readonly 修饰的 class 的 field，为该类的某一个实例独享，除非我们加了 static。
6）Switch：readonly的int是不能作为switch的case语句的，const的可以。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
int a = 1;
const int b = a * 3; //错误
错误，因为在编译时无法确定 a 值。

const int a = 1;
const int b = a * 3; //正确
正确，a 是常量，可以这样给 b 赋值。

class CFoo
{
    private int n;
    public readonly int r;
    
    public CFoo()
    {
        n = 1;
        r = n * 3; //正确
    }
}
正确，readonly 是运行时常量。

class CFoo
{
    private int n = 1;
    public readonly int r = n * 3; //错误
}
错误，实际上该错误并不是由 readonly 引起的，而是 field（不是 filed） 初始化不能引用一个非静态变量（未使用 static 或 const 标明的），该知识点不属于本文范畴，列出来只是用于正确理解 readonly。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



4、void:返回值为空（不返回数值）
如果方法为void类型，则可以省略return语句。

5、终止、跳转命令
break;     结束{}内所有循环
continue;  结束{}内本次循环
goto Found;  跳转至“Found:”行
Found:

6、new
new 修饰符只能用于嵌套的类，表示对继承父类同名类型的隐藏。
首先int是一个struct，是值类型.和静态类没关系
new一个int时，new运算符用于初始化其值为0。

结论： 
•new一个class时，new完成了以下两个方面的内容：一是调用newobj命令来为实例在托管堆中分配内存；二是调用构造方法来实现对象初始化。 
•new一个struct时，new运算符用于调用其带构造方法，完成实例的初始化。 
•new一个int时，new运算符用于初始化其值为0。 
•另外必须清楚，值类型和引用类型在分配内存时是不同的，值类型分配于线程的堆栈（stack）上，并变量本身就保存其实值，因此也不受GC的控制，；而引用类型变量，包含了指向托管堆的引用，内存分配于托管堆（managed heap）上，内存收集由GC完成。  

另外还有以下规则要多加注意： 
•new运算符不可重载。 
•new分配内存失败，将引发OutOfMemoryException异常。  





7、VB与c#一些区别
Imports       me    i+=1              VB
using         this  i++               C#

is
page




8、string
（1）基本概念
String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。这里尝试举个不是很恰当的例子： 

string S1 = "abc"; 
for(int I = 0 ; I < 10000 ; I ++) // for 模拟程序的多次调用 
{ 
  S1 + = "def"; 
  S1 = "abc"; 
}

    如果是这样的话，到这个 for 循环完毕后，如果内存中的对象没有被 GC 清理掉的话，内存中一共有 2 万多个了，惊人的数目，而如果这是一个很多人使用的系统，这样的数目就不算很多了，所以大家使用的时候一定要小心。 
※
String.IsNullOrEmpty(mytext)        判断字符串是否为：null或者string.Empty。如果是如"\t"这样的字符就返回false了，为了达到判断过滤这些功能，就要使用Trim()和Length属性帮忙，判断是否长度为零，于是乎就产生了如下的方法。
String.IsNullOrWhiteSpace(mytext)   这个是判断所有空白字符，功能相当于string.IsNullOrEmpty和str.Trim().Length总和，他将字符串给Char.IsWhiteSpace为true的任何字符都将是正确的。根据MSDN的说明，这个方法会比调用上述两个方法的性能更高而且简洁，所以在判断这个功能时，推荐使用。

using System;
public class Example
{
   public static void Main()
   {
      string[] values = { null, String.Empty, "ABCDE", 
                          new String(' ', 20), "  \t   ", 
                          new String('\u2000', 10) };
      foreach (string value in values)
         Console.WriteLine(String.IsNullOrWhiteSpace(value));
   }
}
// The example displays the following output:
//       True
//       True
//       False
//       True
//       True
//       True





（2）字符串类型
1）几种空类型的涵义
·null                没有指向，是引用类型变量的默认值。那么也只有引用型的变量可以为NULL，如果 int i=null，的话，是不可以的。
·DBNULL              DBNull在DotNet是单独的一个类型，该类只能存在唯一的实例，DBNULL.Value，DBNull唯一作用是可以表示数据库中的字符串，数字，或日期，为什么可以表示原因是DotNet储存这些数据的类（DataRow等）都是以 object 的形式来储存数据的。对于 DataRow ，它的 row[column] 返回的值永远不为 null ， 要么就是具体的为column 的类型的值 。 要么就是 DBNull 。 所以 row[column].ToString() 这个写法永远不会在ToString那里发生NullReferenceException。DBNull 实现了 IConvertible 。但是，除了 ToString 是正常的外，其他的ToXXX都会抛出不能转换的错误。
·System.String.Empty 指向一个空字符串，但不分配存储空间
·""                  指向"\0"的空字符串，并且分配长度占用一个字节的存储空间 
※关于String.Empty和null的问题是这样的，这两个都是表示空字符串，其中有一个重点是string str1 = String.Empty和 string str2 = null 的区别，这样定义后，str1是一个空字符串，空字符串是一个特殊的字符串，只不过这个字符串的值为空，在内存中是有准确的指向的，string str2=null，这样定义后，只是定义了一个string 类的引用，str2并没有指向任何地方，在使用前如果不实例化的话，都将报错。在 C# 中，大多数情况下 "" 和 string.Empty 可以互换使用。
另：
int类型不能转化为null
string类型可以转化为null
引用类型可以转化为null



2）几种空类型的判断
string.IsNullOrEmpty            指示指定的字符串是否是null或System.String.Empty类型
string.IsNullOrWhiteSpace       指示指定的字符串是否是null、空还是仅由空白字符组成
※判定为空字符串的几种写法，按照性能从高到低的顺序是：s.Length == 0 优于 s == string.Empty 优于 s == "" 
另：还有一种判断空类型的方法，typeof str == 'undefined'


（3）字符串操作
1）Guid码
Guid是全球唯一码的意思.很难重复的.但是没有绝对~System.Guid.NewGuid().ToString()就是实例化一个GUID并且转换为一个字符串. GUID 在数据库中的优点比自动增加(int)强.主要就是 数据迁移方便~但是在数据库中一般是 默认值(newid())对应的数据库类型是(针对sqlserver数据库)uniqueidentifier所以你的想法很好，绝对能行~
同时，相对于Random只能生成数字而言，Guid可生成字符串(ABCD-1234)，Guid.NewGuid().ToString()可生成一串类似"12f5cdbd-2a6d-4ba6-a394-6961e4f5d5b5"36位的随机编码字符串，之所以这么长，是因为这样随即生成的字符串是不可能重复的.例如：
    string RandomString = Convert.ToString(Guid.NewGuid());
================================================================================
可用于上传文件生成新的文件名

eg.：

       string newfilename = Guid.NewGuid().ToString() +Path.GetExtension(filename);

                     Path.GetExtension(filename)       指定路径字符串的扩展名

1、Guid.NewGuid().ToString("N") 结果为：
      38bddf48f43c48588e0d78761eaa1ce6

2、Guid.NewGuid().ToString("D") 结果为： 
      57d99d89-caab-482a-a0e9-a0a803eed3ba

3、Guid.NewGuid().ToString("B") 结果为：
     {09f140d5-af72-44ba-a763-c861304b46f8}

4、Guid.NewGuid().ToString("P") 结果为：
     (778406c2-efff-4262-ab03-70a77d09c2b5)

可见默认的为第2种效果
================================================================================

2）string补齐
DateTime.Now.Month.ToString().PadLeft(2, '0');


3）三元运算符?
(bool) ? (ValueIfTrue) : (ValueIfFalse);
例1：chkenable = this.chk_enable.Checked ? 1 : 0;
例2：a > b ? a=8 : b=9

value != null ? value : string.Empty; 
value == null ? string.Empty : value;
还可以更简单，变成：
value = value ?? string.Empty;              //如果value为空，则value = string.Empty
//或
return value ?? (value = string.Empty);     //由于该三元运算符只能用在赋值语法中，所以这种方式只能用在返回值的情况

4）字符串的分隔
using System.Text.RegularExpressions;
string str="aaajsbbbjsccc";
string[] sArray1 = Regex.Split(str, "js", RegexOptions.IgnoreCase);
string[] sArray2 = str.Split('j');
string[] sArray3 = str.Split(new char[3]{'a','b','c'});

5）字符串的连接
string str = string.Join(",", strs);

（4）String与string的区别
1）string是c#中的类，String是.net Framework的类(在c# IDE中不会显示蓝色) 
2）string映射为.net Framework的String 
3）如果用string，编译器会把它编译成String，所以如果直接用String就可以让编译器少做一点点工作。如果使用c#，建议使用string，比较符合规范    
4）string始终代表 System.String(1.x) 或 ::System.String(2.0)，String只有在前面有using System;的时候并且当前命名空间中没有名为String的类型（class、struct、delegate、enum）的时候才代表System.String 
5）string是关键字，String不是，也就是说string不能作为类、结构、枚举、字段、变量、方法、属性的名称，而String可以。

（5）自定义
public class MyComparer : IComparer                     //也可以IComparer<T>
{

    int System.Collections.IComparer.Compare(object x, object y)
    {
        if (x == null || y == null)
            throw new ArgumentException("参数不能为空");
        if (...)
            return 1;
        if (...)
            return -1;
        if (...)
            return 0;
    }
}


（6）一句话判断中文
str.charCodeAt(i) > 255         //中文
或
if (System.Text.Encoding.GetEncoding("gb2312").GetBytes("中").Length == 2)
GetBytes 的参数是一个长度的字符串。
（7）bool b = str.StartsWith("C", StringComparison.CurrentCultureIgnoreCase); //忽略大小写 true 
     bool b = txt_filename.Value.ToLower().EndsWith(".png");
（8）char == '\0 ' 空字符
（9）时间
yyyyMMddHHmmssfff  //年月日时分秒毫秒

9、可空类型
System.Nullable<T>
例：
System.Nullable<int> myNullableInteger = null;
简写成
int? myNullableInteger = null;

也可表示可空类型，如int?、double?

10、空值
IntPtr.Zero  //一个只读字段，代表已初始化为零的指针或句柄
string.Empty //一个只读字段，相当于只读的""

11、默认值
（1）switch中的default
default

    switch (key)
    {
        case 1:
            Console.WriteLine("1"); break;
        case 2:
            Console.WriteLine("2"); break;
        default:
            Console.WriteLine("Sorry, no one matches!");
            break;
    } 
（2）取默认值的default
泛型代码
在泛型类和泛型方法中，在预先未知以下情况时，如何将默认值分配给参数化类型 T： 
T 是引用类型还是值类型。
如果 T 为值类型，则它是数值还是结构。
给定参数化类型 T 的一个变量 t，只有当 T 为引用类型时，语句 t = null 才有效；只有当 T 为数值类型而不是结构时，语句 t = 0 才能正常使用。解决方案是使用 default 关键字，此关键字对于引用类型会返回空，对于数值类型会返回零。对于结构，此关键字将返回初始化为零或空的每个结构成员，具体取决于这些结构是值类型还是引用类型。
        public class GenericClass< T>  { 
        public T Function(BaseEntity arg)    
        {        
            T temp = default(T);     
            if (arg != null) temp = arg;    
            return temp;      }      //...  } 注意：不仅可以在定义泛型类或者泛型方法的代码中可以使用C# default关键字，甚至在任何地方都可以使用该关键字。如下面代码。

        static void Main(string[] args)  {  
            Console.WriteLine(default(int));   
            Console.WriteLine(default(string));    
            Console.WriteLine(default(Color)); 
        }
//输出：
行1： 0
行2：       
行3： Color [Empty]

12、变量交换
通过第三个变量交换
tmp = a; a = b; b = tmp;
在不用第三方变量的前提下，把a,b的值互换
1) a = a + b; b = a - b; a = a - b;
2) a ^= b ^ (b ^= a ^ b);           // 13个字节
3) a = b + (b = a) * 0;             // 11个字节

13、CLR属性（Property）
定义：属性是面向对象思想里所说的封装在类里面的数据字段，Get，Set方法。
I.普通用法
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
private string title;
public string Title
{
   get {return title;}  //获取这个值
   set {title = value;}   //设置这个值
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
这种形式叫做封装。
在类外部只能调用Title而不能访问title 但是可以通过Title来访问title
这里可以给set里面加入条件
II.晋升用法
在这里get { return age; }   相当于  int get(){return age;} 
其实get就是个返回函数  用于返回需要数据   
在这里 set 那个也就相当于  
void set(int value)
{
    if (value < 100 && value > 0)
    {
        age = value;
    }
    else
    {
        age = 18;
    }

} 
get 和set就是一个为了方便返回和设定的一个简写的函数，其实GET和SET是为了保护好类内的数据变量，可以“有限制地”对数据变量进行赋值和获取，如果不用GET 和SET 也可以根据类名.变量改变类中的数据，不过就把类里面的结构暴露出来了，这样就有可能被别人用内存修改器，改变类中的数据 安全性不够高，如果用GET、SET这样的属性设定工具 就可以有效安全的管理类内的变量
III.扩展用法
get set是用来扩展域的，也就是C里的变量，只是用起来更加灵活而己。看以下代码：  
using System;  
public class cls  
{  
    private int book;//定义一个域（也可以叫变量，只是面向对像里都这么叫，使用起来也更加方便）  
    public int Book  
    {  
        get  
        {  
            Console.WriteLine("dsf");  
            return book;  
        }  
        set  
        {  
            Console.WriteLine("aaa");  
            book = value;  
        }  
    }  
    public static void Main()  
    {  
        cls obj = new cls();  
        obj.Book = 120; //注意这一句  
        Console.WriteLine(obj.Book);  
    }  
}  
运行结果为：  
aaa  
dsf  
120  
也就是先把120赋值给value(相当一个存储空间），然后再用get{}返回给Book，实际上也就是一次改变变量值的过程。  
那你也许会问为什么要这么复杂呢？因为这是用了嵌套，所以可以更加方便的写入其它语句，在以后你就应该学到了。  
如果没有：  
obj.Book = 120;  
请想一想会是什么结果呢？  
只是一个取值过程:get{}而没有执行set{}  
结果为：  
dsf  
0 

IV.自动属性
C#3.0对这种常见的写法提供了“自动属性”这一特性：
public class Person
{
    public string Name { get; set; }
}


V.集合属性
class MCollection
{
    public MessageType this[string type] {
        get {
            return MessageTypes.Find(n => n.Type.Equals(type, StringComparison.CurrentCultureIgnoreCase));
        }
    }
}
MCollection m = new MCollection();
MessageType type = m["type1"];


VI.反馈属性（WPF中）
class Bar : INotifyPropertyChanged
{  
    private int foo;  
  
  
    public int Foo  
    {  
        get { return foo; }  
        set  
        {  
            foo = value;  
            PropertyChanged(this, new PropertyChangedEventArgs(nameof(Foo));  
        }  
    }  
  
  
    public event PropertyChangedEventHandler PropertyChanged;  
}

14、特性（Attribute）
A.定义
官方解释：特性是给指定的某一声明的一则附加的声明性信息。 允许类似关键字的描述声明。它对程序中的元素进行标注，如类型、字段、方法、属性等。从.net角度看，特性是一种 类，这些类继承于System.Attribute类，用于对类、属性、方法、事件等进行描述，主要用在反射中。但从面向对象的级别看，其实Attribute是类型级别的，而不是对象级别。
B.作为编译器的指令
Conditional：起条件编译的作用，只有满足条件，才允许编译器对它的代码进行编译。一般在程序调试的时候使用。
DllImport：用来标记费.net的函数，表明该方法在一个外部的DLL中定义。
Obsolete：这个属性用来标记当前的方法已经废弃，不再使用。
注：Attribute是一个类，因此DllImport也是一个类，Attribute类是在编译的时候实例化，而不是像通常那样在运行时实例化。
CLSCompliant：保证整个程序集代码遵守CLS，否则编译将报错。

C.自定义特性
[AttributeUsageAttribute(AttributeTargets.All       //可以应用到任何元素，默认为AttributeTargets.All
    , AllowMultiple = true                          //允许应用多次，该特性能否被重复放在同一个元素前多次，默认为false
    , Inherited = false                             //该特性不继承到派生，默认为false
)]
public class MyselfAttribute : System.Attribute{}     //特性也是一个类，必须继承于System.Attribute类，命名规范为“类名”+Attribute。不管是直接还是间接继承，都会成为一个特性类，特性类的声明定义了一种可以放置在声明之上新的特性。
※实际只不过是将一个自定义的对象绑定到某一个变量、方法或类上。

D.实例
//实例1（原生特性）
#define DEBUG
using System.Runtime.InteropServices.DllImportAttribute

namespace ConsoleTest
{
    class Program
    {
        [System.Diagnostics.DebuggerStepThrough]    //跳过调试
        [Conditional("DEBUG")]                      //只有在DEBUG模式或定义#define DEBUG时，才会被执行
        public static void Message(string msg)
        {
            Console.WriteLine(msg);
            object[] MyAttrs = typeof(Program).GetCustomAttributes(typeof(MyAttr), false);      //通过反射获取特性
        }
        
        static void Main(string[] args)
        {
            Message("...");
        }
    }
}

//实例2（自定义特性）
//AttributeUsage：用来定义属性用在什么地方．
//AllowMultiple:定义用户是否能给元素添加一个或多个相同的属性
//BindingFlags:一个枚举．这里是用来限制返回成员类型的


using System;
using System.Reflection;

namespace AttributeDemo
{
    //自定义特性
    [AttributeUsage(AttributeTargets.Class |
        AttributeTargets.Property |
        AttributeTargets.Method |
        AttributeTargets.Constructor,
        AllowMultiple = true)]
    public class BugFixAttribute : Attribute                                                    //定制一个BugFixAttribute属性类
    {
        public BugFixAttribute(string bugNumber, string comments)
        {
            BugNumber = bugNumber;
            Comments = comments;
        }

        public readonly string BugNumber;
        public readonly string Comments;
        public string Author = null;

        public override string ToString()                                                       //重写ToString()方法
        {
            if (null == Author)
                return string.Format("BugFix {0} : {1}", BugNumber, Comments);
            else
                return string.Format("BugFix {0} by {1} : {2}", BugNumber, Author, Comments);
        }

        public static void DisplayFixes(System.Type t)                                          //静态方法DisplayFix
        {
            object[] fixes = t.GetCustomAttributes(typeof(BugFixAttribute), false);             //反射t中的BugFix属性

            Console.WriteLine("Displaying fixes for {0}", t);

            foreach (BugFixAttribute bugFix in fixes)
            {
                Console.WriteLine("  {0}", bugFix);
            }

            foreach (MemberInfo member in t.GetMembers(BindingFlags.Instance |
                                                          BindingFlags.Public |
                                                          BindingFlags.NonPublic |
                                                          BindingFlags.Static))                 //迭代类上的所有成员，并用BindingFlags枚举限制返回成员列表
            {
                // ICustomAttributeProvider表示所有可以承载“CustomAttribute”自定义属性的载体，可以是类、方法、属性、字段等等
                // MemberInfo:ICustomAttributeProvider，其中ICustomAttributeProvider包含GetCustomAttributes方法
                object[] memberFixes = member.GetCustomAttributes(typeof(BugFixAttribute), false);

                if (memberFixes.Length > 0)                                                     //如果Bugfix属性数目大于0
                {
                    Console.WriteLine("  {0}", member.Name);                                    //输出这些成员

                    foreach (BugFixAttribute memberFix in memberFixes)
                    {
                        Console.WriteLine("{0}", memberFix);
                    }
                }
            }
        }
    }

    //标注特性
    [BugFix("101", "Created some methods")]                                         //使用构造方法
    public class MyBuggyCode                                                        //MyBuggyCode类
    {
        [BugFix("90125", "Removed call to base()", Author = "Morgan")]
        public MyBuggyCode()
        {
        }

        [BugFix("2112", "Returned a non null string")]
        [BugFix("38382", "Returned OK")]
        public string DoSomething()
        {
            return "OK";
        }
    }
    
    //使用特性
    public class Demo
    {
        static void Main(string[] args)
        {
            BugFixAttribute.DisplayFixes(typeof(MyBuggyCode));
            Console.ReadKey();
        }
    }
}

//实例3
//将所有标注RegisterHandlerAttribute的AbsTaskHandler对象收集起来
    class Demo
    {
        private void registerHandler()
        {
            //Activator.CreateInstance(handler.GetType());
            Type[] types = Assembly.GetExecutingAssembly().GetTypes();
            foreach (Type type in types)
            {
                RegisterHandlerAttribute attr = type.GetCustomAttribute<RegisterHandlerAttribute>(true);
                if (attr != null)
                {
                    AbsTaskHandler handler = Activator.CreateInstance(type) as AbsTaskHandler;
                    taskHandlers.Add(attr.Sort, handler);
                }
            }            
        }
    }

    //执行每一个标注了VerifyActionAttribute特性的方法
    class Demo
    {
        public virtual bool Verify(out ResponseMsgRCDTO result)
        {
            bool b = true;
            result = null;

            MethodInfo[] methodInfos = this.GetType().GetMethods();
            object[] _params = new object[] { result };
            foreach (var methodInfo in methodInfos)
            {
                VerifyActionAttribute attr = methodInfo.GetCustomAttribute<VerifyActionAttribute>(true);
                if (attr != null && attr.GetType().FullName
                    .Equals("BitAuto.EP.PRC.Presentation.PRCWebAPI.VerifyActionAttribute", StringComparison.CurrentCultureIgnoreCase))
                {
                    b = (bool)methodInfo.Invoke(this, _params);
                    if (!b)
                    {
                        result = _params[0] as ResponseMsgRCDTO;
                        break;
                    }
                }
            }
            return b;
        }
    }




15、全局变量
只是对某一进程的不同模块而言是共享的，不同进程间需要使用进程间通信才能实现数据交互
∴多个不同进程内的全局变量是不共享的。

C、概念
1、各种类型的等级
类级：用struct enum class delegate定义，如Dataset DataGrid OledbCommand             动词：定义一个类
对象（实例）级：用sbyte short int long float double string定义，如conn comm opera         动词：实例化、声明一个对象
变量级：直接使用x y z str                                                           动词：赋值、初始化
域也叫成员变量

2、面向对象的三大特性
面向对象三大特性是封装、继承和多态
（1）封装技术
封装是OOP编程中的一个重要手段，就是指把具体实现的逻辑细节在内部隐藏起来，对外部只暴露公共的、规范的接口和调用方法，从而隐藏实现细节，使在使用的时候不用去考虑其内部的运作模式等等具体细节。以后即使是要修改其逻辑也不会影响外部调用的，称为封装，主要是为了降低组件之间的耦合度，以提高扩展性和维护性。 

这是面向对象编程的第一个特征，封装性。
封装就是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。
封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。 

（2）多态性
接口的多种不同的实现方式即为多态。
同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。
多态性通过派生类重载基类中的虚函数型方法来实现。 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public class DrawingObject 
{ 
    public virtual void Draw() 
    { 
        Console.WriteLine("I'm just a generic drawing object."); 
    } 
} 
public class Line : DrawingObject 
{ 
    public override void Draw() 
    { 
        Console.WriteLine("I'm a Line."); 
    } 
} 

public class Circle : DrawingObject 
{ 
    public override void Draw() 
    { 
        Console.WriteLine("I'm a Circle."); 
    } 
} 

public class Square : DrawingObject 
{ 
    public override void Draw() 
    { 
        Console.WriteLine("I'm a Square."); 
    } 
} 



public class DrawDemo 
{ 
public static int Main(string[] args) 
{ 
    DrawingObject[] dObj = new DrawingObject[4]; 
    dObj[0] = new Line(); 
    dObj[1] = new Circle(); 
    dObj[2] = new Square(); 
    dObj[3] = new DrawingObject(); 
    foreach (DrawingObject drawObj in dObj) 
    { 
        drawObj.Draw(); 
    } 
    return 0; 
    } 
}
result:
I'm a Line. 
I'm a Circle. 
I'm a Square. 
I'm just a generic drawing object. 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


（3）继承
一个自定义类，并想不需要实例化该类，而直接调用类中的方法时，有三种方法：
1、定义一个静态方法
2、使用方法时直接使用(new className).method();
3、让调用的类继承此类，具体方法如下：
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
namespace GrcFrameWork
{
//定义类
    public class GrcCommmon
    {
        public void Alert(string AlertText, string Code)
        {
        }
    }
//实例化类
    public abstract class GrcPage
    {
        public GrcCommmon grcCommon//此为一个属性（只读）
        {
            get
            {
                return new GrcCommmon();
            }
        }
    }
}

//调用
public partial class myClass : GrcFrameWork.GrcPage
{
    protected void Page_Load(object sender, EventArgs e)
    {
        grcCommon.Alert("", "")
    }
}

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


3、事件
对象可以激活事件，作为它们处理的一部分。
使用事件可以创建事件驱动的应用程序，这类应用程序比读者此时所能想到的多得多。例如，许多基于Windows的应用程序完全依赖于事件。每个按钮单击或滚动条拖动操作都是通过事件处理实现的，其中事件是通过鼠标或键盘触发的。

4、三层架构
ASP.NET中“三层架构”的开发方法，其思想跟JAVA的类似，JAVA中的三层架构为前端的Html、Jsp、Serlet，中间层为JavaBean、EJB，后面为数据库服务器。在ASP.NET中，前端为HTML、asp、aspx等，中间层为.vb、.cs等文件编译而成的.dll控件，后面为数据库服务器。 
在三层架构中，数据层通过中间层来连接以及操作，前端给中间层传递参数，并接受中间层的返回值。一般情况下，主要关注的是中间层与前端的数据交互，中间层可被称为组件，一般为.dll文件。在ASP.NET中.dll文件不用考虑注册的问题，拷贝过来就可以用。 
在设计模式上，三层架构的三层分别成为：表示层，业务层和数据层。 
（1）表示层： 
    提供应用程序的用户界面，通常也包括Window窗体和ASP.NET页面的使用。 
（2）业务层： 
    业务层实现应用程序的业务功能。 
（3）数据层： 
    数据层提供对外部系统（如数据库）的访问，该层涉及到的主要.NET技术是ADO.NET的数据库访问技术． 
5、CS/BS架构
首先咱们讨论一下文件上传下载系统的目的和要求：使用方便、管理方便、安全。
若想使用方便，应该是客户端免安装的，所以，使用CS结构并不合理，除非使用通用工具，比如成熟的ftp工具。
管理方便，如你理解，服务器管理用BS模式，好处就是管理员可以漫游，便于管理，然而管理员有没有全球漫游的必要？
但由于BS不需要专门的客户端，因此受攻击的可能性更大。
综上所述，我觉得你的理解不一定正确，最好问一下你的指导老师。你可以在看完下面的内容后再问。
不管怎末说，说服务器端用BS模式、客户端用CS模式的说法是显然不对的，你补充的，尽管经过上面分析，不一定合理，但还是语义还是没有问题，即服务器管理用BS模式，用户使用CS模式完成上传下载。 
如果一定要按你说的做，需要一下知识和技术：
（1）CS架构：
首先，工程上，应该采用成熟的FTP客户端工具作为首选方案。服务器上则使用ServerU或IIS等FTP服务器端工具。
如果一定要自己开发，应该学习Sockets编程、Windows服务项目的开发，服务器端用Windows服务打开监听线程，接受客户端连接，并将客户端请求存入队列（System.Collections.Queue对象），等待主线程处理，主线程处理请求，并调用通信线程发送文件数据。
客户端使用同样的结构，主线程发送请求，并处理队列中的数据，并存为文件，通信线程负责用同样的端口连接服务器，发送请求，接收服务器发来的文件数据。
显然，这需要定义协议结构，或者使用FTP协议规程。
（2）BS架构管理服务器：
用ASP.NET开发网站，对提供下载的目录进行列表，允许网站用户删除、重命名、移动、复制、上传（创建）、下载（读取）文件和子目录，也就是说，编写一个资源管理器的Web实现。
需要了解IIS发布网站、System.IO命名空间下的文件和目录管理操作。为了网站安全，应该使用身份验证。
总之，这时一个很复杂的系统。
反之，如果用户使用BS模式上传、下载，管理员使用CS模式在局域网中进行管理，则简单得多。更具可行性、可用性、可靠性。网页中只需要FileUpLoad控件进行上传，GridView控件列出文件允许下载即可。管理界面中则只需要TreeView、ListView等控件以NetBios机器名或IP地址，通过服务器的Windows身份验证，模拟一个资源管理器即可。
哪怕是性能等价的，两种方案的工作量则相差比加大。所以我说你的老师不会如此布置。


16、浮点类型误差
I.问题描述之一
float a = 0.65f;
float b = 0.6f;
float c = a - b;
Console.WriteLine(c);
结果：
0.0499999523
其根本原因是计算机所使用二进制01代码无法准确表示某些带小数位的十进制数据。


II.问题描述之二
#include <stdio.h>
main()
{
    float a,b,c;
    a = 0.99999999;
    b = 1.0;
    if(a == b)
        printf("equal!");
    getch();
}
结果：
equal!

III.原理解析
将一个十进制数值转换为二进制数值，需要通过下面的计算方法：
1.整数部分：连续用该整数除以2，取余数，然后商再除以2，直到商等于0为止。然后把得到的各个余数按相反的顺序排列。简称"除2取余法"。
2.小数部分：十进制小数转换为二进制小数，采用"乘2取整，顺序排列"法。用2乘以十进制小数，将得到的整数部分取出，再用2乘余下的小数部分，然后再将积的整数部分取出，如此进行，直到积中的小数部分为0或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，即先取出的整数部分作为二进制小数的高位，后取出的整数部分作为低位有效位。简称"乘2取整法"。
3.含有小数的十进制数转换成二进制，整数、小数部分分别进行转换，然后相加。

eg.
将十进制数值25.75转换为二进制数值，步骤如下：
25(整数部分)
25/2=12......1
12/2=6.......0
6/2=3......0
3/2=1......1
1/2=0......1
(25) 10=(11001) 2
0.75(小数部分)
0.75*2=1.5......1
0.5*2=1......1
(0.75) 10=(0.11) 2
(25.75) 10=(11001) 2+(0.11) 2=(11001.11) 2
按照上述方法，我们将0.65及0.6转换为二进制代码：
(0.65)10 = (0.101001100110011001100110011001100110011......)2
(0.6) 10 = (0.10011001100110011001100110011001100110011......)2

★IEEE754标准
  既然有的十进制小数用二进制是永远也无法精确表示的，那么为此浪费过多的存储空间没有意义，所以对小数的存储有了精度的规定，精度即小数部分的位数。而且，实际应用中的小数通常用科学计数法表示，例如1.0*10^2，0.1*10^3，0.01*10^4都可以表示100。小数点位置的浮动和不同指数搭配而成的不同记法可以表示同一个数，这也是小数被成为浮点数的原因。因为在浮点数的存储上有这些问题导致不统一，所以必须要有一个标准来规范它。
  国际上通用的标准为IEEE754标准：
  IEEE754标准规定一个实数V可以用V＝(－1)s×M×2^E的形式表示，说明如下：
    (1)符号s(sign)决定实数是正数(s＝0)还是负数(s＝1)，对数值0的符号位特殊处理。
    (2)有效数字M是二进制小数，M的取值范围在1≤M＜2或0≤M＜1。
    (3)指数E（exponent）是2的幂，它的作用是对浮点数加权。
  其中1≤M＜2且指数部分E的各位不全为0也不全为1的表示称为规格化浮点数。








二、对象类型
A、常用类型操作
1、取得
（1）typeof()
System.Type type = typeof(int);
（2）GetType
Int32 i = new Int32();
i.GetType();
i.GetType().IsValueType
（3）GetType和typeof的区别
1）概念
typeof: The typeof operator is used to obtain the System.Type object for a type.
运算符，获得某一类型的 System.Type 对象。
GetType: Gets the Type of the current instance.
方法，获取当前实例的类型。
2）归属自不同的类
GetType()是基类System.Object的方法，因此只有建立一个实例之后才能够被调用（初始化以后）；
typeof()的参数只能是int，string，String，自定义类型，且不能是实例 
3）使用对象
GetType() 和typeof()都返回System.Type的引用，但是
typeOf()是得到一个Class的Type
GetType()是得到一个当前实例的Type
例：
if(myobj.GetType() == typeof(MyComplexClass)) {}

2、sizeof()
    确定堆栈中值类型需要的长度，如：sizeof(int)  为4

3、判断
（1）is（相当于java中的instanceof）
    检查对象是否与特定的类型“兼容”，“兼容”表示对象是该类型，或者派生于该类型，返回true和false。如果一个对象是某个类型或是其父类型的话就返回为true，否则的话就会返回为false。另外is操作符永远不会抛出异常。代码如下：
System.Boolean b1 = (o is System.Object);//b1 为true
System.Boolean b2 = (o is Employee);//b2为false
如果对象引用为null，那么is操作符总是返回为false，因为没有对象可以检查其类型。
（2）as
    就是对类型的转换，如果类型相同，就进行转换，返回一个非空类型的引用；如果类型不同，就返回null，代码如下：
Employee e = o as Employee;
if(e != null)
{
    //在if语句中使用e
}

（3）反射方式
var instance = ...;
System.Boolean b = typeof(string).IsAssignableFrom(instance.getType());



B、基本类型转换
1、数值转换
（1）进制转换
 (int).toString(16); // converts int to hex, eg 12 => "C"
 (int).toString(8);  // converts int to octal, eg. 12 => "14"
 parseInt(string, 16) // converts hex to int, eg. "FF" => 255
 parseInt(string, 8) // converts octal to int, eg. "20" => 16
（2）数值转换溢出
低－>高，直接隐式转换即可，不需考虑数据范围问题。（当然，显式也可以，但不必要）
高－>低，须进行显式转换，转换过程中，如果数据超出范围会溢出。
byte ushort, short int, uint long, ulong float double, decimal
sbyte short int long float double或decimal
char ushort int long ulong float double decimal
注：
bool和string类型没有隐式转换
char存储的是数值，所以被当作一个数值类型

val.ToString()
Convert.ToString(val)    检查溢出    允许Convert.ToInt32(null) 
string.Parse(val)        无视类型    不允许int.Parse(null) 只能转换string类型
(string)val              不检查溢出显式
unchecked((string)val)   不检查溢出
checked((string)val)     检查溢出
unchecked{}              不检查溢出
checked{}                检查溢出

（3）四舍五入
Math.Round(d, decimals, MidpointRounding.AwayFromZero)             //d被舍数，decimals保留位数

2、string转换
（1）Convert.ToString()
obj为null时，结果返回空。
（2）obj.ToString()
obj为null时，结果会导致NullReferenceException异常。
（3）强制转换(string)obj
要求obj运行时类型必须是 string，否则抛异常。
（4）as
当obj运行时，如类型不是string时会返回null，而不抛出异常。

3、int转换
（1）Convert.ToInt32
参数为 null 时，返回 0。
参数为 "" 时，抛出异常。
可以转换的类型较多。
与 int.Parse 较为类似，实际上 Convert.ToInt32 内部调用了 int.Parse。
（2）int.Parse（Int32.Parse）
参数为 null 时，抛出异常。
参数为 "" 时，抛出异常。
int.Parse 只能转换数字类型的字符串。
（3）int.TryParse
它不会产生异常，转换成功返回 true，转换失败返回 false。最后一个参数为输出值，如果转换失败，输出值为 0。
（4）(int) 
属 cast 转换，只能将其它数字类型转换成 int 类型，它不能转换字符串，比如下例就会失败：
int n = (int)"1";
（5）判断是否为数字
     bool isNum=System.Double.TryParse("所要判断的字符串"  ,System.Globalization.NumberStyles.Integer,null,out );

4、string<->char[]转换
string str = "mytest";
char[] chars = str.ToCharArray();
char c = str[3];

char[] tcs = {'t', 'e', 's', 't', ' ', 'm', 'e'};
string tstr = new String(tcs);



C、隐式与显式
C#语言中数据类型的转换可以用分为两类：隐式转换(implicit conversions)和显式转换(explicit conversions)。
显式转换：也叫强制转换，明确要求编译器把数值从一种数据类型转换为另一种数据类型，转换过程不能保证数据的完整性，可能引起一定的精度损失或者引起不可知的异常发生。
1、显式与隐式转换
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
int a=0;
double b=a;//隐式
double c=static_cast<double>(a);//显式
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
第二行就是将整形变量a隐式地转换为double型变量并赋给了b；而第三行，自然就是显式地进行类型转换了。
2、显式调用和隐式调用
显式调用和隐式调用的区别和实例：
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public class MyClass : IMyInterface
{
    void IMyInterface.DoSomething()
    {
    }
    public void DoSomethingElse()
    {
    }
}
//此为隐式调用
  MyClass myObj = new MyClass();
  myObj.DoSomething();          //如此调用会错错
  myObj.DoSomethingElse();
//此为显式调用
  IMyInterface myInt = myObj;   //或IMyInterface myInt = new MyClass();
  myInt.DoSomethingElse();      //如此调用会错错
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



D、值类型与引用类型
1、数据的值类型与引用类型

                                                类型
                值类型                                                       引用类型
        内置值类型、用户定义的值类型、枚举           自描述类型           指针类型            接口类型
                                                  类类型     数组

值类型：
·简单类型：有符号整型（sbyte、short、int、long）、无符号整型（byte、ushort、uint、ulong）、Unicode字符（char）、IEEE浮点型（float、double）、高精度小数（decimal）、布尔型（bool）
·枚举类型：用户自定义类型（enum）
·结构类型：用户自定义类型（struct）
引用类型：
·类类型：所有其他类型的最终基类（object）、Unicode字符串（string）、用户自定义类型（class）
·接口类型：用户自定义类型（interface）
·数组类型：单维与多维数组（[]、[,]）
·委托类型：用户自定义类型（delegate）

（1）常见值类型：
StringBuilder、结构体（数值类型，bool型，用户定义的结构体），枚举，可空类型。
int a = 5; // stack给a分配空间，并且初始化为5
int b = a; // stack给b分配空间，并且将a的值作为初始值，这时候，a和b可以分别改变其值，而不会对另一方造成影响
int c; // stack给c分配空间，无初始值，直接使用编译器报错
（2）常见引用类型：
数组、用户定义的类、接口、委托，object，字符串。
数组的元素，不管是引用类型还是值类型，都存储在托管堆上。
（3）区别
<1>值类型。
1.值类型是在栈中分配内存，在声明时初始化才能使用，不能为null。
2.值类型超出作用范围系统自动释放内存。
3.主要由两类组成：结构，枚举（enum），结构分为以下几类：
    （1）整型（Sbyte、Byte、Char、Short、Ushort、Int、Uint、Long、Ulong）
    （2）浮点型（Float、Double）
    （3）decimal
    （4）bool
    （5）用户定义的结构（struct）
<2>引用类型。
1.引用类型在堆中分配内存，初始化时默认为null。
2.引用类型是通过垃圾回收机制进行回收。
3.包括类、接口、委托、数组以及内置引用类型object与string。
<3>更多的区别
•值类型继承自ValueType（注意：而System.ValueType又继承自System.Object）；而引用类型继承自System.Object。 
•值类型变量包含其实例数据，每个变量保存了其本身的数据拷贝（副本），因此在默认情况下，值类型的参数传递不会影响参数本身；而引用类型变量保存了其数据的引用地址，因此以引用方式进行参数传递时会影响到参数本身，因为两个变量会引用了内存中的同一块地址。 
•值类型有两种表示：装箱与拆箱；引用类型只有装箱一种形式。我会在下节以专门的篇幅来深入讨论这个话题。 
•典型的值类型为：struct，enum以及大量的内置值类型；而能称为类的都可以说是引用类型。 struct和class主要的区别可以参见我的拙作《第四回：后来居上：class和struct》来详细了解，也是对值类型和引用类型在应用方面的有力补充。 
•值类型的内存不由GC（垃圾回收，Gabage Collection）控制，作用域结束时，值类型会自行释放，减少了托管堆的压力，因此具有性能上的优势。例如，通常struct比class更高效；而引用类型的内存回收，由GC来完成，微软甚至建议用户最好不要自行释放内存。 
•值类型是密封的（sealed），因此值类型不能作为其他任何类型的基类，但是可以单继承或者多继承接口；而引用类型一般都有继承性。  
•值类型不具有多态性；而引用类型有多态性。 
•值类型变量不可为null值，值类型都会自行初始化为0值；而引用类型变量默认情况下，创建为null值，表示没有指向任何托管堆的引用地址。对值为null的引用类型的任何操作，都会抛出NullReferenceException异常。 
•值类型有两种状态：装箱和未装箱，运行库提供了所有值类型的已装箱形式；而引用类型通常只有一种形式：装箱。
★通常可以使用Type.IsValueType来判断一个变量的类型是否为值类型
★sizeof()运算符用于获取值类型的大小，但是不适用于引用类型。 
¤堆与栈
Heap是堆，空间是由手动操作分配和释放的，它的存储区很大的自由存储区。
Stack是栈，是由是操作系统自动分配和释放的，栈上的空间是有限的。程序在编译期间变量和函数分配内存都是在栈上进行的，且在运行时函数调用时的参数的传递也是在栈上进行的。

（4）装箱与拆箱
装箱：一个值类型转换为引用类型（object）
拆箱：一个引用类型（object）转换成一个值类型
※装箱会重新分配地址
如：
int a = 99;
object c = a;
object d = a;
object e = c;
c与d值相等，但指向不相同。---重新分配新地址，相当于用了new
c与e则完全相同。---不重新分配新地址
注：string类型虽然许多方法被重写，但仍为引用类型，转为object类型时，不重新分配新地址
所以
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
            string aString = "123";
            string bString = "123";
            Console.WriteLine((aString == bString)); //显示为true，等价于aString.Equals(bString)；
            string cString = bString;
            cString = "456";
            Console.WriteLine((bString == cString)); //显示为false，等价于bString.Equals(cString)；
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

（5）深度复制与浅度复制
<1>概念
    a.浅拷贝(Shallow Copy影子克隆)：只复制对象的基本类型，对象类型，仍属于原来的引用。
    b.深拷贝(Deep Copy 深度克隆)：不紧复制对象的基本类，同时也复制原对象中的对象.完全产生新对象。
<2>区别
对于值类型：
    a.浅拷贝：通过赋值等操作直接实现，将对象中的值类型的字段拷贝到新的对象中。
    b.深拷贝：通过赋值等操作直接实现，将对象中的值类型的字段拷贝到新的对象中。和浅拷贝相同
对于引用类型：
    a.浅拷贝： MemberwiseClone 方法创建一个浅副本，方法是创建一个新对象，如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用原始对象，与原对象引用同一对象。
    b.深拷贝：拷贝对象应用，也拷贝对象实际内容，也就是创建了一个新的改变新对象 不会影响到原始对象的内容 


3、类型比较
（0）相等性
C#中有三种“相等性”：
引用相等：多个进行比较的对象引用指向同一个对象。
按位相等：多个进行比较的对象具有相同的二进制表示形式。
值相等：多个进行比较的对象具有相同的值，即使他们具有不同的二进制表示形式。

I.静态方式
System.Object中，实现相等性判断的还有两个静态方法：
public static bool Equals(object objA, object objB);
public static bool ReferenceEquals(object objA, object objB);
Equals(Object)默认实现：对于引用类型，引用相等；对于值类型，按位相等。派生类可重写此方法，以实现值相等。
Equals(object objA, object objB)实现：对于引用类型，引用相等；对于值类型，按位相等。
ReferenceEquals()实现：引用相等。注意：如果进行比较的对象是值类型，须先装箱，再比较。所以，为值类型对象调用ReferenceEquals()方法将总是返回False。
¤静态的Equals本质上也是调用虚拟的Equals，它们的区别在于调用时，虚拟的要考虑对象是否为空，否则会抛异常，而静态的则无需考虑。

II.动态方式
（1）ReferenceEquals(x, y);//针对引用类型（是否“相同”），针对值类型（总是返回False）
    1）对于值类型它总是返回False。
    2）ReferenceEquals是Object的静态方法，用于比较两个引用类型的对象是否是对于同一个对象的引用。
（2）x == y;//针对引用类型（是否相同，String除外）、针对值类型（是否相似）
    1）对于值类型，判断两个对象是否“相似”，即代数值是否“相等”。它会根据需要自动进行必要的类型转换，并根据两个对象的值是否相等返回True或者False，2.00与2相等。
    2）对于引用类型，默认的行为与ReferenceEquals的行为相同，仅有两个对象指向同一个Reference的时候才返回True。但是.NET Framework中的类很多对 == 进行了重载，例如String类的 == 与Equals的行为相同，判断两个字符串的内容是否相等。所以在应用中，对于系统定义的引用类型建议不要使用==操作符，以免程序出现与预期不同的运行结果。 
（3）x.Equals(y)|Object.Equals(x, y);//针对引用类型、相同值类型（数值类型相同），Equals都实现了GetHashCode()
    1）对于值类型，判断两个对象的“值”是否“相等”(对于struct的每个成员都必须相同)，2.00与2不相同。
    2）对于引用类型，比较的是两个对象“引用的值”是否“相等”。即：object o1 = 1; object o2 = 1; o1.Equals(o2); 结果是True。
总结：
ReferenceEquals比较引用是否“相同”。
Equals比较值是否“相等”。
==会动态判断是“值类型”还是“引用类型”，值类型比较值，引用类型比较引用（但string除外，比较值）。

允许重写Equals(Object)方法给程序员留下了很大的空间。比如，对于Point对象，x和y必须相等。然而，对于Student对象，可能比较ID就足够了。所以，如果想构建可靠性高、性能良好的类，你需要重写它。同时，你需要重写GetHashCode()，实现==运算符和!=运算符。重写Equals(Object)，而不重写GetHashCode()，编译器会显示一条警告信息。一个类型在Equals(Object)。==和!=实现中应该使用相同的算法。Equals(Object)，GetHashCode()，==和!=永远不能引发异常。

※ReferenceEquals的例外
string name1 = "Jack";
string name2 = "Jack";
object o1 = name1;
object o2 = name2;

Console.WriteLine("name1 ReferenceEquals name2: {0}", object.ReferenceEquals(name1, name2));            //True
Console.WriteLine("o1 ReferenceEquals o2: {0}", object.ReferenceEquals(o1, o2));                        //True

由于string类型的特殊性，CLR可以通过一个string对象共享多个完全一致的string内容，所以上面的name1和name2指向的地方是一样的。

E、char
字符类型
char Letter=(char)65;    //Letter=A
char Letter=(char)91;    //Letter=Z
char Letter=(char)97;    //Letter=a
char Letter=(char)123;   //Letter=z



E、数字
随机数：new Random().Next(NO1, NO2);    //返回一个大于等于NO1，小于NO2的整数
伪随机数：new Random().Next(5);         //会发现每次得到的值都相同
随机数种子：从1、2、3、4、5、6、7、8、9、0这十个数中随机取出一个数，取出的数是6的话，那么6就叫随机数。十个数字就叫随机数种子。
Random rand = new Random(Guid.NewGuid().GetHashCode());
Random random=new Random(Environment.TickCount);

//并发随机数种子
public int Seed()
{
    byte[] bytes = new byte[4];
    System.Security.Cryptography.RNGCryptoServiceProvider rng = new System.Security.Cryptography.RNGCryptoServiceProvider();
    rng.GetBytes(bytes);
    return System.Math.Abs(BitConverter.ToInt32(bytes, 0));
}


F、字符串
1、StringBuilder
StringBuilder s = new StringBuilder(); // stack给s分配空间，存入指向heap的地址，并初始化heap
StringBuilder k = s; // stack给k分配空间，将s在stack中的地址拷贝到k，这时候，s和k指向相同的heap位置
// 这种情况下，任何一方改变了heap中的值，都会对另一方造成影响。

            StringBuilder s = new StringBuilder(); 
            StringBuilder k = s; 
            s.Append("123");
            MessageBox.Show("s1 is " + s);
            MessageBox.Show("s2 is " + k);
            k.Append("456");
            MessageBox.Show("s1 is " + s);
            MessageBox.Show("s2 is " + k);
result:
s1 is 123
s2 is 123
s1 is 123 456
s2 is 123 456

2、String
（1）C#中的string是一个引用类型，String对象是存放在堆上，而不是堆栈上的，因此，当把一个字符串变量赋给另一个字符串时，会得到对内存中同一个字符串的两个引用。但是大家有没有想过，为什么修改其中一个字符串，另外一个不受影响呢？
原来，当我们把一个字符串变量赋给另一个字符串时，就会创建一个全新的String对象，就是说这个时候就会有两个对象，比如：
            string s1 =null;                            //==> s1----->new String(null) 
            object s2 = s1;                             //==> s2----->s1
            Console.WriteLine( "s1 is "+ s1 );          
            Console.WriteLine( "s2 is "+ s2 );
            s1 = "original";                            //==> s1----->new String("original") 
            Console.WriteLine( "s1 is "+ s1 );
            Console.WriteLine( "s2 is "+ s2 );
            s2 = "changed";                             //==> s2----->new String("changed") 
            Console.WriteLine( "s1 is "+ s1 );
            Console.WriteLine( "s2 is "+ s2 );
result:
s1 is 
s2 is 
s1 is original
s2 is 
s1 is changed
s2 is original
改变s1的值并没有对s2造成任何影响，这与我们平时所说的引用类型的行为正好相反。
当用值null初始化s1时，就在堆上分配了一个String对象。
当用值"original"赋予s1时，就在新堆上分配了一个String对象，将s1新的指针地址由指向null变为指向"original"，s2仍指向null。
在用值"changed"赋予s2时，将会为s2分配一个新地址，s2的指针变为指向"original"，s1仍指向"original"。

（2）另外，如果我们像下面这样：
string str1 = "abc";
string str2 = "abc";
当我们用System.Object.Equals(str1, str2)比较时，返回值是true;按理说str1和str2应该指向不同的空间，应该返回false才对啊。原来Equals有三个版本:

public override bool Equals(object);
public bool Equals(string);
public static bool Equals(string, string);

前两个实例方法内部会调用CompareOrdinal静态方法，它会字符串中的各个字符，如果相等就返回true。第三个首先会检查两个引用指向的是否是同一个对象，如果是，就返回true，不再去比较各个字符了。
其实CLR使用了一种叫字符串驻留的技术，对于
string str1="abc";
string str2="abc";
当CLR初始化时，会创建一个内部的散列表，其中的键为字符串，值为指向托管堆中字符串的引用。刚开始，散列表为空，JIT编译器编译方法时，会在散列表中查找每一个文本常量字符串，首先会查找"abc"字符串，并且因为没有找到，编译器会在托管堆中构造一个新的指向"abc"的String对象引用，然后将"abc"字符串和指向该对象的引用添加到散列表中。
接着，在散列表中查找第二个"abc"，这一次由于找到了该字符串，所以编译器不会执行任何操作，代码中再没有其它的文本常量字符串，编译器的任务完成，代码开始执行。执行时，CLR发现第一个语句需要一个"abc"字符串引用，于是，CLR会在内部的散列表中查找"abc"，并且会找到，这样指向先前创建的String对象的引用就被保存在变量s1中，执行第二条语句时，CLR会再一次在散列表中查找"abc"，并且仍然会找到，指向同一个String对象的引用会被保存在变量s2中，到此s1和s2指向了同一个引用，所以System.Object.Equals(s1, s2)就会返回true了。
另外，C#中是不允许用new操作符创建String对象的，编译器会报错。

类似的：
Dataset ds = new Dataset();创建了1个Dataset Object:
首先new Dataset()在内存中开辟了一个Dataset Object 空间，值=null
其次ds是引用类型，Dataset ds在内存中申明是引用类型，不占用空间，引用了new Dataset()的null值


H、类（Class）
1、类
class就是传引用，请与前面string对比进行查看
        class MyClass { public int val;}
        class class 
        {
            MyClass objectA = new MyClass();             //==> objectA----->new String("")
            MyClass objectB = objectA;                   //==> objectB----->objectA
            objectA.val = 10;
            objectB.val = 20;
            MessageBox.Show("objectA is " + objectA.val);
            MessageBox.Show("objectB is " + objectB.val);
            objectA.val = 20;
            objectB.val = 10;
            MessageBox.Show("objectA is " + objectA.val);
            MessageBox.Show("objectB is " + objectB.val);
        }
result:
objectA is 20
objectB is 20
objectA is 10
objectB is 10

与string相同的是：将objectA的值赋予objectB时，传递的也是地址
与string不同的是：尽管objectB是引用类型，但objectB.val是数值类型，当objectB.val改变时，改变的是objectB.val的值，objectB的引用地址不变，同时objectA的引用地址也不变，因此objectA 、objectB都是指向同一个地址，当其中一个.val的值改变时，另一个也会发生变化。所以string赋值引用地址会发生改变，对象objectB.val赋值objectB的引用地址不发生改变。

★类的声明同时赋值
    class enumeric {
        public int n1;
        public int n2;
        public int n3;
    }
    enumeric e = new enumeric { n1 = 1, n2 = 2 };

另：子类=继承类=派生类，父类=基类=超类
2、类的类型
（1）静态类，如果类只包含静态的方法和属性，该类就是静态的。静态类在功能上与使用私有静态函数创建的类相同。不能创建静态类的实例，静态类不能被继承。使用static关键字，编译器可以检查以后是否给该类添加了实例成员，这可以确保不创建静态类的实例。
（2）部分类，partial关键字允许类，接口或结构放在多个文件中，这样做的好处：
    1）一个大型的项目类可以同时分成不同的区块交由不同的程序员拽写，同时进行
    2）若有系统自动产生source，可以用独立的Partial Class加入，而不用更改原先的类
    3）当类很大时，可以用Partial Class做功能性划分，这也是一种不错的分类方式
    如果在声明类时使用了以下的关键字，这些类将用于同一个类的所有部分:
    public, private, protected, internal, abstract, sealed, new
    在把部分类编译到类型中时，会合并属性，XML 注释，接口，泛型类型的参数属性和成员。
（3）匿名类，匿名类型只是一个继承了Object的，没有名字的类。该类得定义初始化器中推断，类似于隐式类型化的变量。
（4）内部类，C#中的内部类能够使用外部类定义的类型和静态方法，但是不直接使用外部类的实例方法，直接看来，外部类的作用更像是一个命名空间，在C#中，始终可以用Sys.Model.Key key = new Sys.Model.Key();来创建一个内部类的实例，这个实例与外部类的任何实例没有任何直接的关系。类似于Java中的静态内部类。
    C#中，类分为Nested Class和Non-Nested Class，前者是声明在其他数据类型内部的类。后者是直接定义在某一命名空间的类。
    非嵌套类只允许使用public和internal的访问控制，而内置类则允许使用所有的5种访问修饰符。内部类也可以访问外部类的所有方法，包括instance方法和private方法，但是需要显示的传递一个外部类的实例。
    内部类的反射名称的.改为+，例如Sys.Model+Key[其中Key是Model的内部类]。
（5）抽象类，C#中允许将类和方法声明为abstract，抽象类不能实例化，而抽象函数没有执行代码，必须由非抽象的派生类中重写。如果类包含抽象函数，该类也是抽象的，也必须声明为抽象的。抽象类不能被密封。
（6）密封类，C#中把类和方法声明为sealed。对于类来说，这表示不能继承该类；对于方法来说，表示不能重写该方法。当用于方法或属性时，sealed修饰符必须始终与override一起使用.NET基类库大量使用了密封类，使希望从这些类中派生出自己类的第三方开发人员无法访问这些类，Java开发人员可以把C#中的sealed当作Java中的final。



Codes:
    class Program
    {
        static void Main(string[] args)
        {
            PartialClass partialClass = new PartialClass();
            Console.WriteLine(partialClass.Method("Xufei"));
            Console.WriteLine();
 
            InstanceClass instanceClass = new ChildClass();
            InstanceClass instanceClass1 = new InstanceClass();
            Console.WriteLine(instanceClass1.Method("Xufei"));
            Console.WriteLine(instanceClass.Method("Xufei"));
            Console.WriteLine();
 
            Console.WriteLine(StaticClass.Method());
            Console.WriteLine();
 
            InstanceClass.NestedClass nestedClass = new InstanceClass.NestedClass();
            Console.WriteLine(nestedClass.Method("Xufei"));
            Console.WriteLine();
 
            InstanceClass.NestedClass nestedClass2 = InstanceClass.nestedClass;
            Console.WriteLine(nestedClass2.Method());
            Console.WriteLine();
 
            Console.WriteLine(instanceClass.Method());
            Console.ReadKey();
        }
    }
    /// <summary>
    /// 普通类
    /// </summary>
    class InstanceClass
    {
        public static NestedClass nestedClass;
        public virtual string Method(string str)
        {
            return str;
        }
        static InstanceClass()
        {
            nestedClass = new NestedClass("Xufei");
        }
        /// <summary>
        /// 匿名类dynamicClass
        /// </summary>
        /// <returns></returns>
        public string Method()
        {
            var dynamicClass = new { name = "Xufei", hometown = "Liayang" };
            return dynamicClass.name;
        }
        /// <summary>
        /// 内部类
        /// </summary>
        public class NestedClass
        {
            string str;
            public string Method()
            {
                InstanceClass instanceClass = new InstanceClass();
                return instanceClass.Method(str);
            }
            public string Method(string str)
            {
                InstanceClass instanceClass = new InstanceClass();
                return instanceClass.Method(str);
            }
            public NestedClass() { }
            public NestedClass(string theStr) 
            {
                str=theStr;
            }
        }
    }
    /// <summary>
    /// 子类
    /// </summary>
    class ChildClass : InstanceClass
    {
        public sealed override string Method(string str)
        {
            return str + " Fan";
        }
    }
    /// <summary>
    /// 静态类
    /// </summary>
    static class StaticClass
    {
        private static string str;
        public static string Method()
        {
            return str;
        }
        static StaticClass()
        {
            str = "Xufei";
        }
    }
    /// <summary>
    /// 抽象类
    /// </summary>
    abstract class AbstractClass
    {
        public abstract void Method();
        public virtual string Method(string str) 
        { 
            return str; 
        }
    }
    /// <summary>
    /// 密封类
    /// </summary>
    sealed class SealedClass : AbstractClass
    {
        public sealed override void Method(){}
        public sealed override string Method(string str)
        {
            return base.Method(str);
        }
    }
    /// <summary>
    /// 部分类
    /// </summary>
    partial class PartialClass
    {
        public void Method() { }
    }
    partial class PartialClass
    {
        public string Method(string str)
        {
            return str;
        }
    }



★想要在类中返回另一个类，但又不希望这个类是共用的，可以使用内部类。
class TestClass
{
    public void dest(String s)
    {
        class PDestination(String whereTO)
        {
            label = whereTo;
        }
        public String readLabel()
        {
            return label;
        }
    }

    public static void main(String[] args)
    {
        TestClass P = new TestClass();
        P.dest("Tanzania");
    }
}


3、构造方法
（1）定义
构造方法是在创建给定类型的对象时执行的类方法。构造方法具有与类相同的名称，它通常初始化新对象的数据成员。
（2）格式
构造方法： public(修饰符) + 名称（必须与类名相同） 
public MethodName()
函数声明： public(修饰符) + 返回值 + 名称(不能与类名相同)
public void MethodName()
（3）静态构造方法
静态构造方法用于初始化类，在创建第一个实例或引用任何静态成员之前，将自动调用静态构造方法来初始化类。
public class MyClass
{
    static MyClass()
    {
    }
}
（4）注意事项
函数必须要有返回值类型（即使为void），但构造方法是没有void这个关键字的
※静态构造方法：
  1）添加static关键字，既没有访问修饰符，也没有参数。因为是.NET调用的，所以像public和private等修饰符就没有意义了。
  2）在创建此类的第一个实例或引用任何静态成员之前，.NET将自动调用静态构造方法来初始化类，且在给定应用程序域中至多执行一次。
  3）一个类只能有一个静态构造方法，编译器自动将静态字段、只读字段等的初始化放在其中。如果没有编写静态构造方法，而这时类中包含带有初始值设定的静态字段，那么编译器会自动生成默认的静态构造方法。 
  4）无参数的构造方法可以与静态构造方法共存。尽管参数列表相同，但一个属于类，一个属于实例，所以不会冲突。
  5）静态构造方法是不可继承的，而且不能被直接调用。
（5）继承中构造方法的调用顺序
在C#中，父类与子类构造方法的初始化顺序为：
----子类----|----父类----|
静态代码
成员变量

构造方法
--------]------静态代码
        ]------成员变量
        ]------]构造方法
        ]      ]
        ]------]
        ]
        ]
        ]
--------]

         子类                父类
  1）子类静态代码
  2）子类成员变量
  3）                    父类静态代码
  4）                    父类成员变量
  5）                    父类构造方法
  6）                    如在父类构造方法中调用了override的子类方法，会调用该子类方法
  7）子类构造方法

------------------------------------------------------------------------------------------------------------------------
在JAVA中，父类与子类构造方法的调用顺序为：
----子类----|----父类----|
             静态代码
静态代码

构造方法        构造方法
--------]------]成员变量
        ]      ]
        ]      ]
        ]------]
        ]成员变量
        ]
        ]
--------]


静态
  1）                    父类静态代码
  2）子类静态代码
动态
  1）                    父类成员变量
  2）                    父类构造方法
  3）                    如在父类构造方法中调用了override的子类方法，会调用该子类方法，如该子类方法中引用了其本身内部的成员变量，并不初始化子类中的成员变量
  4）子类成员变量
  5）子类构造方法



※
区别：对继承关系，C#是先初始化子类构造方法，再初始化父类构造方法；JAVA是先初始化父类构造方法，再初始化子类构造方法
相同：对于单级类型，都是先初始化成员变量，再初始化构造方法
（6）构造方法的继承
class aa(int a, int b)
{
}
class bb(int x, int y) : aa(x, y)
{
}



（7）构造方法内部调用顺序
例1：（C#）
例例例例例例例例例例例例例例例例例例
abstract class parent
{
    public abstract void fun();
    private int parentint = 11;
    public parent()
    {
        Console.WriteLine("class parent");
        Console.WriteLine(parentint);
        fun();
    }
}

class child : parent
{
    private int childint = 22;
    public child()
    {
        Console.WriteLine("class child");
        fun();
    }
    public override void fun()
    {
        Console.WriteLine(childint);
    }
}

class cc
{
    public static void Main()  
    {
        new child();
        Console.ReadKey();
    }
}

result:
class parent
11
11              //此处不同
class child
22
例例例例例例例例例例例例例例例例例例


例2：（JAVA）
例例例例例例例例例例例例例例例例例例
abstract class parent
{ 
    abstract void fun();
    private int parentint = 11;
    
    parent()
    {
        System.out.println("class parent");
        System.out.println(Integer.toString(parentint));
        fun();   
    }
}

class child extends parent
{
    private int childint = 22;
    child()
    {
        System.out.println("class child");
        fun();
    }

    void fun()
    {
        System.out.println(Integer.toString(childint));
    }
}

class Test
{
    public static void Main()  
    {
        new child();
    }
}
class parent
11
0               //此处不同
class child
22
例例例例例例例例例例例例例例例例例例



（8）构造方法中对泛型的约束
where 子句用于指定类型约束，这些约束可以作为泛型声明中定义的类型参数的变量，定义时，放在“被实现接口”、“被继承类”之后，即“最后”。
<1>接口约束（interface constraint）
·指定某个类型实参必须实现一个或多个接口。这种约束是通过指定接口名称来实现的。
public class MyGenericClass<T> where T : IComparable        //类型参数 T 要实现 IComparable<T> 接口
{ }

<2>基类约束（base class constraint）
·指出某个类型必须将指定的类作为基类（或者就是该类本身），才能用作该泛型类型的类型参数。这样的约束一经使用，就必须出现在该类型参数的所有其他约束之前。
public class MyGenericClass<T> where T : Comparable         //类型参数 T 要继承 Comparable 基类

<3>构造方法约束（constructor constraint）
·可以使用 new 运算符创建类型参数的实例；但类型参数为此必须受构造方法约束 new() 的约束。new() 约束可以让编译器知道：提供的任何类型参数都必须具有可访问的无参数（或默认）构造方法。例如：
public class MyGenericClass <T> where T: new()
{ 
    // The following line is not possible without new() constraint: 
    T item = new T();
}
new() 约束出现在 where 子句的最后。

<4>引用类型约束（value type constraint）
·通过关键字class指定“引用类型约束”（reference type constraint）来限制某个类型实参必须是引用类型。
public class MyClassy<T, U>
       where T : class
{ }

<5>值类型约束（reference type constraint）
·通过关键字struct指定“值类型约束”（value type constraint）来限制某个类型实参必须是值类型。
public class MyClassy<T, U>
       where U : struct
{ }

<6>对于多个类型参数，每个类型参数都使用一个 where 子句，例如：
// cs_where_3.cs
// compile with: /target:library
using System;
using System.Collections;
interface MyI { }
class Dictionary<TKey, TVal> 
where TKey: IComparable, IEnumerable 
where TVal: MyI
{ 
        public void Add(TKey key, TVal val) 
        {
        }
}

<5>还可以将约束附加到泛型方法的类型参数，例如：
public bool MyMethod<T>(T t) where T : IMyInterface { }
请注意，对于委托和方法两者来说，描述类型参数约束的语法是一样的：
delegate T MyDelegate<T>() where T : new()





4、TypeConverter
using System.ComponentModel;

    public class StringToHumanTypeConverter : TypeConverter
    {
        //// <summary>
        /// 是否能用string转换到Human类型
        /// </summary>
        /// <param name="context">上下文</param>
        /// <param name="sourceType">转换源的Type</param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            if (sourceType == typeof(string))
            { return true; }
            else
            { return false; }
        }


        //// <summary>
        /// 从string转到Human类型
        /// </summary>
        /// <param name="context">提供Component的上下文，如Component.Instance对象等</param>
        /// <param name="culture">提供区域信息，如语言、时间格式、货币格式等</param>
        /// <param name="value"></param>
        /// <returns></returns>

        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
        {
            if (value is string)
            {
                Human h = new Human();
                h.Name = value as string;
                return h;
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        //// <summary>
        /// 是否能用Human转换到string类型
        /// </summary>
        /// <param name="context">上下文</param>
        /// <param name="destinationType">转换源的Type</param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type destinationType)
        {
            if (destinationType == typeof(Human))
            { return true; }
            else
            { return false; }
        }

        //// <summary>
        /// 从Human转到string类型
        /// </summary>
        /// <param name="context">提供Component的上下文，如Component.Instance对象等</param>
        /// <param name="culture">提供区域信息，如语言、时间格式、货币格式等</param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
        {
            if (value == null) return string.Empty;
            if (destinationType == typeof(string))
            {
                Human h = (Human)value;
                return h.Name as string;
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }

    [TypeConverterAttribute(typeof(StringToHumanTypeConverter))]
    //简写为[TypeConverter(typeof(StringToHumanTypeConverter))]
    public class Human
    {
        public string Name { get; set; }
        //public Human Child { get; set; }
    }
    
    int main()
    {
       Human h = (Human)this.FindResource("human");
       MessageBox.Show(h.Child.Name);
    }
    
    


I、数组
数组与其他引用型对象一样，本身也是一个引用型对象。
一般格式为：
char[] cs={'a', 'b'};
char[2] cs={'a', 'b'};        //不可如此使用

<1>多维数组   
  string[,]   names   =   new   string[5, 4];   
  names是一个二维数组（二维及以上的称为多维数组），可以将其理解为一个长度为5的一维数组，但其每一个元素是长度（！必须都！）为4的string类型的一维数组。从结构上来说，它是规则的，必须是5*4的。
<2>多重数组   
  byte[][]   scores   =   new   byte[5][];   
  scores则是一个多重数组，可以将其理解为一个长度为5的一维数组，其每一个元素是长度（！不确定！）的byte类型的一维数组。从结构上来说，它是不规则的，除了本身的长度为固定的5，其元素所引用的数组长度是可变的。从代码中可以看得出来。

关键的区别，一个是规则的，一个是不规则的。这就提供了使用上的灵活性。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
还有一点必须指出，在本质上，names   是一个二维数组，而   scores   是一个一维数组。   
  names.Rank   ==   2                             
  names.GetLength(0)   ==   5   
  names.GetLength(1)   ==   4   
  names.Length   ==   20   
    
  scores.Rank   ==   1   
  scores.GetLength(0)   ==   5   
  scores.GetLength(1)   ==   4     //   此句会导致异常，因为不存在第   2   个维度。   
  scores.Length   ==   5   
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

★能用foreach遍历访问的对象需要实现IEnumerable接口和GetEnumerator()方法。
GetEnumerator()方法返回IEnumerator，IEnumerator才是真正的迭代器。
即：
//该接口目的：用于使用foreach循环
interface IEnumerable
{
    IEnumerator GetIEnumerator();
}
//该接口是一个迭代器，可使用MoveNext等方法
interface IEnumerator
{
    object Current { get; }
    bool MoveNext();
    bool Reset();
}

J、结构体
1、使用结构体类型的步骤:
首先、声明一个结构体的定义范围
其次、对结构体实例化
最后、给对象（实例化后的）赋值、初始化
2、声明
struct ssss
{
 string hour;
 string minute;
 string second;
}
ssss cccc = new ssss();

cccc.hour = 13;
cccc.minute = 30;
cccc.second = 40;
3、初始化
第一种：
struct my
{
   int x;
   int y;
   my(int x, int y)
   {this.x = x;this.y = y}
}
my mytest = new my(10, 10);
这样mytest.x 和mytest.y 都初始化为10；
第二种：
结构还可以这么初始化
my mytest;    现在的mytest 数据值类型变量 
mytest.x=XX;  

而引用类型就不允许这么做，引用类型存储其地址，所以需要使用new返回地址及分配空间。
不能在结构中初始化字段，
比如
struct my
{
   int x=10;
}
将导致编译错误，因为my现在属于一个数据类型，它不占用存储空间，只有在定义变量的时候才能初始化使用





K、枚举
1、枚举类型
枚举类型的步骤：
（1）声明一个枚举的定义范围
（2）对枚举实例化
（3）给对象（实例化后的）赋值
枚举的基本类型可以是byte，sbyte，short，ushort，int，uint，long和ulong。
    enum Days : int
    {
        Sat, 
        Sun, 
        Mon, 
        Tue, 
        Wed, 
        Thu, 
        Fri
    }
    enum orientation : byte
    {
     int east = 1,
     int south = 2,
     int west = 4,
     int north = 8
    }

orientation myDirection = orientation.north;


¤枚举<->字符串
enum Mode
{
    Debug = 0,
    QA = 1,
    Online = 2
}
//枚举-->字符串
string s = Mode.Debug.ToString();
//或
string s = Enum.GetName(typeof(Mode), Mode.Online);
//枚举-->字符串数组
string[] dayArray = Enum.GetNames(typeof(Days));
//字符串-->枚举
Mode Mode = (Mode)Enum.Parse(typeof(Mode), "Debug");

¤枚举<-->数字
//枚举-->数字
int num = (int)Debug;
//枚举-->数字数组
int[] modeArray = (int[])Enum.GetValues(typeof(Mode));
//数字-->枚举
Mode mode = (Mode)0;

¤组合枚举
[Flags]
public enum Roles                                       //值必须为2的幂  
{  
    None = 0,  
    Admin = 1,  
    User = 2,  
    Guest = 4,  
    All = Admin | User | Guest                          //所有
}
public void Main()
{
    Roles roles = (Roles)5;                             //将int值转换为枚举( Admin = 1 + Guest = 4就是5)
    role = role | Roles.Admin | Roles.User;             //通过位或操作为该角色添加权限
    role = role ^ Roles.Admin;                          //通过位非操作删除Admin权限
    role = role ^ Roles.Admin;                          //通过位非操作添加Admin权限
}


2、枚举器IEnumerator（®JAVA中叫Iterator）
（1）使用系统原带IEnumerator
初始或进行Reset()方法后，index值为-1。
        string[] Arr={"1", "2", "3", "a", "c", "f"};
        IEnumerator ienum = Arr.GetEnumerator();
        while (ienum.MoveNext()) {
            Response.Write(ienum.Current);
        }
（2）自定义IEnumerator（关键字yield）
yield return 表示在迭代中下一个迭代时返回的数据，除此之外还有yield break，其表示跳出迭代。
例1
    public class HelloCollection : System.Collections.IEnumerable
    {
        public System.Collections.IEnumerator GetEnumerator()
        {
            yield return "Hello";
            if (...)
                yield break;                            //不再继续向下执行，就此中断
            yield return "World";
        }
    }

例2
    private static System.Collections.IEnumerator YieldSomeStuff()
    {
        Console.WriteLine("foo1!");                     //第一次MoveNext()
        yield return "hello";                           //第一次Current
        Console.WriteLine("foo2!");                     //第二次MoveNext()
        yield return "world";                           //第二次Current
    }

    System.Collections.IEnumerator e = YieldSomeStuff();
    while (e.MoveNext())
    {
        Console.WriteLine(e.Current);
    }



3、IEnumerable
IEnumerable<string> mylist = new List<string>();
mylist.Add("a");
mylist.Add("b");
mylist.Add("c");
mylist.Where(...);


L、Hashtable表
    Hashtable是System.Collections命名空间提供的一个容器，用于处理和表现类似key/value的键值对，其中key通常可用来快速查找，同时key是区分大小写；用于存储对应于key的值。Hashtable中key/value键值对均为object类型，所以Hashtable可以支持任何类型的key/value键值对。
特点:
<1>哈希表里没有索引号：不支持for循环，但支持foreach循环
<2>键不能重复
<3>哈希表在遍历中可移除某个键/值对；注意，移除后一定要退出循环（break;）
<4>键放入顺序不一定是自然顺序；
    用来通过制定的Key，查找Value的。Key不可重复，但是Value可以重复。Key的检索是通过HashCode进行的，效率比普通列表要高，因此有人单独使用Key来存放不重复的关键字，而Value不给值，设为null，用来判断某个key是否存在，效率比普通的集合中判断是否存在要高，不过相应的内存消耗也比较大。
1、常用方法：
    Hashtable hshTable = new Hashtable(); // 创建哈希表
    hshTable.Add("Person1", "zhanghf"); // 往哈希表里添加键值对
    hshTable.Clear(); //移除哈希表里所有的键值对
    hshTable.Contains("Person1");   //判断哈希表里是否包含该键
    string name = (string)hshTable["Person1"].ToString(); //取哈希表里指定键的值
    hshTable.Remove("Person1"); // 删除哈希表里指定键的键值对
    IDictionaryEnumerator en = hshTable.GetEnumerator(); //   遍历哈希表所有的键，读出相应的值
    while (en.MoveNext())
    {
       string str = en.Value.ToString();
    }
2、遍历方法：
遍历哈希表需要用到DictionaryEntry Object，代码如下：
foreach (DictionaryEntry entry in ht)              //ht为一个Hashtable实例
{
    Console.WriteLine(entry.Key);                  //entry.Key对应于key/value键值对key
    Console.WriteLine(entry.Value);                //entry.Key对应于key/value键值对value
}
或者
foreach (string mykey in ht.Keys)
{
    string str=(string)ht[mykey];
    Console.WriteLine(str);
}

M、Collection<T>
可以重写CRUD四个方法，这样一来，可以重写CRUD，可以以AOP的形式在其中插入事件。
public class TCollection : Collection<T>
{
    public event EventHandler<TChangedEventArgs> CollectionChanged;
    protected override void InsertItem(int index, T item)
    {
        T insertItem = item;
        base.InsertItem(index, item);

        if (CollectionChanged != null)
        {
            CollectionChanged(this, new TChangedEventArgs(ChangeType.Added, insertItem, null));
        }
    }

    protected override void SetItem(int index, T item)
    {
        T replacedItem = Items[index];
        base.SetItem(index, item);

        if (CollectionChanged != null)
        {
            CollectionChanged(this, new TChangedEventArgs(ChangeType.Replaced, replacedItem, item));
        }
    }

    protected override void RemoveItem(int index)
    {
        T removedItem = Items[index];
        base.RemoveItem(index);

        if (CollectionChanged != null)
        {
            CollectionChanged(this, new TChangedEventArgs(ChangeType.Removed, removedItem, null));
        }
    }

    protected override void ClearItems()
    {
        base.ClearItems();

        if (CollectionChanged != null)
        {
            CollectionChanged(this, new TChangedEventArgs(ChangeType.Cleared, null, null));
        }
    }
}

¤ObservableCollection
另外，也可使用ObservableCollection简化以上步骤，
当ObservableCollection的值发生改变时，可主动触发事先自定义的事件：
    ObservableCollection<string> collection = new ObservableCollection<string>() { "1" };
    collection.CollectionChanged += collection_CollectionChanged;


N、泛型
1、泛型说明
如果一个对象不确定，用变量；如果一个类型不确定，用泛型
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
static void Main(string[] args)
{
    PrintInt(1);//正常
    PrintString("a");//正常
    PrintAll1(2, "b");//正常
    PrintAll2<int>(3);//正常
    PrintAll2<string>("c");//正常
    PrintAll2(4);//正常
    PrintAll2("d");//正常
    PrintAll2(5.5);//报错
    Console.ReadLine();
}

static void PrintInt(int x)
{
    Console.WriteLine(x);
}

static void PrintString(string y)
{
    Console.WriteLine(y);
}

static void PrintAll1(int x, string y)
{
    Console.WriteLine(x);
    Console.WriteLine(y);
}

static void PrintAll2<T>(T x)
{
    if (typeof(T) == typeof(int))
    {
        Console.WriteLine(x);
    }
    else if (typeof(T) == typeof(string))
    {
        Console.WriteLine(x);
    }
    else
    {
        Console.WriteLine("Error");
    }
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
代码说明：
Void Main是Console控制台应用的程序入口，这个大家都应该知道吧，然后Console.WriteLine一个int型变量是允许的，不用x.ToString()，Console.ReadLine()目的是为了停止屏幕，方便查看运行结果。下面说正题：
作为一个普通的方法，PrintInt是打印一个数字，PrintString是打印一个字符串，但是如果我需要一个方法，既能打印数字，又能打印字符串呢，那就是PrintAll1这个方法，它同时接收整型、字符串型2个变量，然后分两行显示。如果我的要求更苛刻，我需要一个方法，除了既能打印数字又能打印字符串之外，还必须有且只有1个参数，不考虑结构体什么的，实现这样子的东西，就叫泛型。理智的说，普通方法传递不同值变量，泛型方法传递不同类型的变量，上面这个例子，就是从泛型方法。当然泛型技术还能用在类上面，为了入门，先不说这些，从泛型方法入手。
PrintAll2就是泛型方法，记住泛型方法的书写格式，先定义一个未知类型T，写在方法名后面的尖括号里，然后参数是这个未知类型T的实例，然后方法里面的代码逻辑就是判断这个T到底是啥类型，然后根据不同类型，做出不同判断，执行不同代码。那么如何调用这个泛型方法呢？我在void Main里面调用了PrintAll2五次，PrintAll2<int>(3)指定了参数就是整型的，PrintAll2<string>("c")指定了参数就是字符串，PrintAll2(4)和PrintAll2("d")没有明说参数是啥类型，但是程序会通过参数自动判断类型，得到正确的结果，PrintAll2(5.5)由于泛型方法里面没有写该怎么处理浮点型，所以打印Error。

2、泛型与数组的转换
    int[] list1 = { 6, 5, 2, 9, 7, 4, 0 };
    List<int> list2 = new List<int>() { 1, -93, 9, 723, 4, 92, 79, 13, 34, 29, 64, 3, 81, 3, -69 };
（1）数组 --> 泛型
    List<int> list;
    list = new List<int>(list1);
（2）泛型 --> 数组
    int[] list = new int[list2.Length];
    list2.CopyTo(list);
    或int[] list = list2.ToArray();


3、几个泛型集合类的用法：
（1）Dictionary 和HashTable类似，ConcurrentDictionary是他的线程安全版
    此类在 .NET Framework 2.0 版中是新增的。表示键和值的集合。
命名空间:System.Collections.Generic，
程序集:mscorlib（在mscorlib.dll 中）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    class TestGenericList
    {
         static void Main()
        {
            //声明对象，参数表示，键是int类型，值是string类型
            Dictionary<int, string> fruit = new Dictionary<int, string>();
            try{
                //加入重复键会引发异常
                fruit.Add(1, "苹果");
                fruit.Add(2, "桔子");
                fruit.Add(3, "香蕉");
                fruit.Add(4, "菠萝");
                //参数错误将引发异常，如下所示
                //fruit.Add("5", "aa");
            }
            catch (ArgumentException)
            {
                Console.WriteLine("添加错误！！！");
            }
            //因为引入了泛型，所以键取出后不需要进行Object到int的转换，值的集合也一样
            foreach (int i in fruit.Keys)
            {
                Console.WriteLine("键是：{0} 值是：{1}",i, fruit);
            }
            //按键值对遍历
            foreach(KeyValuePair keyValue in fruit)
            {
                 Console.WriteLine("键是：{0} 值是：{1}", keyValue.Key, keyValue.Value);
            }
            //删除指定键，值
            fruit.Remove(1);
             //判断是否包含指定键
            if (fruit.ContainsKey(1))
            {
                Console.WriteLine("包含此键");
            }
            //清除集合中所有对象
            fruit.Clear();
        }
    }
    Dictionary遍历输出的顺序，就是加入的顺序，这点与Hashtable不同，其它方法如：ContainsKey ，ContainsValue ，Remove 等，使用方法基本一致。
fruit["key"]=value;
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

（2）List类
    此类在 .NET Framework 2.0 版中是新增的。表示可通过索引访问的对象的强类型列表。提供用于对列表进行搜索、排序和操作的方法。命名空间:System.Collections.Generic，
程序集:mscorlib（在 mscorlib.dll 中），List 类是 ArrayList 类的泛型等效类。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
   //声明一个泛型类   
    class TestGenericList
    {
        static void Main()
        {
            //声明一个List对象和ArrayList对应，只加入string参数
            List<string> names = new List<string>();
            names.Add("乔峰");
            names.Add("欧阳峰");
            names.Add("马蜂");
            //遍历List，或直接names.ForEach(Console.WriteLine);其中List<T>.ForEach的格式为List<T>.ForEach(Action<T> action)
            foreach (string name in names)
            {
                Console.WriteLine(name);
            }
            //向List中插入元素
            names.Insert(2, "张三峰");
            //移除指定元素
            names.Remove("马蜂");            
        }
    }

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
   在决定使用 List 还是使用 ArrayList 类（两者具有类似的功能）时，记住 List 类在大多数情况下执行得更好并且是类型安全的。如果对 List 类的类型 T 使用引用类型，则两个类的行为是完全相同的。但是，如果对类型 T 使用值类型，则需要考虑实现和装箱问题。    如果对类型 T 使用值类型，则编译器将特别针对该值类型生成 List 类的实现。这意味着不必对 List 对象的列表元素进行装箱就可以使用该元素，并且在创建大约 500 个列表元素之后，不对列表元素装箱所节省的内存将大于生成该类实现所使用的内存。   其实我们也可以自己定义一个泛型类，如下所示：
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    //声明一个泛型类
    public class ItemList<T>
    {
        void Add(T item) { }
    }
    class TestGenericList
    {
        private class ExampleClass { }
        static void Main()
        {
            // 声明一个对象，只能加入int型
            ItemList<int> list1 = new ItemList<int>();            //声明一个对象，只能加入Student类型，Student类为自定义类
            ItemList<Student> list2 = new ItemList<Student>();        }
    }   
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
泛型的用法还有很多种，如泛型方法，泛型委托，泛型接口等。



（3）KeyValuePair
    //设置
    int intKey = 1;
    string strValue = "My value";
    KeyValuePair<int, string> kvp = new KeyValuePair<int, string>(intKey, strValue);
    //读取
    int intKey = kvp.Key;
    string strValue = kvp.Value;

O、队列
Queue先进先出。Enqueue入列，Dequeue出列。
1、Enqueue方法 ：将对象添加到 Queue 的结尾处。
2、Dequeue 方法：移除并返回位于 Queue 开始处的对象，但不重置Queue的容量。
3、Peek 方法：返回位于 Queue 开始处的对象但不将其移除。
4、ToArray 方法：将 Queue 元素复制到新数组。
5、CopyTo 方法：从指定数组索引开始将 Queue 元素复制到现有一维 Array 中。
6、Count 属性：获取 Queue 中包含的元素数。
7、Contains()方法：确定某元素是否在队列中，如果是，返回true
8、TrimExcess()方法：重设队列的容量，Dequeue不重置Queue的容量，要从头部去除空元素，使用该方法。

P、栈
stack后进先出。push方法入栈，pop方法出栈。
1、Push方法：将对象插入 Stack 的顶部。
2、PEEK方法：返回位于 Stack 顶部的对象但不将其移除。
3、POP方法：移除并返回位于 Stack 顶部的对象。
4、CopyTo方法：从指定数组索引开始将 Stack 复制到现有一维 Array 中。 次序不变。
5、Foreach方法：由于Stack实现了IEnumerable接口，所以可以使用foreach取值。
6、count属性：获取 Stack 中包含的元素数。
7、ToArray 方法：将 Stack 复制到新数组中。次序不变。


Q、各种集合的性能
标记说明： 
1.O(1)      表示无论集合中有多少项，这个操作需要的时间都不变，例如，ArraryLIst的Add()方法就O(1)，无论集合中有多少元素，在列表尾部添加一个新的元素的时间都是相同的.
2.O(n)      表示对于集合中的每个元素，需要增加的时间量都是相同的，如果需要重新给集合分配内存，ArrayList的Add()方法就O(n)，改变容量，需要复制列表，复制的时间随元素的增加和线性增加.
3.O(log n)  表示操作需要的时间随着集合中元素的增加和增加，但每个元素增加的时间不是线性的.而是呈对数曲线，在集合中插入操作时，SortedDictionary<Tkey，Tvalue>就是O(log n)，而SortedList<Tkey，Tvalue> 就是O(n)，这里SortedDictionary<Tkey,Tvalue>要快的多，因为它在树形结构中插入元素的效率比列表高的多。
下表显示各种集合的操作时间：
  注：如果单元格中有多个大O值，表示集合需要重置大小，该操作需要一定的时间，如果单元格内容是no，就表示不支持这种操作。
集合                 Add                                           Insert           Remove         Item                                Sort               Find 
List<T>              如果集合必须重置大小就是O(1)或O(n)            O(n)             O(n)           O(1)                                O(n log n)         O(n) 
                                                                                                                                       最坏情况O(n^2)
SortedList           无序数据为O(n)，如果必选重置大小，            no               O(n)           读写是O(log n)，如果键在列表中，就  no                 no 
<Tkey,Tvalue>        到列表的尾部就是O(log n)                                                      是O(log n),如果键不在列表中就是O(n)

Stack<T>(栈)         Push()，如果栈必须重置大小，就是O(1)或O(n)    no               Pop(),O(1)     no                                  no                 no 

Queue<T>(列队)       Enqueue()，如果栈必须重置大小，就是O(1)或O(n) no               Dequeu(),O(1)  no                                  no                 no 

HastSet<T>(无序列表) 如果栈必须重置大小，就是O(1)或O(n)            Add()O(1)或O(n)  O(1)           no                                  no                 no 

LinkedList<T>(链表)  AddLast()，O(1)                               AddAfter(),O(1)  O(1)           no                                  no                 O(n)

Dictionary           O(1) 或 O(n)                                  no               O(1)           O(1)                                no                 no 
<Tkey,TValue>

SortedDictionary     O(log n)                                      no               O(log n)       O(log n)                            no                 no 
<Tkey,Tvalue> 


R、匿名类型与动态类型
I.匿名类型
匿名类型：顾名思义，当然是没用使用class 或者struct关键字命名的类型。它是使用new关键字和对象初始值进行声明的（它是直接从对象派生的引用类型）。
    对于var关键字，当然与javascript的var不同，它是C# 3.0开始新增的特性，称为类型推断。而推断类型可以是内置类型、匿名类型、用户定义类型、.NET fk 类库中定义的类型或任何表达式。
    在C#里有这样一些类型，它是作为临时储存数据的，生命周期只在这个方法内，方法结束了，这个类型的生命周期也没有了。那么这里我们就可以使用一个C#匿名类型。
    C#匿名类型是没有名字的类型，没有名字你怎么来称呼它，怎么来声明它？但是C#匿名类型真的是没有名字的么？看看C#编译器又在我们背后干了些什么，使用ILDASM打开编译过的程序集，发现多了一个类型：

<>f__AnonymousType0<<Key>j__TPar, <Value>j__TPar>     这个类型是直接继承自System.Object的，并且是internal seald(只在程序集内可见，并且不能被继承)。有心的你也许会发现，这个类型还是一个泛型类型，那么只要我们在使用一个C#匿名类型的时候参数个数，参数名称不发生变化，编译器是不会为我们产生更多的类型的：

var KeyPair1 = new { myKey="yuyi", myValue="Programer"};  
var KeyPair2 = new { myKey="y", myValue=3};  
var KeyPair3 = new { myKey=4, myValue="abc"}; 
    上面三个C#匿名类型，编译器只会为我们在背后产生一个新类型，一个泛型的新类型。如果我们将这个C#匿名类型内的属性名修改一下：对
var KeyPair1 = new { Key="yuyi", Value="Programer"};  
var KeyPair2 = new { Key="y", Value1=3}; 
    就会产生两个新泛型了：
<>f__AnonymousType0<<Key>j__TPar, <Value>j__TPar> <>f__AnonymousType1<<Key>j__TPar, <Value1>j__TPar> 
    看看，这个命名还是有规律可循哦。如果你给这个C#匿名类型添加一个新属性呢？这样又产生了一个新类型了：
<>f__AnonymousType1<<Key>j__TPar, <Value1>j__TPar, <Test>j__TPar> 
    嗯，这个问题还是值得关注的，所以我们在使用C#匿名类型的时候应该尽量保持“一致性”：属性个数一致(这个尽量了)。属性名称一致，这个比较好把握。
例：
    var obj = new { a = "this is only a test", b = 10, c = (decimal)20 };
    Console.WriteLine("Anonymous value : \n A={0}, \n B={1}, \n C={2}",obj.a, obj.b, obj.c);
    Console.Read();

II.动态类型
1.介绍
dynamic是FrameWork4.0的新特性。dynamic的出现让C#具有了弱语言类型的特性。编译器在编译的时候不再对类型进行检查，编译期默认dynamic对象支持你想要的任何特性。比如，即使你对GetDynamicObject方法返回的对象一无所知，你也可以像如下那样进行代码的调用，编译器不会报错：
            dynamic dynamicObject = GetDynamicObject();
            Console.WriteLine(dynamicObject.Name);
            Console.WriteLine(dynamicObject.SampleMethod());
2.var与dynamic的区别
常有人会拿var这个关键字来和dynamic做比较。实际上，var和dynamic完全是两个概念，根本不应该放在一起做比较。var实际上是编译期抛给我们的“语法糖”，一旦被编译，编译期会自动匹配var 变量的实际类型，并用实际类型来替换该变量的申明，这看上去就好像我们在编码的时候是用实际类型进行申明的。而dynamic被编译后，实际是一个object类型，只不过编译器会对dynamic类型进行特殊处理，让它在编译期间“不进行任何的类型检查”，而是将类型检查放到了运行期。

•var
（1）var是编译时语法。
（2）以var声明的变量，支持“智能感知”，因为visual studio能推断出var类型的实际类型
•dynamic
（1）dynamic类型是一种运行时语法。
（2）以dynamic声明的变量却不支持“智能感知”，因为编译器对其运行期的类型一无所知。对dynamic变量使用“智能感知”，会提示“此操作将在运行时解析”。
（3）dynamic变量是一个object变量这一点，可以通过IL代码得到验证，这里不再贴出IL代码。当然，编译器也对dynamic声明进行了处理，以区别直接object变量。

3.dynamic的应用
//简化反射
public class DynamicSample
{
    public string Name { get; set; }
    public int Add(int a, int b)
    {
        return a + b;
    }
}
dynamic dynamicSample = Activator.CreateInstance(typeof(DynamicSample)) as DynamicSample;
/*不使用dynamic方式*/
var addMethod = typeof(DynamicSample).GetMethod("Add");
int re1 = (int)addMethod.Invoke(dynamicSample, new object[] { 1, 2 });
/*使用dynamic方式*/
int re2 = dynamicSample2.Add(1, 2);

//不必定义类型
dynamic dynamicObj = new System.Dynamic.ExpandoObject();
dynamicObj.Field1 = "Field1";
dynamicObj.Field2 = "Field2";

//DynamicObject
class DynamicProduct : System.Dynamic.DynamicObject
{
    public long Id {get; set;}
}

S、时间
1.
private long lLeft = 621355968000000000;
    //将数字变成时间
    public  string GetTimeFromInt(long ltime)
    {
        long Eticks = (long)(ltime * 10000000) + lLeft;
        DateTime dt = new DateTime(Eticks).ToLocalTime();
        return dt.ToString();
    }


    //将时间变成数字
    public  long GetIntFromTime(DateTime dt)
    {
        DateTime dt1 = dt.ToUniversalTime();
        long Sticks = (dt1.Ticks - lLeft) / 10000000;
        return Sticks;
    }

DateTime.Now.AddDays(-1).ToString("dd/MM/yy")
DateTime.Now.Year.ToString()
DateTime.Now.Month.ToString().PadLeft(2, '0')
DateTime.Now.Day.ToString().PadLeft(2, '0')
DateTime.Now.Hour.ToString().PadLeft(2, '0')
DateTime.Now.Minute.ToString().PadLeft(2, '0')
DateTime.Now.Second.ToString().PadLeft(2, '0')
DateTime.Now.Ticks.ToString();                      //Ticks是一个很大的长整数，单位是 100 毫微秒。表示自 0001 年 1 月 1 日午夜 12:00:00 以来已经过的时间的以 100 毫微秒为间隔的间隔数

2.时间解析
//将字符变成时间
方式一
DateTime.Parse("2010/12/21").ToString("yyyy-MM-dd")
方式二
DateTime time = DateTime.ParseExact( "2008年09月12日 15点14分56秒", "yyyy年MM月dd日 HH点mm分ss秒", null );

//将时间变成字符
DateTime dt = DateTime.Now;
string dtStr = dt.ToString("yyyy-MM-dd HH:mm:ss.fff");


3.UTC时间
  世界的每个地区都有自己的本地时间，在Internet及无线电通信时，时间的统一非常重要！
  整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信中，为统一而普遍使用一个标准时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。UTC与GMT含义完全相同。
  每个时区都有一个对应的UTC时间，场景：如果要计算两个不同时区的时间差值，可先分别转换成UTC时间，再进行差值计算。

unixTime = utcTime_end - utcTime_start = gmt8_end - gmt8_start
                          1970-01-01                1970-01-01
                           00:00:00                  08:00:00
unix时间：在一个时区中，从起始时间到截止时间所经过的秒数。
∴已知某一unixTime和时区，才能推断出“在该时区unixTime所表示的时间”。反之，已知某一时间和时区，才能推断出unix时间。即：
只有在时区确定的基础上，unix时间和时间才能相互转换。
unixTime & timezone => datetime
datetime & timezone => unixTime

    /// <summary>
    /// 将Unix时间戳转换为本地DateTime类型时间
    /// </summary>
    /// <param name="unix">double 型数字</param>
    /// <returns>本地DateTime</returns>
    public static DateTime ConvertUnix2DateTime(double unix)
    {
        DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));
        //或DateTime startTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Local);
        DateTime time = startTime.AddSeconds(unix);
        return time;
    }

    /// <summary>
    /// 将本地DateTime时间格式转换为Unix时间戳格式
    /// </summary>
    /// <param name="time">本地时间</param>
    /// <returns>long</returns>
    public static double ConvertDateTime2Unix(DateTime time)
    {
        DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0));
        //或DateTime startTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Local);
        double t = (time - startTime).TotalSeconds;
        return t;
    }

4.

DateTime dt = DateTime.Now; 
dt.ToString();                                  // 2005-11-5 13:21:25 
dt.ToFileTime().ToString();                     // 127756416859912816 
dt.ToFileTimeUtc().ToString();                  // 127756704859912816 
dt.ToLocalTime().ToString();                    // 2005-11-5 21:21:25 
dt.ToLongDateString().ToString();               // 2005年11月5日 
dt.ToLongTimeString().ToString();               // 13:21:25 
dt.ToOADate().ToString();                       // 38661.5565508218 
dt.ToShortDateString().ToString();              // 2005-11-5 
dt.ToShortTimeString().ToString();              // 13:21 
dt.ToUniversalTime().ToString();                // 2005-11-5 5:21:25 
dt.Year.ToString();                             // 2005 
dt.Date.ToString();                             // 2005-11-5 0:00:00 
dt.DayOfWeek.ToString();                        // Saturday 
dt.DayOfYear.ToString();                        // 309 
dt.Hour.ToString();                             // 13 
dt.Millisecond.ToString();                      // 441 
dt.Minute.ToString();                           // 30 
dt.Month.ToString();                            // 11 
dt.Second.ToString();                           // 28 
dt.Ticks.ToString();                            // 632667942284412864 
dt.TimeOfDay.ToString();                        // 13:30:28.4412864 
dt.ToString();                                  // 2005-11-5 13:47:04 
dt.AddYears(1).ToString();                      // 2006-11-5 13:47:04 
dt.AddDays(1.1).ToString();                     // 2005-11-6 16:11:04 
dt.AddHours(1.1).ToString();                    // 2005-11-5 14:53:04 
dt.AddMilliseconds(1.1).ToString();             // 2005-11-5 13:47:04 
dt.AddMonths(1).ToString();                     // 2005-12-5 13:47:04 
dt.AddSeconds(1.1).ToString();                  // 2005-11-5 13:47:05 
dt.AddMinutes(1.1).ToString();                  // 2005-11-5 13:48:10 
dt.AddTicks(1000).ToString();                   // 2005-11-5 13:47:04 
dt.CompareTo(dt).ToString();                    // 0 
dt.Add(?).ToString();                           // 问号为一个时间段 
dt.Equals("2005-11-6 16:11:04").ToString();     // False 
dt.Equals(dt).ToString();                       // True 
dt.GetHashCode().ToString();                    // 1474088234 
dt.GetType().ToString();                        // System.DateTime 
dt.GetTypeCode().ToString();                    // DateTime

dt.GetDateTimeFormats('s')[0].ToString();       // 2005-11-05T14:06:25 
dt.GetDateTimeFormats('t')[0].ToString();       // 14:06 
dt.GetDateTimeFormats('y')[0].ToString();       // 2005年11月 
dt.GetDateTimeFormats('D')[0].ToString();       // 2005年11月5日 
dt.GetDateTimeFormats('D')[1].ToString();       // 2005 11 05 
dt.GetDateTimeFormats('D')[2].ToString();       // 星期六 2005 11 05 
dt.GetDateTimeFormats('D')[3].ToString();       // 星期六 2005年11月5日 
dt.GetDateTimeFormats('M')[0].ToString();       // 11月5日 
dt.GetDateTimeFormats('f')[0].ToString();       // 2005年11月5日 14:06 
dt.GetDateTimeFormats('g')[0].ToString();       // 2005-11-5 14:06 
dt.GetDateTimeFormats('r')[0].ToString();       // Sat, 05 Nov 2005 14:06:25 GMT 
string.Format("{0:d}",dt);                      // 2005-11-5 
string.Format("{0}",dt);                        // 2005年11月5日 
string.Format("{0:f}",dt);                      // 2005年11月5日 14:23 
string.Format("{0:F}",dt);                      // 2005年11月5日 14:23:23 
string.Format("{0:g}",dt);                      // 2005-11-5 14:23 
string.Format("{0:G}",dt);                      // 2005-11-5 14:23:23 
string.Format("{0:M}",dt);                      // 11月5日 
string.Format("{0:R}",dt);                      // Sat, 05 Nov 2005 14:23:23 GMT 
string.Format("{0:s}",dt);                      // 2005-11-05T14:23:23 
string.Format("{0:t}",dt);                      // 14:23 
string.Format("{0:T}",dt);                      // 14:23:23 
string.Format("{0:u}",dt);                      // 2005-11-05 14:23:23Z 
string.Format("{0:U}",dt);                      // 2005年11月5日 6:23:23 
string.Format("{0:Y}",dt);                      // 2005年11月 
string.Format("{0}",dt);                        // 2005-11-5 14:23:23 
string.Format("{0:yyyyMMddHHmmssffff}",dt); 
计算2个日期之间的天数差 
----------------------------------------------- 
DateTime dt1 = Convert.DateTime("2007-8-1"); 
DateTime dt2 = Convert.DateTime("2007-8-15"); 
TimeSpan span = dt2.Subtract(dt1); 
int dayDiff = span.Days + 1; 
计算某年某月的天数 
----------------------------------------------- 
int days = DateTime.DaysInMonth(2007, 8); 
days = 31; 
给日期增加一天、减少一天 
----------------------------------------------- 
DateTime dt =DateTime.Now; 
dt.AddDays(1);                                  // 增加一天 
dt.AddDays(-1);                                 // 减少一天 
其它年份方法类似... 
Oracle SQL里转换日期函数 
----------------------------------------------- 
to_date("2007-6-6",'YYYY-MM-DD"); 
to_date("2007/6/6",'yyyy/mm/dd");




T、Lazy<T>延迟加载
   public class Student
   {
      public Student()
      {
         this.Name = "DefaultName";
         this.Age = 0;
         Console.WriteLine("Student is initing.");
      }

      public string Name { get; set; }
      public int Age { get; set; }
   }

  private static judgeInit(Lazy<Student> stu)
  {
  if(stu.IsValueCreated)
      Console.WriteLine("Student is inited!");
  if(!stu.IsValueCreated)
      Console.WriteLine("Student isn't init!");
  }

  private void Main()
  {
    Lazy<Student> stu = new Lazy<Student>();
    judgeInit(stu);
    Console.WriteLine(stu.Value.Name);                    // 第一次引用
    judgeInit(stu);
    stu.Value.Name = "Tom";                               // 第二次引用
    judgeInit(stu);
  }

Student isn't init!
Student is initing.
DefaultName
Student is inited!
Tom

三、方法的值参数、引用参数、输出参数、数组型参数
1、值传递        值类型：实参只是将值传给了形参。
               引用类型：其本质上实参浅拷贝出一份形参，实质上是对形参操作（可以修改，但重新指向“不会”受影响，因为实参未发生改变）。
（本质上是对参数的浅拷贝）
（同Java，且Java只有值传递）
2、引用传递         ref：实参将实际地址传给了形参，本质上是对实参操作（可以修改，重新指向“会”受影响，因为实参被改变）。该参数必须已被初始化，也就是说此时的形参和实参没有区别，退出函数时ref引用的容量可以修改，也可以不修改。定义和调用时，必须同时加上ref，否则报错。
★即
①“按值传递引用类型”时，可以修改该参数对象的成员，并会影响原来的引用类型。但是如果为该参数指向一个新的实例，并不会影响原来的引用类型。
②“按引用传递引用类型”时，也可以修改该参数对象的成员，并会影响原来的引用类型。为如果为参数指向一个新的实例，会影响原来的引用类型。
共性：修改参数对象的成员时（包括成员的值及指向），总是会影响原值。
差异：修改参数对象的指向时，“值传递”不会影响原值，“引用传递”会影响原值。※※※“值传递”、“引用传递”的差别即在于此。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
值传递引用类型例：
        static void Main(string[] args)
        {
            Dog aDog = new Dog("Old");

            foo1(aDog);
            ShowName(aDog);

            foo2(aDog);
            ShowName(aDog);

            foo3(ref aDog);
            ShowName(aDog);

            Console.ReadKey();
        }

        private static void ShowName(Dog aDog)
        {
            Console.WriteLine(string.Format("Dog's name is {0}.", aDog.Name));
        }


        public static void foo1(Dog d)
        {
            d = new Dog("New");
        }
        public static void foo2(Dog d)
        {
            d.Name = "OldChanged";
        }
        public static void foo3(ref Dog d)
        {
            d = new Dog("New");
        }

Result:
Dog's name is Old.
Dog's name is OldChanged.
Dog's name is New.

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
3、输出传递         out：同上，但可以不初始化，即使初始化值也会被清空，退出函数时所有out引用的变量都要赋值，不能为空。同样定义和调用时，必须同时加上out，否则报错。
★ref与out关键字运行时处理方式不同，但编译时处理方式相同，所以当一方法用ref另一个用out是不能进行重载的，如以下不会重载：
    public void SampleMethod(out int i) { }
    public void SampleMethod(ref int i) { }
4、数组型参数    params：构造方法声明数组，而不知道数组长度用的，类似js中的arguments，在方法声明中的 params 关键字之后不允许任何其他参数，并且在方法声明中只允许一个 params 关键字
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static void UseParams(params int[] list) 
{
 for (int i = 0 ; i < list.Length; i++) 
 {
  Console.WriteLine(list[i]); 
 }
} 
UseParams(2, 4, 6, 8)
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
5、可选参数  <parameterType> <parameterTName> = <defaultValue>：可设置不选此参数时的默认值
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static void UseParams(string s, bool reverseWords = false) 
{
.....
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
6、命名参数  指定某一个参数值（可不按声明顺序），在声明上没有区别，只是在调用上的格式为：<paramName>:<paramValue>
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static void UseParams(int n, bool reverseWords = false, int UpLimit = 50, bool convertTostring = false) 
{
.....
}
UseParams(99, convertTostring:true, UpLimit:100);
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



四、委托和事件
A、委托
1、定义：
委托允许我们只需指定调用的方法是什么样子，而不需要指定具体调用哪个方法。委托的声明看起来就像是方法的声明，除了一个情形，那就是在我们要声明的方法正好是这个委托能够引用的方法的时候。
※类似C中的函数指针，但函数指针只能是一个函数，委托可以是有顺序的多个方法。
（1）委托好像一个加载“办法”的容器
（2）通过委托，可以声明一个事件，事件的好处是可以事先计划好在某处调用它，然后在main()中利用"+="定义它所容纳的"办法"(即注册)
※委托存储的是方法的地址，委托使用的时候有两个条件：
（1）声明委托，此时决定了委托代理何种类型的方法。
（2）实例化委托，与具体方法挂钩，这里的方法可以是静态的，但是方法原型，即方法的返回值，签名必须与委托声明时候的类型一致，不然编译器报错。还有你要明白，如果你多个方法都满足这个要求，没有关系，因为只有在实例化的才挂钩到一个方法。不会影响其他方法。

2、步骤及格式
使用三个步骤: 
（1）声明 
（2）实例化 
（3）调用 

单路广播委托型构（signature）如下: 
delegate result-type identifier ([parameters]);
这里:
result-type: 返回值的类型，和方法的返回值类型一致 
identifier: 委托的名称 
parameters: 参数，要引用的方法带的参数

3、使用方法
例1:
// 这个声明定义了一个名为SimpleDelegate的委托，它可以封装任何不带参数不返回值的方法。
public delegate void SimpleDelegate(); 
// 这个声明定义了一个名为ButtonClickHandler的委托，它可以封装任何带2个Objec参数返回int类型值的方法。 
public delegate int ButtonClickHandler (object obj1, object obj2)
例2:
public delegate void SimpleDelegate();                              // 跟class是同级

    class Test
    {
        public static void MyFunc()
        {
            Console.WriteLine("I was called by delegate ...");
        }

        public static void Main()
        {
            // 将方法传递给委托，然后通过委托执行方法
            SimpleDelegate simpleDelegate = new SimpleDelegate(MyFunc);
            simpleDelegate();
        }
    }
※触发委托的方法：
1、通过对委托本身的触发
public delegate void MyDelegate();
class TestDelegate
{
    public void myFun()
    {
        // Console.WriteLine("This my delegate");
    }

    MyDelegate m = new MyDelegate(myFun);
    m();// 事件触发，或是m.invoke();两者相同
}

2、通过对事件的触发
public delegate void MyDelegate();
class TestDelegate
{
    event event1;
    public void myFun()
    {
        // Console.WriteLine("This my delegate");
    }

    MyDelegate m = new MyDelegate(myFun);
    event1 += m;
    event1();// 事件触发
}






B、匿名方法
1、匿名方法的由来
<<<<<<<<<<<<<<<<<
没有匿名方法的时候(c# 1.0)
addBoutton.Click += new EventHandler(AddClick);
void AddClick(object sender, EventArgs e)
{
    listBox.Items.Add(textBox.Text);
}
>>>>>>>>>>>>>>>>>
有了匿名方法后(c# 2.0)
addBoutton.Click += delegate {
    listBox.Items.Add(textBox.Text);
};
^^^^^^^^^^^^^^^^^
匿名方法可以在delegate关键字后跟一个参数列表(可以不指定)，后面的代码块则可以访问这些参数：
addBoutton.Click += delegate(object sender, EventArgs e)
{
    MessageBox.Show(((Button)sender).Text);
};

注意：＂不指定参数列表＂与＂参数列表为空＂的区别
addBoutton.Click += delegate {...}      // 正确
addBoutton.Click += delegate() {...}    // 错误

※匿名方法是一种语法的简化，适用于临时、只使用一次的方法。


2、匿名方法的参数
（1）参数范围
匿名方法的参数的范围是“匿名方法块”。如果目标在块外部，那么，在匿名方法块内使用跳转语句（如 goto、break 或 continue）是错误的。如果目标在块内部，在匿名方法块外部使用跳转语句（如 goto、break 或 continue）也是错误的。
（2）参数类型
1）当定义带有参数的匿名方法时，应该在 delegate 关键字后面定义参数类型和名称，就好像它是一个常规方法一样。方法签名必须与它指派的委托的定义相匹配。当调用委托时，可以传递参数的值，与正常的委托调用完全一样：
delegate void SomeDelegate(string str);
public void InvokeMethod()
{
     SomeDelegate del = delegate(string str) { MessageBox.Show(str); }
     del("Hello");
}
result:
Hello
2）如果匿名方法没有参数，则可以在 delegate 关键字后面使用一对空括号：
delegate void SomeDelegate();
public void InvokeMethod()
{
     SomeDelegate del = delegate() { MessageBox.Show(("Hello"); }
     del();
}
result:
Hello
3）如果将 delegate 关键字后面的空括号一起忽略，则您将定义一种特殊的匿名方法，它可以指派给“具有任何签名的任何委托”，即左边定义的委托可有参数也可无参数：
delegate void SomeDelegate();
delegate void OtherDelegate(string str);
public void InvokeMethod()
{
     SomeDelegate somedel = delegate { MessageBox.Show("Hello"); }
     OtherDelegate otherdel = delegate { MessageBox.Show("Hello"); }
     somedel();
     otherdel("sss");
}
result:
Hello
Hello
如果匿名方法并不依赖于任何参数，而且想要使用这种与委托签名无关的方法代码，则只能使用这样的语法。注意，当调用委托时，仍然需要提供参数，因为编译器为从委托签名中推理的匿名方法生成无名参数。



3、匿名方法的返回值
- 如果委托类型的返回值void，匿名方法里便不可能为空；
- 如果委托类型的返回值类型不为void，匿名方法里的返回值必须和委托类型的返回值兼容；
没有返回值的：
delegate void MyDelegate();
MyDelegate d = delegate {
    ......
    return;// 不指定返回值，也可不写
};
有返回值的：
delegate int MyDelegate();
MyDelegate d = delegate {
    ......
    return 100;
};

4、匿名方法原理机制
delegate void myDel();
private void myFun(){};
myDel myDelInstance1 = delegate() { };
myDel myDelInstance2 = () => { };
myDel myDelInstance3 = myfun;
即匿名方法是一种方法，而不是委托，匿名方法与上面的myDel是同级的

- c# 2.0中的匿名方法仅仅是通过编译器的一层额外处理，来简化委托实例化的工作．它与c#1.0的代码不存在根本性的区别．
- 通过ILDasm.exe反汇编工具我们可以获得对匿名方法的深入了解：
    - 静态方法中的匿名方法
    - 实例方法中的匿名方法
    - 匿名方法中的外部变量
（1）静态方法中的匿名方法:
public delegate void D();
static void F()
{
    D d = delegate {Console.WriteLing("test");}
}
上面的代码被编译器转换为：
static void F()
{
    D d = new D(_Method1);
}
static void _Method1()
{
    Console.WriteLing("test");
}
编译器自动为我们的匿名方法生成一个静态方法，编译器会根据F推断生成什么方法

5、委托类型的推断
委托（或事件）的几种赋值方法：
void AddClick(object sender, EventArgs e) {
    listBox.Items.Add(textBox.Text);
}
第一种方式：（c# 1.0的传统方式）
addButton.Click += new EventHandler(AddClick);
第二种方式：（匿名方法）
addButton.Click += delegate {
    listBox.Items.Add(textBox.Text);
};
第三种方式：（直接将方法带入）
- c# ２.０ 允许我们在进行委托实例化时，省略掉委托类型，而直接采用方法名，c#编译器会做合理的推断．
addButton.Click += AddClick;    // 允许省略掉委托类型，直接使用方法名，编译器会做判断
Apply(a, Math.Sin)              // 省略参数列表




6、委托之λ表达式
与匿名方法本质上是相同的，只是书写方式不同：
// 以下两者相同
delegate() { };
() => { };

// 以下相同
delegate(int a) { };
(int a) => { };   或   (a) => { };

// 以下相同
delegate { };   会根据内容自动判断参数
() => { };   或  (int a) => { };   或   (a) => { };



C#3.0之后匿名方法可以使用λ表达式来进行定义
// 左边是参数，使用括号表达 (string param)
    myTimer.Elapsed += { (object source, EventArgs e) => Console.WriteLine("Event handler called after {0} milliseconds.", (source as Timer).Interval ) };  
// 也可以是 (param)这样不定义类型，编译器会推断出来，只有一个参数的时候可以不使用花括号。
    myTimer.Elapsed += { (source, e) => Console.WriteLine("Event handler called after {0} milliseconds.", (source as Timer).Interval ) }; 
右边是实现代码，使用花括号，如果代码只有一行，则不使用花括号和return关键字也可以，编译器会为我们添加，即不加花括号简写如下：
    myTimer.Elapsed += (source, e) => Console.WriteLine("Event handler called after {0} milliseconds.", (source as Timer).Interval );  
// 应用λ表达式。(source, e)参数应用了匿名类型，会根据上下文推到类型。=>把参数列表 和 表达式体分开。
可以代替内联的匿名方法：
   myTimer.Elapsed += delegate(object source, ElapsedEventArgs e) 
{Console.WriteLine("Event handler called after {0} milliseconds.", (source as Timer).Interval );};


★使用c# 自带的Action和Func委托
.NET 2.0带来了Action、Func两个泛型委托，Action委托没有返回值，而Func则有返回值，Action、Action<T>、Func<T>

Action、Func实际就是函数这种类型，只不过是Action没有返回值、Func有返回值
如：
public static void fun()
{}
Action a = fun;
Action b = delegate() {};
Action c = delegate(string s) {};

（1）Action系列的泛型委托
Action系列的委托定义的是没有返回值(返回值为void)的委托。它有多个版本包括无输入参数，n个输入参数等。

Action泛型示意图：
delegate void Action(); 
Action 
Action<T> 
Action<T1, T2> 
Action<T1, T2, T3> 
Action<T1, T2, T3, T4> 
Action<T1, T2, T3, T4, T5> 
Action<T1, T2, T3, T4, T5, T6> 
Action<T1, T2, T3, T4, T5, T6, T7> 
Action<T1, T2, T3, T4, T5, T6, T7, T8> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> 
Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> 

例一：
Action a(){
    return () => {Console.WriteLine("ok"); return;};    // 可以不加return;
}
例二：
Action a = () => {Console.WriteLine("ok"); return;};    // 可以不加return;   // 等同于void a() {Console.WriteLine("ok"); return;}
例三：
void show(){Console.WriteLine("show me");}
Action a = show;
例四，带参数的Action：
void show(string s){Console.WriteLine(s);}
Action<string> a = show;

（2）Func系列的泛型委托
Func系列的委托定义的是返回值的委托。它有多个版本包括无输入参数，n个输入参数等。
1）没有输入参数有返回值(返回值不为void)的委托
    Func<TResult>封装一个不具有参数但却返回 TResult 参数指定的类型值的方法。
    可以使用此委托构造一个能以参数形式传递的方法，而不用显式声明自定义的委托。该方法必须与此委托定义的方法签名相对应。这意味着封装的方法不得具有参数，但必须返回值。
2）具有一个输入参数有返回值(返回值不为void)的委托
    Func<T,TResult>封装一个具有一个参数并返回 TResult 参数指定的类型值的方法。
    可以使用此委托构造一个能以参数形式传递的方法，而不用显式声明自定义的委托。该方法必须与此委托定义的方法签名相对应。也就是说，封装的方法必须具有一个通过值传递给它的参数，并且必须返回值。
3）具有n个输入参数有返回值(返回值不为void)的委托
    Func<T1,T2,...,Tn,TResult>封装一个具有一个参数并返回 TResult 参数指定的类型值的方法。
    可以使用此委托构造一个能以参数形式传递的方法，而不用显式声明自定义的委托。该方法必须与此委托定义的方法签名相对应。也就是说，封装的方法必须具有n个均通过值传递给它的参数，并且必须返回值。

Func泛型示意图：
delegate TResult Func<out TResult>();
Func<TResult>
Func<T, TResult>
Func<T1, T2, TResult>
Func<T1, T2, T3, TResult>
Func<T1, T2, T3, T4, TResult>
Func<T1, T2, T3, T4, T5, TResult> 
Func<T1, T2, T3, T4, T5, T6, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> 
Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> 

例：
Func<String> func0() { return "Func0"; }

Func<String> func1 = () => { return "Func1"; };
// 等同Func<String> func1 = delegate { return "Func1"; };
Console.WriteLine(func1());

Func<String, String> func2 = m => { return m; };
// 等同Func<String, String> func2 = delegate(string m) { return m; };
Console.WriteLine(func2("Func2"));

Func<String, int, String> func3 = (string m, int i) => { return m + i; };
// 等同Func<String, int, String> func3 = delegate(string m, int i) { return m + i; };
Console.WriteLine(func3("Func", 3));


6、λ表达式
目标表达式：num => num == 0
构建过程：
ParameterExpression pExpression = Expression.Parameter(typeof(int));                                                    // Parameter 表达式：num
ConstantExpression cExpression = Expression.Constant(0);                                                                // Constant 表达式：0
BinaryExpression bExpression = Expression.MakeBinary(ExpressionType.Equal, pExpression, cExpression);                   // Binary 表达式：num == 0
Expression<Func<int, bool>> lambdaExpression = Expression.Lambda<Func<int, bool>>(bExpression, pExpression);            // lambda 表达式：num => num == 0

Expression<Func<int, bool>> funcExpression = num => num == 0;
// 解析
ParameterExpression pExpression = funcExpression.Parameters[0]; // lambda 表达式参数
BinaryExpression body = (BinaryExpression)funcExpression.Body;  // lambda 表达式主体：num == 0
Console.WriteLine($"解析：{pExpression.Name} => {body.Left} {body.NodeType} {body.Right}");

// 转换成委托
var lambda = funcExpression.Compile(); lambda("param1");
// 或
funcExpression.Compile()("param1");


7、匿名方法中“闭包”
    如果局部变量和参数的范围包含匿名方法声明，则该局部变量和参数称为该匿名方法的“外部”变量，这样就引出了闭包的概念。
（1）概念
官方解释：
    所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。
白话解释：
    1、内部方法（可能是匿名方法）引用了外部方法成员，此成员称为内部方法的“外部成员”，属于内部方法的一部分。
    2、调用时，如果变量引用了内部方法，则外部方法即使周期结束，外部方法的成员仍然被保持下来。
一句话解释：
    外部成员也是属于内部方法的一部分。
    外部方法返回内部方法，内部方法返回外部成员。
js中的闭包：
    function a(){
      var i=0;
      function b(){
        alert(++i);
      }
      return b;
    }
    var c = a();
    c();
这段代码有两个特点：
1）函数b嵌套在函数a内部；
2）函数a返回函数b。
    简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。
    在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。
（2）作用
1）保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。
2）在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。
（3）js与C#中闭包的对比
js中的闭包：
    function sum (x) {  
        // 以下也可直接返回匿名方法，效果相同：return function(y) { return x + y; };  
        function sumIt(y) {  
            return x + y;  
        };  
        return sumIt;  
    }  
    // Usage  
    var sumA = sum(4);  
    var sumB = sumA(3);  
    console.log(sumB); // Returns 7 

c#中的闭包：
    class Aclass
    {
        public Func<int> outerFun()   // 外部方法
        {
            int a = 1;
            return () =>      // 内部方法（由于c#不允许在方法中内嵌方法，故此处使用匿名方法）
            {
                return a;
            };
        }
    }
    var innerFun = new Aclass().outerFun();
    Console.WriteLine( innerFun().Tostring() );
（4）例释
    简单来讲，闭包允许你将一些行为封装，将它像一个对象一样传来递去，而且它依然能够访问到原来第一次声明时的上下文。这样可以使控制结构、逻辑操作等从调用细节中分离出来。访问原来上下文的能力是闭包区别一般对象的重要特征，尽管在实现上只是多了一些编译器技巧。
来个最简单的javascript中常常见到的关于闭包的例子:
function f()
{
   var n=999;
   return function(){  alert(n);  return n;  }
}
var retf =f();
alert(retf());  
这段代码翻译成C#代码就是这样：
class TCloser{
  static void Main()
  {
     var Cls =new TCloser();
     var retf = Cls.f();
     Console.WriteLine(retf());
  }
  
   public Func<int> f()
   {
      var n = 999;
      return () =>  {  Console.WriteLine(n);  return n;  };
   } 
}
    从上面的代码我们不难看到，变量n实际上是属于函数T1的局部变量，它本来生命周期应该是伴随着函数T1的调用结束而被释放掉的，但这里我们却在返回的委托b中仍然能调用它，这里正是闭包所展示出来的威力，因为T1调用返回的匿名委托的代码片段中我们用到了n，而在编译器看来，这些都是合法的，因为返回的委托b和函数T1存在上下文关系，也就是说匿名委托b是允许使用它所在的函数或者类里面的局部变量的，于是编译器通过一系列动作(具体动作我们后面再说)使b中调用的函数T1的局部变量自动闭合，从而使该局部变量满足新的作用范围。
    因此如果你看到.net中的闭包，你就可以像js中那样理解它，由于返回的匿名函数对象是在函数T1中生成的，因此相当于它是属于T1的一个属性。如果你把T1的对象级别往上提升一个层次就很好理解了，这里就相当于T1是一个类，而返回的匿名对象则是T1的一个属性，对属性而言，它可以调用它所寄存的对象T1的任何其他属性或者方法，包括T1寄存的对象TCloser内部的其他属性。如果这个匿名函数会被返回给其他对象调用，那么编译器会自动将匿名函数所用到的方法T1中的局部变量的生命周转期自动提升并与匿名函数的生命周期相同，这样就称之为闭合。


（5）另一种闭包
这是一种多线程中的闭包，

    Thread doSomethingThread = new Thread(new ParameterizedThreadStart(DoSomethingWapper));
    ClosureClass closure = new ClosureClass();
    doSomethingThread.Start(closure);// 闭包对象，用于变量穿越

8、回调
回调的若干种方法
（1）Action或Func
（2）委托
（3）接口
（4）对象
其中：
（1）、（2）是在对象A中调用对象B的一个方法时，在B中定义一个Action或Func或委托，将A的回调方法赋值给B的Action或Func或委托，需要回调时在B中调用它
（3）、（4）是在对象A中调用对象B的一个方法时，该方法要传入A对象本身或A对象转换后的接口，需要回调时在B中调A的回调方法



C、事件
1、定义
    事件是一种函数回调机制，它通过委托来实现函数回调。事件其实就是一种特殊的委托，只不过把方法注册到特定的事件，即button_click(function)->EventHandler(delegate)->button.Click(event)之后，满足特定条件时，即可通过该事件触发该方法，此事件可以看成是该方法的变量。
    自定义的EventArgs类，只不过是对“触发事件的相关信息”的一个包装类。
    C#中的事件处理实际上是一种具有特殊签名的delegate：
∵如果声明的是一个委托的话，必须要先声明委托的返回类型及参数，例如：public delegate void MyEventHandler(object sender, MyEventArgs e); 这就声明了事件的发送源sender，事件的参数e
而如果声名的是一个事件的话，他则是事先已经在C#内预置好的，是有特定的签名的，因此不需要声明任何的参数，例如：private event MyEventHandler myevent
∴C#中的event实际上是一种具有特殊签名（即(object sender, EventArgs e)）的delegate。※事件是封装过的委托实例。

2、步骤
    （1）定义一个委托类型（EventHandler）表示时间处理函数的类型
    （2）在类中用关键字event声明一个EventHandler类型的事件，事件同样具有访问性，通常为public
    （3）定义一个事件触发后欲调用的方法
    （4）注册事件
    （5）触发事件
亦即：
（0）系统在后台做的事情：开启后台线程，不断执行event事件，即运行event事件内的方法。
（1）注册事件：event += new EventHandler(function)
               事件             委托       方法
（2）触发事件：event(this, EventArgs);

备注：
※事件是一种特殊的“委托实例”
为声明的是一个委托，要先声明委托的返回类型及参数
例如：public delegate void MyEventHandler(object sender, MyEventArgs e); 
这就声明了事件的发送源sender，事件的参数e

如果声名的是一个事件，是事先已经在C#内预置好的，是有特定的签名的，因此不需要声明任何的参数
例如：private event MyEventHandler myevent

3、使用
    在c#中你可以给控件和菜单事件添加事件处理器以俘获你想处理的事件，下面的代码给Button控件的click事件设计了一个事件处理器：
button.Click += new System.EventHandler(this.button_Click);     // 回调比较典型的一种就是事件，事件其实就是一个特殊的委托
（1）button.Click相当于事件
（2）System.EventHandler相当于委托
（3）button_Click相当于方法
※button.Click实际就是一种类型为System.EventHandler的delegate的event，其定义如下：
public delegate void EventHandler(Object sender, System.EventArgs e);
public event EventHandler Click;

button_Click事件处理器必须被处理：
private void button_Click(Object sender, System.EventArgs e) 
{ MessageBox.Show("Thank you.", "The Event Information"); } 


C#的委托最经典的解释：
例子：
this.Activated += new EventHandler(Form1_Activated);     // 这是一个委托的原理.
this.Activated = 你吃完饭;   
Form1_Activated = 喊我一声;
这句话的意思就是把这两个事放在一起了，意思就是叫你吃完饭了喊我一声。我委托你吃完饭了，喊我一声。这样我就不用过一会就来看一下你吃完了没有了，已经委托你了。


常用的几个例子：
    this.Closing += new System.ComponentModel.CancelEventHandler(this.Train_Closing);
    this.Load += new System.EventHandler(this.Train_Load);
    ((System.ComponentModel.ISupportInitialize)(this.dataGrid1)).EndInit();
    this.ResumeLayout(false);
4、整理思路

                      调用                      调用
触发过程：function <-------- MyDelegate实例 <---------- event实例

                     注入                    多次注入（多播）
注册过程：function --------> MyDelegate实例 ----------> event实例
                                  ^
                                  |
            定义一个delegate      |
  delegate ------------------> MyDelegate





5、完整例子：
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    // 事件三要素之一-----定义委托
    delegate void MyEventHandler(object sender, MyEventArgs e); 
    // 事件三要素之一-----声明事件（其实就是委托）
    event MyEventHandler myEvent; 
    // 事件三要素之一-----定义方法
    void myMay(object sender, MyEventArgs e) { MessageBox.Show(e.Message); }

    // 注册监听事件
    private void Listen()
    {
        myEvent += new MyEventHandler(myMay);
    }

    // 触发事件
    private void button1_Click(object sender, EventArgs e)
    {
        if (myEvent != null)
        {
            myEvent(this, new MyEventArgs() { Message = this.button1.Text });
        }
    }

    public class MyEventArgs : EventArgs
    {
        public string Message { set; get; }
    }

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
总结：
① 委托就是一个类，也可以实例化，通过委托的构造方法来把方法赋值给委托实例
② 触发委托有2种方式: 委托实例.Invoke(参数列表)，委托实例(参数列表)
③ 事件可以看作是一个委托类型的变量
④ 通过+=为事件注册多个委托实例或多个方法
⑤ 通过-=为事件注销多个委托实例或多个方法
⑥ EventHandler就是一个委托

6、键盘点击事件监听
（1）点击事件
KeyPress事件能返回一个字符的ASCII码，但无法得知当前按键是被持续按着，还是已经放开。
KeyUp和KeyDown事件过程能处理KeyPress事件无法处理的按键，如功能键、编辑键、组合键等。
三个事件的发生顺序：KeyDown->KeyPress->KeyUp事件。
（2）键的种类
using System.Windows.Forms.Keys;
KeyEventArgs参数（KeyEventArgs e）
   Alt 获取一个值，该值指示是否曾按下 Alt 键。 
   Control 获取一个值，该值指示是否曾按下 Ctrl 键。 
   Handled 获取或设置一个值，该值指示是否处理过此事件。 
   KeyCode 获取 KeyDown 或 KeyUp 事件的键盘代码。 
   KeyData 获取 KeyDown 或 KeyUp 事件的键数据。 
   KeyValue 获取 KeyDown 或 KeyUp 事件的键盘值。 
   Modifiers 获取 KeyDown 或 KeyUp 事件的修饰符标志。这些标志指示按下的 Ctrl、Shift 和 Alt 键的组合。 
   Shift 获取一个值，该值指示是否曾按下 Shift 键。 
   SuppressKeyPress 获取或设置一个值，该值指示键事件是否应传递到基础控件。 
常用按键字符    KeyValue键值    Keys枚举值
A-Z             65-90           Keys.A-Keys.Z
0-9             48-57           Keys.0-Keys.9
F1-F12          112-123         Keys.F1-Keys.F12
上、下键        38、40          Keys.Up、Keys.Down
左、右键        37、39          Keys.Left、Keys.Right
回车键          13              Keys.Enter
空格键          32              Keys.Space
Shift键         16              Keys.ShiftKey
Ctrl键          17              Keys.Ctrl
Alt键           18              Keys.AltKey
Esc键           27              Keys.Escape
退格键          8               Keys.Backspace
Home            36              Keys.Home
End             35              Keys.End
PgUp、PgDn      33、34          Keys.PgUp、Keys.PgDn
Ins键           45              Keys.Insert
Del键           46              Keys.Delete

（3）要点
1）KeyCode、KeyData、KeyValue的区别
KeyCode最为常用，记录了键盘上按了哪个键，当使用组合键时如ctrl+a，其值是"A"；
KeyData可以记录组合键，当使用组合键时如ctrl+a时，其值为"A,ctrl"；
KeyValue则是KeyCode的数字值，当使用组合键时如ctrl+a时，其值为65（A），注意不是97（a）；
注意：这三个属性对于字母键只记录其大写的值（不管你是否开启了caplock或是按下shift键），如果一定要区分到底是大小写，可以使用KeyChar来判断。
2）ShiftKey与Shift的区别
Keys.ShiftKey  单键，用于KeyCode
Keys.Shift    组合键，用于Keydata
（4）实例
单键：
if (e.KeyCode == Keys.ShiftKey)
组合键：
if (e.KeyData == (Keys.Shift|Keys.A))
if (e.Shift==true && e.KeyCode == Keys.A)





D、协变(Covariance)和逆变(Contravariance)
class BaseEntity
{ }
class DerivedEntity : BaseEntity
{ }

static DerivedEntity DerivedEntityInstance()
{
    return new DerivedEntity();
}

static void BaseEntityInstance(BaseEntity baseEntity)
{
    // return new BaseEntity();
}

delegate T Covariance<out T>();                                                                             // 定义协变体
delegate void Contravariance<in T>(T instance);                                                             //定义逆变体
static void Main(string[] args)
{
    Covariance<DerivedEntity> derivedCovar = new Covariance<DerivedEntity>(DerivedEntityInstance);
    Covariance<BaseEntity> baseContr = derivedCovar;                                                        // 协变

    Contravariance<BaseEntity> baseContravar = new Contravariance<BaseEntity>(BaseEntityInstance);
    Contravariance<DerivedEntity> derivedContravar = baseContravar;                                         // 逆变
}




五、命名空间、类（及变量）的作用域
A、命名空间（namespace）
    在C#中命名空间有很大的作用，它指明了你所用到的类来自哪个命名空间中，例如Mail类在命名空间using System.Net.Mail和using System.Web.Mail都存在。
namespace LevelOne
{
    // name "NameThree" defined

    namespace LevelTwo
    {
        // name "NameThree" defined
    }
}
（1）在全局名称空间中，NameTwo必须被引用为LevelOne.LevelTwo.NameTwo。
（2）在LevelOne名称空间中，则可以被引用为LevelTwo.NameTwo。
（3）在LevelOne.LevelTwo名称空间中，则可以被引用为NameTwo。
要注意的是，名称是由名称空间唯一定义的。可以在LevelOne 和 LevelTwo名称空间中定义名称NameThree：
这定义了两个不同的名称LevelOne.NameThree和LevelOne.LevelTwo.NameThree，可以独立使用它们，互不干扰。

B、命名空间引用（using）
格式：using [alias = ]class_or_namespace; 
（1）引用命名空间，减少冗余代码
◆作用：创建using 指令，以便在命名空间中使用类型而不必指定命名空间。using 指令不为您提供对可能嵌套在指定命名空间中的任何命名空间的访问。
如：using System.Web.UI.WebControls; 
※using 可放在namespace外部，表示全局引用；也可放在namespace内部，表示局部引用。
如：
// 示例1
namespace A
{
    using System.Threading;
}
// 示例2
using System.Threading;
namespace B
{
}
（2）创建命名空间的别名（using 别名）
◆作用：创建using 别名以便更易于将标识符限定到“命名空间或类”。有时，不同名称空间中的相同名称会产生冲突，如果你在程序当中引用了这两个空间，但是在创建类的对象时候没有指明使用的是哪个空间中的类，那么就会出现错误，使系统崩溃(此时，代码是不能编译的，编译器会告诉我们名称有冲突)。此时，可以使用using语句为名称空间提供一个别名。
using MyAlias = MyCompany.Proj.Nested;

当“别名”与“父命名空间名称”相同时，会优先使用“父命名空间名称”，此时可通过::强制引用别名。
::也可配合关键字global一起使用，global表示顶级根名称空间的别名，如下：
using MyBilly = MyNameSpace.MyAlias;   // 此处为MyBilly
 
namespace MyNameSpace
{
    namespace MyAlias
    {
        public class MyClass
        {
        }
    }

    namespace MyBilly                  // 此处也为MyBilly
    {
        public class MyClass
        {
        }
    }

    public class MyClass
    {
        // 此引用的真实类名是MyNameSpace.MyBilly.MyClass，而不是MyNameSpace.MyAlias(using MyBilly).MyClass
        MyBilly.MyClass...
        // 此引用的真实类名是MyNameSpace.MyAlias(using MyBilly).MyClass，而不是MyNameSpace.MyBilly.MyClass
        MyBilly::MyClass...
        // 此例中global与MyNameSpace表示意义相同
    }
}
因此，实际应用中，应尽量避免使命名空间的别名与已有的.NET命名空间名称相同。

（3）即时释放资源
◆作用：定义一个对象的执行区域，在这个区域代码执行完毕后，释放该对象所占用资源（包括托管资源和非托管资源）。
using (TestObject a = new TestObject()) { 
    // 执行代码 
} //对象资源被释放 

（4）不同程序集存在相同命名空间的冲突解决办法
step 1:
引用->A程序集->别名->globalA        //多个不同的程序集可使用相同的别名
step 2:
extern alias globalA;               //通过别名引入程序集


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
using GuangDong;                    //引用这个命名空间，主要是省去当前文档代码下的前缀.
            
namespace GuangDong                 //这个是命名空间的地址  (比方说，命名空间是省份地址，如广东省)
{               
   public class aaa                 //这个是类名   (类名是市级地址，如广州)
   {}
} 


namespace BeiJing
{
   public class HaiDian
   {}
}

当在BeiJing的命名空间下要访问GuangDong命名空间里的类，
GuangDong.GuangZhou gz = new GuangDong.GuangZhou();定义一个类，但要完全指定命名空间。

如果在开头打上：using GuangDong
GuangZhou gz = new GuangZhou();定义一个类，但要完全指定命名空间。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

C、各种修饰符的意义
在用继承的时候，public修饰符会自动初始化，在这里相当于自动初始b，又把它变为了0。
在用static修饰符的时候，不会自动初始化，把变量的值记录下来.

private   仅限本类中可以访问，其它类（包括派生类）不可访问
protected 仅限本类及派生类中可以访问，其它类不可访问
internal  访问仅限于当前程序集。（默认为此）
public    其它类也可以访问，值是相互隔离的
abstract  修饰抽象类时，指示该类只能作为父类被用于继承，而不能进行对象实例化
          修饰抽象方法时，指示该方法或属性没有实现.
virtual   允许在派生类中重写该对象，用于修饰方法，属性，索引器或事件声明
sealed    用来修饰类为密封类，阻止该类被继承。同时对一个类作abstract和sealed的修饰是没有意义的，也是被禁止的
extern    用于声明在外部实现的方法，在调用windows底层c语言接口时常会用到
override  要扩展或修改继承的方法、属性、索引器或事件的抽象实现或虚实现，必须使用 override 修饰符（重写的基方法必须是 virtual、abstract 或 override 的）
void      没有返回值
static    静态：指示一个成员属于类型本身，而不是某一特定的对象，在vb中叫作shared
          调用该方法时，不用实例化
          仅本类中可以访问，不能在本类的实例中访问         
          非静态方法可以访问静态和非静态类中的任何成员，静态方法只能访问类中的静态成员，否则会提示“非静态的字段、方法或属性”
partial   指示一个类只是定义的一部分，用于把类定义拆分为几个部分
readonly  指定该成员是只读的
const     指定该成员是常量
event     声明一个事件
new       指示该方法或属性隐藏其对应的父类方法或属性

-----------------------------------------------------------------------
c# 的默认访问修饰符是private 还是 internal？ 
准确的说，不能一概而论。 
[MSDN] 
Classes and structs that are not nested within other classes or structs can be either public or internal. A type declared as public is accessible by any other type. A type declared as internal is only accessible by types within the same assembly. Classes and structs are declared as internal by default unless the keyword public is added to the class definition, as in the previous example. Class or struct definitions can add the internal keyword to make their access level explicit. Access modifiers do not affect the class or struct itself — it always has access to itself and all of its own members. 
类(class)或结构(struct)如果不是在其它类或结构中的话，它的访问类型不是internal, 就是public； 
※换句话说，如果它在其它类或结构中的话，则可以为private 或protected等。下面我说的类和结构，如无特殊说明，均指非"类中类" 
类、结构、枚举（不在类中的）、委托这种定义级别的，默认访问类型是internal. 
类中所有的成员（包括类中的枚举）这种声明级别的，默认均为private。 
[MSDN] 
Interfaces, like classes, can be declared as public or internal types. Unlike classes, interfaces default to internal access. Interface members are always public, and no access modifiers can be applied. 
Namespaces and enumeration members are always public, and no access modifiers can be applied. 
Delegates have internal access by default. 
Any types declared within a namespace or at the top level of a compilation unit (for example, not within a namespace, class, or struct) are internal by default, but can be made public. 
-----------------------------------------------------------------------
例例例例例例例例例例例例例例例例例例
//partial例
class ClassA
{
      void A(){;}
      void B(){;}
}
与
partial class ClassA
{
      void A(){;}
}
partial class ClassA
{
      void B(){;}
}
是一样的 
例例例例例例例例例例例例例例例例例例
父类调子类的方法
class Parent
{
    public virtual void Do()
    {}

    public void Test()
    {
        Do();                                   //此处当调用者是子类Son即①的实例时，此处调用的是子类的Do方法
        Do();                                   //此处当调用者是父类Parent即②本身的实例时，此处调用的是父类的Do方法
        dynamic son = this; son.OnlySon();      //此处当调用者是子类Son即①的实例时，可执行子类的Only方法
        dynamic son = this; son.OnlySon();      //此处当调用者是父类Parent即②本身的实例时，会报错（因为父类没有此方法）
    }
}

class Son : Parent
{
    public override void Do()
    {}
    public void OnlySon()
    {}
}

即：
class Program
{
    static void Main(string[] args)
    {
        Son son = new Son();
        son.Test();                             //Test方法中调用的是子类的Do方法①
        Parent parent = new Parent();
        parent.Test();                          //Test方法中调用的是父类的Do方法②
    }
}
例例例例例例例例例例例例例例例例例例


总结：
普通父类  目的是为了每个派生类都有“相同的父类方法”
abstract  目的是为了每个派生类都有“同一个‘不同实现’的派生类方法”。可用于类、方法，不可实例化。其中抽象类可声明、可定义方法，抽象方法只可声明、不可定义
virtual   目的是为了每个派生类都有“同一个‘不同实现’的派生类方法”，同上。可用于方法、属性，表示该方法或属性可以被重写覆盖
interface 目的是为了每个派生类都有“相同签名的方法”，不可实例化，可声明、不可定义方法


※解析
1、new新定义类（可用于隐藏类）
在用作修饰符时，new关键字可以在派生类中隐藏基类的方法，也就说在使用派生类的方法是调用的方法是new关键字新定义出来的方法，而不是基类的方法。在不使用new关键字来隐藏基类方法也是可以的，编译器会出现一个警告，提示如果有意去隐藏基类的方法，请使用new关键字修饰。（不使用new关键词也能运行，但会出现警告。） 


public class BaseClass
{
    public void Do()
    {
        HttpContext.Current.Response.Write("基类方法");
    }
}
 
public class DerivedClass : BaseClass
{
    public new void Do()
    {
        HttpContext.Current.Response.Write("派生类方法");
    }
}
new 不能位于返回值类型（这里是 void）之后。

调用：

DerivedClass dc = new DerivedClass();
dc.Do(); // 派生类方法
((BaseClass)dc).Do(); // 基类方法
dc 被转换成 BaseClass 后，其调用的就是基类的方法。

2、virtual虚拟方法
virtual 关键字允许在派生类中重写这些对象，默认情况下，方法是非虚拟的，不可以重写非虚方法，virtual关键字不可以与static、abstract、 private、override一起使用。virtual关键字又是和override紧密不可分的，如果要实现virtual方法就必须要使用 override或new关键字（new和override产生的机理不同）。 

关键字用于修饰方法、属性、索引器或事件声明，并使它们可以在派生类中被重写。 例如，此方法可被任何继承它的类重写。 
 public virtual double Area() 
{
    return x * y;
}
虚拟成员的实现可由派生类中的重写成员更改。
通过包括使用 override 修饰符的属性声明，可在派生类中重写虚拟继承属性。

3、override重写类
override关键字主要是提供派生类对基类方法的新实现，重写的基类方法必须和override的方法具有相同的签名， 此关键字不可以用于重写非虚方法和静态方法，与其配套使用的关键字是virtual、abstract、override。与此同时，override方 法还不可以修改virtual方法的可访问性，override方法和virtual方法必须具有相同的访问修饰符，不能使用修饰符 new、static、virtual 或 abstract 来修改 override 方法。 

public class BaseClass
{
    public virtual void Do()
    {
        HttpContext.Current.Response.Write("基类方法");
    }
}
 
public class DerivedClass : BaseClass
{
    public override void Do()
    {
        HttpContext.Current.Response.Write("派生类方法");
    }
}
调用：

DerivedClass dc = new DerivedClass();
dc.Do(); // 派生类方法
((BaseClass)dc).Do(); // 派生类方法
调用的都是派生类方法。

另：有个注意事项就是new和override这两个关键字是互斥的。不可以同时使用。




3.5、override与new
----------------------------------------
class Base
{
    public virtual void F1()
    {
        Console.WriteLine("Base's virtual function F1");
    }
    public virtual void F2()
    {
        Console.WriteLine("Base's virtual fucntion F2");
    }
}

class Derived : Base
{
    public override void F1()
    {
        Console.WriteLine("Derived's override function F1");
    }
    public new void F2()
    {
        Console.WriteLine("Derived's new function F2");
    }
}

class Program
{
    public static void Main(string[] args)
    {
        Base b1 = new Derived();
        //由于子类覆盖了父类的方法，因此这里调用的是子类的F1方法。也是OO中多态的体现
        b1.F1();
        //由于在子类中用new隐藏了父类的方法，因此这里是调用了隐藏的父类方法
        b1.F2();
    }
}

----------------------------------------

4、static静态类
（1）static静态类
静态类只用于包含静态成员的类型，它既不能实例化，静态类的特性是防止继承，防止外部来NEW。它相当于一个sealed abstract类
静态类的几个注意点：
静态类不能有实例构造器。
静态类不能有任何实例成员。
静态类不能使用abstract或sealed修饰符。
静态类默认继承自System.Object根类，不能显式指定任何其他基类。
静态类不能指定任何接口实现。
静态类的成员不能有protected或protected internal访问保护修饰符.
    通常，类是写着一个指向存储“实例化后对象”的“堆”的地址，而静态类最主要的一个优点是写在栈中，安全高速稳定，而且在执行的时候，十分优先，你做个断点就知道了，它总是被先编译的。

静态类和非静态类的区别：
1）构造方法，无论在静态类或非静态类中，如果我们定义了一个static的构造方法，那么只要创建这个类的实例或调用这个类的方法，都将自动调用这个Static的构造方法，并且Static的构造方法是不能有访问权限的。static的构造方法是不能有参数的。
2）静态类中不能调用实例构造方法
3）静态类中不能创建非静态的方法。即静态方法中只能创建静态方法，但在非静态类中可以调用静态方法
在c#中 class 不能显式地声明为 private 声明一个不能被外部所有地方访问的 private class 有什么意义?（我不知道）


（2）static静态变量
静态分配的，有两种情况：
1. 用在类内部的属性、方法前面，这样的静态属性与方法不需要创建实例就能访问，通过类名或对象名都能访问它，静态属性、方法只有“一份”：即如果一个类新建有N个对象，这N个对象只有同一个静态属性与方法，使用静态属性、方法不需new实例化，直接使用即可；
2. 用在方法内部的静态变量，执行完静态变量值不消失，再次执行此对象的方法时，值仍存在，它不是在栈中分配的，是在静态区分析的，这是与局部变量最大的区别；静态变量放在程序的全局数据区，而不是在堆栈中分配，不会导致堆栈溢出。
注：
1）static方法中不能直接使用非静态成员，因为非静态成员与实例相关，通过对象取间接使用
2）static方法中不能用this（与实例相关）（但在java中可以，但会警告将this.改为classname.）
3）非static方法中可以使用static成员
4）类的静态成员是属于类的，不属于类的实例，所以多次初始化一个带有静态成员的类，不会多次初始化该静态成员

（3）static静态方法
静态函数无法访问非静态变量。非静态变量是实例变量（和实例相关），而静态方法是类方法（只和类相关），在实例还没有生成之前静态变量是无法使用实例变量的，因为实例变量根本还没生成。

class Test{
    int i;
    static void setTest(){
        i = 1;//这样编译出错
    }
}


5、abstract抽象类
抽象类实现一个接口可以不实现接口的方法

6、extern函数在程序集外部实现
extern关键字表示函数的实现在程序集外部
多用于调用winAPI函数(配合DllImport使用)，在和DllImport使用时需要加上static，不能和abstract同时使用，因为方法的实现在外部。用DllImport需要引入using System.Runtime.InteropServices命名空间。
例：
[DllImport("User32.dll")]
public static extern int MessageBox(int Handle, string Message, string Caption, int Type);
static int Main()
{
   return MessageBox(0, "Hello World", "My Message Box", 0);
}



D、各种类型的默认修饰符
属于     默认的成员可访问性     该成员允许的声明的可访问性 
Enum     public                
class    private                public 
                                protected 
                                internal 
                                private 
                                protected internal
private  public                 无
struct   private                public 
                                internal 
                                private



E、例1：（以变量为例）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
public class A
{
    protected int x;
    private int y;
    public int z;
}


public class B:A
{
    protected int zxy;
    
    public void main()
    {
        A aa=new A();
        B bb=new B();
        //aa.z
        //bb.x bb.z bb.zxy
    }
}




public class C
{
    protected int zxy;
    
    public void main()
    {
        A aa=new A();
        B bb=new B();
        C cc=new C();
        //aa.z
        //bb.z
        //cc.zxy
    }
}


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
例2：（仍以变量为例，说明C#中变量有无static的区别）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
using System;

namespace Project3
{
 /// <summary>
 /// Class1 的摘要说明。
 /// </summary>
 /// 

 
 public class Class1
 {
  public int b;
  public static int a;
  public void Class11()
  {
   b=b+1;
   a=a+1;
   System.Console.Write("static:" + a + "\n");
   System.Console.Write("public:" + b + "\n");
   
  }


 }
 public class Class2:Class1
 {
  public void Class22()
  {
   b=b+1;
   a=a+1;
   System.Console.Write("static:" + a + "\n");
   System.Console.Write("public:"+ b + "\n");
  }

  static void Main(string[] args)
  {
   Class1 bb = new Class1();
   bb.Class11();
   Class2 cc = new Class2();
   cc.Class22();
   System.Console.Read();

  }
 }

}

输出结果

static:1
public:1
static:2
public:1

在用继承的时候，public修饰符会自动初始化，在这里相当于自动初始b，又把它变为了0。

在用static修饰符的时候，不会自动初始化，把变量的值记录下来.
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

例3：
例例例例例例例例例例例例例例例例例例 
public class a
{
public static int a1 = 1; 
public int a2 =2; 
}
如B中使用a
Class b
{
int b1 = a.a1;          //对
int b1 = a.a2;          //错
a A = new a();          //a实例化后
int b1 = a.a2;          //对
}
例例例例例例例例例例例例例例例例例例



六、接口
A、意义：
    接口只包含只有方法，属性，索引器（有参属性），事件四种成员。方法的实现是在实现接口的类中完成的。接口方法默认是public类型，不能显示指定方法的public类型。接口或抽象类都不能实例化。
1.接口是对行为的抽象，可以定义多个类分别实现不同的行为。
2.多人同时开发时，可以让团队成员的开发独立最后通过统一调用接口而提高协同效率。
3.在设计的时候，接口可以让我们思路清晰，而且可以加上注释让人更容易理解，而不用关心具体实现的类【如果有N个类就麻烦了】。

B、接口与抽象类
1、不同点：
（1）抽象类是一个不完全的类，可以被继承（但不能被实例化），有成员变量（包含静态成员变量）、属性、常量、静态方法和抽象方法，并且他们可以是非公共的；
     接口是一个行为的规范，里面的所有东西都是抽象的，不可以被实例化，不能有成员变量、常量、静态方法（但在Java中接口可以定义final static常量），只能有公共的属性。
（2）一个类可以继承一个父类，或实现多个接口；
     接口不能继承类，可以继承多个接口。
（3）抽象类前可以加private、public、protected等修饰符；
     接口前不能加private、public、protected等修饰符；（但java中可以）
2、相同点：
（1）不能实例化，只能被继承或实现（在java中叫作被实现implements）；
（2）包含未实现的方法声明；
（3）派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）；
3、适用情况
（1）如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。
（2）如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口。
（3）如果要设计大的功能单元，则使用抽象类。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类。   
（4）抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。

C、抽象方法与虚方法
（1）抽象方法
   1）使用abstract关键字   例如： public abstract bool Withdraw(…);
   2）抽象方法只能在抽象类中声明， 抽象方法必须在派生类中重写
   3）抽象方法是可以看成是没有实现体的虚方法
   如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其它一般方法。
（2）虚方法
   1）使用virtual关键字   例如： public virtual bool Withdraw(…);
   2）调用虚方法，运行时将确定调用对象是什么类的实例，并调用适当的覆写的方法。
   3）虚方法必须有实现部分，子类可以覆盖也可以不覆盖，根据取决于要求。


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
接口与抽象方法
1.接口
Interface IDemo
{
    void Do();
}

class Demo
{
    void Do()
    {}
}

IDemo demo = new Demo();
demo.Do();                      //Do方法是IDemo中定义的，实际调用的是Demo的Do方法
                                //本质：以基类为“骨”，以派生抽象类为“内容”


2.抽象方法
public abstract class Demo
{
    public abstract string Do()
    {
        return "base";
    }
}

public class DemoDerive
{
    public override string Do()
    {
        return "derive";
    }
}

void Main()
{
    Demo d = new DemoDerive();
    d.Do();                     //Do方法是Demo中定义的，实际调用的是DemoDerive的Do方法
                                //本质：以基类为“基础”，以派生抽象类为“补充”，叠加部分以派生抽象类为准
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
接口实现：接口实现分显式实现和隐式实现。
//定义接口
interface IGraphic
{
    float getArea();
}
//隐式实现接口
public class Rectangle : IGraphic
{
    private float _width = 10;
    private float _height = 10;


    #region  隐式实现 IGraphic 成员
    public float getArea()
    {
        return _width * _height;
    }
    #endregion

}
//两种方式均可以调用接口方法
static void Main(string[] args)
{
    //调用方式1
    IGraphic grahic  = new Rectangle();
    float area = grahic.getArea();
    Console.Write(area.ToString());
    Console.Read();

    //调用方式2
    Rectangle rectangle = new Rectangle();
    area = rectangle.getArea();
    Console.Write(area.ToString());
    Console.Read();
}


为了限制使用者只能通过接口调用，可以显式实现接口
namespace ConsoleApplication1
{
    interface IGraphic
    {
        float getArea();
    }

    public class Rectangle : IGraphic
    {
        private float _width = 10;
        private float _height = 10;


        #region  显式实现 IGraphic 成员，只复写接口中的方法，屏蔽子类中的方法
        float IGraphic.getArea()
        {
            return _width * _height;
        }
        #endregion

       
        //#region  隐式实现 IGraphic 成员，复写子类和接口中的方法
        //public float getArea()
        //{
        //    return _width * _height;
        //}
        //#endregion

    }

    class Program
    {
        static void Main(string[] args)
        {
            //调用方式1  
            IGraphic grahic = new Rectangle();
            float area = grahic.getArea();
            Console.Write(area.ToString());
            Console.Read();

            ////调用方式2 已经通不过编译了
            //Rectangle rectangle = new Rectangle();
            //float area = rectangle.getArea();
            //Console.Write(area.ToString());
            //Console.Read();
        }
    }
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
总结：从接口的定义方面来说，接口其实就是类和类之间的一种协定，一种约束。从调用者角度来说，如果他知道了某个类是继承于IGraphic接口，那么他就可以放心大胆的调用
getArea方法。再就是如果接口显示实现，就可以限制调用者只能通过接口调用了。


七、异常处理
A、类型
对.NET类来说，一般的 异常类System.Exception 派生于 System.Object。还有许多定义好的异常类（如：System.SystemException、System.ApplicationException等），他们又派生于 System.Exception 类。
●System.SystemException——通常由.NET运行库生成，或者有着非常一般的本质、可以由几乎所有的应用程序生成。例如，如果.NET运行库检测到堆栈已满，就会抛出StackOverflowException。另一方面，如果检测到调用方法时参数不正确，可以在自己的代码中选择抛出ArgumentException或其子类。System.SystemException的子类包括表示致命错误和非致命错误的异常。
●System.ApplicationException——这个类非常重要，因为它是第三方定义的异常基类。如果自己定义的异常覆盖了应用程序独有的错误情况，就应使它们直接或间接派生于System.ApplicationException。
其他可能用到的异常类包括：
●StackOverflowException——如果分配给堆栈的内存区域已满，就会抛出这个异常。如果一个方法连续地递归调用它自己，就可能发生堆栈溢出。这一般是一个致命错误，因为它禁止应用程序执行除了中断以外的其他任务。在这种情况下，甚至也不可能执行finally块，通常用户自己不能处理像这样的错误，而应退出应用程序。
●EndOfStreamException——这个异常通常是因为读到文件末尾而抛出的。第35章将解释流，流表示数据源之间的数据流。
●OverflowException——如果要在checked环境下把包含值–40的int类型数据转换为uint数据，就会抛出这个异常。

System.Exception　　最泛化的异常，所有在异常类型都从它派生
System.ArgumentException　　传给方法的一个参数无效
System.ArgumentNullException　　一个不应该为null的参数为null
System.FormatException　　参数格式不符合调用的方法的参数规范
System.IndexOutOfRangeException　　试图访问一个不存在的数组元素
System.InvalidCastException　　因无效的类型转换或显式转换引发的异常
System.NotImplementedException　　虽然找到了对应的方法签名，但是该方法尚未完全实现
System.NullReferenceException　　试图访问尚未包含任何数据的一个变量
System.ArithmeticException　　发生了一个无效的数学运算，但其中不包括被零除
System.ArrayTypeMismatchException　　试图将类型有误的元素存储到数组中


B、作用
try { //执行的代码，其中可能有异常。一旦发现异常，则立即跳到catch执行。否则不会执行catch里面的内容 }
catch { //除非try里面执行代码发生了异常，否则这里的代码不会执行 }
finally { //不管什么情况都会执行，包括try catch 里面用了return，可以理解为只要执行了try或者catch，就一定会执行 finally }
C、格式
在代码中对异常进行处理，一般要使用三个代码块：
Try 块的代码是程序中可能出现错误的操作部分。
Catch 块的代码是用来处理各种错误的部分（可以有多个）。必须正确排列捕获异常的catch子句，范围小的Exception放在前面的catch。即如果Exception之间存在继承关系，就应把子类的Exception放在前面的catch子句中
Finally 块的代码用来清理资源或执行要在try块末尾执行的其他操作（可以省略）。且无论是否产生异常，Finally块都会执行。

try
{
  throw new Exception("Here is error!");
}
catch (Exception ex)
{
  MessageBox.Show(ex.Message);
}
finally
{
}
ex的位置：只能在cath块 （异常处理块）
ex的作用：存着系统捕获的异常;
为什么要用ex:因为你不是神，并不能预测到你的程序会出什么错，所以就用
MessageBox.Show(ex.Message);让系统提示你程序错在哪里，就可以顺藤摸瓜，逮到错误原从而解决他！

D、执行顺序
※finally执行是在try、catch之后，try、catch的return之前
1、try-->无错直接finally及finally的return-->try的return（如finally无return，则执行此步）
2、有错执行catch
3、finally及finally的return
4、catch的return（如finally无return，则执行此步）

E、自定义异常
1、定义我们的基础异常类
例：
定义两个处理异常的方法，使用base关键字让CustomException方法继承自基本的错误异常类ApplicationException并提供了两个参数，一个异常消息参数和一个异常错误类。
public class CustomException:ApplicationException  
{  
    public CustomException()  
    { 
    }  
    public CustomException(string message, Exception inner) : base(message, inner) 
    { 
    }  
} 
2、然后我们再定一个处理我们不同自定义错误类型的错误处理类，不同的应用程序异常类型使用不同的异常处理类。   
例：当出现相应类型的异常时，在这个自定义异常处理中可以在出现错误的时候做一系列的处理，然后再抛出异常信息，例如：记录错误日志，或者做容错处理等。
public class DuplicateCustomerIDException : CustomException  
{  
    public DuplicateCustomerIDException()  
    { 
    } 

    public DuplicateCustomerIDException(string message, Exception inner) : base(message, inner)  
    { 
    }  
} 
3、最后我们在调用自定义的C#异常类时，编写代码捕获这个我们自定义类型的异常
try
{
    if(ex.Number == 8888)  
    {  
        throw new DuplicateCustomerIDException("CustomerID重复", ex);  
    } 
}
catch(DuplicateCustomerIDException ex)
{
    MessageBox.Show(ex.Message);
}  

F、C#异常类相关总结
C#异常类一、基类Exception
C#异常类二、常见的异常类
1、SystemException类:该类是System命名空间中所有其他异常类的基类。（建议：公共语言运行时引发的异常通常用此类）
2、ApplicationException类：该类表示应用程序发生非致命错误时所引发的异常（建议：应用程序自身引发的异常通常用此类）
C#异常类三、与参数有关的异常类
此类异常类均派生于SystemException，用于处理给方法成员传递的参数时发生异常
1、ArgumentException类：该类用于处理参数无效的异常，除了继承来的属性名，此类还提供了string类型的属性ParamName表示引发异常的参数名称。
2、FormatException类：该类用于处理参数格式错误的异常。
C#异常类四、与成员访问有关的异常
1、MemberAccessException类：该类用于处理访问类的成员失败时所引发的异常。失败的原因可能的原因是没有足够的访问权限，也可能是要访问的成员根本不存在（类与类之间调用时常用）
2、MemberAccessException类的直接派生类：
i、FileAccessException类：该类用于处理访问字段成员失败所引发的异常
ii、MethodAccessException类：该类用于处理访问方法成员失败所引发的异常
iii、MissingMemberException类：该类用于处理成员不存在时所引发的异常
C#异常类五、与数组有关的异常
以下三个类均继承于SystemException类
1、IndexOutOfException类：该类用于处理下标超出了数组长度所引发的异常
2、ArrayTypeMismatchException类：该类用于处理在数组中存储数据类型不正确的元素所引发的异常
3、RankException类：该类用于处理维数错误所引发的异常
C#异常类六、与IO有关的异常
1、IOException类：该类用于处理进行文件输入输出操作时所引发的异常。
2、IOException类的5个直接派生类：
i、DirectionNotFoundException类：该类用于处理没有找到指定的目录而引发的异常。
ii、FileNotFoundException类：该类用于处理没有找到文件而引发的异常。
iii、EndOfStreamException类：该类用于处理已经到达流的末尾而还要继续读数据而引发的异常。
iv、FileLoadException类：该类用于处理无法加载文件而引发的异常。
v、PathTooLongException类：该类用于处理由于文件名太长而引发的异常。
C#异常类七、与算术有关的异常
1、ArithmeticException类：该类用于处理与算术有关的异常。
2、ArithmeticException类的派生类：
i、DivideByZeroException类：表示整数货十进制运算中试图除以零而引发的异常。
ii、NotFiniteNumberException类：表示浮点数运算中出现无穷打或者非负值时所引发的异常。




"ERROR: 55P03: could not obtain lock on relation \"grc_group\""


G、PostgreSQL 错误码
PostgreSQL 服务器发出的所有消息都赋予了五个字符 的错误代码， 这些代码遵循 SQL 的 "SQLSTATE" 代码的习惯。需要知道发生了什么错误条件的应用通常应该测试错误代码， 而不是查看文本错误信息。这些错误 代码轻易不会随着 PostgreSQL 的版本更新而修改， 并且一般也不会随着错误信息的本地化而发生修改。 请注意有些，但不是全部，PostgreSQL 生成的错误代码是由 SQL 标准定义的； 有些标准没有定义的错误条件是我们发明的或者是从其它数据库借来的。
 
    根据标准，错误代码的头两个字符表示错误类别，而后三个字符表示在该 类别内特定的条件。 因此，那些不能识别特定错误代码的应用仍然可以从错误类别中推断要做什么。
 
    Table A-1 里面列出了 PostgreSQL 8.0.0 定义的所有错误代码。（有些实际上目前并没有使用，但是 SQL 标准定义了。） 错误类别也列出在此。对于每个错误类别都有个"标准"的错误代码， 它的最后三个字符是 000。这个代码只用于那些落在该类别内， 但是没有赋予任何更准确的代码的错误条件。
 
    PL/pgSQL 用于每个错误代码的条件名和表中显示的措辞相同， 只是用下划线代替了空白。比如，代码 22012，DIVISION BY ZERO， 它的条件名是 DIVISION_BY_ZERO。条件名可以用大写或者小写来写都可以。 （请注意PL/pgSQL并不识别警告，这一点和错误，条件名正相反；那些类别是00，01，和02。）


错误代码 含义 
 00 类     成功完成 
 00000     成功完成（SUCCESSFUL COMPLETION） 
 01 类     警告 
 01000 警告（WARNING） 
 0100C 返回了动态结果（DYNAMIC RESULT SETS RETURNED） 
 01008 警告，隐含补齐了零比特位（IMPLICIT ZERO BIT PADDING） 
 01003 在集合函数里消除了空值（NULL VALUE ELIMINATED IN SET FUNCTION） 
 01007 没有赋予权限（PRIVILEGE NOT GRANTED） 
 01006 没有撤销权限（PRIVILEGE NOT REVOKED） 
 01004 字串数据在右端截断（STRING DATA RIGHT TRUNCATION） 
 01P01 废弃的特性（DEPRECATED FEATURE） 
 02 类 没有数据 — 按照 SQL:1999 的要求，这也是警告类 
 02000 没有数据（NO DATA） 
 02001 返回了没有附加动态结果集（NO ADDITIONAL DYNAMIC RESULT SETS RETURNED） 
 03 类 SQL 语句尚未结束 
 03000 SQL 语句尚未结束（SQL STATEMENT NOT YET COMPLETE） 
 08 类 连接例外 
 08000 连接例外（CONNECTION EXCEPTION） 
 08003 连接不存在（CONNECTION DOES NOT EXIST） 
 08006 连接失败（CONNECTION FAILURE） 
 08001 SQL 客户端不能建立 SQL 连接（SQLCLIENT UNABLE TO ESTABLISH SQLCONNECTION） 
 08004 SQL 服务器拒绝建立 SQL 连接（SQLSERVER REJECTED ESTABLISHMENT OF SQLCONNECTION） 
 08007 未知的事务解析（TRANSACTION RESOLUTION UNKNOWN） 
 08P01 违反协议（PROTOCOL VIOLATION） 
 09 类 触发器动作列外 
 09000 触发的动作例外（TRIGGERED ACTION EXCEPTION） 
 0A 类 不支持特性 
 0A000 不支持此特性（FEATURE NOT SUPPORTED） 
 0B 类 非法事务初始化 
 0B000 非法事务初始化（INVALID TRANSACTION INITIATION） 
 0F 类 指示器例外 
 0F000 指示器例外（LOCATOR EXCEPTION） 
 0F001 非法的定位器声明（INVALID LOCATOR SPECIFICATION） 
 0L 类 非法赋权人 
 0L000 非法赋权人（INVALID GRANTOR） 
 0LP01 非法赋权操作（INVALID GRANT OPERATION） 
 0P 类 非法角色声明 
 0P000 非法角色声明（INVALID ROLE SPECIFICATION） 
 21 类 势违反 
 21000 势违反（CARDINALITY VIOLATION） 
 22 类 数据例外 
 22000 数据例外（DATA EXCEPTION） 
 2202E 数组下标错误（ARRAY SUBSCRIPT ERROR） 
 22021 字符不在准备好的范围内（CHARACTER NOT IN REPERTOIRE） 
 22008 日期时间字段溢出（DATETIME FIELD OVERFLOW） 
 22012 被零除（DIVISION BY ZERO） 
 22005 赋值中出错（ERROR IN ASSIGNMENT） 
 2200B 逃逸字符冲突（ESCAPE CHARACTER CONFLICT） 
 22022 指示器溢出（INDICATOR OVERFLOW） 
 22015 内部字段溢出（INTERVAL FIELD OVERFLOW） 
 2201E 对数运算的非法参数（INVALID ARGUMENT FOR LOGARITHM） 
 2201F 指数函数的非法参数（INVALID ARGUMENT FOR POWER FUNCTION） 
 2201G 宽桶函数的非法参数（INVALID ARGUMENT FOR WIDTH BUCKET FUNCTION） 
 22018 类型转换时非法的字符值（INVALID CHARACTER VALUE FOR CAST） 
 22007 非法日期时间格式（INVALID DATETIME FORMAT） 
 22019 非法的逃逸字符（INVALID ESCAPE CHARACTER） 
 2200D 非法的逃逸字节（INVALID ESCAPE OCTET） 
 22025 非法逃逸序列（INVALID ESCAPE SEQUENCE） 
 22010 非法指示器参数值（INVALID INDICATOR PARAMETER VALUE） 
 22020 非法限制值（INVALID LIMIT VALUE） 
 22023 非法参数值（INVALID PARAMETER VALUE） 
 2201B 非法正则表达式（INVALID REGULAR EXPRESSION） 
 22009 非法时区显示值（INVALID TIME ZONE DISPLACEMENT VALUE） 
 2200C 非法使用逃逸字符（INVALID USE OF ESCAPE CHARACTER） 
 2200G 最相关类型不匹配（MOST SPECIFIC TYPE MISMATCH） 
 22004 不允许 NULL 值（NULL VALUE NOT ALLOWED） 
 22002 NULL 值不能做指示器参数（NULL VALUE NO INDICATOR PARAMETER） 
 22003 数字值超出范围（NUMERIC VALUE OUT OF RANGE） 
 22026 字串数据长度不匹配（STRING DATA LENGTH MISMATCH） 
 22001 字串数据右边被截断（STRING DATA RIGHT TRUNCATION） 
 22011 抽取子字串错误（SUBSTRING ERROR） 
 22027 截断错误（TRIM ERROR） 
 22024 未结束的 C 字串（UNTERMINATED C STRING） 
 2200F 零长度的字符串（ZERO LENGTH CHARACTER STRING） 
 22P01 浮点例外（FLOATING POINT EXCEPTION） 
 22P02 非法文本表现形式（INVALID TEXT REPRESENTATION） 
 22P03 非法二进制表现形式（INVALID BINARY REPRESENTATION） 
 22P04 错误的 COPY 格式（BAD COPY FILE FORMAT） 
 22P05 不可翻译字符（UNTRANSLATABLE CHARACTER） 
 23 类 违反完整性约束 
 23000 违反完整性约束（INTEGRITY CONSTRAINT VIOLATION） 
 23001 违反限制（RESTRICT VIOLATION） 
 23502 违反非空（NOT NULL VIOLATION） 
 23503 违反外键约束（FOREIGN KEY VIOLATION） 
 23505 违反唯一约束（UNIQUE VIOLATION） 
 23514 违反检查（CHECK VIOLATION） 
 24 类 非法游标状态 
 24000 非法游标状态（INVALID CURSOR STATE） 
 25 类 非法事务状态 
 25000 非法事务状态（INVALID TRANSACTION STATE） 
 25001 活跃的 SQL 状态（ACTIVE SQL TRANSACTION） 
 25002 分支事务已经激活（BRANCH TRANSACTION ALREADY ACTIVE） 
 25008 持有的游标要求同样的隔离级别（HELD CURSOR REQUIRES SAME ISOLATION LEVEL） 
 25003 对分支事务的不恰当的访问方式（INAPPROPRIATE ACCESS MODE FOR BRANCH TRANSACTION） 
 25004 对分支事务的不恰当的隔离级别（INAPPROPRIATE ISOLATION LEVEL FOR BRANCH TRANSACTION） 
 25005 分支事务没有活跃的 SQL 事务（NO ACTIVE SQL TRANSACTION FOR BRANCH TRANSACTION） 
 25006 只读的 SQL 事务（READ ONLY SQL TRANSACTION） 
 25007 不支持混和的模式和数据语句（SCHEMA AND DATA STATEMENT MIXING NOT SUPPORTED） 
 25P01 没有活跃的 SQL 事务（NO ACTIVE SQL TRANSACTION） 
 25P02 在失败的 SQL 事务中（IN FAILED SQL TRANSACTION） 
 26 类 非法 SQL 语句名 
 26000 非法 SQL 语句名（INVALID SQL STATEMENT NAME） 
 27 类 触发的数据改变违规 
 27000 触发的数据改变违规（TRIGGERED DATA CHANGE VIOLATION） 
 28 类 非法授权声明 
 28000 非法授权声明（INVALID AUTHORIZATION SPECIFICATION） 
 2B 类 依然存在依赖的优先级描述符 
 2B000 依然存在依赖的优先级描述符（DEPENDENT PRIVILEGE DESCRIPTORS STILL EXIST） 
 2BP01 依赖性对象仍然存在（DEPENDENT OBJECTS STILL EXIST） 
 2D 类 非法的事务终止 
 2D000 非法的事务终止（INVALID TRANSACTION TERMINATION） 
 2F 类 SQL 过程例外 
 2F000 SQL 过程例外（SQL ROUTINE EXCEPTION） 
 2F005 执行的函数没有返回语句（FUNCTION EXECUTED NO RETURN STATEMENT） 
 2F002 不允许修改 SQL 数据（MODIFYING SQL DATA NOT PERMITTED） 
 2F003 企图使用禁止的 SQL 语句（PROHIBITED SQL STATEMENT ATTEMPTED） 
 2F004 不允许读取 SQL 数据（READING SQL DATA NOT PERMITTED） 
 34 类 非法游标名 
 34000 非法游标名（INVALID CURSOR NAME） 
 38 类 外部过程例外 
 38000 外部过程例外（EXTERNAL ROUTINE EXCEPTION） 
 38001 不允许包含的 SQL （CONTAINING SQL NOT PERMITTED） 
 38002 不允许修改 SQL 数据（MODIFYING SQL DATA NOT PERMITTED） 
 38003 企图使用禁止的 SQL 语句（PROHIBITED SQL STATEMENT ATTEMPTED） 
 38004 不允许读取 SQL 数据（READING SQL DATA NOT PERMITTED） 
 39 类 外部过程调用例外 
 39000 外部过程调用例外（EXTERNAL ROUTINE INVOCATION EXCEPTION） 
 39001 返回了非法的 SQLSTATE（INVALID SQLSTATE RETURNED） 
 39004 不允许空值（NULL VALUE NOT ALLOWED） 
 39P01 违反触发器协议（TRIGGER PROTOCOL VIOLATED） 
 39P02 违反SRF协议（SRF PROTOCOL VIOLATED） 
 3B 类 保存点例外 
 3B000 保存点例外（SAVEPOINT EXCEPTION） 
 3B001 无效的保存点声明（INVALID SAVEPOINT SPECIFICATION） 
 3D 类 非法数据库名 
 3D000 非法数据库名（INVALID CATALOG NAME） 
 3F 类 非法模式名 
 3F000 非法模式名（INVALID SCHEMA NAME） 
 40 类 事务回滚 
 40000 事务回滚（TRANSACTION ROLLBACK） 
 40002 违反事务完整性约束（TRANSACTION INTEGRITY CONSTRAINT VIOLATION） 
 40001 串行化失败（SERIALIZATION FAILURE） 
 40003 不知道语句是否结束（STATEMENT COMPLETION UNKNOWN） 
 40P01 侦测到死锁（DEADLOCK DETECTED） 
 42 类 语法错误或者违反访问规则 
 42000 语法错误或者违反访问规则（SYNTAX ERROR OR ACCESS RULE VIOLATION） 
 42601 语法错误（SYNTAX ERROR） 
 42501 权限不够（INSUFFICIENT PRIVILEGE） 
 42846 无法进行类型转换（CANNOT COERCE） 
 42803 分组错误（GROUPING ERROR） 
 42830 非法的外键（INVALID FOREIGN KEY） 
 42602 非法名字（INVALID NAME） 
 42622 名字太长（NAME TOO LONG） 
 42939 保留名字（RESERVED NAME） 
 42804 数据类型不匹配（DATATYPE MISMATCH） 
 42P18 未决的数据类型（INDETERMINATE DATATYPE） 
 42809 错误的对象类型（WRONG OBJECT TYPE） 
 42703 未定义的字段（UNDEFINED COLUMN） 
 42883 未定义的函数（UNDEFINED FUNCTION） 
 42P01 未定义的表（UNDEFINED TABLE） 
 42P02 未定义的参数（UNDEFINED PARAMETER） 
 42704 未定义对象（UNDEFINED OBJECT） 
 42701 重复的字段（DUPLICATE COLUMN） 
 42P03 重复的游标（DUPLICATE CURSOR） 
 42P04 重复的数据库（DUPLICATE DATABASE）） 
 42723 重复的函数（DUPLICATE FUNCTION） 
 42P05 重复的准备好语句（DUPLICATE PREPARED STATEMENT） 
 42P06 重复的模式（DUPLICATE SCHEMA） 
 42P07 重复的表（DUPLICATE TABLE） 
 42712 重复的别名（DUPLICATE ALIAS） 
 42710 重复的对象（DUPLICATE OBJECT） 
 42702 模糊的字段（AMBIGUOUS COLUMN） 
 42725 模糊的函数（AMBIGUOUS FUNCTION） 
 42P08 模糊的参数（AMBIGUOUS PARAMETER） 
 42P09 模糊的别名（AMBIGUOUS ALIAS） 
 42P10 非法字段引用（INVALID COLUMN REFERENCE） 
 42611 非法字段定义（INVALID COLUMN DEFINITION） 
 42P11 非法游标定义（INVALID CURSOR DEFINITION） 
 42P12 非法的数据库定义（INVALID DATABASE DEFINITION） 
 42P13 非法函数定义（INVALID FUNCTION DEFINITION） 
 42P14 非法准备好语句定义（INVALID PREPARED STATEMENT DEFINITION） 
 42P15 非法模式定义（INVALID SCHEMA DEFINITION） 
 42P16 非法表定义（INVALID TABLE DEFINITION） 
 42P17 非法对象定义（INVALID OBJECT DEFINITION） 
 44 类 违反 WITH CHECK 选项 
 44000 违反 WITH CHECK 选项（WITH CHECK OPTION VIOLATION） 
 53 类 资源不够 
 53000 资源不够（INSUFFICIENT RESOURCES） 
 53100 磁盘满（DISK FULL） 
 53200 内存耗尽（OUT OF MEMORY） 
 53300 太多连接（TOO MANY CONNECTIONS） 
 54 类 超过程序限制 
 54000 超过程序限制（PROGRAM LIMIT EXCEEDED） 
 54001 语句太复杂（STATEMENT TOO COMPLEX） 
 54011 太多字段（TOO MANY COLUMNS） 
 54023 参数太多（TOO MANY ARGUMENTS） 
 55 类 对象不在预先要求的状态 
 55000 对象不在预先要求的状态（OBJECT NOT IN PREREQUISITE STATE） 
 55006 对象在使用中（OBJECT IN USE） 
 55P02 无法修改运行时参数（CANT CHANGE RUNTIME PARAM） 
 55P03 锁不可获得（LOCK NOT AVAILABLE） 
 57 类 操作者干涉 
 57000 操作者干涉（OPERATOR INTERVENTION） 
 57014 查询被取消（QUERY CANCELED） 
 57P01 管理员关机（ADMIN SHUTDOWN） 
 57P02 崩溃关机（CRASH SHUTDOWN） 
 57P03 现在无法连接（CANNOT CONNECT NOW） 
 58 类 系统错误( PostgreSQL 自己内部的错误) 
 58030 IO 错误（IO ERROR） 
 58P01 未定义的文件（UNDEFINED FILE） 
 58P02 重复的文件（DUPLICATE FILE） 
 F0 类 配置文件错误 
 F0000 配置文件错误（CONFIG FILE ERROR） 
 F0001 锁文件存在（LOCK FILE EXISTS） 
 P0 类 PL/pgSQL 错误 
 P0000 PLPGSQL 错误（PLPGSQL ERROR） 
 P0001 抛出例外（RAISE EXCEPTION） 
 XX 类 内部错误 
 XX000 内部错误（INTERNAL ERROR） 
 XX001 数据损坏（DATA CORRUPTED） 
 XX002 索引损坏（INDEX CORRUPTED） 




八、异步、多线程及进程
A、画面死锁
Application.DoEvents();
交出CPU控制权，让系统可以处理队列中的所有Windows消息，比如在大运算量循环内，加Application.DoEvents可以防止界面停止响应，因为winform的消息循环是一个线程来处理，那么假如你的某个操作比较耗时，那么消息处理得等你这个耗时操作做完了才能继续，而Application.DoEvents方法就是允许你在耗时操作的内部调用它，而去处理消息队列中的消息。像鼠标移动鼠标点击都是windows消息，如果耗时操作一直进行，那么界面就像死锁一样。

当运行 Windows 窗体时，它将创建新窗体，然后该窗体等待处理事件。该窗体在每次处理事件时，均将处理与该事件关联的所有代码。所有其他事件在队列中等待。在代码处理事件时，应用程序并不响应。例如，当将另一窗口拖到该窗口前面时，该窗口不重新绘制。
如果在代码中调用 DoEvents，则您的应用程序可以处理其他事件。例如，如果您有向 ListBox 添加数据的窗体，并将 DoEvents 添加到代码中，那么当将另一窗口拖到您的窗体上时，该窗体将重新绘制。如果从代码中移除 DoEvents，那么在按钮的单击事件处理程序执行结束以前，您的窗体不会重新绘制。
private void button1_Click(object sender, System.EventArgs e)
{
    int i = 0;
    while(i < 10)
    {
        Thread.Sleep(1000);
        textBox1.Text += i.ToString() + "\r\n";
        Application.DoEvents();
        i++;
    }
}

B、异步
.NET Framework 允许您异步调用任何方法。定义与您需要调用的方法具有相同签名的委托；公共语言运行库将自动为该委托定义具有适当签名的 BeginInvoke 和 EndInvoke 方法。此种方式的线程ID与主线程（即UI线程）ID相同，即说明此种方法并未开启新的线程，而是与主线程运行在同一线程中，是异步而非“多线程”。
1、使用 EndInvoke 等待异步调用
    同步调用会阻塞线程，如果是要调用一项繁重的工作（如大量IO操作），可能会让程序停顿很长时间，造成糟糕的用户体验，这时候异步调用就很有必要了。异步调用不阻塞线程，而是把调用塞到线程池中，程序主线程或UI线程可以继续执行。委托的异步调用通过BeginInvoke和EndInvoke来实现。
    使用BeginInvoke方法启动C#异步调用，用EndInvoke方法检索C#异步调用结果。
格式：mydelegate.BeginInvoke(parm, null, null);
parm是mydelegate的参数。
流程：
|
|---
|   |
|---
|
步骤：
（0）声明一个委托，BeginInvoke() 与EndInvoke() 皆为委托的方法；
（1）BeginInvoke 方法与需要异步执行的方法具有相同的参数，BeginInvoke 立即返回，不等待C#异步调用完成。BeginInvoke 返回IasyncResult，可用于监视调用进度；
（2）执行完 BeginInvoke 方法后，可执行除异步外的其它操作；
（3）EndInvoke 方法之前要调用 BeginInvoke ，如果C#异步调用未完成，EndInvoke 将一直阻塞到C#异步调用完成。EndInvoke的参数包括您需要异步执行的方法的out和ref参数以及由 BeginInvoke 返回的 IAsyncResult 。


例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static int myfun(int NO)
{
    Thread.Sleep(3000);
    return NO;
}
public delegate int mydel(int NO);

static void Main()
{
  mydel dl = myfun;
  IAsyncResult iaR = dl.BeginInvoke(88, null, null);

  Console.WriteLine("Do other work... ... ...")

  int result = dl.EndInvoke(iaR);                     //此处会阻塞，直至异步调用完成
  Console.WriteLine("result:{0}", result);
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例
    可以看到，主线程并没有等待，而是直接向下运行了。但是问题依然存在，当主线程运行到 EndInvoke 时，如果这时调用没有结束(这种情况很可能出现)，这时为了等待调用结果，线程依旧会被阻塞。 解决的办法是用回调函数，当调用结束时会自动调用回调函数。
2、异步调用完成时执行回调方法
    如果启动异步调用的线程不需要处理调用结果，则可以在调用完成时执行回调方法。回调方法在 ThreadPool 线程上执行。要使用回调方法，必须将代表该方法的 AsyncCallback 委托传递给 BeginInvoke 。也可以传递包含回调方法将要使用的信息的对象。例如，可以传递启动调用时曾使用的委托，以便回调方法能够调用 EndInvoke 。
格式：mydelegate.BeginInvoke(parm, compeleteFunction, transmitValue);
parm是后台线程所执行的委托mydelegate的参数。
compeleteFunction是后台线程结束后的回调函数
transmitValue是需要向后台线程传入的值，这个值可通过IAsyncResult.AsyncState取得，类型为Object，须进行转换后使用。
流程：
|
|---
|   |
|   |

例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static int myfun(int NO)
{
  Thread.Sleep(3000);
  return NO;
}
public delegate int mydel(int NO);

public void AddComplete(IAsyncResult fniaR)
{
    mydel dl = (mydel)fniaR.AsyncState;                   //变化之处，取得委托

    int result = dl.EndInvoke(fniaR);                     //原有移入
    Console.WriteLine("result:{0}" + result.ToString());  //原有移入
} 


static void Main()
{
  mydel dl = myfun;
  IAsyncResult iaR = dl.BeginInvoke(88, new AsyncCallback(AddComplete), dl);  //变化之处，执行委托实例主体dl后等待回调，第二个参数为回调函数，第三个参数为待等待的委托实例主体，此处为dl

  Console.WriteLine("Do other work... ... ...");
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例
首先BeginInvoke是开始调用异步方法，其次EndInvoke是等待异步方法的结果，如果把它放在主线程就会阻塞，但如果放在回调函数中就不会了。
3、使用 WaitHandle 等待异步调用（实际是一种同步技术）
    等待 WaitHandle 是一项常用的线程同步技术。可以使用由 BeginInvoke 返回的 IAsyncResult 的 AsyncWaitHandle 属性来获取 WaitHandle。C#在异步调用完成时会发出 WaitHandle 信号，可以通过IAsyncResult 的 AsyncWaitHandle 调用 WaitOne 方法来等待它。
流程：
|
|---
|   |
|---
|
例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static int myfun(int NO)
{
    Thread.Sleep(3000);
    return NO;
}
public delegate int mydel(int NO);

static void Main()
{
  mydel dl = myfun;
  IAsyncResult iaR = dl.BeginInvoke(88, null, null);

  Console.WriteLine("Do other work... ... ...")

                                                         //变化之处
----------------------------------------------------------------------
  //第一种写法
  iaR.AsyncWaitHandle.WaitOne();
----------------------------------------------------------------------
  //第二种写法
  while (!iaR.AsyncWaitHandle.WaitOne(50, false))         //每隔50ms轮询一次，如果线程未结束则返回
  {
     Console.Write(".");
  }
----------------------------------------------------------------------

  int result = dl.EndInvoke(iaR);
  Console.WriteLine("result:{0}", result);
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例
4、轮询异步调用完成
    可以使用由 BeginInvoke 返回的 IAsyncResult 的 IsCompleted 属性来发现C#异步调用何时完成。从用户界面的服务线程中进行C#异步调用时可以执行此操作。轮询完成允许用户界面线程继续处理用户输入。
流程：
|
|---
|   |
|---
|
例例例例例例例例例例例例例例例例例例例例例例例例例例例
public static int myfun(int NO)
{
    Thread.Sleep(3000);
    return NO;
}
public delegate int mydel(int NO);

static void Main()
{
  mydel dl = myfun;
  IAsyncResult iaR = dl.BeginInvoke(88, null, null);
  /*****************************变化之处*****************************/
  while(!iaR.IsCompleted)
  {
    Console.Write(".");
    Thread.Sleep(50);
  }
  /*****************************变化之处*****************************/
  int result = dl.EndInvoke(iaR);
  Console.WriteLine("result:{0}", result);
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例

B、定时器
System.Timers.Timer _timer = new System.Timers.Timer();
_timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed);
_timer.Interval = 300;  //设置时间间隔
_timer.Enabled = true;
_timer.Start();
_timer.Stop();

static void _timer_Elapsed(object sender, ElapsedEventArgs e)
{
    SendMessage("13161626306", "13161626306");
}



C、多线程
1、线程的建立
下面我们就动手来创建一个线程，使用Thread类创建线程时，只需提供线程入口即可。（线程入口使程序知道该让这个线程干什么事）
在C#中，线程入口是通过ThreadStart委托（delegate）来提供的，你可以把ThreadStart理解为一个函数指针，指向线程要执行的函数，当调用Thread.Start()方法后，线程就开始执行ThreadStart所代表或者说指向的函数。 

ThreadStart threadStart = new ThreadStart(ThreadMethod);
Thread oThread = new Thread(threadStart);
oThread.Start();
while (!oThread.IsAlive)
       Thread.Sleep(1);
oThread.Abort();
oThread.Join();
Console.WriteLine("Alpha.Beta has finished"); 

//ThreadMethod如下:
 public void ThreadMethod(object ParObject)
 {
     //程序代码
 }






public static void show(object x)
{
    Console.WriteLine("show me"+x);
}
（1）ThreadStart显式建立（无参数）
ThreadStart TS = delegate() { show("222"); };
//或ThreadStart TS = delegate { show("222"); };
new Thread(TS).Start();
（2）ParameterizedThreadStart显式建立（带参数）
ParameterizedThreadStart pts= delegate (object k) {show(k);  };
//或ParameterizedThreadStart pts= delegate {show(k);  };
new Thread(pts).Start("");
（3）省略ThreadStart或ParameterizedThreadStart，隐式直接建立
原理：隐式将delegate转为ThreadStart，再代入Thread。
new Thread(delegate() { show("111"); }).Start();                //利用Thread的构造方法为new Thread(ThreadStart start)
new Thread(delegate(object x) { show(k); }).Start();            //利用Thread的构造方法为new Thread(ParameterizedThreadStart start)
new Thread(delegate { show(k); }).Start();                      //错误，因为Thread的构造方法为new Thread(ThreadStart start)或new Thread(ParameterizedThreadStart start)，如此写编译器将不知应将参数delegate转为ThreadStart还是ParameterizedThreadStart

2、线程的优先级
当线程之间争夺CPU时间时，可以通过System.Threading.Thread.Priority枚举设定线程的优先级别，从而决定线程能够得到多少CPU时间。高优先级的线程通常会比一般优先级的线程得到更多的CPU时间，如果不止一个高优先级的线程，操作系统将在这些线程之间循环分配CPU时间。低优先级的线程得到的CPU时间相对较少，当这里没有高优先级的线程，操作系统将挑选下一个低优先级 的线程执行。一旦低优先级的线程在执行时遇到了高优先级的线程，它将让出CPU给高优先级的线程。新创建的线程优先级为一般优先级，我们可以设置线程的优先级别的值。在C#应用程序中，用户可以设定5个不同的优先级，由高到低分别是Highest，AboveNormal，Normal，BelowNormal，Lowest，在创建线程时如果不指定优先级，那么系统默认为ThreadPriority.Normal。
给一个线程指定优先级，可以使用如下代码：
//设定优先级为最低
myThread.Priority=ThreadPriority.Lowest; 

3、Thread 生命周期
（1）Thread.ThreadState 线程状态属性
这个属性代表了线程运行时状态，在不同的情况下有不同的值，我们有时候可以通过对该值的判断来设计程序流程。
ThreadState 属性的取值如下：
Aborted：线程已停止； 
AbortRequested：线程的Thread.Abort()方法已被调用，但是线程还未停止； 
Background：线程在后台执行，与属性Thread.IsBackground有关； 
Running：线程正在正常运行； 
Stopped：线程已经被停止； 
StopRequested：线程正在被要求停止； 
Suspended：线程已经被挂起（此状态下，可以通过调用Resume()方法重新运行）；
SuspendRequested：线程正在要求被挂起，但是未来得及响应； 
Unstarted：未调用Thread.Start()开始线程的运行； 
WaitSleepJoin：线程因为调用了Wait()，Sleep()或Join()等方法处于封锁状态； 
上面提到了Background状态表示该线程在后台运行，那么后台运行的线程有什么特别的地方呢？其实后台线程跟前台线程只有一个区别，那就是后台线程不妨碍程序的终止。一旦一个进程所有的前台线程都终止后，CLR（通用语言运行环境）将通过调用任意一个存活中的后台进程的Abort()方法来彻底终止进程。 

myThread.IsAlive         //它表示线程当前是否为可用状态，如果线程已经启动，并且当前没有任何异常的话，则返回true，否则为false
myThread.IsBackground    //获取或设置一个值，该值指示某个线程是否为后台线程。true主线程结束，线程就自动结束，false主线程等待线程结束后才会结束，如果是Windows服务中启用该选项，或许你能看到有些事务未处理完时，APP无法停止

（2）状态的改变
Thread类有几个至关重要的方法，描述如下：
Start()：启动线程；
Sleep(int)：静态方法，暂停当前线程指定的毫秒数；
Abort()：通常使用该方法来终止一个线程；
Suspend()：该方法并不终止未完成的线程，它仅仅挂起线程，以后还可恢复；
Resume()：恢复被Suspend()方法挂起的线程的执行；
Join()：将本线程阻塞直至另一线程终止。

★当线程被创建时，它处在Unstarted状态，
★Thread类的Start() 方法将使线程状态变为Running状态，线程将一直处于这样的状态，除非我们调用了相应的方法使其挂起、阻塞、销毁或者自然终止。
★如果线程被挂起，它将处于Suspended状态，
★除非我们调用resume（）方法使其重新执行，这时候线程将重新变为Running状态。
★一旦线程被销毁或者终止，线程处于Stopped状态。处于这个状态的线程将不复存在，正如线程开始启动，线程将不可能回到Unstarted状态。
★线程还有一个Background状态，它表明线程运行在前台还是后台。在一个确定的时间，线程可能处于多个状态。例如，一个线程被调用了Sleep而处于阻塞，而接着另外一个线程调用Abort方法于这个阻塞的线程，这时候线程将同时处于WaitSleepJoin和AbortRequested状态。一旦线程响应转为Sle阻塞或者中止，当销毁时会抛出ThreadAbortException异常。



4、线程调用带参数的方法
第一种：使用ParameterizedThreadStart。
调用 System.Threading.Thread.Start(System.Object) 重载方法时将包含数据的对象传递给线程。
使用 ParameterizedThreadStart 委托不是传递数据的类型安全的方法，因为 System.Threading.Thread.Start(System.Object) 方法重载接受任何对象。
这种方法不推荐使用。

 object o = "hello";
 ParameterizedThreadStart ParStart = new ParameterizedThreadStart(ThreadMethod);
 Thread myThread = new Thread(ParStart);
 myThread.Start(o);
 

//ThreadMethod如下:
 public void ThreadMethod(object ParObject)
 {
     //程序代码
 }

第二种：将线程执行的方法和参数都封装到一个类里面。通过实例化该类，方法就可以调用属性来实现间接的类型安全地传递参数。
using System;
using System.Threading;

//ThreadWithState 类里包含了将要执行的任务以及执行任务的方法
public class ThreadWithState {
    //要用到的属性，也就是我们要传递的参数
    private string boilerplate;
    private int value;

    //包含参数的构造方法
    public ThreadWithState(string text, int number) 
    {
        boilerplate = text;
        value = number;
    }
    //要丢给线程执行的方法，本处无返回类型就是为了能让ThreadStart来调用
    public void ThreadProc() 
    {
        //这里就是要执行的任务，本处只显示一下传入的参数
        Console.WriteLine(boilerplate, value); 
    }
}

//用来调用上面方法的类，是本例执行的入口
public class Example {
    public static void Main() 
    {
        //实例化ThreadWithState类，为线程提供参数
        ThreadWithState tws = new ThreadWithState(
            "This report displays the number {0}.", 42);

        // 创建执行任务的线程，并执行
        Thread t = new Thread(new ThreadStart(tws.ThreadProc));
        t.Start();
        Console.WriteLine("Main thread does some work, then waits.");
        t.Join();
        Console.WriteLine("Independent task has completed; main thread ends.");  
    }
}

第三种：利用委托
 ThreadStart starter = delegate { Download(yourUrl); };
 //上句为缩写，实际应为ThreadStart starter = new ThreadStart( delegate { Download(yourUrl); } );
 new Thread(starter).Start();

5、线程的Join
Join能够将两个交替执行的线程合并为顺序执行的线程，如在线程B中调用线程A的Join()方法，则会将线程A插入线程B中某一位置，直到线程A执行完毕后，才会继续执行线程B。

6、线程锁
    首先，多线程中各线程的执行顺序是不可控的，所以多线程是竞争关系，而不是队列关系（任何平台均为如此）。这同android中的handler不同，handler实际是在同一个线程中执行，不是多线程，所以可以形成队列。

（1）Interlocked 自由锁或互锁
在多线程环境中，线程切换有可能会发生在这多个语句中间。
在大多数计算机上，如C#中的一个语句，编译成机器代码后会变成多个语句，以增加变量操作为例，需要执行下列步骤：
1）将实例变量中的值加载到寄存器中。
2）加或减少该值。
3）在实例变量中存储该值。
在多线程环境下，线程会在执行完前两个步骤后被抢先。然后由另一个线程执行所有三个步骤，当第一个线程重新开始执行时，它覆盖实例变量中的值，造成第二个线程执行增减操作的结果丢失。使用原子操作可以避免被打断，保证线程安全。
Interlocked可以为多个线程共享的变量提供原子操作。
Interlocked.Increment：以原子操作的形式递增指定变量的值并存储结果，让++成为原子操作；  lock(d){ d.Data++; }相当于Interlocked.Increment(ref d.Data);
Interlocked.Decrement：以原子操作的形式递减指定变量的值并存储结果，让--成为原子操作。  lock(d){ d.Data--; }相当于Interlocked.Decrement(ref d.Data);
Interlocked.Add：以原子操作的形式，添加两个整数并用两者的和替换第一个整数
Interlocked.Read：
Interlocked.Exchange：
Interlocked.CompareExchange：Interlocked.CompareExchange(ref n, 1, 0) == 0           //比较n如果等于0，就赋值为1，Go语言中类似为CompareAndSwapUint64

（2）volatile
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次对这些变量的存取不能缓存到寄存器，每次使用时都会直接从变量地址中重新读取数据。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量可能被多个线程修改，而程序通过该变量同步各个线程。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。
作用：volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
原理：如volatile int i中 volatile 指出i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动读取上次的数据。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。
msdn解释：
volatile 关键字指示一个字段可以由多个同时执行的线程修改。声明为 volatile 的字段不受编译器优化（假定由单个线程访问）的限制。这样可以确保该字段在任何时间呈现的都是最新的值。
volatile 修饰符通常用于由多个线程访问但不使用 lock 语句对访问进行序列化的字段。
例：
    int i;
    {
        int geti() {return i;} 
    }
多个线程有多个i变量拷贝，而且这些i之间可以互不相同。换句话说，另一个线程可能已经改变了它线程内的i值，而这个值可以和当前线程中的i值不相同。
    volatile int i;
    {
        int geti() {return i;} 
    }
一个变量经 volatile 修饰后在所有线程中必须是同步的；任何线程中改变了它的值，所有其他线程立即获取到了相同的值。理所当然的，volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。

（3）区域隔离：lock （类似java的Synchrnized）
每个线程都有自己的资源，但是代码区是共享的，即每个线程都可以执行相同的函数。这可能带来的问题就是几个线程同时执行一个函数，导致数据的混乱，产生不可预料的结果，因此我们必须避免这种情况的发生。
C#提供了一个关键字 lock ，它可以把一段代码定义为互斥段（critical section），互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。在C#中，关键字 lock 定义如下：
lock(expression) statement_block          //如果expression对象未被锁住，那么锁住他，并执行代码块statement_block；如果expression对象已被锁住，那么阻塞，直到该expression对象被解锁。即同时只会有一个线程访问代码块statement_block；
1）expression代表你希望跟踪的对象，通常是对象引用，同一时间只能有一个线程访问expression被lock的statement_block，其他线程等待。
·如果你想保护一个类的实例，一般地，你可以使用this；
·如果你想保护一个静态变量（如互斥代码段在一个静态方法内部），一般使用类名就可以了。√
应避免锁定 public 类型，否则实例将超出代码的控制范围。常见的结构 lock (this)、lock (typeof (MyType)) 和 lock ("myLock") 违反此准则：如果实例可以被公共访问，将出现 lock (this) 问题。如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。由于进程中使用同一字符串的任何其他代码将共享同一个锁，所以出现 lock("myLock") 问题。
·正确的做法：在类中定义一个私有静态变量，private static object obj = new object(); lock(obj);
※注：
<1>如果是单例，使用lock(this)时，没有问题。
<2>如果是new出来的多个实例，使用lock(this)时，每个实例的this代表的是不同实例，所以实际lock住的是多个实例各自的this，并不能达到预想的效果。
<3>在同一线程中，当先后lock两个相同对象时，不会加锁。即lock在纯单线程中不会起作用，只在多线程中起作用。
2）statement_block就是互斥段的代码，这段代码在一个时刻内只可能被一个线程执行。 
3）由于使用lock实际在同一时刻是单线程运行，会降低效率，应尽量减少lock的使用

（4）区域隔离：Monitor 临界区
    当多线程公用一个对象时，也会出现和公用代码类似的问题，这种问题就不应该使用lock关键字了，这里需要用到System.Threading中的一个类Monitor，我们可以称之为监视器，Monitor提供了使线程共享资源的方案。 
    Monitor类可以锁定一个对象，一个线程只有得到这把锁才可以对该对象进行操作。对象锁机制保证了在可能引起混乱的情况下一个时刻只有一个线程可以访问这个对象。
Monitor必须和一个具体的对象相关联，但是由于它是一个静态的类，所以不能使用它来定义对象，而且它的所有方法都是静态的，不能使用对象来引用。下面代码说明了使用Monitor锁定一个对象的情形：
    Queue oQueue=new Queue();
......
Monitor.Enter(oQueue);
......//现在oQueue对象只能被当前线程操纵了
Monitor.Exit(oQueue);//释放锁 
    如上所示，当一个线程调用Monitor.Enter()方法锁定一个对象时，这个对象就归它所有了，其它线程想要访问这个对象，只有等待它使用Monitor.Exit()方法释放锁。为了保证线程最终都能释放锁，可以把Monitor.Exit()方法写在try-catch-finally结构中的finally代码块里。
    使用独占锁的方式来控制线程同步，只有获得独占锁的线程才能访问临界资源。当一个线程进入临界区时，首先调用Monitor类的Enter()方法，尝试获取临界资源的独占锁，若独占锁已被其他线程占用，就进入等待状态，直到其他线程释放独占锁为止。若独占锁没有被其他线程占用，该线程就会获取独占锁，进入临界区，执行操作临界资源的代码。若这时候恰好有其他的线程也来访问临界资源，后来的线程只能进行等待，睡眠在临界资源上。Monitor会记录所有睡眠在临界资源上的线程，当线程退出临界区时，需要通过调用Monitor类的Pulse()方法唤醒睡眠在临界资源的线程。
|-------Enter()  试图获取独占资源的独占锁，若不成功，则当前线程阻塞在临界资源上。       --进入临界区就绪状态，首个线程拥有独占锁，其他线程进入就绪状态
|-------TryEnter()  试图获取独占资源的独占锁，若不成功立即返回。                        --进入临界区就绪状态，某一线程试图获得独占锁，若不成功，就立刻退出临界区
|   |---Pulse()  唤醒其他睡眠在临界资源上的线程。                                       --睡眠状态->就绪状态，唤醒一个睡眠中的线程，进入就绪状态
|   |---PulseAll()  唤醒所有睡眠在临界资源上的线程。                                    --睡眠状态->就绪状态，唤醒所有睡眠中的线程，进入就绪状态
|   >---Wait()  已重载。 暂时释放独占锁，并让当前线程阻塞在临界资源上，直到它被Pulse。  --执行状态->睡眠状态，当前线程释放独占锁，并进入睡眠状态，直到再次被pulse
>-------Exit()  释放独占锁，退出临界区。                                                --退出临界区就绪状态，线程释放独占锁，并退出临界区

线程进入临界区后的3种状态：
就绪状态：通过lock(expression)、enter()、Pulse()
执行状态：就绪状态的线程竞争后，“随机”一个线程进入此状态
睡眠（或叫阻塞）状态：通过Wait()

 -------------------------------------------------------------------------------
|                                 /*  临界区 */                                 |
|                                      Wait                                     |
|     <-------------------------------------------------------------------      |
|    |       Pulse              如果独占锁空闲，随机抽取一个线程进入      |     |   Exit
|睡眠状态区 ------> 就绪状态区 -------------------------------------> 执行 状态 ------------> 非临界区
|                       ^                                                       |
 -----------------------|-------------------------------------------------------
                        |Enter
                        |
                     非临界区

★与java的类比
     java                           c#
Reentrant（动态类）    ≈    Monitor（静态方法）
notify                 ≈    Pulse
notifyAll              ≈    PulseAll
wait                   ≈    Wait


（4.5）lock与Monitor
1）lock与Monitor的联系
lock和Monitor都是对被操作对象同步控制的方法，lock是Monitor的简化版本，lock关键字比Monitor简洁，其实lock就是对Monitor的Enter和Exit的一个封装：
    lock(lockObj)
    {
       //...
    }
    ////相当于（.Net4以前）：
    Monitor.Enter(lockObj);
    try
    {
       //...
    }
    finally
    {
       Monitor.Exit(lockObj);
    }
但是，这种实现逻辑至少理论上有一个错误：当Monitor.Enter(lockObj);刚刚完成，还没有进入try区的时候，有可能从其他线程发出了Thread.Abort等命令，使得该线程没有机会进入try...finally。也就是说lockObj没有办法得到释放，有可能造成程序死锁。这也是Thread.Abort一般被认为是邪恶的原因之一。
DotNet4开始，增加了Monitor.Enter(object, ref bool)重载。而C#编译器会把lock展开为更安全的Monitor.Enter(object, ref bool)和Monitor.Exit：
    lock(lockObj)
    {
        //...
    }
    ////相当于（DotNet 4）：
    bool lockTaken = false;
    try
    {
        Monitor.Enter(lockObj, ref lockTaken);
        //
    }
    finally
    {
        if (lockTaken) Monitor.Exit(lockObj);
    }
现在Monitor.TryEnter在try的保护下，“加锁”成功意味着“放锁”将得到finally的保护。
2）lock与Monitor的区别
<1>lock 只能对引用对象加锁
lock 锁定区间内可以对锁定值修改而不发生运行时错误，通常也会采用此种修改方式。这种方式又有点类同于使用Monitor.Wait 取得资源，并对这个资源进行操作。
lock (lockObj)
{
    lockObj = newObj;
}
<2>Monitor 可以对值类型加锁，实际上是在调用Monitor.Enter时对值类型装箱了
Monitor在锁定区域内不能对被锁对象的值进行修改，运行时报错“从不同步的代码块中调用了对象同步方法”
int lockInt = 0;
try
{
    Monitor.Enter(lockInt);
    lockInt = newValue;
}
catch
{
 
}
finally
{
    Monitor.Exit(newValue);
}
3）lock与Monitor的联合使用
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
class Program
{
    static void Main(string[] args)
    {
        new Thread(A).Start();
        new Thread(B).Start();
        new Thread(C).Start();
        Console.ReadLine();
    }

    static object lockObj = new object();
    static void A()
    {
        lock (lockObj)               //进入就绪队列
        {
            Thread.Sleep(1000);
            Monitor.Pulse(lockObj);
            Monitor.Wait(lockObj);   //自我流放到等待队列
        }
        Console.WriteLine("A exit...");
    }
    static void B()
    {
        Thread.Sleep(500);
        lock (lockObj)               //进入就绪队列
        {
            Monitor.Pulse(lockObj);
        }
        Console.WriteLine("B exit...");
    }
    static void C()
    {
        Thread.Sleep(800);
        lock (lockObj)               //进入就绪队列
        {
        }
        Console.WriteLine("C exit...");
    }
}
--------------------------------------------------------------------------------------------
分析：
T  线程A
0  lock( lockObj )
1  {
2     //...           线程B                   线程C
3     //...           lock( lockObj )       lock( lockObj )
4     //...           {                     {
5     //...              //...
6     //...              //...
7     Monitor.Pulse      //...
8     Monitor.Wait       //...
9     //...              Monitor.Pulse
10    //...           }                     }
11 }

时间点0，假设线程A先得到了同步对象，它就登记到同步对象lockObj的“拥有者引用”中。
时间点3，线程B和C要求拥有同步对象，他们将在“就绪队列”排队：
            |--(拥有锁的线程) A
            |
3  lockObj--|--(就绪队列)   B,C
            |
            |--(等待队列)

时间点7，线程A用Pulse发出信号，允许第一个正在"等待队列"中的线程进入到”就绪队列“。但由于就绪队列是空的，什么事也没有发生。
时间点8，线程A用Wait放弃同步对象，并把自己放入"等待队列"。B,C已经在就绪队列中，因此其中的一个得以获得同步对象（假定是B）。B成了同步

对象的拥有者。C现在还是候补委员，可以自动获得空缺。而A则被关在门外，不能自动获得空缺。
            |--(拥有锁的线程) B
            |
8  lockObj--|--(就绪队列)   C
            |
            |--(等待队列)   A

时间点9，线程B用Pulse发出信号开门，第一个被关在门外的A被允许放入到就绪队列，现在C和A都成了候补委员，一旦同步对象空闲，都有机会得它。
            |--(拥有锁的线程) B
            |
9  lockObj--|--(就绪队列)   C,A
            |
            |--(等待队列)


时间点10，线程B退出Lock区块，同步对象闲置，就绪队列队列中的C或A就可以转正为拥有者（假设C得到了同步对象）。
            |--(拥有锁的线程) C
            |
10 lockObj--|--(就绪队列)   A
            |
            |--(等待队列)

随后C也退出Lock区块，同步对象闲置，A就重新得到了同步对象，并从Monitor.Wait中返回...
最终的执行结果就是：
B exit...
C exit...
A exit...
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

（5）读写锁之ReaderWriterLock（单写多读）
static ReaderWriterLock rwlock = new ReaderWriterLock();
rwlock.AcquireReaderLock(1000);        //申请读操作锁，如果在1000ms内未获取读操作锁，则放弃（可设为-1，表示无限等待）
rwlock.ReleaseReaderLock();            //释放读锁
rwlock.AcquireWriterLock(1000);        //申请写操作锁，如果在1000ms内未获取写操作锁，则放弃（可设为-1，表示无限等待）
rwlock.ReleaseWriterLock();            //释放写锁

※排斥关系
<1>读锁->读锁   √   多个线程可以同时添加读锁
<2>读锁->写锁   ╳   添加读锁后，（在该读锁释放之前）不能再添加写锁，因为会导致读值发生变化
<3>写锁->读锁   √   用于降级
<4>写锁->写锁   ╳   同“读锁->写锁”
虽然不加锁也可以实现并发，但读锁可以实现对写锁的控制。

（6）读写锁之ReaderWriterLockSlim（单写多读）
ReaderWriterLockSlim 类似于 ReaderWriterLock，只是简化了递归、 升级和降级锁定状态的规则。 ReaderWriterLockSlim可避免潜在的死锁的很多情况。此外，性能的 ReaderWriterLockSlim 明显优于 ReaderWriterLock。
一句话：多个线程可同时读，除此之外不能并发。

static private ReaderWriterLockSlim lockSlim = new ReaderWriterLockSlim();
//读锁
try{
    lockSlim.EnterReadLock();
}
finally
{
    lockSlim.ExitReadLock();
}
//写锁
try
    lockSlim.EnterWriteLock();
}
finally
{
    lockSlim.ExitWriteLock();
}

（7）点隔离：ManualResetEvent（类比拨动开关）与AutoResetEvent（类比按钮开关）
    其实，我们抛开.NET环境看线程同步，线程同步的方式，无非是执行两种操作：一是互斥/加锁，目的是保证临界区代码操作的“原子性”；另一种是信号灯操作，目的是保证多个线程按照一定顺序执行，如生产者线程要先于消费者线程执行。.NET中线程同步的类无非是对这两种方式的封装，目的归根结底都可以归结为实现互斥/加锁或者是信号灯这两种方式，只是它们的适用场合有所不。
¤ManualResetEvent
    ManualResetEvent 允许线程通过发信号互相通信。通常，此通信涉及一个线程在其他线程进行之前必须完成的任务。当一个线程开始一个活动（此活动必须完成后，其他线程才能开始）时，它调用 Reset 以将 ManualResetEvent 置于非终止状态，此线程可被视为控制 ManualResetEvent。调用 ManualResetEvent 上的 WaitOne 的线程将阻止，并等待信号。当控制线程完成活动时，它调用 Set 以发出等待线程可以继续进行的信号。并释放所有等待线程。一旦它被终止，ManualResetEvent 将保持终止状态（即对 WaitOne 的调用的线程将立即返回，并不阻塞），直到它被手动重置。可以通过将布尔值传递给构造方法来控制 ManualResetEvent 的初始状态，如果初始状态处于终止状态，为 true；否则为 false。
public ManualResetEvent manualReset = new ManualResetEvent(false);     //初始状态设为false
manualReset.WaitOne(Timeout.Infinite, true);                           //表示退出时，状态设为true。当前线程阻塞->直至执行了manualReset.Set()后继续->再执行manualReset.Reset()后暂停->...

总结：
ManualResetEvent仅仅是一个状态值：
当ManualResetEvent状态为Reset时（即为true时），阻塞。
当ManualResetEvent状态为Set时（即为false时），继续。

¤AutoResetEvent
本质上AutoResetEvent.Set()方法相当于ManualResetEvent.Set()+ManualResetEvent.Reset();
因此AutoResetEvent一次只能唤醒一个线程，其他线程还是阻塞。

（8）单一并发数量：Mutex 互斥量
“mutex”是术语“互相排斥（mutually exclusive）”的简写形式，也就是互斥量。互斥量跟临界区中提到的Monitor很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂，因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。.Net中mutex由Mutex类来表示。
1）构造方法：
public Mutex(bool initiallyOwned, string name, out bool createdNew)，
如：Mutex myMutex = new Mutex(false, "myUniqueName", out bCreatedNew);
◆initiallyOwned
类型：System..::.Boolean
如果为 true，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 false。（设置互斥体初始所属权）
◆name
类型：System..::.String
Mutex 的名称。 如果值为 nullNothingnullptrnull 引用（在 Visual Basic 中为 Nothing），则 Mutex 是未命名的。 
◆createdNew
类型：System..::.Boolean%
在此方法返回时，如果创建了局部互斥体（即，如果 name 为 nullNothingnullptrnull 引用（在 Visual Basic 中为 Nothing） 或空字符串）或指定的命名系统互斥体，则包含布尔值 true；如果指定的命名系统互斥体已存在，则为 false。 该参数未经初始化即被传递。（是否成功创建互斥体）
2）说明
◆Mutex是封装了Win32 API的类，它将比较直接地调用操作系统“对应”部分功能；而Monitor并没有继承自任何父类，相对来说是.Net自己“原生”的（当然.Net最终还是要靠运行时调用操作系统的各种API）。相较于Monitor，你可以把Mutex近似看作是一个关于Win32互斥量API的壳子。 
◆Mutex是可以跨应用程序/应用程序域，因此可以被用于应用程序域/应用程序间的通信和互斥；Monitor就我们到目前为止所见，只能在应用程序内部的线程之间通信。其实，如果用于锁的对象派生自MarshalByRefObject，Monitor 也可在多个应用程序域中提供锁定。 
◆Mutex由于需要调用操作系统资源，因此执行的开销比Monitor大得多，所以如果仅仅需要在应用程序内部的线程间同步操作，Monitor/lock应当是首选。 
WaitOne() / WaitOne(Int32, Boolean) / WaitOne(TimeSpan, Boolean)：请求所有权，该调用会一直阻塞到当前 mutex 收到信号，或直至达到可选的超时间隔。这几个方法除了不需要提供锁定对象作为参数外，看起来与Monitor上的Wait()方法及其重载很相似相似。不过千万不要误会，WaitOne()本质上跟Monitor.Enter()/TryEnter()等效，而不是Monitor.Wait()！这是因为这个WaitOne()并没有办法在获取控制权以后象Monitor.Wait()释放当前Mutex，然后阻塞自己。 
ReleaseMutex()：释放当前 Mutex 一次。注意，这里强调了一次，因为拥有互斥体的线程可以在重复的调用Wait系列函数而不会阻止其执行；这个跟Monitor的Enter()/Exit()可以在获取对象锁后可以被重复调用一样。Mutex被调用的次数由公共语言运行库（CLR）保存，每WaitOne()一次计数+1，每ReleaseMutex()一次计数-1，只要这个计数不为0，其它Mutex的等待者就会认为这个Mutex没有被释放，也就没有办法获得该Mutex。另外，跟Monitor.Exit()一样，只有Mutex的拥有者才能RleaseMutex()，否则会引发异常。 
如果线程在拥有互斥体时终止，我们称此互斥体被遗弃（Abandoned）。在MSDN里，微软以警告的方式指出这属于“严重的”编程错误。这是说拥有mutex的拥有者在获得所有权后，WaitOne()和RelaseMutex()的次数不对等，调用者自身又不负责任地中止，造成mutex 正在保护的资源可能会处于不一致的状态。其实，这无非就是提醒你记得在try/finally结构中使用Mutex。 
3）方法
.WaitOne()
请求互斥体的所属权，若成功，则进入临界区，若不成功，则等待
.ReleaseMutex()
释放互斥体的所属权
4）
bool bCreatedNew;
Mutex mutex = new Mutex(false, "myUniqueName", out bCreatedNew);
mutex.WaitOne();
mutex.ReleaseMutex();
★注意：服务与控制台都加Mutex，两者仍会启动；两个控制台都加Mutex，只有一个可以启动。

（9）多并发数量：Semaphore信号量（信号量计数器为1时，相当于Mutex）
Semaphore 信号量用来限制可同时访问某一资源或资源池的线程数。信号量维护了一个计数器，计数器的值可以在0到指定的最大值之间。当一个线程完成了对信号量的等待后，信号量计数器值减少。当一个线程释放信号量时，信号量计数器值增加。当计数器值达到零后，信号量是“未标志的”，当计数器值大于零时，信号量是“标志的”。任何线程都无法等待信号量变为“标志的”，因此信号量对限制可以共享数据的线程数量很有用处。

例：
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace SemaphoreTest
{
    class Program
    {
        static Semaphore hSemaphore;
        static void Main(string[] args)
        {
            hSemaphore = new Semaphore(1, 3);                                        //共申请3个信号量，其中1个空闲信号
            Thread[] hThread = new Thread[4];
            for (int i = 0; i < 4; i++)
            {
                hThread[i] = new Thread(new ThreadStart(Proc));
                hThread[i].Name = string.Format("线程{0}", i + 1);
                hThread[i].Start();
            }
            for (int i = 0; i < hThread.Length; i++)
            {
                hThread[i].Join();
            }
            Console.ReadKey();
        }

        static void Proc()
        {
            hSemaphore.WaitOne();                                                    //申请一个信号量
            Console.WriteLine("{0} 已经进入一个信号量, --使用资源--", Thread.CurrentThread.Name);

            Console.WriteLine("{0} 已经释放一个信号量, --释放资源--, 原信号量数目: {1}", Thread.CurrentThread.Name, beforeSemaphore);
            int beforeSemaphore = hSemaphore.Release();                              //释放一个信号量，默认是释放一个，也可以释放全部（Release()相当于Release(1)）
        }
    }
}

result:
线程1 已经进入一个信号量, --使用资源--
线程1 已经释放一个信号量, --释放资源--, 原信号量数目: 0
线程3 已经进入一个信号量, --使用资源--
线程3 已经释放一个信号量, --释放资源--, 原信号量数目: 0
线程2 已经进入一个信号量, --使用资源--
线程2 已经释放一个信号量, --释放资源--, 原信号量数目: 0
线程4 已经进入一个信号量, --使用资源--
线程4 已经释放一个信号量, --释放资源--, 原信号量数目: 0



（10）死锁（一种线程锁出现冲突的现象）
死锁是指多个线程共享某些资源时，都在等待对方释放资源，从而导致程序停滞不前的情况。
通常 lock 语句是被转化为对一个资源的无限长时间的等待，所以一旦资源被占用而又永不释放，那么必然死锁。
那么如何规避的危害呢？应用程序应该避免 lock(obj) 块，推荐使用 Monitor.TryEnter(obj, millisecondsTimeout) 代替，二者的第一个参数意义相同，而后者还可以设置等待超时时间，一旦在限定的时间内无法获得锁，那么 TryEnter 就会返回  false。这样就不会造成死锁，无法获得资源，业务程序可以采取重试或抛异常的方式进行善后处理。
        public static void HaveLunchByTryEnter()
        {
            if (Monitor.TryEnter(m_isFull, 15000))
            {
                try
                {
                    Console.WriteLine("Wait for seta");
                    Monitor.Wait(m_isFull);
                    Console.WriteLine("Have a good lunch!");
                }
                finally
                {
                    Monitor.Exit(m_isFull);
                }
            }
            else
            {
                //超时后处理代码
            }
        }


7、线程本地存储(Thread-Local Storage)
线程本地存储(Thread-Local Storage)：ThreadStatic, LocalDataStoreSlot和ThreadLocal<T>
//通常，全局静态变量在各线程间是被共用的，使用TLS，可以使每个线程的全局静态变量独立出来
[ThreadStatic]
static string str = "hehe";

static void Main(string[] args)
{
    Thread th = new Thread(() => { str = "Mgen"; Display(); });
    th.Start();
    th.Join();
    Console.WriteLine("{0} {1}", Thread.CurrentThread.ManagedThreadId, str);
}
Result:
1 hehe
3 Mgen




7、ThreadPool 线程池
（1）ThreadPool介绍（From MSDN）
ThreadPool class提供了一个线程池，该线程池可用于发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。线程池允许在后台运行多个工作，而不需要为每个任务频繁地创建和销毁单独的线程，从而减少了开销。
线程池通过为应用程序提供一个由系统管理的辅助线程池使您可以更为有效地使用线程。一个线程监视排到线程池的若干个等待操作的状态。当一个等待操作完成时，线程池中的一个辅助线程就会执行对应的回调函数。
也可以将与等待操作不相关的工作项排列到线程池。若要请求由线程池中的一个线程来处理工作项，请调用 QueueUserWorkItem 方法。此方法将对将被从线程池中选定的线程调用的方法或委托的引用用作参数。一个工作项排入队列后就无法再取消它。
计时器（System.Threading.Timer）队列中的计时器以及已注册的等待操作也使用线程池。它们的回调函数也会排列到线程池。关于这部分的内容，可以参考《System.Threading.Timer类的TimerCallback 委托》。
线程池在首次创建 ThreadPool 类的实例时被创建。线程池具有每个可用处理器 25 个线程的默认限制，这可以使用 mscoree.h 文件中定义的 CorSetMaxThreads 来更改。每个线程使用默认的堆栈大小并按照默认的优先级运行。每个进程只能具有一个操作系统线程池。
（2）ThreadPool.QueueUserWorkItem方法
QueueUserWorkItem方法将指定的方法排入队列以便执行，并指定包含该方法所用数据的对象，此方法在有线程池线程变得可用时执行。
public static bool QueueUserWorkItem(
   WaitCallback callBack,
   object state
);
如果将方法成功排入队列，则为 true；否则为 false。如果排入队列的方法仅需要单个数据项，可以将数据项强制转换为类型 Object。如果该方法需要多个复杂数据，则必须定义包含这些数据的类。如果没有参数传入，则可以调用QueueUserWorkItem(WaitCallback callBack)重载。
ThreadPool提供的公共方法都是static方法，因此也不需要生成ThreadPool对象。通过QueueUserWorkItem方法在线程池中添加一个工作项目后，目前没有提供简单的方法取消。你不必建立咨监线程，只需要把相应的函数或方法依托WaitCallback委托传递给ThreadPool.QueueUserWorkItem()方法即可。而线程的创建、管理和运行等等都由系统自动完成，这就是ThreadPool的优点。
（3）WaitCallback委托
WaitCallback委托声明线程池要执行的回调方法，回调方法的声明必须与WaitCallback委托声明具有相同的参数。
WaitCallback 表示要在 ThreadPool 线程上执行的回调方法。创建委托，方法是将回调方法传递给 WaitCallback 构造方法。您的方法必须具有此处所显示的签名。通过将 WaitCallback 委托传递给 ThreadPool.QueueUserWorkItem 来将任务排入队列以便执行。您的回调方法将在某个线程池线程可用时执行。
如果要将信息传递给回调方法，请创建包含所需信息的对象，并在将任务排入队列以便执行时将它传递给 QueueUserWorkItem。每次执行您的回调方法时，state 参数都包含此对象。
通过将一个方法打包到 WaitCallback 委托中，然后将该委托传递给 ThreadPool.QueueUserWorkItem 静态方法，在线程池中对任务进行排队。


for(int i=0;i<9;i++)
    ThreadPool.QueueUserWorkItem(new WaitCallback(WorkFunction),i);//WaitCallback委托声明线程池要执行的回调方法，回调方法的声明必须与WaitCallback委托声明具有相同的参数

public static void WorkFunction()
{
}


    ThreadPool.QueueUserWorkItem(state =>
    {
         Thread.Sleep(2000);
         Console.WriteLine("线程池线程开始执行异步任务。线程ID：{0}", Thread.CurrentThread.ManagedThreadId);
    });



（4）以下情况不适用于使用ThreadPool
1）线程执行需要很长时间
2）需要为线程指定详细的优先级
3）在执行过程中需要对线程进行操作，如睡眠，挂起等。
所以ThreadPool适合于并发运行若干个运行时间不长且互不干扰的函数。

8、BackgroundWorker
        BackgroundWorker worker;
        ManualResetEvent manualReset;
        int i;
        private void Window_Load()
        {
            manualReset = new ManualResetEvent(true);
            worker = new BackgroundWorker();
            worker.WorkerReportsProgress = true;                                                            //支持进度（用ReportProgress(n)方法）
            worker.WorkerSupportsCancellation = true;                                                       //支持取消（用CancelAsync()方法，此时CancellationPending参数会变为false）
            worker.DoWork += new DoWorkEventHandler(worker_DoWork);                                         //开始后，执行的“方法”（用RunWorkerAsync方法开始执行）
            worker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(worker_RunWorkerCompleted);     //结束后，执行的“方法”
            worker.ProgressChanged += new ProgressChangedEventHandler(worker_ProgressChanged);              //进度发生改变后，执行的“方法”
        }

        void worker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            WorkingInfo_ProgressBar.Value = e.ProgressPercentage;
        }

        void worker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Cancelled)
                MessageBox.Show("用户取消了操作");
            else
            {
                MessageBox.Show("正常完成了操作");
            }
        }

        void worker_DoWork(object sender, DoWorkEventArgs e)
        {
            for (i = 0; i < 100; i++)                                                   //1.当用户点击启动
            {
                if (worker.CancellationPending)                                         //2.当用户点击取消
                {
                    for (int k = i; k >= 0; k--)
                    {
                        Thread.Sleep(10);
                        worker.ReportProgress(k);                                       //模拟回滚的效果
                    }
                    e.Cancel = true;
                    return;
                }
                manualReset.WaitOne();                                                  //3.当用户点击暂停，即manualReset.Reset()，此处会发生阻塞。
                                                                                        //当用户点击继续，即manualReset.Set()，就继续向下执行。
                                                                                        //如果ManualResetEvent的初始化为终止状态（true），那么该方法将一直工作，直到收到Reset信号。
                Thread.Sleep(200);
                worker.ReportProgress(i + 1);
            }
        }

        private void start_btn_Click(object sender, RoutedEventArgs e)
        {
            if (!worker.IsBusy)
                worker.RunWorkerAsync();
        }

        private void pause_btn_Click(object sender, RoutedEventArgs e)
        {
            if (pause_btn.Content.ToString().Equals("暂停"))
            {
                manualReset.Reset();                                                    //暂停当前线程的工作，发信号给waitOne方法，阻塞
                pause_btn.Content = "继续";
            }
            else
            {
                manualReset.Set();                                                      //继续某个线程的工作
                pause_btn.Content = "暂停";
            }
        }

        private void cancel_btn_Click(object sender, RoutedEventArgs e)
        {
                worker.CancelAsync();
                pause_btn.Content = "暂停";
                manualReset.Set();
        }




9、跨线程使用控件
（1）Control的Invoke和BeginInvoke与Delegate的Invoke和BeginInvoke是不同的。
（2）Control的Invoke和BeginInvoke的参数为delegate，委托的方法是在Control的线程上执行的，也就是我们平时所说的UI线程。
    在多线程编程中，我们经常要在工作线程中去更新界面显示，而在多线程中直接调用界面控件的方法是错误的做法。一般来说，直接在子线程中对窗体上的控件操作是会出现异常，这是由于子线程和运行窗体的线程是不同的空间，因此想要在子线程来操作窗体上的控件，是不可能简单的通过控件对象名来操作，但不是说不能进行操作，微软提供了Invoke的方法，其作用就是让子线程告诉窗体线程来完成相应的控件操作。
    Control类（及其派生类）对象有一个Invoke方法很特别，这是少数几个不受线程限制的成员之一。除了创建控件的线程以外，绝对不要在任何其他线程里面调用非本线程创建的控件的成员时，也就是说控件属于创建它的线程，不能从其他线程里面访问，这一条适用于所有从System.Windows.Forms.Control派生的控件(因此可以说是几乎所有控件)，包括Form控件本身也是。但这个Invoke方法就是极个别情况之一----Invoke方法可以从任何线程里面调用。
    Invoke方法首先检查发出调用的线程(即当前线程)是不是UI线程，如果是，直接执行委托指向的方法，如果不是，它将切换到UI线程，然后执行委托指向的方法。不管当前线程是不是UI线程，Invoke都阻塞直到委托指向的方法执行完毕，然后切换回发出调用的线程(如果需要的话)，返回。注意，使用Invoke方法时，UI线程不能处于阻塞状态。
    以上是Invoke，再说说BeginInvoke，毫无疑问这是Invoke的异步版本 (Invoke是同步完成的)，不过不要和上面的System.Windows.Forms.MethodInvoker委托中的 BeginInvoke混淆，两者都是利用不同线程来完成工作，但是控件的BeginInvoke方法总是使用UI线程，而其他的异步委托调用方法则是利用线程池里的线程。相对Invoke而言，使用BeginInvoke稍稍麻烦一点，但还是那句话，异步比同步效果好，尽管复杂些。比如同步方法可能出现这样一种死锁情况：工作者线程通过Invoke同步调用UI线程里的方法时会阻塞，而万一UI线程正在等待工作者线程做某件事时怎么办？因此，能够使用异步方法时应尽量使用异步方法。
（1）非推荐方法
System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls = false;

（2）用xControl.Invoke/xControl.BeginInvoke
控件禁止由创建它的线程以外的线程直接访问，这是C#的保护机制，可以这样来做：
当一个控件的InvokeRequired属性值为真时，说明有一个创建它以外的线程想访问它，此时它将会在内部调用new MethodInvoker(LoadGlobalImage)来完成下面的步骤，这个做法保证了控件的安全，你可以这样理解，有人想找你借钱，他可以直接在你的钱包中拿，这样太不安全，因此必须让别人先要告诉你，你再从自己的钱包把钱拿出来借给别人，这样就安全了。

        //回调函数处理
        delegate void UpdateControlText(string s);
        //线程安全的访问窗体控件  
        private void x1()
        {  
            for (int i = 0; i < 1000; i++)  
            {  
                //判断是否线程外调用
                if (this.InvokeRequired)  
                {  
                    //外部调用
                    UpdateControlText update = new UpdateControlText(updateControlText);    //用更新控件的方法updateControlText实例化一个委托update，如果有类似循环的费时操作，不要放入updateControlText方法中，因为会被在UI线程中执行，从而导致UI线程无响应，而是应该放在UI线程外面的子线程  
                    this.Invoke(update, i.ToString());                                      //※重点，调用窗体Invoke方法，此过程在UI线程中执行，非子线程，Invoke为同步执行，BeginInvoke为异步执行
                    //this.Dispatcher.Invoke(update, i.ToString());                         //如果是WPF，应替换成本行
                }  
                else  
                {  
                    //内部调用
                    //this.label1.Text = i.ToString();  
                    updateControlText(i.ToString());
                }  
            }  
        }  
        private void updateControlText(string i)
        {
            this.label1.Text = i.ToString();  
        }
这种方式其实相当于把这个新开的线程“注入”到了主控制线程中，它取得了主线程的控制。如果这个线程不返回（如无限循环），那么主线程将永远都无法响应。就算新开的线程中不使用无限循环，使之可以返回了。这种方式的使用多线程也失去了它本来的意义。


（3）SynchronizationContext--线程之间的通讯
说明：SynchronizationContext是一个管道，通过它在线程间进行数据传输。另外，不是每个线程都附加SynchronizationContext这个对象，只有UI线程是一直拥有的。
步骤：
1）在ui线程中获得SynchronizationContext实例
    SynchronizationContext uiContext = SynchronizationContext.Current;
2）在子线程中进行跨线程操作
    for(int i = 0; i < 100; i++)
    {
        //Send 方法启动一个同步请求以发送消息
        uiContext.Send(MyTrans, i.ToString());
        //Post 方法启动一个异步请求以发送消息。 
        uiContext.Post(MyTrans, i.ToString());
    }

    private void MyTrans(object state)
    {
        mListBox.Items.Add(state.ToString());
    }






D、Task
1.


2.async、await异步方法框架分析
※“await”运算符只能用于异步方法中。即必须位于用“async”修饰符标记的方法内，并将其返回类型更改为“Task”。
async修饰符表示该方法为异步方法，不会被阻塞，一旦方法内部遇到阻塞时，1.立刻跳出该方法，继续执行，2.阻塞部分继续照常执行。
即，有await，必用async修饰。

using System.Threading.Tasks;               //async、await用到
using System.Runtime.CompilerServices;      //AsyncTaskMethodBuilder用到
（1）一般调用结构
syncFunction
{
    asyncFunction
    {
        var v = await asyncFunction
        {
            
        }
    }
}
即，
//1.调用异步方法，不需要返回值时，都可以调用
private void syncFun()
{
  ...
  asyncFun1();
  ...
}
//2.调用异步方法，等待返回值时，只有异步方法可以调用
private async void asyncFun1()
{
  int i = await asyncFun2();
}
//3.带返回值的异步方法
private async Task<int> asyncFun2()
{
  await System.Threading.Tasks.Task.Delay(1000);
  return 1;
}
（2）执行顺序
一个同步方法中调用带await的async方法：当程序执行到async方法中的await时，会分叉成两条线执行：一条跳出该async方法，继续向下执行，一条阻塞在await处，直接执行完毕后，在该async方法内继续向下执行。

例：
01    int main()
02    {
03      asyncFun();
04      Thread.Sleep(2000);                    //4s--6s
05    }
06    
07    public async Task<int> asyncFun()
08    {
09        int i = 0;
10        Thread.Sleep(4000);                  //0s--4s
11        await xiaohao1000ms();               //4s--5s
12        i = i + 2;                           //6s
13        return 1;
14    }

其执行顺序是这样的：
03
09
10
04  11

Task task = new Task(...);
await task.Start();
task.Wait();

Wait方法是“真阻塞”，而await操作则是使用阻塞语义的代码实现非阻塞的效果，这个区别一定要分清。


3.语法解析
async               表示该方法“可以”是异步方法，不阻塞当前线程。所谓“可以”的意思是，只有该方法内部出现await时，才是异步方法，否则被忽略。（异步方法的返回值必须是void或Task）
await               表示在此位置，fork，一个线程会让内层方法阻塞并等待返回，另一个线程会跳出此async方法，使外部方法继续向下执行
Task.Result         表示在此位置，开始阻塞，等待此task完成，同时会阻塞外部方法
await Task.Delay    不会阻塞，会跳到方法外部继续执行，而内部在延时后继续执行
Thread.Sleep        是同步方法的等待

在同步方法中，单独调用一个带返回值的异步方法没有意义，因为同步方法不会等待这个返回值。
在异步方法中，可以调用一个带返回值的异步方法，因为异步方法中可以使用关键字await等待。
即：带返回值的异步方法，只能在异步方法中被调用。


4.Task
A.Task的优势
ThreadPool相比Thread来说具备了很多优势，但是ThreadPool却又存在一些使用上的不方便。比如：
  1）ThreadPool不支持线程的取消、完成、失败通知等交互性操作；
  2）ThreadPool不支持线程执行的先后次序；
以往，如果开发者要实现上述功能，需要完成很多额外的工作，现在，FCL中提供了一个功能更强大的概念：Task。Task在线程池的基础上进行了优化，并提供了更多的API。在FCL4.0中，如果我们要编写多线程程序，Task显然已经优于传统的方式。

B.Task的方法
I.Task
CancellationTokenSource tokenSource = new CancellationTokenSource();
//定义Task
Task t = new Task(TaskStarted, tokenSource.Token);                          //静态形式：Task.Run(TaskStarted, tokenSource.Token);
//定义Task
Task t = new Task(() => TaskStarted(tokenSource), tokenSource.Token);       //静态形式：Task.Run(() => TaskStarted(tokenSource), tokenSource.Token);

t.Start();                                  //开始（异步）
t.RunSynchronously();                       //开始（同步），相当于await t.Start();
t.ContinueWith( (item) => TaskEnded );      //结束后执行（异步），其中item即为t，相当于回调

Task tasks = new Task[] { t };
Task.WhenAll(tasks);                        //异步方法，保持等待，直到所有Task[]结束，返回“表示所有提供的任务的完成情况的任务”，前可加await
Task.WhenAny(tasks);                        //异步方法，保持等待，直到任一Task[]结束，返回“表示所有提供的任务的完成情况的任务”，前可加await
Task.WaitAll(tasks);                        //同步方法，保持等待，直到所有Task[]结束
Task.WaitAny(tasks);                        //同步方法，保持等待，直到任一Task[]结束
tokenSource.Cancel()                        //取消Task

CancellationTokenSource说明：
•IsCompleted：tokenSource.Cancel()  ->  tokenSource.Token.IsCancellationRequested  ->  task.IsCompleted                  已完成（无论成功，还是失败）
                                                                IsCancellationRequested == true
•IsCanceled： tokenSource.Token.ThrowIfCancellationRequested()  ------------------------------->  task.IsCanceled        因为被取消而完成
•IsFaulted：  throw new Exception("error");  ->  task.IsFaulted                                                          因为发生异常而完成

II.TaskFactory任务工厂（TaskFactory之于Task，相当于TheadPool之于Thread）
CancellationTokenSource tokenSource = new CancellationTokenSource();
TaskFactory taskFactory = new TaskFactory();

Task t1 = taskFactory.StartNew(() => add(tokenSource.Token));       //此时已开始异步执行，静态形式：Task.Factory.StartNew(() => add(tokenSource.Token))
Task t2 = taskFactory.StartNew(() => add(tokenSource.Token));
Task t3 = taskFactory.StartNew(() => add(tokenSource.Token));

Task[] tasks = new Task[] { t1, t2, t3 };
//当taskFactory的tasks任务集合都结束后，继续执行TasksEnded。其中，CancellationToken.None指示TasksEnded不能被取消
taskFactory.ContinueWhenAll(tasks, TasksEnded, CancellationToken.None);、
//当taskFactory的tasks任务集合中的任一任务结束，继续执行TasksEnded。其中，CancellationToken.None指示TasksEnded不能被取消
taskFactory.ContinueWhenAny(tasks, TasksEnded, CancellationToken.None);

Console.ReadKey();
tokenSource.Cancel();
Console.ReadKey();


C.异步转同步
在一个方法内，要将内部的异步方法转为同步方法时，需要在异步方法前加await。但加了await之后，该外部方法又要加上async关键字，如此将会无限循环。解决方法是：
//方法一
public async int SyncMethod()
{
    int val;
    val = asyncMethod().GetAwaiter().GetResult();
    val = asyncMethod().Result;
    return val;
}
//方法二
public async void SyncMethod()
{
    AsyncContext.Run(() => MainAsync(args));
}



D.实例
（1）简单的Task
Task t = new Task( TaskStarted );
t.Start();  //开始执行
t.ContinueWith( TaskEnded ); //结束后执行

void TaskEnded(Task<int> task)
{
    Console.WriteLine("任务完成，完成时候的状态为：");
    Console.WriteLine("IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}", task.IsCanceled, task.IsCompleted, task.IsFaulted);
    Console.WriteLine("任务的返回值为：{0}", task.Result);
}

（2）可中止的Task
CancellationTokenSource tokenSource = new CancellationTokenSource();
Task t = new Task( 
        () => TaskStarted(tokenSource), 
        tokenSource
    );

t.Start();                        //开始执行
t.ContinueWith( TaskEnded );      //结束后执行

//等待按下任意一个键取消任务
Console.ReadKey();
tokenSource.Cancel();             //导致IsCompleted=ture
Console.ReadKey();

//开始时的任务
void TaskStarted(CancellationTokenSource tokenSource)
{
    Console.WriteLine("任务开始……");
    int i = 0;
    while (i < 100)
    {
        i = new Random().Next(0, 102);     //[0, 102)
        switch(i)
        {
            case 99: 
                tokenSource.Cancel();                                   •IsCompleted=True, IsCanceled=False, IsFaulted=False
                break;
            case 88: 
                tokenSource.Token.ThrowIfCancellationRequested();       •IsCompleted=True, IsCanceled=True, IsFaulted=False
                break;
            case 77: 
                throw new Exception("error");                           •IsCompleted=True, IsCanceled=False, IsFaulted=True
                break;
        }
        Thread.Sleep(1000);
    }
    return result;
}

//结束时的任务
void TaskEnded(Task<int> task)
{
    Console.WriteLine("任务完成，完成时候的状态为：");
    Console.WriteLine("IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}", task.IsCanceled, task.IsCompleted, task.IsFaulted);
    try{
        Console.WriteLine("任务的返回值为：{0}", task.Result);
    }
    catch (AggregateException e)
    {
        e.Handle((err) => err is OperationCanceledException);
    }
}

（3）任务工厂
static void Main(string[] args)
{
    CancellationTokenSource tokenSource = new CancellationTokenSource();
    //等待按下任意一个键取消任务
    TaskFactory taskFactory = new TaskFactory();
    Task[] tasks = new Task[]
        {
            taskFactory.StartNew(() => Add(tokenSource.Token)),
            taskFactory.StartNew(() => Add(tokenSource.Token)),
            taskFactory.StartNew(() => Add(tokenSource.Token))
        };
    //CancellationToken.None指示TasksEnded不能被取消
    taskFactory.ContinueWhenAll(tasks, TasksEnded, CancellationToken.None);
    Console.ReadKey();
    tokenSource.Cancel();
    Console.ReadKey();
}

static void TasksEnded(Task[] tasks)
{
    Console.WriteLine("所有任务已完成！");
}


5.void、Task、Task<T>返回类型
public async void asyncFun()
{
    //方法一：静态lambda表达式
    int i;
    //       结果再次转为int<----外部返回结果为Task<-----------内部返回结果为int
    i =         await               Task<int>.Run(     () => { Thread.Sleep(3000); return 1; }     );
    ...
    //方法二：动态lambda表达式
    Task<int> t = new Task<int>(                  () => { Thread.Sleep(3000); return 1; }     );
    t.Start();
    i = await t;
    ...
    //方法三：异步函数
    i =         await               fun();
    private async Task<int> fun()
    {
        await Task.Delay(3000);
        return 1;
    }
    ...
    //方法四：定义回调委托（只有Task才有GetAwaiter方法）
    var awaiter = fun().GetAwaiter(); 
    awaiter.OnCompleted (() => 
        { 
            var result = awaiter.GetResult(); 
            ...
        }
    ); 
}

await后要跟一个Task，可以是：（1）带Task返回值的方法
                             （2）或Task<int>.Run(...)静态lambda表达式
                             （3）或new Task<int>(...)动态lambda表达式
对于返回void的async方法，它并不是awaitable，所以其他方法不能用await方法来调用它，而返回Task的async方法则可以。

※不适用于异步方法的情况
并不是所有同步方法都改成异步就是好，异步方法在返回Task之前，当方法中分配了大量对象时，占用了大量资源在内存中，方法真正结束返回Task后，这部分资源需要标记成“待释放”等待被回收。当如此反复，会产生大量的垃圾，大大影响整个程序的性能。对于这种情况，一种解决方式是建议将返回的Task设计成单例，可以反复使用以避免重复分配，（但这种方式似乎不适用于多线程中嵌套Task异步方法）。

6.Task.FromResult
用于创建一个已完成的、带返回值的 System.Threading.Tasks.Task<TResult>。
¤如果使用Task.FromResult不带返回值，就使用Task.FromResult(0) 或 Task.FromResult(null)

7.TaskAwaiter
本质上说await和async的出现也只是一颗语法糖，但是这颗语法糖可以使得异步编程更优雅，直接摒弃了原先EAP和APM这种到处BeginXXX，EndXXX的丑陋模式，提高了生产力。
可以使用await的方法，返回值必须是awaitable对象，自定义awaitable对象比较麻烦，一个对象必须满足下列条件才行：
必须有一个 GetAwaiter()方法，扩展方法或者实例方法都可以
GetAwaiter() 方法返回值必须是awaiter对象。一个对象要成为awaiter对象必须满足下列条件:
该对象实现接口 INotifyCompletion 或者ICriticalNotifyCompletion
必须有 IsCompleted属性
必须有 GetResult()方法，可以返回void或者其他返回值。
由于微软并未给出满足上述条件的接口，因此可以自己实现这样的接口。 

Func方法可以异步执行了，因为Func<int>已经实现扩展方法GetAwaiter，并且返回值类型是自己定义的IAwaitable类型。
当然，更加简单的方法是，采用微软提供的Task对象，让拉姆达表达式返回Task类型就可以了。 



    static Task<string> ProcessAsync()
    {
        AsyncTaskMethodBuilder<string> builder = AsyncTaskMethodBuilder<string>.Create();
        builder.SetResult("Finished");
        return builder.Task;//获取需要的Task
    }

    public static void Main()
    {
        var task = ProcessAsync();
        task.Wait();
        var r = task.Result;
    }





E、Parallel
1.使用Parallel.For进行并行化
（1）作用
    在.NET Framework 4.0中，在库的层次上，微软提供了大量的新内容来帮助程序员完成应用程序的并行化，其中包括Parallel LINQ(PLINQ)，Task Parallel Library(TPL)和Coordination Data Structures。这里我们就先来介绍一下最简单最常用的TPL。
    通常我们在处理大量相互独立的同类数据的时候，比如vector，list这些容器中的数据，都会用到for循环。利用for循环，我们遍历数据集中的每一个数据并进行处理。面对这种简单独立的for循环，我们可以利用TPL提供的Parallel.For将其并行化，以“充分利用多核CPU”的运算能力。让应用程序的性能有大幅度的提升。在双核CPU上测试的结果是，程序性能有将近两倍的提升。
（2）格式原型
    为了使用Parallel类，我们首先需要声明System.Threading名字空间，Parallel类就在这个名字空间中。Parallel.For实际上是Parallel类提供的一个静态方法，它的第3个参数是类型为Action的委托，在这段代码中，我们直接使用Lambda表达式来将一个匿名函数直接“内联”作为Parallel.For方法的参数。
using System.Threading;
    public static ParallelLoopResult For(
        int fromInclusive,
        int toExclusive,
        Action<int, ParallelLoopState> body
    )
（3）解析
    使用Parallel.For需要注意的是，Parallel.For循环中的循环次序是乱的，并不像标准的for循环那样按照从小到大或者从大到小的顺序执行。这一点我们在使用Parallel.For循环的时候要特别注意，如果你的循环对次序有要求，上一次循环是下一次循环的输入，或者是每次循环之间有相同的数据要处理，那么就不能简单地使用Parallel.For循环来并行化程序，需要做一些特殊的处理。

（4）


2.控制Parallel.For循环的执行
    在普通for循环中，我们可以使用break或者continue关键词来控制for循环的执行，在一些特殊的情况下跳出for循环的执行或者是继续for循环的下一次执行。遗憾的是，这两个关键字不能使用在Parallel.For循环中。那么我们又如何控制Parallel.For循环的执行呢?
    Parallel.For函数提供了一些重载版本，这些重载的Parallel.For函数可以接受一个Action作为参数，而我们可以利用ParallelLoopState对象来控制Parallel.For函数的执行，ParallelLoopState对象是由运行时在后台创建的，我们还可以将ParallelLoopState命名为我们喜欢的名字，比如PrimeLoopState等等。这个对象有两个函数，Stop和Break，可以分别用来控制Parallel.For的执行。
（1）Stop
    调用Stop，表示Parallel.For的执行立刻停止，无论其他执行单元是否达到停止的条件。（一个循环单元，停掉整个循环）
// 停止Parallel.For
        private static void StopParallelFor()
        {
            int nTotal = 0;
            Parallel.For(1, 100, (i, loopState) =>
            {
                // 当某一个循环单元的数大于30，
                // 则停止Parallel.For的执行
                if ( i > 30)
                {
                    // 停止并退出Parallel.For
                    loopState.Stop();
                    return;
                }
                Console.WriteLine("Current Nummber: {0} ", i);
                Interlocked.Increment(ref nTotal);
            });

            // 输出结果
            Console.WriteLine("Total Accessed: {0} ", nTotal);
        }
        // 输出：
        /*  Current Nummber: 1
            Current Nummber: 2
            Total Accessed: 2 
        */
（2）Break（一个循环单元，只停掉该循环单元本身）
    调用Break，则表示满足条件的当前执行单元立刻停止，而对于其他执行单元，可能会满足停止条件而通过Break停止，也可能在其执行过程中始终无法满足停止条件，从而全部执行完毕，自然停止。当所有执行单元停止后，Parallel.For函数才停止执行并退出。
       // 跳出Parallel.For的循环
        private static void BreakParallelFor()
        {
            int nTotal = 0;
            Parallel.For(1, 100, (i, loopState) =>
            {  
                // 当某一个循环单元的数大于30，
                // 则跳出当前执行单元，等待其他执行单元结束
                // 所有执行单元结束后退出Parallel.For的执行
                if (i > 30)
                {
                    // 跳出当前执行单元
                    loopState.Break();
                    return; 
                }
                Console.WriteLine("Current  Nummber: {0} ", i);
                Interlocked.Increment(ref nTotal);
            });

            // 输出结果
            Console.WriteLine("Total Accessed: {0} ", nTotal);
        }
        // 输出：
        /*  Current Nummber: 1
            Current Nummber: 2 
            Current Nummber: 22
            Current Nummber: 23
            Current Nummber: 27
            ...
            Current Nummber: 20
            Current Nummber: 21
            Total Accessed: 30
         */

3.使用Parallel.ForEach进行并行化
Parallel.For函数对应于for循环，同样的，在TPL中也提供了一个Parallel.ForEach函数用于并行化foreach循环。
    在后台，TPL“悄悄地”把整个集合分成若干个不相交的子集，然后，针对每个集合从线程池中选择一个线程对集合中的对象进行处理。由于每个子集都只对应着一个线程，因此，无需担心发生多线程访问共享资源的问题，而且多个子集的处理工作可以并行执行。
    通过Parallel.For函数和Parallel.ForEach函数，在利用循环处理并行数据的时候，我们可以非常简便地将一个串行的for循环和foreach并行化，从而充分利用多核CPU的资源，提高应用程序的性能。

    // 并行处理数据
    private static void ParallelForEach()
    {
        Start("ParallelForEach");
        // 使用Parallel.ForEach函数，
        // 并行处理数据集employeeDatas中的每一个数据
        Parallel.ForEach(employeeDatas,
            new ParallelOptions() {                     /*设置最大线程数，可选参数*/
                MaxDegreeOfParallelism = 5
            },
            employeeData =>
            {
                Console.WriteLine("Starting process for employee id {0}",
                    employeeData.EmployeeID);
                decimal span = Employee.Process(employeeData);
                Console.WriteLine("Completed process for employee id {0}",
                    employeeData.EmployeeID);
                Console.WriteLine();
            }
        );

        End("ParallelForEach");
    }

4.使用Parallel.Invoke进行并行化
Parallel.Invoke(
  ()=>
  {
     Console.WriteLine("任务1......");
  },
  ()=>
  {
     Console.WriteLine("任务2......");
  },
  ()=>
  {
     Console.WriteLine("任务3......");
  }
);
输出：
任务2......
任务3......
任务1......


5.说明
Parallel是内部异步，外部仍旧是同步，即Parallel后的语句，需等待Parallel执行完才能执行。

    ParallelLoopResult result = Parallel.For ( 0, 10, i =>{
       Console.WriteLine ( "{0}, task: {1} , thread: {2}", i, Task.CurrentId, Thread.CurrentThread.ManagedThreadId );
       Thread.Sleep ( 10 );
    } );
    Console.WriteLine (result.IsCompleted);


6.LINQ的并行
  var sum = ( from x in data.AsParallel ( )
              where x < 20
              select x ).Sum ( );
或
var sum = data.AsParallel().Where ( x => x < 20 ).Select ( x => x ).Sum ( );                    //非顺序
运行这行代码会启动任务管理器，这样就可以看出系统的所有CPU都在忙碌。如果删除AsParallel()方法，就不可能使用多个CPU。当然，如果系统上没有多个CPU，就不会看到并行版本带来的改进。
var sum = data.AsParallel().AsOrdered().Where ( x => x < 20 ).Select ( x => x ).Sum ( );        //按顺序输出


F、通过 async/await 调用传统 Begin/End 异步方法

public IAsyncResult BeginPutObject(string bucketName, string key, Stream content, AsyncCallback callback, object state);
public PutObjectResult EndPutObject(IAsyncResult asyncResult);

=>

async Task<bool> IBucket.PutFileAsync(string filePath, Stream uploadStream)
{
    filePath = filePath.Substring(1);
    uploadStream.Position = 0;
    var result = await Task<PutObjectResult>.Factory.FromAsync(
                    _client.BeginPutObject,
                    _client.EndPutObject,
                    _bucketName, filePath, uploadStream,
                    null);
    Console.WriteLine(result.ETag);
    return true;
}


G、并发与并行
    并发连接数：网站有时候报错：“HTTP Error 503. The service is unavailable”。但刷一两下又正常，估计很可能是超过网站的最大并发连接数了。并发连接指网络流量管理设备或代理服务器对其业务信息流的处理能力，是能够同时处理的点对点连接的最大数目，它反映出设备对多个连接的访问控制能力和连接状态跟踪能力，这个参数的大小直接影响到设备所能支持的最大信息点数。
    并发可以理解为服务器最多维护多少个会话数，并行则不一样，它关系的是有多少个会话是在同时进行，假如有两台服务器（进程），可能并行的数量是2，而并发的数量是1000。我们还可以对比下吞吐量和带宽的概念。

      并发    并行
      /--\
      /--\
      /---->Executor1
Input------>Executor2
      \---->Executor3
      \--/
      \--/


九、数据流处理与网络访问
A、Stream
I\O流主要有：Stream:FileStream、StreamRead、StreamWrite。
Stream 是所有流的抽象基类
流涉及三个基本操作： 
1.可以读取流。读取是从流到数据结构（如字节数组）的数据传输。
2.可以写入流。写入是从数据结构到流的数据传输。
3.流可以支持查找。查找是对流内的当前位置进行查询和修改。查找功能取决于流具有的后
FileStream   旨在以byte的形式输入、输出字符（序列化）
StreamReader 旨在以一种特定的编码（如UTF8文本等）输入字符，而 Stream 类用于字节的输入和输出。
StreamWriter 旨在以一种特定的编码（如UTF8文本等）输出字符
string与byte[]可以互相转换

B、FileStream
从public class FileStream : Stream可以看出，该类继承自Stream
1、序列化
    把对象转换为字节序列的过程称为对象的序列化。
    把字节序列恢复为对象的过程称为对象的反序列化。
2、声明FileStream
FileStream fs = new FileStream("Schedules.bin", FileMode.Open);
文件的打开模式，这里FileMode是个枚举，包括： 
 CreateNew 指定操作系统应创建新文件。此操作需要 FileIOPermissionAccess..::.Write。如果文件已存在，则将引发 IOException。 
 Create 指定操作系统应创建新文件。如果文件已存在，它将被覆盖。这要求 FileIOPermissionAccess..::.Write。System.IO.FileMode.Create 等效于这样的请求：如果文件不存在，则使用 CreateNew；否则使用 Truncate。 
 Open 指定操作系统应打开现有文件。打开文件的能力取决于 FileAccess 所指定的值。如果该文件不存在，则引发 System.IO..::.FileNotFoundException。 
 OpenOrCreate 指定操作系统应打开文件（如果文件存在）；否则，应创建新文件。如果用 FileAccess.Read 打开文件，则需要 FileIOPermissionAccess..::.Read。如果文件访问为 FileAccess.Write，则需要 FileIOPermissionAccess..::.Write。如果用 FileAccess.ReadWrite 打开文件，则同时需要 FileIOPermissionAccess..::.Read 和 FileIOPermissionAccess..::.Write。 如果文件访问为 FileAccess.Append，则需要 FileIOPermissionAccess..::.Append。 
 Truncate 指定操作系统应打开现有文件。文件一旦打开，就将被截断为零字节大小。此操作需要 FileIOPermissionAccess..::.Write。试图从使用 Truncate 打开的文件中进行读取将导致异常。 
 Append 打开现有文件并查找到文件尾，或创建新文件。FileMode.Append 只能同 FileAccess.Write 一起使用。试图查找文件尾之前的位置时会引发 IOException，并且任何试图读取的操作都会失败并引发 NotSupportedException。

3、FileStream的读写操作
（1）声明byte
c#中字节byte的范围是0~255；
可以构造这样的字节数组：
byte[] buffer = new byte[]{32, 32, 129, 223, 201, 0, 0, 32}
（2）进行读写操作
fileStream.Read(buffer);
fileStream.Read(buffer, offset, count);
fileStream.Write(buffer);
fileStream.Write(buffer, offset, count);
param：
buffer(读取对象后，写入的目标容器): 字节数组。此方法返回时，该缓冲区包含指定的字符数组，该数组的 offset 和 (offset + count -1) 之间的值由从当前源中读取/写入的字节替换。 
offset(偏移量): buffer 中的从零开始的字节偏移量，从此处开始存储从当前流中读取/写入的数据。 
count(要获取的长度): 要从当前流中最多读取/写入的字节数。
返回值：读入缓冲区/从缓冲区写入的总字节数。如果当前可用的字节数没有请求的字节数那么多，则总字节数可能小于请求的字节数，或者如果已到达流的末尾，则为零 (0)。
备注：
此方法的实现从当前流中读取/写入最多的 count 个字节，并将它们存储在从 offset 开始的 buffer 中。流中的当前位置提升已读取/写入的字节数；但是，如果出现异常，流中的当前位置保持不变。实现返回已读取/写入的字节数。仅当位置当前位于流的末尾时，返回值才为零。如果没有任何可用的数据，该实现将一直阻塞到至少有一个字节的数据可读为止。仅当流中不再有其他的数据，而且也不再需要更多的数据（如已关闭的套接字或文件尾）时，Read 才返回 0。即使尚未到达流的末尾，实现仍可以随意返回少于所请求的字节。


    //定义一个文件流，用于读取原文件到内存缓冲区
    FileStream fs = new FileStream(this.textBox2filename.Text, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
    //定义内存缓冲区
    int ByteLength = (int)fs.Length;
    byte[] buffer = new byte[ByteLength];
    //将文件读入到内存缓冲区
    int nByteRead = fs.Read(buffer, 0, ByteLength);
    fs.Close();


    //再定义一个文件流，用于将缓冲区中的文件流写入文件
    FileStream fs1 = new FileStream(this.textBox2filename.Text, FileMode.Create );//FileMode.Append  追加模式
    //写入文件
    int bufferLength = buffer.Length;
    //将内存缓冲区中的文件流写入文件
    fs1.Write(buffer, 0, bufferLength);
    fs1.Close();


例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
                FileStream fileStream = new FileStream("e:\\amy\\11.jpg", FileMode.Open, FileAccess.Read);
                byte[] buffer = new Byte[checked((uint)Math.Min(44096, (int)fileStream.Length))];
                int bytesRead = fileStream.Read(buffer, 1, buffer.Length-1);
                MessageBox.Show("length/read:" + buffer.Length + "-" + bytesRead.ToString());

结果：length/read:16701-16702
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子

C、StreamWrite、StreamReader（以字符串为操作对象，不局限于对FILE的读写，其它stream也可）
StreamReader类的构造参数非常丰富，StreamReader(Stream stream)和StreamReader（String str）这两个最常用，第一个可以直接放入一个数据流，例如FileStream，而第二个更简单直接放入str例如“c:/test.txt”
1、ReadLine（）
当遇到\n \r 或者是\r\n的时候 此方法返回这前面的字符串，然后内部的指针往后移一位下次从新的地方开始读，直到遇到数据的结尾处返回null。
2、Read()
（1）此方法每次读取一个字符，返回的是代表这个字符的一个正数，当独到文件末尾时返回的是-1。
（2）Read()还有一个使用方法
int Read(char[] buffer, int index, int count);
//补充一下，假设制定每次读128个字符，当文件内容小于128时，它会再循环一遍，从头开始读，直到读够128个字符，从文件流的第index个位置开始读，到count个字符，把它们存到buffer中，然后返回一个正数，内部指针后移一位，保证下次从新的位置开始读。
3、ReadToEnd()
这个方法适用于小文件的读取，一次性的返回整个文件。

另：StreamReader sr = new StreamReader(filename, System.Text.Encoding.Default);可解决乱码问题
或者指定UTF-8或者System.Text.Encoding.GetEncoding("gb2312")
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
        StreamWriter sw = new StreamWriter(SaveFileDialog1.FileName, true);
        sw.WriteLine("Line1");
        sw.WriteLine("Line2");
        sw.WriteLine("Line3");

        StreamReader sr = new StreamReader(OpenFileDialog1.FileName);
        textBox1.Text = sr.ReadToEnd();
        // 重置文件指针至文件头.
        sr.BaseStream.Seek(0, SeekOrigin.Begin);
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子




D、WebClient
WebClient 类提供向 URI 标识的任何本地、Intranet 或 Internet 资源发送数据以及从这些资源接收数据的公共方法。
主要功能：
提供四种将数据上传到资源的方法：
·OpenWrite 返回一个用于将数据发送到资源的 Stream。返回Stream格式
·UploadData 将字节数组发送到资源并返回包含任何响应的字节数组。返回byte[]格式
·UploadFile 将本地文件发送到资源并返回包含任何响应的字节数组。返回byte[]格式
·UploadValues 将 NameValueCollection 发送到资源并返回包含任何响应的字节数组。
提供三种从资源下载数据的方法：
·DownloadData 从资源下载数据并返回字节数组。返回byte[]格式
·DownloadFile 从资源将数据下载到本地文件。返回byte[]格式
·OpenRead(URL) 从资源以 Stream 的形式返回数据。返回Stream格式

I、下载
1、DownloadFile
WebClient Client = new WebClient();
Client.DownloadFile("http://localhost:90/", "d:\\123.txt");

2、OpenRead
WebClient Client = new WebClient();
Stream strm = Client.OpenRead("http://localhost:90/");
/*
StreamReader sr = new StreamReader(strm);
*/

3、DownloadData
WebClient Client = new WebClient();
byte[] retByte = Client.DownloadData("http://localhost:90/");

II、上传
1、UploadFile
WebClient client = new WebClient();
client.UploadFile("http://localhost:90/", "d:\\123.txt");
/*
FileStream fs = new FileStream("d:\\123.jpg", FileMode.Open);
byte[] image = new byte[fs.Length];
fs.Read(image, 0, (int)fs.Length);
client.UploadData("http://localhost:90/image.jpg", image);
*/

2、OpenWrite
WebClient webClient = new WebClient();
Stream stream = webClient.OpenWrite("http://localhost:90/", "PUT");
/*
StreamWriter streamWriter = new StreamWriter(stream);
streamWriter.WriteLine("Hello World");
streamWriter.Close();
*/

3、UploadData
WebClient client = new WebClient();
client.UploadFile("http://www.ourwebsite.com/NewFile.htm", "C://WebSiteFiles//NewFile.htm");
/*
byte [] image;
client.UploadData("http://www.ourwebsite.com/NewFile.jpg", image);
*/




异步
    wc.OpenWriteCompleted += new OpenWriteCompletedEventHandler(wc_OpenWriteCompleted);
    wc.OpenWriteAsync(new Uri("WebClientUpload.ashx", UriKind.Relative), "POST", fs);






using System.Net;
public Form1()
{
  WebClient Client = new WebClient();
  Stream sm = Client.OpenRead("http://www.baidu.com");
  StreamReader sr = new StreamReader(sm);
  string line;
  while(( line=sr.ReadLine() ) =! null )
  {
      listBox1.Items.Add(line);
  }
  sm.Close();
}


using System.Net;
public Form1()
{
  WebClient Client = new WebClient();
  Stream sm = Client.OpenWrite("http://www.baidu.com", "PUT");
  StreamWriter sw = new StreamWriter(sm);
  sw.WriteLine("Hello World");
  sw.Close();
}



E、WebRequest和WebResponse
身份验证：解决“请求因 HTTP 状态 401 失败: Unauthorized。”
调用WS的时候，在IIS上有验证设置的，一般设置的是basic验证或者Windows集成验证，这就是说，你要访问这个WS，必须提供一个有权限调用的windows身份，这个时候，
（1）如果你的当前调用WS的运行帐号存在于对方系统中，并且密码一样，那么，你的那句webrequest.Credentials = CredentialCache.DefaultCredentials;就有用，
（2）否则，应该如此写：webrequest.Credentials = new NetworkCredential(userid, password, domainname)，
（3）如果对方的WS使用了匿名验证，你当前就可以不用写webrequest.Credentials=....这行代码了。 

using System.Net;
public Form1()
{
  WebRequest request = WebRequest.Create("http://www.baidu.com");
  WebResponse response = request.GetResponse();
  Stream sm = response.GetResponseStream();
  StreamReader sr = new StreamReader(sm);
  string line;
  while(( line = sr.ReadLine() ) =! null )
  {
      listBox1.Items.Add(line);
  }
  sm.Close();
}

异步请求
using System.Net;
public Form1()
{
  WebRequest request = WebRequest.Create("http://www.baidu.com");
  request.BeginGetResponse( new AsyncCallback(OnResponse), request );
}

protected void OnResponse(IAsyncResult ar)
{
  WebRequest request = (WebRequest)ar.AsyncState;
  WebResponse response = request.EndGetResponse(ar);
  下同...
  StreamReader sr = new StreamReader(sm);
  string line;
  while(( line=sr.ReadLine() ) =! null )
  {
      listBox1.Items.Add(line);
  }
  sm.Close();
}



F、HttpWebRequest和HttpWebResponse
HttpWebRequest是WebRequest的派生类，HttpWebResponse是WebResponse的派生类。所以可以使用HttpWebRequest webrequest = (HttpWebRequest)WebRequest.Create(url); 
1.地址
网址：http://localhost:1897/News/Press/Content.aspx/123?id=1#toc
Request.ApplicationPath                                 /
Request.PhysicalPath                                    D:\Projects\Solution\web\News\Press\Content.aspx
System.IO.Path.GetDirectoryName(Request.PhysicalPath)   D:\Projects\Solution\web\News\Press
Request.PhysicalApplicationPath                         D:\Projects\Solution\web\
System.IO.Path.GetFileName(Request.PhysicalPath)        Content.aspx
Request.CurrentExecutionFilePath                        /News/Press/Content.aspx
Request.FilePath                                        /News/Press/Content.aspx
Request.Path                                            /News/Press/Content.aspx/123
Request.RawUrl                                          /News/Press/Content.aspx/123?id=1
Request.Url.AbsolutePath                                /News/Press/Content.aspx/123
Request.Url.AbsoluteUri                                 http://localhost:1897/News/Press/Content.aspx/123?id=1
Request.Url.Scheme                                      http
Request.Url.Host                                        localhost
Request.Url.Port                                        1897
Request.Url.Authority                                   localhost:1897
Request.Url.LocalPath                                   /News/Press/Content.aspx/123
Request.PathInfo                                        /123
Request.Url.PathAndQuery                                /News/Press/Content.aspx/123?id=1
Request.Url.Query                                       ?id=1
Request.Url.Fragment                                     
Request.Url.Segments                                    / 
                                                        News/ 
                                                        Press/ 
                                                        Content.aspx/ 
                                                        123


2.例
例1向服务器上传数据：
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
            string sql = "select * from house.dbo.houseInfo order by ID";
            string filefullpath = Application.StartupPath + "\\Pic\\" + Form1.hI.getDataBase(sql).Rows[NO][PicNO].ToString().Trim();
            string url = Form1.hI.getDataBase("select * from house.dbo.WebList where WebID = '" + NowWebID + "'").Rows[0]["UpPicUrl"].ToString().Trim();
            string boundary = "---------------------------" + DateTime.Now.Ticks.ToString("x");
            string filename = Form1.hI.GetFileName(filefullpath).ToString().Trim();

            //创建request对象 
            HttpWebRequest webrequest = (HttpWebRequest)WebRequest.Create(url); 
            webrequest.Method = "POST"; 
            webrequest.ProtocolVersion = new Version("1.0");
            webrequest.Accept = "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, application/x-silverlight, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, application/x-silverlight-2-b1, */*";
            webrequest.Referer = "http://post.58.com/2422/12/s5";
            webrequest.Headers.Add("Accept-Language: zh-cn");
            webrequest.ContentType = "multipart/form-data; boundary=" + boundary;       //"application/x-www-form-urlencoded";
            webrequest.KeepAlive = true;
            webrequest.UserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)";
            webrequest.Headers.Add("Cookie: " + webBrowser1.Document.Cookie);
            webrequest.Headers.Add("Pragma: no-cache");  



            //构造流数据
            FileStream fileStream = new FileStream(filefullpath, FileMode.Open, FileAccess.Read);
            long length = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;
            webrequest.ContentLength = length;
            Stream requestStream = webrequest.GetRequestStream();
            
            //输入文件流数据
            byte[] buffer = new Byte[checked((uint)Math.Min(4096, (int)fileStream.Length))];
            int bytesRead = 0;
            while ((bytesRead = fileStream.Read(buffer, 0, buffer.Length)) != 0)
                requestStream.Write(buffer, 0, bytesRead);

            //输入尾部数据
            requestStream.Write(boundaryBytes, 0, boundaryBytes.Length);

            Stream s = webrequest.GetResponse().GetResponseStream();
            StreamReader sr = new StreamReader(s);

            //返回数据流(源码)
            return sr.ReadToEnd();
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子




例2向服务器上传数据：
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
        //文件服务器上传
        public string HttpUploadFile(string filefullpath, StringBuilder sbHeader, StringBuilder sbTailer, WebRequest webrequest)
        {
            //数据流 = 头部数据 + 文件数据 + 尾部数据 
            //构造头部数据 
            string postHeader = sbHeader.ToString();
            byte[] postHeaderBytes = Encoding.UTF8.GetBytes(postHeader);

            //构造文件数据
            int bytesRead = 0;
            FileStream fileStream = new FileStream(filefullpath, FileMode.Open, FileAccess.Read);
            byte[] buffer = new Byte[checked((uint)Math.Min(4096, (int)fileStream.Length))];
            bytesRead = fileStream.Read(buffer, 0, buffer.Length;

            //构造尾部数据 
            string postLast = sbTailer.ToString();
            byte[] boundaryBytes = Encoding.UTF8.GetBytes(postLast);

            //定义数据流
            long length = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;
            webrequest.ContentLength = length;
            Stream requestStream = webrequest.GetRequestStream();

            //上传头部数据
            requestStream.Write(postHeaderBytes, 0, postHeaderBytes.Length);

            //上传文件数据
            if (bytesRead != 0) requestStream.Write(buffer, 0, bytesRead);

            //上传尾部数据
            requestStream.Write(boundaryBytes, 0, boundaryBytes.Length);

            //返回数据流(源码)
            Stream s = webrequest.GetResponse().GetResponseStream();
            StreamReader sr = new StreamReader(s);
            return sr.ReadToEnd();
        }
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子


例3
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
读取网页HTML内容
        private void get_BAIDU_html()
        {
            byte[] buf = new byte[38192]; 
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create("http://www.baidu.com/"); 
            HttpWebResponse response = (HttpWebResponse)request.GetResponse(); 
            Stream resStream = response.GetResponseStream(); 
            int count = resStream.Read(buf, 0, buf.Length); 
            MessageBox.Show( Encoding.Default.GetString(buf, 0, count)); 
            resStream.Close(); 
        }
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子

G、附：常用转换
1、 二进制转换成图片
MemoryStream ms = new MemoryStream(bytes);
ms.Position = 0;
Image img = Image.FromStream(ms);
ms.Close();
this.pictureBox1.Image

2、 C#中byte[]与string的转换代码
（1）Encoding动态方式
    //Encoding动态方式
    byte[] inputBytes = new System.Text.UnicodeEncoding().GetBytes(inputString);
    string inputString = new System.Text.UnicodeEncoding().GetString(inputBytes);
    //Encoding静态方式
    byte[] inputBytes = System.Text.UnicodeEncoding.UTF8.GetBytes(inputString);
    string inputString = System.Text.UnicodeEncoding.UTF8.GetString(inputBytes);
（2）Convert方式
    string inputString = System.Convert.ToBase64String(inputBytes);
    byte[] inputBytes = System.Convert.FromBase64String(inputString);

※
一个byte数组中存了一些从数据文件中读取的信息，里面有中文也有英文，我如何把它转化成字符串?
System.Text.ASCIIEncoding.ASCII.GetString(bytes);
System.Convert.ToString(byteArray)也可以把byte[]装换为string
如果得到的结果不正确，可能是字符集设置不正确，一般涉及到中文的字符集是utf8、unicode、和gb2312 
byte[] buf = YourByteArray; 
// 转换成GB2312格式
System.Text.Encoding.GetEncoding(936).GetString(buf);   //同System.Text.Encoding.GetEncoding("GB2312").GetString(buf);中英文都可以解码。
// 转换成UTF8格式
System.Text.Encoding.UTF8.GetString(buf);               //同System.Text.UTF8Encoding.GetString(buf)
// 转换成Unicode格式
System.Text.Encoding.Unicode.GetString(buf);            //同System.Text.UnicodeEncoding.GetString(buf)

3、 C# Stream 与 byte[] 之间的转换
/// 将 Stream 转成 byte[]
public byte[] StreamToBytes(Stream stream)
{
    byte[] bytes = new byte[stream.Length];
    stream.Read(bytes, 0, bytes.Length);
    // 设置当前流的位置为流的开始
    stream.Seek(0, SeekOrigin.Begin);
    return bytes;
}
/// 将 byte[] 转成 Stream
public Stream BytesToStream(byte[] bytes)
{
    Stream stream = new MemoryStream(bytes);
    return stream;
}

4、Stream 和 文件之间的转换
将 Stream 写入文件
public void StreamToFile(Stream stream, string fileName)
{
    // 把 Stream 转换成 byte[]
    byte[] bytes = new byte[stream.Length];
    stream.Read(bytes, 0, bytes.Length);
    // 设置当前流的位置为流的开始
    stream.Seek(0, SeekOrigin.Begin);
    // 把 byte[] 写入文件
    FileStream fs = new FileStream(fileName, FileMode.Create);
    1.方式一
    BinaryWriter bw = new BinaryWriter(fs);
    bw.Write(bytes);
    bw.Close();
    2.方式二
    fs.Write(bytes, 0, bytes.Length);
    fs.Close();
}

5、从文件读取 Stream

public Stream FileToStream(string fileName)
{            
    // 打开文件
    FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
    // 读取文件的 byte[]
    byte[] bytes = new byte[fileStream.Length];
    fileStream.Read(bytes, 0, bytes.Length);
    fileStream.Close();
    // 把 byte[] 转换成 Stream
    Stream stream = new MemoryStream(bytes);
    return stream;
}




H、MemoryStream
和FileStream一样，MemoryStream和BufferedStream都派生自基类Stream，因此它们有很多共同的属性和方法，但是每一个类都有自己独特的用法。这两个类都是实现对内存进行数据读写的功能，而不是对持久性存储器进行读写。
MemoryStream类用于向内存而不是磁盘读写数据。MemoryStream封装以无符号字节数组形式存储的数据，该数组在创建MemoryStream对象时被初始化，或者该数组可创建为空数组。可在内存中直接访问这些封装的数据。内存流可降低应用程序中对临时缓冲区和临时文件的需要。下表列出了MemoryStream类的重要方法：
1、Read()：读取MemoryStream流对象，将值写入缓存区。
2、ReadByte()：从MemoryStream流中读取一个字节。
3、Write()：将值从缓存区写入MemoryStream流对象。
4、WriteByte()：从缓存区写入MemoytStream流对象一个字节。
Read方法使用的语法如下：
mmstream.Read(byte[] buffer, offset, count) 其中mmstream为MemoryStream类的一个流对象，3个参数中，buffer包含指定的字节数组，该数组中，从offset到(offset +count-1)之间的值由当前流中读取的字符替换。Offset是指Buffer中的字节偏移量，从此处开始读取。Count是指最多读取的字节数。Write()方法和Read()方法具有相同的参数类型。

MemoryStream类的使用实例：
using System;  
using System.IO;  
using System.Text;  
class program{  
    static void Main()  
    {  
        int count;  
        byte[] byteArray;  
        char[] charArray;  
        UnicodeEncoding uniEncoding = new UnicodeEncoding();  
        byte[] firstString = uniEncoding.GetBytes("努力学习");  
        byte[] secondString = uniEncoding.GetBytes("不做C#中的菜鸟");  
        using (MemoryStream memStream = new MemoryStream(100))  
        {  
            memStream.Write(firstString, 0, firstString.Length);  
            count = 0;  
            while(count<secondString.Length)  
            {  
                memStream.WriteByte(secondString[count++]);  
            }  
            Console.WriteLine("Capacity={0}, Length={1}, Position={2}\n", memStream.Capacity.ToString(), memStream.Length.ToString(), memStream.Position.ToString());  
            memStream.Seek(0, SeekOrigin.Begin);  
            byteArray = new byte[memStream.Length];  
            count = memStream.Read(byteArray, 0, 20);  
            while(count<memStream.Length)  
            {  
                byteArray[count++] = Convert.ToByte(memStream.ReadByte());  
            }  
            charArray = new char[uniEncoding.GetCharCount(byteArray,0,count)];  
            uniEncoding.GetDecoder().GetChars(byteArray, 0, count, charArray, 0);  
            Console.WriteLine(charArray);  
            Console.ReadKey();  
        }  
    }  
} 



J、安全性
0、常用算法
对称：DES、EAS
非对称：RSA

1、对称算法（DESCryptoServiceProvider）
（1）介绍
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
需要对加密和解密使用相同密钥的加密算法。由于其速度，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。
所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。

DESCryptoServiceProvider定义访问数据加密标准 (DES) 算法的加密服务提供程序 (CSP) 版本的包装对象。
（2）加密步骤
1）声明一个DESCryptoServiceProvider对象，并对其进行初始化设置（设置DESCryptoServiceProvider的密钥、初始化向量等）
2）声明一个Stream介质，用于存放加密数据
3）（通过Stream介质）再声明一个CryptoStream对象，对数据进行加密，并存放在Stream介质中
4）读取Stream介质中加密后的数据
（2.1）实例
public string Encrypt(string pToEncrypt, string sKey)
{
    //建立加密对象的密钥和偏移量 
    MemoryStream ms = new MemoryStream();//声明一个MemoryStream介质，用于存放加密数据
    DESCryptoServiceProvider des = new DESCryptoServiceProvider();//声明一个DESCryptoServiceProvider对象
    des.Key = ASCIIEncoding.ASCII.GetBytes(sKey);//设置密钥，原文使用ASCIIEncoding.ASCII方法的GetBytes方法，使得输入密码必须输入英文文本 
    des.IV = ASCIIEncoding.ASCII.GetBytes(sKey);//设置初始化向量，原文使用ASCIIEncoding.ASCII方法的GetBytes方法，使得输入密码必须输入英文文本     
    CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write);//声明一个CryptoStream对象，用于加密
    //或直接CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(ASCIIEncoding.ASCII.GetBytes(sKey), ASCIIEncoding.ASCII.GetBytes(sKey)), CryptoStreamMode.Write);

    byte[] inputByteArray = Encoding.GetEncoding("UTF-8").GetBytes(pToEncrypt);
    cs.Write(inputByteArray, 0, inputByteArray.Length);//对数据进行加密，并存放在MemoryStream中
    cs.FlushFinalBlock();

    StringBuilder ret = new StringBuilder();
    foreach (byte b in ms.ToArray())//读取Stream介质中加密后的数据
    {
        ret.AppendFormat("{0:X2}", b);
    }
    return ret.ToString();
}


（3）解密步骤
1）声明一个DESCryptoServiceProvider对象，并对其进行初始化设置（设置DESCryptoServiceProvider的密钥、初始化向量等）
2）声明一个Stream介质，用于存放解密数据
3）（通过Stream介质）再声明一个CryptoStream对象，对数据进行解密，并存放在Stream介质中
4）读取Stream介质中加密后的数据
（3.1）实例
public string Decrypt(string pToDecrypt, string sKey)
{
    MemoryStream ms = new MemoryStream();
    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
    des.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
    des.IV = ASCIIEncoding.ASCII.GetBytes(sKey);
    CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write);
    //或直接CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(ASCIIEncoding.ASCII.GetBytes(sKey), ASCIIEncoding.ASCII.GetBytes(sKey)), CryptoStreamMode.Write);
    byte[] inputByteArray = new byte[pToDecrypt.Length / 2];
    for (int x = 0; x < pToDecrypt.Length / 2; x++)
    {
        int i = (Convert.ToInt32(pToDecrypt.Substring(x * 2, 2), 16));
        inputByteArray[x] = (byte)i;
    }
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();

    return System.Text.Encoding.Default.GetString(ms.ToArray());
}

2、非对称加密
（1）介绍
    RSA公钥加密算法是1977年由Ron Rivest、Adi Shamirh和LenAdleman在（美国麻省理工学院）开发的。RSA取名来自开发他们三者的名字。RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
    在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然秘密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK。正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA 密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。
    非对称加密算法使用两把完全不同但又是完全匹配的一对密钥—>公钥和私钥。在使用非对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。加密明文时采用公钥加密，解密密文时使用私钥才能完成，而且发信方（加密者）知道收信方的公钥，只有收信方（解密者）才是唯一知道自己私钥的人。非对称加密算法的基本原理是，如果发信方想发送只有收信方才能解读的加密信息，发信方必须首先知道收信方的公钥，然后利用收信方的公钥来加密原文；收信方收到加密密文后，使用自己的私钥才能解密密文。显然，采用非对称加密算法，收发信双方在通信之前，收信方必须将自己早已随机生成的公钥送给发信方，而自己保留私钥。由于非对称算法拥有两个密钥，因而特别适用于分布式系统中的数据加密。广泛应用的非对称加密算法有RSA算法和美国国家标准局提出的DSA。以非对称加密算法为基础的加密技术应用非常广泛。

（2）应用场景
如果只是单方面采用非对称性加密算法，其实有两种方式，用于不同用处：
第一种是签名，使用私钥加密（唯一源头），公钥解密，用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改。但是不用来保证内容不被他人获得，即：
身份验证：私钥加密->公钥解密
目的：保证数据唯一来源，且未经修改

第二种是加密，使用公钥加密，私钥解密（唯一去处），用于向公钥所有者发布信息，这个信息可能被他人篡改，但是无法被他人获得。如果甲想给乙发一个安全的保密的数据，那么应该甲乙各自有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据。最后再发给乙，这样确保了内容即不会被读取，也不会被篡改，即：
加密：公钥加密->私钥解密
目的：加密数据

（3）密钥长度的选择
1.非对称加密算法中1024 bit密钥的强度相当于对称加密算法80bit密钥的强度。
2.密钥长度增长一倍，公钥操作所需时间增加约4倍，私钥操作所需时间增加约8倍，公私钥生成时间约增长16倍。
3.一次能加密的密文长度与密钥长度成正比，加密后的密文长度跟密钥长度相同(RSA加密内容的长度有限制，和密钥长度有关，这是由它的算法决定的)
  a、加密的明文长度不能超过RSA密钥的长度减去11byte，比如密钥长度是1024位的，1024位=1024bit=128byte，128-11=117byte，所以明文长度不能超过117byte，如果长度超过该值将会抛出异常。
  b、加密后密文的长度为密钥的长度，如密钥长度为1024bit(128Byte)，最后生成的密文固定为 1024bit(128Byte)。

（4）生成证书
makecert -r -pe -n "CN=RSAKey" -b 03/31/2005 -e 12/31/2012 -sky exchange -ss my

（5）步骤
第一步：根据上面的原理性介绍，我们需要生成公钥(发信方需要)和私钥(收信方需要)
//公钥在a.txt文件中，私钥在b.txt文件中.制造公钥和私钥的方法如下:
RSACryptoServiceProvider crypt = new RSACryptoServiceProvider();
string  publickey = crypt.ToXmlString(false);                       //公钥
string  privatekey = crypt.ToXmlString(true);                       //私钥
crypt.Clear();
第二步：发信方使用公钥对明文进行加密
string myText = "被加密数据";
byte[] bytes = new UTF8Encoding().GetBytes(myText);
RSACryptoServiceProvider crypt = new RSACryptoServiceProvider();
crypt.FromXmlString(publickey);
byte[] EncryptBytes = crypt.Encrypt(bytes, false);
string EncryptText = Server.UrlEncode(Convert.ToBase64String(EncryptBytes));
Response.Write("密文为：" + EncryptText);
第三步：收信方使用私钥对密文进行解密
byte[] bytes = Convert.FromBase64String(@Server.UrlDecode(EncryptText));
RSACryptoServiceProvider crypt = new RSACryptoServiceProvider();
crypt.FromXmlString(privatekey);
byte[] DecryptByte = crypt.Decrypt(bytes, false);
string DecryptText = new UTF8Encoding().GetString(DecryptByte);
Response.Write("明文为：" + DecryptText);

3、身份验证
用户身份认证的一般方式：
a.HTTP Basic authentication
HTTP Basic Authentication（HTTP 基本认证）是 HTTP 1.0 提出的一种认证机制。HTTP 基本认证的过程如下：
1）客户端发送 HTTP Request 给服务器
2）因为 Request 中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 Header "WWW-Authenticate" 中添加信息
3）客户端把用户名和密码用 BASE64 加密后，放在 Authorization Header 中发送给服务器， 认证成功
4）服务器将 Authorization Header 中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端
b.Cookies
向后台发送用户名和密码，在用户名和密码通过验证后，保存返回的Cookie作为用户已经登录的凭证，每次请求时附带这个Cookie
c.Signatures
用户拿到服务器给的私钥，在发送请求前，将整个请求使用私钥来加密，发送的将是一串加密信息，此方式只适用于API
d.One-Time Passwords
一次一密，每次登录时使用不同的密码，一般由服务端通过邮件将密码发给用户，这种登录方式比较繁琐
e.JSON Web Token
用户发送按照约定，向服务端发送Header、Payload和Signature，并包含认证信息(密码)，验证通过后服务端返回一个token，之后用户使用该token作为登录凭证，适合于移动端和api

Cookies将SessionId传给Session以获取服务端信息，用于存储客户端信息，Session用于存储服务端信息
jwt也用于存储服务端信息，类比Session，但数据是存在客户端上


f.基于 Session 的认证
基于 Session 的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到 Session 中，单体应用架构中，默认 Session 会存储在应用服务器中，并且将 Session ID 返回到客户端，存储在浏览器的 Cookie 中。
但是在分布式架构下，Session 存放于某个具体的应用服务器中自然就无法满足使用了，简单的可以通过 Session 复制或者 Session 粘制的方案来解决。在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将 Session 从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如 Memchached、Redis 等。这正是 David Borsos 建议的第二种方案，分布式 Session 方案。
g.Token
Token 和 Session ID 不同，并非只是一个 key。Token 一般会包含用户的相关信息，通过验证 Token 就可以完成身份校验。像 Twitter、微信、QQ、GitHub 等公有服务的 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。基于 Token 认证的一个典型流程如下：
1）用户输入登录信息（或者调用 Token 接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。
2）身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在 Session 或者数据库中。
3）用户将 Token 放在 HTTP 请求头中，发起相关 API 调用。
4）被调用的微服务，验证 Token 权限。
5）服务端返回相关资源和数据。
基于 Token 认证的好处如下：
1）服务端无状态：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有用户的相关信息。
2）性能较好，因为在验证 Token 时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。
3）支持移动设备。
4）支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。





摘要认证步骤：
（1）客户端请求（无认证）
GET /dir/index.html HTTP/1.0  
Host: localhost
（2）服务器响应（即质询Challenge）
无用户名、密码，服务端返回401无验证状态，并且返回WWW-Authenticate信息,包含了验证方式Digest，realm，qop，nonce，opaque的值。
其中：
Digest：认证方式；
realm：领域，领域参数是强制的，在所有的盘问中都必须有，它的目的是鉴别SIP消息中的机密，在SIP实际应用中，它通常设置为SIP代理服务器所负责的域名；
qop：保护的质量，这个参数规定服务器支持哪种保护方案，客户端可以从列表中选择一个。值 “auth”表示只进行身份查验， “auth-int”表示进行查验外，还有一些完整性保护。需要看更详细的描述，请参阅RFC2617；
nonce：为一串随机值，在下面的请求中会一直使用到，当过了存活期后服务端将刷新生成一个新的nonce值；
opaque：一个不透明的（不让外人知道其意义）数据字符串，在盘问中发送给用户。

HTTP/1.0 401 Unauthorized
Server: HTTPd/0.9
Date: Sun, 10 Apr 2005 20:26:47 GMT
WWW-Authenticate: Digest realm="testrealm@host.com",
                  qop="auth,auth-int",
                  nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                  opaque="5ccc069c403ebaf9f0171e9517f40e41"
（3）客户端请求（带认证）
带用户名、密码请求。(用户名 "Mufasa", 密码 "Circle Of Life")
（4）服务端响应


Forms认证步骤：
如无认证，跳转至登录页面
<system.web>
  <authentication mode="Forms">
    <forms loginUrl="~Login/Index" timeout="2880" />
  </authentication>
</system.web>

授权后，可访问[Autherize]
{
    var ticket = new FormsAuthenticationTicket(
        1,
        userid,
        DateTime.Now,
        DateTime.Now.AddMinutes(20),
        true,
        "role1,role2,role3",
        "/"
    );
 
    var cookie = new HttpCookie(FormsAuthentication.FormsCookieName, FormsAuthentication.Encrypt(ticket));
    cookie.HttpOnly = true;
    HttpContext.Response.Cookies.Add(cookie);
}

4、OAuth
OAuth是一个关于授权（Authorization）的开放网络标准，目前的版本是2.0版。注意是Authorization(授权)，而不是Authentication(认证)。用来做Authentication(认证)的标准叫做openid connect。OAuth认证服务器本质上就是一个代理“授权”服务器，将用户名、密码或其他转换为一种不可逆的授权凭证(access_token)给客户端。OAuth2.0的核心既是取得access_token，四种授权模式殊途同归，最终都是要取得access_token，只是路径不同，参数不同，具体可以参考RFC。
¤为什么OAuth不是Authentication？
在用户访问一个应用程序的上下文环境中认证会告诉应用程序当前用户是谁以及其是否存在。一个完整的认证协议可能还会告诉你一些关于此用户的相关属性，比如唯一标识符、电子邮件地址以及应用程序说“早安”时所需要的内容。认证是关于应用程序中存在的用户，而互联网规模的认证协议需要能够跨网络和安全边界来执行此操作。
然而，OAuth没有告诉应用程序上述任何信息。OAuth对用户没有任何说明，也没有说明如何证明他们的存在，即使他们就在那里。对于OAuth的Client而言，它请求一个token，得到一个token，并用这个token访问一些API。但它不知道是谁授权的应用程序，以及甚至还有一个用户在那里。

认证（Authentication）：就是让用户登录，并且在接下来的一段时间内让用户访问网站时可以使用其账户，而不需要再次登录的机制。
授权（Authorization）：指的是规定并允许用户使用自己的权限，例如发布帖子、管理站点等。
AAA：认证(Authentication)：验证用户的身份与可使用的网络服务；授权(Authorization)：依据认证结果开放网络服务给用户；计帐(Accounting)：记录用户对各种网络服务的用量，并提供给计费系统。整个系统在网络管理与安全问题中十分有效。
区别：
·认证（Authentication）：身份认证，对身份当事人进行身份的确定过程。即证明“我就是我”。
·授权（Authorization）：授权，当身份通过认证后，可以对其授权，以访问目标资源。即“我是否持有对XX的所有权”。

（1）常见应用场景：
·单点登录SSO
·第三方登录授权

（2）OAuth2的改变
OAuth2对比OAuth1，主要改变有下面几点：
  1. 取消繁琐的签名，全部改用HTTPS。
  2. ATOK从原来的永久令牌变为临时令牌，增加RefreshToken
  3. 取消获取RequestToken的步骤
  4. 提供了多种场景的授权流程
̑HTTPS
  OAuth原有的签名算法实在是太繁琐了，吓跑了不少开发者。对于服务提供方，也很不好实现，特别是单次签名的实现，由于服务提供方要确保每次由客户端生成的随机码不被重复利用，必须存储每次请求发来的随机码，无论是对存储还是校验都是一个难题。通常的做法是，存储一段时间的随机码，这个时间需比RequestToken的过期时间要长。这样即使到时还有重放攻击，RequestToken也已经失效。
  OAuth2取消了签名，改用HTTPS来加密，确保通信内容不被第三方窃取。这个改变毫无疑问是降低了门槛，授权的流程被简化了。虽有少量人有异议，但OAuth2最大的异议是临时的ATOK。
̑ATOK与RefreshToken
  由于第三方应用往往不重视ATOK的安全性，开发者为图方便经常把ATOK从后端发给前端页面或者存在cookie中。由于OAuth1中ATOK几乎是永久性的，即使发现ATOK被盗用，也只能让用户取消授权，这可能会造成一些其他的问题。OAuth2将ATOK改为临时令牌，当ATOK过期后，需要使用RefreshToken重新获取新的ATOK，让开发者郁闷的是，RefreshToken也不是永久性的，不同的服务提供方有不同的过期时间，相同的是，过期时间都不会太长，顶多也就几个月。
  这个改变对很多第三方应用是个坑爹的改变，原本他们几乎都是拿ATOK作为OpenID来使用的（所以才有了各种ATOK被盗用的隐患），而到了OAuth2，ATOK已经不能唯一标识一个用户了，他们要多做很多的东西才能维持用户的身份，在使用ATOK访问用户资源时，步骤也是异常繁琐。
  虽然临时ATOK这个改变很合理，但对开发者很不友好，今后会不会继续改变，可以拭目以待。我个人觉得，这个问题其实是另外一个问题，那就是开发者对用户帐号信息的安全意识太单薄，后面讲OAuth的问题时再详细讨论。
̑授权流程
  OAuth1流程比较复杂，尽管规范里有对多种场景的授权流程进行不同的建议，但很多应用和开放平台最终都使用了同一种授权流程，结果产生了安全隐患（例如上面重定向地址的问题吗）。OAuth2描述了四种授权场景，为这些场景下的授权流程提供指导。我只简单说些要点和差异，详细的说明还是看官方文档和各开放平台的文档稳妥些。


（3）证书
(1)生成证书文件和私钥
makecert -a sha1  -sky exchange -n "CN=发行者名称" -b 10/18/2015 -e 01/01/2018 -sv 你的名称.pvk 你的名称.cer
例如：makecert -a sha1 -sky exchange -n "CN=idefav" -b 10/18/2015 -e 01/01/2018 -sv test.pvk test.cer 
弹出窗口，输入密码后，目录里面就生成了cer和pvk文件。

(2)利用证书.cer创建发行者证书.spc
cert2spc 你的名称.cer 你的名称.spc

(3)从.pvk和.spc格式转换成.pfx格式
pvk2pfx -pvk 你的名称.pvk -pi pvk密码 -spc 你的名称.spc
注意：pvk密码就是上次弹出输入的密码
输入命令回车，弹出证书导出向导
导出私钥、个人信息交换/导出所有扩展属性

（4）原理
 ------                                    ----------------
|      | --- (A) Authorization Request --> |Resource Owner|         //客户端转向认证服务器的登录验证页面（如APP转向“某宝或QQ”的登录页面），要求
|      | <-- (B) Authorization Grant   --- |              |         //验证用户身份合法性，以授权客户端
|      |                                   ----------------
|      |
|      |                                   ----------------------
|Client| --- (C) Authorization Grant   --> |Authorization Server|   //服务器
|      | <-- (D) Access Token          --- |                    |
|      |                                   ----------------------
|      |                                   -----------------
|      | --- (E) Access Token          --> |Resource Server|        //最终想要访问的资源服务器
|      | <-- (F) Protected Resource    --- |               |
|      |                                   -----------------
 ------ 

认证（Authentication）
·认证通过后，获取授权码
（A）用户打开客户端以后，客户端要求用户给予授权。
（B）用户同意给予客户端授权。
授权（Authorization）
·用授权码换取令牌Token
（C）客户端使用上一步获的授权，向认证服务器申请令牌。
（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
获取资源（Resource）
·用令牌Token访问资源
（E）客户端使用令牌，向资源服务器申请获取资源。
（F）资源服务器确认令牌无误，同意向客户端开放资源。

（5）授权方式：
认证：通过一定机制（如用户名+密码）换取“授权码”                               授权：通过“授权码”换取“token”
四种授权模式：
1）授权码（认证码）模式 (Authorization Code Credential)
·                               认证：response_type=code
                                 授权：grant_type=authorization_code            // 验证username password，异地输入 + 异地验证（从客户端角度看）
通过将用户引导至认证服务器页面进行认证，认证服务器将授权返回给事先该客户端申请好的指定url。客户端附上该url后，再向"授权服务器"换取令牌。
2）简化（隐形）模式 (Implicit Credential)
·                               授权：response_type=token                      // 验证username password，异地输入 + 异地验证（从客户端角度看）
不作认证，直接在浏览器中向授权服务器申请“令牌”，跳过了"换取授权码"这个步骤，因此得名。（与授权码模式相比，减少了授权码这一步）
3）密码模式 (Resource Owner Password Credential)
·                               认证 + 授权：grant_type=password               // 验证username password，本地输入 + 异地验证（从客户端角度看）
用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"授权服务器"索要令牌。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。（与简化模式相比，减少了跳转到认证页面这一步）
4）客户端模式 (Client Credential)
·                               授权：grant_type=client_credential             // 不验证
指客户端通过证书以自己的名义，而不是用户的名义，直接向"授权服务器"索要授权。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。

获取令牌Token时，要先验证Client的身份（即ClientId以及ClientSecret）


（6）授权码模式
a.基本组成
(1) Third-party application：第三方应用程序，本文中又称“客户端”（client）。
(2) HTTP service：HTTP服务提供商，本文中简称“服务提供商”即上一节例子中的Google。
(3) Resource Owner：资源所者，本文中又称“用户”（user）。
(4) User Agent：用户代理，本文中就是浏览器。
(5) Authoization server：授权服务器，即服务提供商专门用来授权的服务器。
(6) Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。
b.流程图
----------------
|Resource Owner|
----------------
        ^
        |
       (B)
----------------
|              |                                               ----------------------
|              |-----(A)--Client Identifier & Redirection URI->|                    |
|    User      |                                               |   Authorization    |
|    Agent     |-----(B)-------------------User authenticates->|                    |
|              |                                               |       Server       |
|              |-----(C)<------------------Authorization Code------------------------
----------------                                                     ^      |
    ↑    │                                                         |      |
   (A)   (C)                                                         |      |
    │    │                                                         |      |
    │    ↓                                                         |      |
----------------                                                     |      |
|              |                                                     |      |
|              |---(D)--Authorization Code & Redirection URI    ------      ↓
|   Client     |
|              |---(E)--Access Token (w/ Optional Refresh Token)-------------
|              |
----------------

c.流程（Authorization code模式）
（A）用户访问客户端，后者将前者导向认证服务器。
（B）用户选择是否给予客户端授权。
（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码（Code）。
（D）客户端收到授权码，附上之前的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。
（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token），即使用code换取token。
第一轮：
A、B步骤中，用户点击登录，客户端会通过以下链接跳转至认证服务器的登录页面，一般情况下，认证服务器会弹出一个登录页面，要求用户输入用户名、密码。
包含以下参数：（请求）
◾response_type（必填）：表示授权类型，必选项，授权码模式为"code"，简化模式为"token"
◾client_id（必填）：表示客户端的ID，必选项
◾state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值，防止CSRF（跨站请求伪造）。
◾redirect_uri（必填）：表示重定向URI，可选，验证结果返回此页面
◾scope（可选）：表示申请的权限范围，可选项
eg.
GET /authorize?response_type=code  &  client_id=s6BhdRkqt3  &  state=xyz  &  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2F
HTTP/1.1
Host: server.example.com

C步骤中，认证服务器验证了用户名、密码，在登录成功后，认证服务器会把回应重定向至客户端事先指定的redirect_uri处，而非请求时的uri。
包含以下参数：（响应）
◾code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端“只能使用该码一次”，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。
◾state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。
eg.
HTTP/1.1 302 Found
Location: https://client.example.com/?  code=SplxlOBeZQQYbYS6WxSbIA  &  state=xyz

第二轮：
D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：（请求）
◾grant_type：表示使用的授权模式，必选项，授权码模式为"authorization_code"，客户端模式为"client_credentials"，用户名密码模式为"password"，简化模式"token"。
◾client_id：表示客户端ID，必选项。
◾client_secret：由Authorization Server提供，是Client与Authorization Server之间，Client与Authorization Server有责任保护好client_secret不被泄露。
◾code：表示上一步获得的授权码，必选项。
◾redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。
eg.
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code  &  client_id=s6BhdRkqt3  &  client_secret=t7CieSlru4  &  code=SplxlOBeZQQYbYS6WxSbIA  &  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2F

E步骤中，认证服务器发送的HTTP回复，包含以下参数：（响应）
◾access_token（必填）：表示访问令牌，必选项（对认证服务器来讲，下同）。
◾token_type（必填）：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。
◾expires_in（必填）：表示过期时间，单位为“秒”。如果省略该参数，必须其他方式设置过期时间。
◾refresh_token（可选）：表示更新令牌，用来获取下一次的访问令牌，可选项。
◾scope（可选）：表示权限范围，如果与客户端申请的范围一致，此项可省略。
另：微信会多返回一个openid，openid是公众号的普通用户的一个唯一的标识，只针对当前的公众号有效，即相当于业务线
eg.
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。

c.其他
◆为什么要提交两次，先申请authorization code，再换取token？（即authorization code与Implicit的区别）
预备内容
    首先，授权码有有效期，相当于用户授予的一个临时性授权，否则每用一次用户都要做一次登录操作进行授权。
    其次，OAuth 2.0基本都是分“认证”与“授权”两个过程，在授权码模式中，获取授权码是属于第一步的“认证”过程，获得认证后进行第二步获取“授权”。
原因解析
-----------------------------------------------------------------------------------------------------------------------------
协议设计中，为什么要使用authorization_code来交换access_token？这是读者容易想到的一个问题。也就是说，在协议的第3步，为什么不直接将access_token通过重定向方式返回给Client呢？比如:

HTTP/1.1 302
Location:
https://www.facebook.com/?access_token=ya29.AHES6ZSXVKYTW2VAGZtnMjD&token_type=Bearer&expires_in=3600

如果直接返回access_token，协议将变得更加简洁，而且少一次Client与Authorization Server之间的交互，性能也更优。那为何不这么设计呢？协议文档[1]中并没有给出这样设计的理由，但也不难分析：

(1) 浏览器的redirect_uri是一个不安全信道，此方式不适合于传递敏感数据（如access_token）。因为uri可能通过HTTP referrer被传递给其它恶意站点，也可能存在于浏览器cacher或log文件中，这就给攻击者盗取access_token带来了很多机会。另外，此协议也不应该假设Resource Own用户代理的行为是可信赖的，因为Resource Own的浏览器可能早已被攻击者植入了跨站脚本用来监听access_token。因此，access_token通过Resource Own的用户代理传递给Client，会显著扩大access_token被泄露的风险。
    但authorization_code可以通过redirect_uri方式来传递，是因为authorization_code并不像access_token一样敏感。即使authorization_code被泄露，攻击者也无法直接拿到access_token，因为拿authorization_code去交换access_token是需要验证Client的真实身份。也就是说，除了Client之外，其他人拿authorization_code是没有用的。 此外，access_token应该只颁发给Client使用，其他任何主体（包括Resource Own）都不应该获取access_token。协议的设计应能保证Client是唯一有能力获取access_token的主体。引入authorization_code之后，便可以保证Client是access_token的唯一持有人。当然，Client也是唯一的有义务需要保护access_token不被泄露。
    简单来说，就是如果直接返回token，如果reponse网站遭到劫持，token就容易造成泄露。于是先返回authorization_code，再通过提交authorization_code+client_secret的方式才能获取token。
    好比员工们（Client）要维权，即要得到Token：
    第一步：
      员工们（Client）向工会（Authorization Server）发起维权。但由于员工太多，工会不能一一给予答复，于是工会（Authorization Server）事先约定只向一位员工代表（redirect_uri）授予了申请维权的权力。----即申请授权码。
    第二步：
      员工代表（redirect_uri）向工会（Authorization Server）提出维权。工会（Authorization Server）向员工代表（redirect_uri）反馈维权结果。----即换取Token。

(2) 引入authorization_code还会带来如下的好处。由于协议需要验证Client的身份，如果不引入authorization_code，这个Client的身份认证只能通过第1步的redirect_uri来传递。同样由于redirect_uri是一个不安全信道，这就额外要求Client必须使用数字签名技术来进行身份认证，而不能用简单的密码或口令认证方式。引入authorization_code之后，Authorization Server可以直接对Client进行身份认证（见步骤4和5），而且可以支持任意的Client认证方式（比如，简单地直接将Client端密钥发送给Authorization Server）。

首先返回授权码是异步的，中间有一个验证用户账号信息的过程，不能当时就返回验证结果。其次异步返回的redirect_uri是不可信的，它对用户来说是可见的，如果直接返回access_token这种敏感信息很容易被泄露。但如果返回authorization_code，此信息即使泄露也无法直接拿到access_token。拿到authorization_code后，在服务器端再用它换取access_token。即access_token返回给“客户端前台”是不安全的，返回给“客户端后台”是安全的。

在我们理解了上述安全性考虑之后，读者也许会有豁然开朗的感觉，懂得了引入authorization_code的妙处。那么，是不是一定要引入authorization_code才能解决这些安全问题呢？当然不是。笔者将会在另一篇博文给出一个直接返回access_token的扩展授权类型解决方案，它在满足相同安全性的条件下，使协议更简洁，交互次数更少。
-----------------------------------------------------------------------------------------------------------------------------

◆重定向地址
    为了防止有攻击者伪造重定向地址骗取用户授权，服务提供方应对授权时的重定向地址进行验证。所以注册时，第三方应提供重定向地址。服务提供方可以直接对重定向地址进行等值判断，但这样的话就没办法让第三方在授权过程中传递状态，只能借助Cookie/Session之类的方式了。服务提供方也可以判断重定向地址是否同一个域，这样的话应用方就可以在URI里传递少量状态。对于一些没有服务端的第三方Web应用，由于代码是公开的，将应用的帐号密码存在页面里并不合适。OAuth则建议不使用重定向地址，让用户在授权后，把授权码人工输入到应用中进行下一步。记得有段时间FaWave也是这么添加新帐号的。

◆OpenID与OAuth的区别
OpenID是Authentication，OAuth是Authorization
前者是网站对用户进行认证，让网站知道“你是你所声称的URL的属主”；后者其实并不包括认证，只不过“只有认证成功的人才能进行授权”，结果类似于“认证+授权”了。OAuth相当于：A网站给B网站一个令牌，然后告诉B网站说根据这个令牌你可以获取到某用户在A网站上允许你访问的所有信息。如果A网站需要用B网站的用户系统进行登录（学名好像叫federated login），它可以选择OpenID认证，然后通过attribute exchange获取用户的昵称或其他通过OpenID暴露出来的用户属性，或者选择OAuth认证，获取到token后再用token获取用户昵称或其他允许被访问的信息关于OAuth的授权，不能说是滥用，是OAuth Service Provider对OAuth的权限没有细分。好比我只需要用户的昵称性别，你却把修改昵称性别的权限也授权给我了（虽然我不一定会去用）。这个错在OAuth Service Provider。

5、Json Web Token
（1）介绍
Json Web Token本质上只不过是对一个带签名的JSON对象的封装，因为利用它包装过的值可以认为是可信的。它由三部分组成，头部（Header）、载荷（Payload）与签名（Signatures）。可应用于SSO。
（2）原理
a.头部
{
  "typ": "JWT",
  "alg": "HS256"
}
将该JSON对象进行Base64编码，假设为hhhh
b.载荷
这里面的前6个字段都是由JWT的标准所定义的。

sub: 该JWT所面向的用户
iss: 该JWT的签发者
iat(issued at): 在什么时候签发的token
exp(expires): token什么时候过期
nbf(not before)：token在此时间之前不能被接收处理
jti：JWT ID为web token提供唯一标识

{
    //Issuer
    "iss": "John Wu JWT",           //该JWT的签发者
    //Subject
    "sub": "jrocket@example.com",   //该JWT所面向的用户
    //Audience
    "aud": "www.example.com",       //接收该JWT的一方
    //Expireation Time
    "exp": 1441594722,              //过期时间，这里是一个Unix时间戳
    //Not Before
    "nbf": 1440594722,              //在此时间之前是不可用的
    //Issued At
    "iat": 1441593502,              //(issued at): 签发时间
    //JWT ID
    "jti": "37c107e4609ddbcc9c096ea5ee76c667"                       //唯一身份标识，主要用来作为一次性token，从而回避重放攻击
    "from_user": "B",               //自定义内容一
    "target_user": "A"              //自定义内容二
}
将该JSON对象进行Base64编码，假设为llll
c.签名
将上面的两部分编码后的字符串都用“.”连接在一起（头部在前）通过密钥进行加密（此处加密是为了生成签名），得到加密后的内容ssss，即签名。

d.拼接
通过“.”拼接以上三部分，得到hhhh.llll.ssss

（3）代码
依赖包：Install-Package JWT

        string secretKey = "GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk";

        public static string encode()
        {
            //Creating Tokens
            var payload = new Dictionary<string, dynamic>()
                          {
                              { "iss", "irving" },
                              { "exp", Math.Round((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds + 50)},
                              { "name", "irving" },
                              { "age", 25 },
                              { "birthday", "1991-04-18" }
                          };
            string token = JWT.JsonWebToken.Encode(payload, secretKey, JWT.JwtHashAlgorithm.HS256);
        }

        public static void decode(string token)
        {
            try
            {
                //Verifying and Decoding Tokens
                string jsonPayload = JWT.JsonWebToken.Decode(token, secretKey);
                var dictPayload = JWT.JsonWebToken.DecodeToObject<IDictionary<string, object>>(token, secretKey);
            }
            catch (JWT.SignatureVerificationException ex)
            {
                return "Invalid token!";
            }
        }


（4）注意事项
载荷中的内容不应该敏感内容，因为它只是通过base64进行了处理，很容易被反解出来。所以载荷中的内容应该是一个或一系列标识，如果它或它们能与签名匹配得上，就可认为是可被信任的。

（5）目的与应用场景
目的：通过此技术可以辨别，从客户端发来的内容是否为可信的（之前由服务端发出）。
¤备注：签名的生成如果是非对称的，这种方式只能由“服务端”来判断内容的可信度；否则，如果为对称的，“服务端”、“客户端”双方都能够对签名进行验证。
场景：可被用于单点登录。


6、海尔案例
总结一下海尔的加解密方式，很有借鉴价值：

加密方式：
第一步：生成签名，MD5(实体参数序列化+盐值)。可信
第二步：整体加密，非对称加密。非明文

解密方式：
第一步：整体解密
第二步：验证签名




K、消息队列MSMQ
0、前言
利用 MSMQ（Microsoft Message Queue），应用程序开发人员可以通过发送和接收消息方便地与应用程序进行快速可靠的通信。消息处理为您提供了有保障的消息传递和执行许多业务处理的可靠的防故障方法。
MSMQ与XML Web Services和.Net Remoting一样，是一种分布式开发技术。但是在使用XML Web Services或.Net Remoting组件时，Client端需要和Server端实时交换信息，Server需要保持联机。MSMQ则可以在Server离线的情况下工作，将Message临时保存在Client端的消息队列中，以后联机时再发送到Server端处理。
显然，MSMQ不适合于Client需要Server端及时响应的这种情况，MSMQ以异步的方式和Server端交互，不用担心等待Server端的长时间处理过程。
虽然XML Web Services和.Net Remoting都提供了[OneWay]属性来处理异步调用，用来解决Server端长方法调用长时间阻碍Client端。但是不能解决大量Client负载的问题，此时Server接受的请求快于处理请求。
一般情况下，[OneWay]属性不用于专门的消息服务中。
1、基本术语和概念（Basic terms and concepts）
“消息”是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。
消息被发送到队列中。“消息队列”是在消息的传输过程中保存消息的容器。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。
“消息队列”是 Microsoft 的消息处理技术，它在任何安装了 Microsoft Windows 的计算机组合中，为任何应用程序提供消息处理和消息队列功能，无论这些计算机是否在同一个网络上或者是否同时联机。
“消息队列网络”是能够相互间来回发送消息的任何一组计算机。网络中的不同计算机在确保消息顺利处理的过程中扮演不同的角色。它们中有些提供路由信息以确定如何发送消息，有些保存整个网络的重要信息，而有些只是发送和接收消息。
“消息队列”安装期间，管理员确定哪些服务器可以互相通信，并设置特定服务器的特殊角色。构成此“消息队列”网络的计算机称为“站点”，它们之间通过“站点链接”相互连接。每个站点链接都有一个关联的“开销”，它由管理员确定，指示了经过此站点链接传递消息的频率。
“消息队列”管理员还在网络中设置一台或多台作为“路由服务器”的计算机。路由服务器查看各站点链接的开销，确定经过多个站点传递消息的最快和最有效的方法，以此决定如何传递消息。
2、队列类型（Queue Type）
有两种主要的队列类型：由您或网络中的其他用户创建的队列和系统队列。
用户创建的队列可能是以下任何一种队列： 
“公共队列”在整个“消息队列”网络中复制，并且有可能由网络连接的所有站点访问。 
“专用队列”不在整个网络中发布。相反，它们仅在所驻留的本地计算机上可用。专用队列只能由知道队列的完整路径名或标签的应用程序访问。 
“管理队列”包含确认在给定“消息队列”网络中发送的消息回执的消息。指定希望 MessageQueue 组件使用的管理队列（如果有的话）。 
“响应队列”包含目标应用程序接收到消息时返回给发送应用程序的响应消息。指定希望 MessageQueue 组件使用的响应队列（如果有的话）。 
系统生成的队列一般分为以下几类： 
“日记队列”可选地存储发送消息的副本和从队列中移除的消息副本。每个“消息队列”客户端上的单个日记队列存储从该计算机发送的消息副本。在服务器上为每个队列创建了一个单独的日记队列。此日记跟踪从该队列中移除的消息。 
“死信队列”存储无法传递或已过期的消息的副本。如果过期或无法传递的消息是事务性消息，则被存储在一种特殊的死信队列中，称为“事务性死信队列”。死信存储在过期消息所在的计算机上。有关超时期限和过期消息的更多信息，请参见默认消息属性。 
“报告队列”包含指示消息到达目标所经过的路由的消息，还可以包含测试消息。每台计算机上只能有一个报告队列。 
“专用系统队列”是一系列存储系统执行消息处理操作所需的管理和通知消息的专用队列。 
在应用程序中进行的大多数工作都涉及访问公共队列及其消息。但是，根据应用程序的日记记录、确认和其他特殊处理需要，在日常操作中很可能要使用几种不同的系统队列。
3、同步和异步通信（Synchronous VS. Asynchronous Communication）
队列通信天生就是异步的，因为将消息发送到队列和从队列中接收消息是在不同的进程中完成的。另外，可以异步执行接收操作，因为要接收消息的人可以对任何给定的队列调用 BeginReceive 方法，然后立即继续其他任务而不用等待答复。这与人们所了解的“同步通信”截然不同。
在同步通信中，请求的发送方在执行其他任务前，必须等待来自预定接收方的响应。发送方等待的时间完全取决于接收方处理请求和发送响应所用的时间。
4、同消息队列交互（Interacting with Message Queues）
消息处理和消息为基于服务器的应用程序组件之间的进程间通信提供了强大灵活的机制。同组件间的直接调用相比，它们具有若干优点，其中包括： 
稳定性 — 组件失败对消息的影响程度远远小于组件间的直接调用，因为消息存储在队列中并一直留在那里，直到被适当地处理。消息处理同事务处理相似，因为消息处理是有保证的。 
消息优先级 — 更紧急或更重要的消息可在相对不重要的消息之前接收，因此可以为关键的应用程序保证足够的响应时间。 
脱机能力 — 发送消息时，它们可被发送到临时队列中并一直留在那里，直到被成功地传递。当因任何原因对所需队列的访问不可用时，用户可以继续执行操作。同时，其他操作可以继续进行，如同消息已经得到了处理一样，这是因为网络连接恢复时消息传递是有保证的。 
事务性消息处理 — 将多个相关消息耦合为单个事务，确保消息按顺序传递、只传递一次并且可以从它们的目标队列中被成功地检索。如果出现任何错误，将取消整个事务。 
安全性 — MessageQueue 组件基于的消息队列技术使用 Windows 安全来保护访问控制，提供审核，并对组件发送和接收的消息进行加密和验证。 

5、例
（1）先安装Message Queuing Services
通过Control Panel，“Add/Remove Programs” – “Add/Remove Windows Components”步骤安装MSMQ。
MSMQ可以安装为工作组模式或域模式。如果安装程序没有找到一台运行提供目录服务的消息队列的服务器，则只可以安装为工作组模式，此计算机上的“消息队列”只支持创建专用队列和创建与其他运行“消息队列”的计算机的直接连接。
（2）配置MSMQ
打开Computer Management – Message Queuing，在Private Queues下创建MSMQDemo队列
（3）编写代码－简单演示MSMQ对象
MessageQueue 类是“消息队列”周围的包装。MessageQueue 类提供对“消息队列”队列的引用。可以在 MessageQueue 构造方法中指定一个连接到现有资源的路径，或者可在服务器上创建新队列。在调用 Send、Peek 或 Receive 之前，必须将 MessageQueue 类的新实例与某个现有队列关联。
MessageQueue 支持两种类型的消息检索：同步和异步。同步的 Peek 和 Receive 方法使进程线程用指定的间隔时间等待新消息到达队列。异步的 BeginPeek 和 BeginReceive 方法允许主应用程序任务在消息到达队列之前，在单独的线程中继续执行。这些方法通过使用回调对象和状态对象进行工作，以便在线程之间进行信息通讯。
// Send Message
private void btnSendMessage_Click(object sender, System.EventArgs e)
{
       // Open queue
       System.Messaging.MessageQueue queue = new System.Messaging.MessageQueue(".\\Private$\\MSMQDemo");
       // Create message
       System.Messaging.Message message = new System.Messaging.Message();
       message.Body = txtMessage.Text.Trim();
       message.Formatter = new System.Messaging.XmlMessageFormatter(new Type[] {typeof(string)});
       // Put message into queue
       queue.Send(message);
}

// Receive Message
private void btnReceiveMessage_Click(object sender, System.EventArgs e)
{
       // Open queue
       System.Messaging.MessageQueue queue = new System.Messaging.MessageQueue(".\\Private$\\MSMQDemo");
       // Receive message, 同步的Receive方法阻塞当前执行线程，直到一个message可以得到 
       System.Messaging.Message message = queue.Receive(); 
       message.Formatter = new System.Messaging.XmlMessageFormatter(new Type[] {typeof(string)});
       txtReceiveMessage.Text = message.Body.ToString();
}

其中队列的格式可以为以下形式：
1）
FormatName:direct=tcp:127.0.0.1:8000\private$\queuename
2）
.\private$\globalprocess_6
3）
FormatName:direct=os:machinename\private$\queuename


L、Socket
1.概述
    Windows中的很多东西都是从Unix领域借鉴过来的，Socket也是一样。在Unix中，socket代表了一种文件描述符（在Unix中一切都是以文件为单位），而这里这个描述符则是用于描述网络访问的。什么意思呢？就是程序员可以通过socket来发送和接收网络上的数据。你也可以理解成是一个API。有了它，你就不用直接去操作网卡了，而是通过这个接口，这样就省了很多复杂的操作。
    在C#中，MS为我们提供了 System.Net.Sockets 命名空间，里面包含了Socket类。
2.步骤
    a. 建立一个套接字
    b. 绑定本机的IP和端口
    c. 如果是TCP，因为是面向连接的，所以要利用Listen()方法来监听网络上是否有人给自己发东西；如果是UDP，因为是无连接的，所以来者不拒。
    d. TCP情况下，如果监听到一个连接，就可以使用accept来接收这个连接，然后就可以利用Send/Receive来执行操作了。而UDP，则不需要accept， 直接使用SendTo/ReceiveFrom来执行操作。（看清楚哦，和TCP的执行方法有区别，因为UDP不需要建立连接，所以在发送前并不知道对方的IP和端口，因此需要指定一个发送的节点才能进行正常的发送和接收）
    e. 如果你不想继续发送和接收了，就不要浪费资源了。能close的就close吧。
（1）TCP
◆TCPServer
1）//声明本机为服务器端Socket
Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
2）//绑定并监听
IPEndPoint ipep = new IPEndPoint(IPAddress.Any, 8888);                                              //定义一网络端点
serverSocket.Bind(ipep);                                                                            //绑定
serverSocket.Listen(10);                                                                            //后台监听是否有客户端进行连接，监听客户端最大个数为10
3）//监听客户端的连接请求：等待返回一个发出请求的客户端Socket，此处会阻塞线程
Socket clientSocket = serverSocket.Accept();
4）//发送：此处会触发客户端的Receive()方法
byte[] data = Encoding.ASCII.GetBytes("welcome to this server!");                                   //用于缓存客户端所发送的信息，通过socket传递的信息必须为字节数组
clientSocket.Send(data, data.Length, SocketFlags.None);
5）//接收：等待接收客户端Socket，此处会阻塞线程
int recv = clientSocket.Receive(data);
6）//关闭Socket
clientSocket.Close();
serverSocket.Close();

◆TCPClient
1）//声明本机为客户端Socket
Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
2）//连接服务器
IPEndPoint ipep = new IPEndPoint(IPAddress.Parse("*.*.*.*"), 8888);
clientSocket.Connect(ipep);                                                                         //此处会触发服务器端的Accept()方法
3）//发送：此处会触发服务器端的Receive()方法
clientSocket.Send(Encoding.ASCII.GetBytes("this is client."));
4）//接收：等待接收服务器端Socket，此处会阻塞线程
byte[] data = new byte[1024];
int recv = clientSocket.Receive(data);
string stringdata = Encoding.ASCII.GetString(data, 0, recv);
5）//关闭Socket
clientSocket.Close();

（2）UDP（与TCP的区别是，UDP无连接动作）
◆UDPServer（与UDPClient的区别在于Bind()）
1）//声明服务器端Socket
Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Udp);
2）//绑定此服务器端Socket
IPEndPoint ipep = new IPEndPoint(IPAddress.Any, 9999);                                              //定义一网络端点
serverSocket.Bind(ipep);                                                                            //直接绑定，不需要监听
3）//接收：等待接收客户端Socket，此处会阻塞线程
byte[] data = new byte[1024];
IPEndPoint sender = new IPEndPoint(IPAddress.Any, 9999);
int recv = serverSocket.ReceiveFrom(data, ref sender);                                              //返回的IP会写入sender中
//Console.WriteLine("Message received from : {0}", sender.ToString());
//Console.WriteLine(Encoding.ASCII.GetChars(data, 0, recv));
4）//发送：此处会触发客户端的ReceiveFrom()方法
string welcome = "welcome to this server!";
data = Encoding.ASCII.GetBytes(welcome);
/***********广播***********
由于Tcp是有连接的，所以不能用来发送广播消息。发送广播消息，必须用到Udp，Udp可以不用建立连接而发送消息。广播消息的目的IP地址是一种特殊IP地址，称为广播地址。广播地址由IP地址网络前缀加上全1主机后缀组成，如：192.168.1.255是192.169.1.0这个网络的广播地址;130.168.255.255是130.168.0.0这个网络的广播地址。向全部为1的IP地址（255.255.255.255）发送消息的话，那么理论上全世界所有的联网的计算机都能收得到了。但实际上不是这样的，一般路由器上设置抛弃这样的包，只在本地网内广播，所以效果和向本地网的广播地址发送消息是一样的。
C#中发送广播消息的过程如下，注意要调用SetSockOption函数，不然要抛出异常：
serverSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);
IPEndPoint ipep1 = new IPEndPoint(IPAddress.Broadcast, 9999);
IPEndPoint ipep2 = new IPEndPoint(IPAddress.Parse("192.168.1.255"), 9999);
**************************/
serverSocket.SendTo(data, data.Length, SocketFlags.None, sender);
5）//关闭Socket
serverSocket.Close();

◆UDPClient（与UDPServer的区别在于Bind()）
1）//声明本机为客户端Socket
Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Udp);
2）//发送
IPEndPoint sender = new IPEndPoint(IPAddress.Parse("*.*.*.*"), 9999);
byte[] data = Encoding.ASCII.GetBytes("Hello, are you there?");
clientSocket.SendTo(data, data.Length, SocketFlags.None, sender);                                   //将数据发送到指定的终结点
3）//接收
data = new byte[1024];
int recv = clientSocket.ReceiveFrom(data, ref sender);//接受来自服务器的数据，阻塞
Console.WriteLine("Message received from{0}:", sender.ToString());
Console.WriteLine(Encoding.ASCII.GetString(data, 0, recv));
4）//关闭Socket
clientSocket.Close();

3.与JAVA中Socket的区别
Java中：
//TCP
InputStream in = socket.getInputStream();
in.read(...);
OutputStream out = socket.getOutputStream();
out.write(...);

//UDP
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
byte[] mess = s.receive(packet).packet.getData();

DatagramPacket packet = new DatagramPacket(message, message.length, ip, port);
s.send(packet);

c#中：
//TCP
socket.Receive(...);
socket.Send(...);
//UDP
socket.ReceiveFrom(...);
socket.SendTo(...);


4.例
IPAddress是ip，如“127.0.0.1”
IPEndPoint是ip和端口对的组合，如“127.0.0.1:80”
IPAddress.Any 提供一个 IPv4 地址，指示服务器必须侦听所有 IPv4 网络接口上的客户端活动。此字段为只读。等效于以点分隔的四部分表示法格式的 0.0.0.0 这个IP地址，对于SOCKET而言，使用 any ，表示侦听本机的所有IP地址的对应的端口（本机可能有多个IP或只有一个IP）。
new IPEndPoint(IPAddress.Parse("*.*.*.*"), 8888).AddressFamily;                                     //指的是取得指定IP*.*.*.*使用的协议，如IPV4、IPV6
AddressFamily.InterNetwork;                                                                         //表示网络类型IPV4
Dns.GetHostName();


（1）基于TCP
//TCPServer
    static void Main(string[] args)
    {
         //建立连接并监听
         IPEndPoint ipep = new IPEndPoint(IPAddress.Any, 8888);//本机预使用的IP和端口
         Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
         serverSocket.Bind(ipep);                                                                   //绑定
         serverSocket.Listen(10);                                                                   //监听
         Console.WriteLine("waiting for a client");
         //接收部分
         Socket clientSocket = serverSocket.Accept();                                               //当有可用的客户端连接尝试时执行，并返回一个新的socket,用于与客户端之间的通信
         IPEndPoint clientip = (IPEndPoint)clientSocket.RemoteEndPoint;
         Console.WriteLine("connect with client:" + clientip.Address + " at port:" + clientip.Port);
         //发送部分
         string welcome = "welcome here!";
         byte[] data = new byte[1024];                                                              //用于缓存客户端所发送的信息,通过socket传递的信息必须为字节数组
         data = Encoding.ASCII.GetBytes(welcome);
         clientSocket.Send(data, data.Length, SocketFlags.None);                                    //发送信息
         //读取部分
         int recv;                                                                                  //用于表示客户端发送的信息长度
         while(true)
          {
              //用死循环来不断的从客户端获取信息
              data = new byte[1024];
              recv = clientSocket.Receive(data);
              Console.WriteLine("recv=" + recv);
              if (recv == 0)                                                                        //当信息长度为0，说明客户端连接断开
                  break;
              Console.WriteLine(Encoding.ASCII.GetString(data, 0, recv));
              clientSocket.Send(data, recv, SocketFlags.None);
          }
          Console.WriteLine("Disconnected from" + clientip.Address);
          clientSocket.Close();
          serverSocket.Close();
     }

//TCPClient
using System.Net.Sockets;  
using System.Net;
    static void Main(string[] args)
    {
        IPEndPoint ipep = new IPEndPoint(IPAddress.Parse("*.*.*.*"), 8888);                         //填写服务器的IP，如果是其他电脑IP的话需将ConsoleApplication_socketServer工程放在对应的电脑上。  
        Socket clientSocket = new Socket(ipep.AddressFamily, SocketType.Stream, ProtocolType.Tcp);    
        try
        {
            clientSocket.Connect(ipep); 
        }
        catch(SocketException e)
        {
            Console.WriteLine("unable to connect to server");
            Console.WriteLine(e.ToString());
            return;
        }
        //接收部分
        byte[] data = new byte[1024];
        int recv = clientSocket.Receive(data);
        string stringdata = Encoding.ASCII.GetString(data, 0, recv);
        Console.WriteLine(stringdata);
        //发送部分
        while(true)
        {
            string input = Console.ReadLine();
            if(input == "exit")
                break;
            clientSocket.Send(Encoding.ASCII.GetBytes(input));
            data = new byte[1024];
            recv = clientSocket.Receive(data);
            stringdata = Encoding.ASCII.GetString(data, 0, recv);
            Console.WriteLine(stringdata);
        }
        Console.WriteLine("disconnect from sercer");
        clientSocket.Shutdown(SocketShutdown.Both);
        clientSocket.Close();
    }

（2）基于UDP
//UDPServer
    static void Main(string[] args)
     {
         //初始化本机为服务器
         IPEndPoint ipep = new IPEndPoint(IPAddress.Any, 9999);                                                     // 定义一网络端点
         Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);          // 定义一个Socket
         serverSocket.Bind(ipep);                                                                                   // Socket与本地的一个终结点相关联
         Console.WriteLine("Waiting for a client..");
         //初始化要监听的客户端
         IPEndPoint sender = new IPEndPoint(IPAddress.Any, 9999);
         EndPoint Remote = (EndPoint)(sender);
         //第一次接收部分
         byte[] data = new byte[1024];
         int recv = serverSocket.ReceiveFrom(data, ref Remote);                                                     // 接收数据，阻塞，返回的客户端IP会写入Remote中
         Console.WriteLine("Message received from:{0}", Remote.ToString());
         Console.WriteLine(Encoding.ASCII.GetChars(data, 0, recv));
         //第一次发送部分
         string welcome = "Welcome to my test server!";
         data = Encoding.ASCII.GetBytes(welcome);
         serverSocket.SendTo(data, data.Length, SocketFlags.None, Remote);
         //循环接收、发送（此处为发送原值）
         while (true)
         {
             data = new byte[1024];
             recv = serverSocket.ReceiveFrom(data, ref Remote);
             Console.WriteLine(Encoding.ASCII.GetString(data, 0, recv));
             serverSocket.SendTo(data, recv, SocketFlags.None, Remote);
         }
     }
 
//UDPClient
    static void Main(string[] args)
    {
        //初始化本机为客户端
        Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        //初始化服务器端
        IPEndPoint sender = new IPEndPoint(IPAddress.Parse("*.*.*.*"), 9999);
        EndPoint Remote = (EndPoint)sender;
        //第一次发送部分
        string welcome = "Hello,are you there?";
        byte[] data = new byte[1024];                                                               //定义一个数组用来做数据的缓冲区
        data = Encoding.ASCII.GetBytes(welcome);
        clientSocket.SendTo(data, data.Length, SocketFlags.None, Remote);                           //将数据发送到指定的终结点
        //第一次接收部分
        string input, stringData;
        data = new byte[1024];
        int recv = clientSocket.ReceiveFrom(data, ref Remote);//接受来自服务器的数据，阻塞
        Console.WriteLine("Message received from:{0}", Remote.ToString());
        Console.WriteLine(Encoding.ASCII.GetString(data, 0, recv));
        //循环发送（此处为发送输入的值）、接收
        while (true)//读取数据
        {
            input = Console.ReadLine();                                                             //从键盘读取数据
            if (input == "text")                                                                    //结束标记
            {                           
                break;                          
            }                           
            clientSocket.SendTo(Encoding.ASCII.GetBytes(input), Remote);                            //将数据发送到指定的终结点Remote
            data = new byte[1024];
            recv = clientSocket.ReceiveFrom(data, ref Remote);                                      //从Remote接受数据
            stringData = Encoding.ASCII.GetString(data, 0, recv);
            Console.WriteLine(stringData);
        }
        Console.WriteLine("Stopping client");
        clientSocket.Close();
    }











十、数据库
A、数据库语言
0、基本
（1）注释
--select * from tableA

（2）转义符
SQL 的转义字符是：'（单引号）
例：select * from tbl where uyear='''06'
请注意其中第2个单引号，它即表示转义字符，如果我们省略，则整个语句会出错，转义字符不会输出，上例中 uyear 的实际条件值为 '06，而不是 ''06。
（3）通配符
%                            替代零个、一个或多个字符 
_                            仅替代一个字符 
[charlist]                   字符列中的任何单一字符 
[^charlist]或者[!charlist]   不在字符列中的任何单一字符 
变量
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
USE pubs
DECLARE @find varchar(30)
SET @find = 'Ring%'
SELECT au_lname, au_fname, phone
FROM authors
WHERE au_lname LIKE @find
下面是结果集：
au_lname                                au_fname              phone        
-------------------------------------- --------------------  ------------ 
Ringer                                  Anne                  801 826-0752 
Ringer                                  Albert                801 826-0752 

(2 row(s) affected)
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

（4）数据类型
1）char和varchar的长度都在1到8000之间，它们的区别在于char是定长字符数据，而varchar是变长字符数据。所谓定长就是长度固定的，当输入的数据长度没有达到指定的长度时将自动以英文空格在其后面填充，使长度达到相应的长度；而变长字符数据则不会以空格填充。text存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。 
后面三种数据类型和前面的相比，从名称上看只是多了个字母"n"，它表示存储的是Unicode数据类型的字符。字符中，英文字符只需要一个字节存储就足够了，但汉字众多，需要两个字节存储，英文与汉字同时存在时容易造成混乱，Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。
2）nchar、nvarchar的长度是在1到4000之间。和char、varchar比较：nchar、nvarchar则最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。

CHAR，NCHAR 定长，速度快，占空间大，需处理
VARCHAR，NVARCHAR，TEXT 不定长，空间小，速度慢，无需处理
NCHAR、NVARCHAR、NTEXT处理Unicode码


定义变量是 varchar(8000) 变量长度要放在括号里面 
SQL2000的字符串数据类型： 
char:1-8000字节 
nchar:1-4000字节 
varchar:1-8000字节 
nvarchar:1-4000字节 
SQL2000文本和图形数据： 
text  :1-2,147,483,647 
ntext :1-1,073,741,823
image :1-2,147,483,647只存储图片，大约2G字节 
有人在text数据类型中存储过2万多汉字文件

3）数值类型
<1>简单类型
smallint 2 字节 小范围整数 -32768 到 +32767 
integer 4 字节 常用的整数 -2147483648 到 +2147483647 
bigint 8 字节 大范围的整数 -9223372036854775808 到 9223372036854775807 
decimal 变长 用户声明精度，精确 无限制 
numeric 变长 用户声明精度，精确 无限制 
real 4 字节 变精度，不精确 6 位十进制数字精度 
double precision 8 字节 变精度，不精确 15 位十进制数字精度 
serial 4 字节 自增整数 1 到 2147483647 
bigserial 8 字节 大范围的自增整数 1 到 9223372036854775807 

<2>序列号类型
serial 和 bigserial 类型不是真正的类型，只是为在表中设置唯一标识做的概念上的便利。类似其它一些数据库中的 AUTO_INCREMENT 属性。在目前的实现中，下面一个语句：
CREATE TABLE tablename (
    colname SERIAL
);
等价于声明下面几个语句：
CREATE SEQUENCE tablename_colname_seq;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
因此，我们就创建了一个整数字段并且把它的缺省数值安排为从一个序列发生器读取。应用了一个 NOT NULL 约束以确保 NULL 不会被插入。在大多数情况下你可能还希望附加一个 UNIQUE 或 PRIMARY KEY 约束避免意外地插入重复的数值，但这个不是自动的。最后，将序列发生器"从属于"那个字段，这样当该字段或表被删除的时候也一并删除它。
【注意】PostgreSQL 7.3以前，serial 隐含 UNIQUE 。但现在不再如此。如果你希望一个序列字段有一个唯一约束或者一个主键，那么你现在必须声明，就像其它数据类型一样。
要在 serial字段中插入序列中的下一个数值，主要是要注意 serial字段应该赋予缺省值。我们可以通过在 INSERT 语句中把该字段排除在字段列表之外来实现，也可以通过使用 DEFAULT 关键字来实现。
类型名 serial 和 serial4 是等效的：两者都创建 integer 字段。类型名 bigserial 和 serial8 也一样，只不过它创建一个 bigint 字段。如果你预计在表的生存期中使用的标识数目可能超过 231 个，那么你应该使用 bigserial 。
一个 serial 类型创建的序列在所属的字段被删除的时候自动删除。你可以只删除序列而不删除字段，不过这将删除该字段的缺省值表达式。


（5）字段名为关键字的处理
oracle:将字段名加双引号（""）
        如： select "update" from table1
sql server：将字段名加中括号（[]）
        如：select [update] from table1
mysql:将字段名加反引号（``）
        如：select `update` from table1
PostgreSQL:将字段名加双引号（""）
        如： select "update" from table1


（6）分隔标识符 或 引号包围的标识符
把一个标识符用引号包围起来同时也令它大小写相关，而没有引号包围起来的名字总是转成小写。比如，我们认为标识符 FOO, foo, "foo" 是等价的 PostgreSQL 名字，但 "Foo" 和 "FOO" 与上面三个以及它们之间都是不同的。PostgreSQL 里对未加引号的名子总是转换成小写，这和 SQL 标准是不兼容的，SQL 标准要求未用引号包围起来的名字总是转成大写。因此根据标准，foo 等于 "FOO" 但不等于 "foo" 。如果你想编写可移植的程序，那么我们建议你要么就总是用引号包围某个名字，要么就从来不引。
例例例例例例例例例例例例例例例例
SELECT 'foo'
'bar';
等效于
SELECT 'foobar';但
SELECT 'foo'      'bar';会报错
例例例例例例例例例例例例例例例例


（7）SQL语句顺序
书写顺序
select--from--where--group by--having--order by  

标准的 SQL 的解析顺序为:
    1）FROM 子句， 组装来自不同数据源的数据
    2）WHERE 子句， 基于指定的条件对记录进行筛选
    3）GROUP BY 子句， 将数据划分为多个分组
    4）使用聚合函数进行计算
    5）使用 HAVING 子句筛选分组
    6）计算所有的表达式
    7）使用 ORDER BY 对结果集进行排序 
    8）Select集合输出

为了准确说明Select语句所在位置：
    1. FROM clause
    2. WHERE clause
    3. GROUP BY clause
    4. HAVING clause
    5. SELECT clause
    6. ORDER BY clause


（8）数据库连接字符串
 1）Windows验证与Sql自身的验证的区别：
  Windows验证就是SqlServer服务器使用Windows自带的验证系统，如果你指定SqlServer内Windows的一个组有访问的权限，那么加入此组的Windows用户都有访问数据库的权限。此验证有个缺点，就是如果不是在域模式下，无法加入远程计算机的用户，所以如果使用C/S方式写程序的话，使用Windows验证无法使本地计算机的Windows帐户访问远程数据库服务器。  
  Sql验证就简单多了，就是使用sqlserver的企业管理器中自己定义由Sql控制的用户，指定用户权限等。这个帐户信息是由SqlServer自己维护的，所以SqlServer更换计算机后信息不会丢失，不用重新设定。  
  所以如果你的项目使用在一个比较大的网络中，而且对安全要求比较高，那么应该建立域，使用Windows验证，而且要与系统管理员配合详细设定可以访问SqlServer的Windows帐户。如果使用一个小网络，而且此网络仅用来使用项目，对安全没有高要求，那么使用SqlServer验证，而且更新，升级等都方便。  
  Windows验证与SqlServer验证的数据库联接字符串是不同的。

 2）
我们就可以使用如下两种方式连接数据库，即采用集成的Windows验证和使用Sql Server身份验证进行数据库的登录。
<1>集成的Windows身份验证语法范例
string constr = "server=.;database=myschool;integrated security=SSPI";
说明：程序代码中，设置了一个针对Sql Server数据库的连接字符串。其中server表示运行Sql Server的计算机名，由于程序和数据库系统是位于同一台计算机的，所以我们可以用.(或localhost)取代当前的计算机名。database表示所使用的数据库名(myschool)。由于我们希望采用集成的Windows验证方式，所以设置 integrated security为SSPI即可。
<2>Sql Server 2005中的Windows身份验证模式如下：
string constr = "server=.;database=myschool;uid=sa;pwd=sa";
说明：程序代码中，采用了使用已知的用户名和密码验证进行数据库的登录。数据库连接字符串是不区分大小写的。uid为指定的数据库用户名，pwd为指定的用户口令。为了安全起见，一般不要在代码中包括用户名和口令，你可以采用前面的集成的Windows验证方式或者对Web.Config文件中的连接字符串加密的方式提高程序的安全性。
<3>Sql Server 2005中的Sql Server身份验证模式如下：
string constr = "data source=.;initial catalog=myschool;user id=sa;pwd=sa";
说明：程序代码中data source 表示运行数据库对应的计算机名，initial catalog表示所使用的数据库名。uid为指定的数据库用户名，pwd为指定的用户口令。

例1：集成Windows身份验证
---------------
server=.;
database=myschool;
integrated security=SSPI;
---------------
例2：账号Windows身份验证
---------------
server=.;
database=myschool;
uid=sa;
pwd=sa;
---------------
例3：Sql Server身份验证
---------------
Data Source=localhost;
Initial Catalog=Test;
Persist Security Info=True;
User ID=sa; uid=sa;
Password=1; pwd=1;
---------------


1、数据库操作
（1）添加数据库
CREATE DATABASE database_name
（2）删除数据库
DROP DATABASE 数据库名称
（3）数据库属性
--所有表
select name from sys.sysobjects where type='U'
select * from information_schema.tables
--所有视图
select * from information_schema.views
-所有列
select * from information_schema.columns
--所有字段
Select name from syscolumns Where ID=OBJECT_ID('表名')
--返回表的相关信息
exec sp_help '表名'
（4）跨库操作
方式一
/********************链接数据库 *******************************/
exec OPENDATASOURCE(
         'SQLOLEDB',
         'Data Source=远程ip;User ID=sa;Password=密码'
         ).库名.dbo.存储过程名

select * into 本地库名.dbo.表名 from OPENDATASOURCE(
         'SQLOLEDB',
         'Data Source=远程ip;User ID=sa;Password=密码'
         ).库名.dbo.表名

insert 本地库名.dbo.表名 select * from OPENDATASOURCE(
         'SQLOLEDB',
         'Data Source=远程ip;User ID=sa;Password=密码'
         ).库名.dbo.表名

方式二：
或使用联结服务器:
EXEC sp_addlinkedserver '别名','','MSDASQL',NULL,NULL,'DRIVER={SQL Server};SERVER=远程名;UID=用户;PWD=密码;'
exec sp_addlinkedsrvlogin  @rmtsrvname='别名',@useself='false',@locallogin='sa',@rmtuser='sa',@rmtpassword='密码'
GO
然后就可以如下：
select * from 别名.库名.dbo.表名
insert 库名.dbo.表名 select * from 别名.库名.dbo.表名
select * into 库名.dbo.新表名 from 别名.库名.dbo.表名
GO


2、表操作
（1）新建与约束
CREATE TABLE Persons (
    --方式一：单行
    Id_P int NOT NULL PRIMARY KEY,                      --主键
    FirstName varchar(255) NOT NULL,                    --非空
    LastName varchar(255) UNIQUE,                       --唯一
    Sex varchar(255) DEFAULT 'male',                    --缺省值
    age integer CHECK (age > 0),                        --约束
    Country varchar(255) REFERENCES Location(Country),  --外键，Location为表名，Country为字段名，字段名(Country)可省略，缺省为被引用表的主键。
                                                        --（字段约束没有FOREIGN KEY字样）
    Id_City varchar(255) REFERENCES Location ON DELETE RESTRICT,  --※联级更新、联级删除
    Collage varchar(255) REFERENCES Location ON DELETE CASCADE,   --※联级更新、联级删除
    --方式二：多行
    PRIMARY KEY (Id_P),
    UNIQUE (FirstName, LastName),
    CONSTRAINT chk_Person CHECK (Id_P > 0 AND City='Sandnes' AND Country IS NOT NULL),
    CONSTRAINT chk_PerOrders FOREIGN KEY (Country) REFERENCES AddressTable(Country)
)
·RESTRICT 禁止删除被引用的行。
·NO ACTION 的意思是如果在检查约束的时候还存在任何引用行，则抛出错误；如果你不声明任何东西，那么它就是缺省的行为。这两个选择的实际区别是：NO ACTION 允许约束检查推迟到事务的晚些时候，而 RESTRICT 不行。
·CASCADE 声明在删除一个被引用的行的时候，所有引用它的行也会被自动删除掉。
·在外键字段上的动作还有两个选项：SET NULL 和 SET DEFAULT ，它们导致在被引用行删除的时候，将引用它们的字段分别设置为 NULL 和缺省值。请注意这些选项并不能让你逃脱被观察和约束的境地。比如，如果一个动作声明 SET DEFAULT ，但是缺省值并不能满足外键，那么该动作就会失败。
·缺省值可以是一个表达式，它会在插入缺省值的时候计算(不是在创建表的时候)。一个常见的例子是一个 timestamp 字段可能有缺省值 now() ，它表示插入行的时刻。
·从技术上讲，主键约束只是（唯一约束+非空约束）的组合，可以同时应用于多个字段。

（2）修改
1）表名
<1>修改
·ALTER table 表名 rename to 新表名
EXEC sp_rename 'customers', 'custs'             --sql server
<2>删除
·DROP TABLE table_name

2）主键
<1>修改
·单：ALTER TABLE Persons ADD PRIMARY KEY (Id_P)
·多：ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)
<2>撤销
·ALTER TABLE Persons DROP CONSTRAINT pk_PersonID
<3>组合唯一
//sql server
alter table 表名
add constraint 约束名 unique (column1, column2)

3）外键
<1>修改
·单：ALTER TABLE Orders ADD FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
·多：ALTER TABLE Orders ADD CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
<2>撤销
·ALTER TABLE Orders DROP CONSTRAINT fk_PerOrders

4）缺省值
<1>修改
·ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
(SQLServer中是这样
ALTER TABLE Company ADD Switch2In5 int not null default(0)
ALTER TABLE EmailTemplate  add constraint DF_Original default(0) for Original
)

请注意这么做不会影响任何表中现有的数据行，它只是为将来的 INSERT 命令改变缺省值。
CREATE TABLE Orders
(
    Id_O int NOT NULL,
    OrderNo int NOT NULL,
    Id_P int,
    OrderDate date DEFAULT GETDATE()
)
<2>撤销
·ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
这样实际上相当于把缺省设置为空。结果是，如果我们删除一个还没有定义的缺省值不算错误，因为缺省隐含就是 NULL。

5）字段
<1>添加字段
ALTER TABLE Persons ADD COLUMN column_name VARCHAR(200)
ALTER TABLE Persons ADD [State] varchar(20)                                 --SQLServer
ALTER TABLE [表名] ADD CONSTRAINT 约束名 DEFAULT date  FOR [字段名]         --

<2>修改
alter table table_name rename COLUMN column_name to column_name_new
ALTER TABLE Persons ALTER COLUMN [Content] NVARCHAR(MAX)    --SQLServer
<3>删除
ALTER TABLE table_name DROP COLUMN column_name
不管字段里有什么数据，都会消失，和这个字段相关的约束也会被删除。不过，如果这个字段被另一个表的外键所引用，PostgreSQL 则不会隐含地删除该约束。你可以通过使用 CASCADE 指明删除任何依赖该字段的东西：
ALTER TABLE products DROP COLUMN column_name CASCADE;

6）字段类型
<1>修改
alter table dbo.titemtype alter column id type integer using to_number(id,'9');
如：ID 字段 原类型为 character varying(50) 新类型为integer，其中，ID中原有数据为1，2，3等数字。
只有在字段里现有的每个项都可以隐含的转换城新类型时才可能成功。如果需要更复杂的转换，你可以增加一个 USING 子句，它声明如何从旧值里计算新值。
PostgreSQL 将试图把字段的缺省值(如果存在)转换成新的类型，还有涉及该字段的任何约束。但是这些转换可能失败，或者可能生成奇怪的结果。在修改某字段类型之前，你最好删除那些约束，然后再把合适的约束添加上去。
<2>删除
ALTER TABLE products ADD COLUMN description text CHECK (description <> '');
新增的字段对于表中已经存在的行而言最初将先填充所给出的缺省值(如果你没有声明 DEFAULT 子句，那么缺省是 NULL)。

7）主键
主键如果是INTEGER，默认就是增长类型，其他字段可以通过申明AUTOINCREMENT ，但是最好不要这样做，因为自动增长主要是为主键设置的
CREATE TABLE salespeople (
  id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  commission_rate REAL NOT NULL);

已经建立的表。或从其它数据库导入的表如何添加一个这样的键？
ALTER TABLE salespeople ADD NewCol INTEGER AUTOINCREMENT

（3）继承
CREATE TABLE cities (
  name       text,
  population real,
  altitude   int     -- (单位是英尺)
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);


SELECT name, altitude
    FROM ONLY cities
    WHERE altitude > 500;
  cities 前面的 ONLY 指示系统只对 cities 表运行查询，而不包括继承级别中低于 cities 的表。许多我们已经讨论过的命令 SELECT, UPDATE, DELETE 都支持这个 ONLY 表示法。
【注意】尽管继承经常是有用的，但是它还没有集成唯一约束或者外键，因此制约了其实用性。

（4）表连接
 t1
 num | name
-----+------
   1 | a
   2 | b
   3 | c
   和

 t2
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz

交叉连接：并集
外连接：交集，不去行
内连接：交集，去所有行

1）交叉连接（笛卡尔连接）
=> SELECT * FROM t1 CROSS JOIN t2;

 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

2）内连接
<1>使用ON
=> SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)
<2>使用USING
=> SELECT * FROM t1 INNER JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<3>使用NATURAL
=> SELECT * FROM t1 NATURAL INNER JOIN t2;
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)


3）外连接FULL JOIN（或称全连接FULL OUTER JOIN）
=> SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)用 ON 声明的连接条

4）左连接LEFT JOIN（或称左外连接LEFT OUTER JOIN）
=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

=> SELECT * FROM t1 LEFT JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

5）右连接RIGHT JOIN（或称右外连接RIGHT OUTER JOIN）
=> SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

6）用 ON 声明的连接条件也可以包含与连接不直接相关的条件。这种功能可能对某些查询很有用，但是需要我们仔细想清楚。比如：

=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)

（5）视图
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;




3、数据操作
SQL语言包含4个部分： 
※ 数据定义语言(DDL)，例如：CREATE、DROP、ALTER等语句。 
※ 数据操作语言(DML)，例如：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。
※ 数据查询语言(DQL)，例如：SELECT语句。 
※ 数据控制语言(DCL)，例如：GRANT、REVOKE、COMMIT、ROLLBACK等语句。 

（1）查询
SELECT * FROM B WHERE (条件)
select * from 人员库 order by ID where 计件或生产奖=1
select cola, colb from 人员库 order by ID where 计件或生产奖=1

（2）插入
1）方式1
INSERT INTO table_name VALUES (值1, 值2,....)
2）方式2
INSERT INTO table_name (字段1, 字段2,...) VALUES (值1, 值2,....)
3）方式3
要求目标表Table2必须存在，由于目标表Table2已经存在，所以我们除了插入源表Table1的字段外，还可以插入常量。
INSERT INTO TABLE2(FIELD1,FIELD2,...) SELECT VALUE1,VALUE2,... FROM TABLE1
INSERT INTO TABLE2 SELECT * FROM TABLE1
4）方式4
要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。
SELECT VALUE1, VALUE2 INTO TABLE2 FROM TABLE1

（3）更新
update table_name set 字段1=值1, 字段2=值2...
"update 人员库 set 系数=" + textBox2.Text + " where 职名='" + comboBox3.Text + "' and 计件或生产奖=0";


有A、B张表，其记录如下：
A表              B表
c1   c2          c1   c2
----------       ----------
1    a1          1    b1
2    a2          2    b1
3    a3          3    b3
8    a8          10   b10
---------------------------
用一条sql语句实现，A.c1与B.c1相等时，A.c2的值更新为B.c2

UPDATE A
SET A.c2 = B.c2
from A, B
where A.c1 = B.c1
或
UPDATE A
SET A.c2 = B.c2
from A inner join B on A.c1=B.c1
注意：update后面是不能跟多表的，但跟在from子句后面

（4）删除
DELETE FROM 表名称 WHERE 字段名 = 值
delete from b where (key字段) in (select top 100 (key字段) from b)
对(select top 100 (key字段) from b)释义：表b中排在前100行的key字段内容

（5）条件限定
Case具有两种格式。简单Case函数和Case搜索函数。 
1）简单Case函数
    CASE sex
    WHEN '1' THEN '男'
    WHEN '2' THEN '女'
    ELSE '其他' END
2）Case搜索函数
    CASE WHEN sex = '1' THEN '男'
    WHEN sex = '2' THEN '女'
    ELSE '其他' END
    AS 性别        --不加此行是：sex='男'，加此行是：性别='男'
3）
    CASE WHEN col_1 IN ( 'a', 'b') THEN '第一类'
    WHEN col_1 IN ('a')       THEN '第二类'
    ELSE'其他' END

★下面是一种企图避免在 WHERE 子句里被零除的不可靠方法，但两个条件的判定顺序是不定的：
SELECT ... WHERE x <> 0 AND y/x > 1.5;但是下面这个是安全的：
SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false END;这种风格的 CASE 构造会阻止优化，因此应该只在必要的时候才使用。在这个特殊的例子里，毫无疑问写成 y > 1.5*x 更好。

（6）OUTPUT
OUTPUT的使用，用于在更新数据库的同时，输出更新结果，使用例子：
a.对于INSERT,可以引用inserted表以查询新行的属性. 
   insert into [表名] (a) OUTPUT Inserted.a values ('a')      
b.对于DELETE,可以引用deleted表以查询旧行的属性. 
   delete [表名] OUTPUT deleted.a where links = 'a' 
c.对于UPDATE,使用deleted表查询被更新行在更改前的属性,用inserted表标识被更新行在更改后的值. 
   update [表名] set a = 'b' OUTPUT inserted.a where a = 'a'(返回修改后a的值) 
   update [表名] set a = 'b' OUTPUT deleted.a where a = 'a' (返回修改前a的值) 
后面也可加into @t，将OUTPUT的结果更新到另一张表中。

4、逻辑词、函数
（1）AND 和 OR

（2）MAX、MIN
SELECT * FROM T1 WHERE NUM = SELECT MAX(NUM)FROM T2
对SELECT MAX(NUM) FROM T2释义：取表T2中NUM字段值为最大的NUM
聚集函数 MAX 不能用于 WHERE 子句中，因为需要通过WHERE确定MAX的范围

（3）count(column_name) 、count(*)
SELECT COUNT(store_name) FROM Store_Information WHERE store_name is not NULL
释义：表Store_Information中有多少条store_name不为空

总结一下：
count(*)和count(1)执行的效率是完全一样的。 
count(*)的执行效率比count(col)高，因此可以用count(*)的时候就不要去用count(col)。 
count(col)的执行效率比count(distinct col)高，不过这个结论的意义不大，这两种方法也是看需要去用。 
如果是对特定的列做count的话建立这个列的非聚集索引能对count有很大的帮助。 
如果经常count(*)的话则可以找一个最小的col建立非聚集索引以避免全表扫描而影响整体性能。 

（4）DISTINCT
SELECT COUNT(DISTINCT store_name) FROM Store_Information
释义：表Store_Information中有多少条不同的store_name
※DISTINCT ON 子句不是 SQL 标准的一部分，有时候被是一个糟糕的风格，因为它的结果是不可判定的。如果用有可选的 GROUP BY 和在 FROM 中的子查询可以达到目的，那么我们可以避免使用这个构造，但是通常它是更方便的方法。

（5）ORDER
SELECT TOP 1 * FROM BIAO ORDER BY NUM [ASC | DESC]
释义：将表biao中的字段num以逆序排列，取第一行值
按指定顺序排序:
1）ORDER BY (SELECT CASE 新区域 WHEN '睿信整体' THEN 1 ELSE 2 END)
2）select 到帐月, CHARINDEX(','+CONVERT(varchar(10),到帐月)+',' , ',2,4,6,8,10,12,11,9,7,5,3,1,') As IdIndex
from TABLEA
order by IdIndex

（6）TOP
SELECT TOP 2 * FROM Persons
释义：选取表Persons中头两条记录
SELECT TOP 50 PERCENT * FROM Persons
释义：从表Persons中的头两条记录，选取50%的记录

（7）LIMIT、OFFSET 
LIMIT 将返回不超过该数字的行(也可能更少些，因为可能查询本身生成的总行数就比较少)。LIMIT ALL 和省略 LIMIT 子句是一样的。
OFFSET 指明在开始返回行之前忽略多少行。OFFSET 0 和省略 OFFSET 子句是一样的。如果 OFFSET 和 LIMIT 都出现了，那么在计算 OFFSET 之前先忽略 LIMIT 指定的行数。
select * from xxx limit 10 offset 0;

（8）LIKE
SELECT COLUMN_NAME(S) FROM TABLE_NAME WHERE COLUMN_NAME LIKE PATTERN
SELECT * FROM PERSONS WHERE CITY NOT LIKE 'N%'

（9）IN
SELECT COLUMN_NAME(S) FROM TABLE_NAME WHERE COLUMN_NAME IN (VALUE1, VALUE2,...)

（10）AVG、SUM
SELECT SUM(OrderPrice) AS OrderTotal FROM Orders

（11）AS Alias
SELECT po.OrderID, p.LastName, p.FirstName FROM Persons AS p, Product_Orders AS po WHERE p.LastName='Adams' AND p.FirstName='John'
假设我们有两个表分别是："Persons" 和 "Product_Orders"。我们分别为它们指定别名 "p" 和 "po"。现在，我们希望列出 "John Adams" 的所有定单。
1）列别名（AS可省略）
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
       W2.city, W2.temp_lo AS low, W2.temp_hi AS high
       FROM weather W1, weather W2
2）表别名（AS可省略）
SELECT *
    FROM weather AS w, cities AS c
    WHERE w.city = c.name;
SELECT *
    FROM (SELECT * FROM table1) AS alias_name


★（PostgreSQL无此问题）在SQL Server中，列别名不可在where中使用，因为sql语句的执行顺序为：
    1. FROM clause
    2. WHERE clause
    3. GROUP BY clause
    4. HAVING clause
    5. SELECT clause
    6. ORDER BY clause
    此时列还未生成，表现现象为：
select id, (c1 + c2) as s
from t1
where s > 100 
SQL Server 报错: "列名 s 无效"
    但可通过如下方法：
select t2.*                                    --“t2”可以省略
from (select id, (c1 + c2) as c from t1) t2
where c > 100
--或者
select t2.*                                    --“t2”可以省略
from (select id, c = c1+c2 from t1) t2
where c > 100

（12）ISNULL
SELECT ISNULL(A, 0) + ISNULL(B,0) FROM XXX
如果a、b为null，则将其替换为0
★
--利用一定规则连接某一字段的n个值，成为一个字符串，如[数学],[语言],[英语]
declare @sql_query varchar(8000)
select @sql_query = isnull(@sql_query + '],[' , '') + tableA.课程 from tableA
set @sql_query='[' + @sql_query + ']'
--由于@sql_query为null，因此null+任何字符串都为null

（13）GROUP BY
讲解一
SELECT select_list
    FROM ...
    [WHERE ...]
    GROUP BY grouping_column_reference [, grouping_column_reference]...
GROUP BY 子句 用于把那些所有列出的 grouping_column_reference 值都相同的行聚集在一起，缩减为一行，这样就可以删除输出里的重复和/或计算应用于这些组的聚集。这些字段的列出顺序无关紧要。
SELECT Customer, SUM(OrderPrice) FROM Orders GROUP BY Customer
GROUP BY语句用于结合合计函数，根据一个或多个列对结果集进行分组。
举例，原表如下：
CREATE TABLE [dbo].[GT](
    [O_Id] [bigint] IDENTITY(1,1) NOT NULL,
    [OrderDate] [datetime] NOT NULL,
    [OrderPrice] [bigint] NOT NULL,
    [Customer] [nvarchar](200) NULL
)
GO

insert into GT
values ('2008/12/29',1000,'Bush');
insert into GT
values ('2008/11/23',1600,'Carter');
insert into GT
values ('2008/10/05',700,'Bush');
insert into GT
values ('2008/09/28',300,'Bush');
insert into GT
values ('2008/08/06',2000,'Adams');
insert into GT
values ('2008/07/21',100,'Carter');
GO

O_Id    OrderDate   OrderPrice  Customer
 1      2008/12/29  1000        Bush
 2      2008/11/23  1600        Carter
 3      2008/10/05  700         Bush
 4      2008/09/28  300         Bush
 5      2008/08/06  2000        Adams
 6      2008/07/21  100         Carter
1）SELECT Customer, SUM(OrderPrice) FROM Orders
结果：
Customer    SUM(OrderPrice)
Bush        5700
Carter      5700
Bush        5700
Bush        5700
Adams       5700
Carter      5700
2）SELECT Customer, SUM(OrderPrice) FROM Orders GROUP BY Customer
结果：
Customer    SUM(OrderPrice)
Bush        2000
Carter      1700
Adams       2000
3）SELECT OrderDate, Customer, SUM(OrderPrice) FROM Orders GROUP BY Customer, OrderDate
结果：
Customer    OrderDate   SUM(OrderPrice)
Carter      2008-07-21  100
Adams       2008-08-06  2000
Bush        2008-09-28  300
Bush        2008-10-05  700
Carter      2008-11-23  1600
Bush        2008-12-29  1000

4）SELECT Customer, OrderDate, SUM(OrderPrice) FROM Orders GROUP BY Customer, OrderDate with rollup
结果：
Customer    OrderDate   SUM(OrderPrice)
Adams       2008-08-06  2000
Adams       NULL        2000
Bush        2008-09-28  300
Bush        2008-10-05  700
Bush        2008-12-29  1000
Bush        NULL        2000
Carter      2008-07-21  100
Carter      2008-11-23  1600
Carter      NULL        1700
NULL        NULL        5700

5）SELECT Customer, OrderDate, SUM(OrderPrice) FROM Orders GROUP BY Customer, OrderDate with cube
结果：
Customer    OrderDate   SUM(OrderPrice)
Carter      2008-07-21  100
NULL        2008-07-21  100
Adams       2008-08-06  2000
NULL        2008-08-06  2000
Bush        2008-09-28  300
NULL        2008-09-28  300
Bush        2008-10-05  700
NULL        2008-10-05  700
Carter      2008-11-23  1600
NULL        2008-11-23  1600
Bush        2008-12-29  1000
NULL        2008-12-29  1000
NULL        NULL        5700
Adams       NULL        2000
Bush        NULL        2000
Carter      NULL        1700

讲解二
=> SELECT * FROM test1;
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

=> SELECT x FROM test1 GROUP BY x;
 x
---
 a
 b
 c
(3 rows)

=> SELECT x, sum(y) FROM test1 GROUP BY x;
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)


※使用group by以后不能随便再使用select *
select后面的字段名，必须出现在group by后面，因为这些字段名都在查询选择列表中被引用了。
但形如select sum(price)，price可不出现在group by后面，因为它只是一个聚集表达式，代表一组数值的总和。



（14）HAVING 子句
如果一个表已经用 GROUP BY 子句分了组，然后你又只对其中的某些组感兴趣，那么就可以用 HAVING 子句筛选分组。语法是：
SELECT select_list FROM ... [WHERE ...] GROUP BY ... HAVING boolean_expression在 HAVING 子句中的表达式可以引用分组的表达式和未分组的表达式(后者必须涉及一个聚集函数)。

讲解一
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value

在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
举例，原表如下：
O_Id    OrderDate   OrderPrice  Customer
1       2008/12/29  1000        Bush
2       2008/11/23  1600        Carter
3       2008/10/05  700         Bush
4       2008/09/28  300         Bush
5       2008/08/06  2000        Adams
6       2008/07/21  100         Carter
执行：
SELECT Customer, SUM(OrderPrice) FROM Orders
WHERE Customer='Bush' OR Customer='Adams'
GROUP BY Customer
HAVING SUM(OrderPrice)>1500
结果：
Customer    SUM(OrderPrice)
Bush        2000
Adams       2000

讲解二
=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

（15）BETWEEN
释义：
SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2
释义：以字母顺序显示介于 "Adams"（包括）和 "Carter"（不包括）之间的人
SELECT * FROM Persons WHERE LastName BETWEEN 'Adams' AND 'Carter'
在SQL SERVER中BETWEEN包括AND两边的值

（16）UNION、UNION ALL（并集）
释义：UNION合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。
但不保证
SELECT E_Name FROM Employees_China
UNION
SELECT E_Name FROM Employees_USA

释义：UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION什么去年重复的值，UNION ALL 命令会列出所有的值。
SELECT E_Name FROM Employees_China
UNION ALL
SELECT E_Name FROM Employees_USA

（17）INTERSECT、INTERSECT ALL（交集）
释义：同上，但是为交集结果

释义：INTERSECT ALL 命令和 INTERSECT 命令几乎是等效的，不过 INTERSECT ALL 命令会列出所有的值。

（18）EXCEPT、EXCEPT ALL（差集）
释义：返回所有在 query1 结果中但是不在 query2 结果中的行(有时侯这叫做两个查询的差)。除非声明了 EXCEPT ALL ，否则所有重复行都被删除。

（19）INTO
1）SELECT INTO SELECT
要求目标表不存在，因为在插入时会自动创建表，
下面的例子会制作 "Persons" 表的备份复件：
SELECT *
INTO Persons_backup(varyA, varyB)
SELECT varyA, varyB
FROM Persons

 IN 子句也可用于向另一个数据库中拷贝表：
SELECT *
INTO Persons IN 'Backup.mdb'
FROM Persons

2）INSERT INTO
要求目标表必须存在，由于目标表已经存在，所以除了插入源表的字段外，还可以插入常量。
Insert into table1 values('a', 'b', 'c')

（20）CONVERT
SQL只取日期的年月日部分
方法一:
select replace(replace(replace(CONVERT(varchar, getdate(), 120 ), \'-\', \'\'), \' \', \'\'), \':\', \'\') 
20040912110608 
Select CONVERT(varchar(100), GETDATE(), 0): 05 16 2006 10:57AM
Select CONVERT(varchar(100), GETDATE(), 1): 05/16/06
Select CONVERT(varchar(100), GETDATE(), 2): 06.05.16
Select CONVERT(varchar(100), GETDATE(), 3): 16/05/06
Select CONVERT(varchar(100), GETDATE(), 4): 16.05.06
Select CONVERT(varchar(100), GETDATE(), 5): 16-05-06
Select CONVERT(varchar(100), GETDATE(), 6): 16 05 06
Select CONVERT(varchar(100), GETDATE(), 7): 05 16, 06
Select CONVERT(varchar(100), GETDATE(), 8): 10:57:46
Select CONVERT(varchar(100), GETDATE(), 9): 05 16 2006 10:57:46:827AM
Select CONVERT(varchar(100), GETDATE(), 10): 05-16-06
Select CONVERT(varchar(100), GETDATE(), 11): 06/05/16
Select CONVERT(varchar(100), GETDATE(), 12): 060516
Select CONVERT(varchar(100), GETDATE(), 13): 16 05 2006 10:57:46:937
Select CONVERT(varchar(100), GETDATE(), 14): 10:57:46:967
Select CONVERT(varchar(100), GETDATE(), 20): 2006-05-16 10:57:47
Select CONVERT(varchar(100), GETDATE(), 21): 2006-05-16 10:57:47.157
Select CONVERT(varchar(100), GETDATE(), 22): 05/16/06 10:57:47 AM
Select CONVERT(varchar(100), GETDATE(), 23): 2006-05-16
Select CONVERT(varchar(100), GETDATE(), 24): 10:57:47
Select CONVERT(varchar(100), GETDATE(), 25): 2006-05-16 10:57:47.250
Select CONVERT(varchar(100), GETDATE(), 100): 05 16 2006 10:57AM
Select CONVERT(varchar(100), GETDATE(), 101): 05/16/2006
Select CONVERT(varchar(100), GETDATE(), 102): 2006.05.16
Select CONVERT(varchar(100), GETDATE(), 103): 16/05/2006
Select CONVERT(varchar(100), GETDATE(), 104): 16.05.2006
Select CONVERT(varchar(100), GETDATE(), 105): 16-05-2006
Select CONVERT(varchar(100), GETDATE(), 106): 16 05 2006
Select CONVERT(varchar(100), GETDATE(), 107): 05 16, 2006
Select CONVERT(varchar(100), GETDATE(), 108): 10:57:49
Select CONVERT(varchar(100), GETDATE(), 109): 05 16 2006 10:57:49:437AM
Select CONVERT(varchar(100), GETDATE(), 110): 05-16-2006
Select CONVERT(varchar(100), GETDATE(), 111): 2006/05/16
Select CONVERT(varchar(100), GETDATE(), 112): 20060516
Select CONVERT(varchar(100), GETDATE(), 113): 16 05 2006 10:57:49:513
Select CONVERT(varchar(100), GETDATE(), 114): 10:57:49:547
Select CONVERT(varchar(100), GETDATE(), 120): 2006-05-16 10:57:49
Select CONVERT(varchar(100), GETDATE(), 121): 2006-05-16 10:57:49.700
Select CONVERT(varchar(100), GETDATE(), 126): 2006-05-16T10:57:49.827
Select CONVERT(varchar(100), GETDATE(), 130): 18 ???? ?????? 1427 10:57:49:907AM
Select CONVERT(varchar(100), GETDATE(), 131): 18/04/1427 10:57:49:920AM
方法二:
declare @tt varchar(4), @pp varchar(8), @ss varchar(4), @aa varchar(16)

set @tt=rtrim(cast(month(getdate()) as varchar(10)))
set @ss=rtrim(cast(day(getdate()) as varchar(10)))
select @pp=rtrim(cast(year(getdate()) as varchar(10)))
select @aa=@pp+@tt+@ss
select @aa
只显示年月,不显示日:select datepart(year, getdate())*100+datepart(month, getdate())
                   200811 






说明:
使用 CONVERT：
CONVERT ( data_type [ ( length ) ] , expression [ , style ] )
参数
expression
是任何有效的 Microsoft® SQL Server™ 表达式。
data_type
目标系统所提供的数据类型，包括 bigint 和 sql_variant。不能使用用户定义的数据类型。
length
nchar、nvarchar、char、varchar、binary 或 varbinary 数据类型的可选参数。 
style
日期格式样式，借以将 datetime 或 smalldatetime 数据转换为字符数据（nchar、nvarchar、char、varchar、nchar 或 nvarchar 数据类型）；或者字符串格式样式，借以将 float、real、money 或 smallmoney 数据转换为字符数据（nchar、nvarchar、char、varchar、nchar 或 nvarchar 数据类型）。
SQL Server 支持使用科威特算法的阿拉伯样式中的数据格式。
在表中，左侧的两列表示将 datetime 或 smalldatetime 转换为字符数据的 style 值。给 style 值加 100，可获得包括世纪数位的四位年份 (yyyy)。
不带世纪数位 (yy) 带世纪数位 (yyyy) 
标准 
输入/输出** 
- 0 或 100 (*) 默认值 mon dd yyyy hh:miAM（或 PM） 
1 101 美国 mm/dd/yyyy 
2 102 ANSI yy.mm.dd 
3 103 英国/法国 dd/mm/yy 
4 104 德国 dd.mm.yy 
5 105 意大利 dd-mm-yy 
6 106 - dd mon yy 
7 107 - mon dd, yy 
8 108 - hh:mm:ss 
- 9 或 109 (*) 默认值 + 毫秒 mon dd yyyy hh:mi:ss:mmmAM（或 PM） 
10 110 美国 mm-dd-yy 
11 111 日本 yy/mm/dd 
12 112 ISO yymmdd 
- 13 或 113 (*) 欧洲默认值 + 毫秒 dd mon yyyy hh:mm:ss:mmm(24h) 
14 114 - hh:mi:ss:mmm(24h) 
- 20 或 120 (*) ODBC 规范 yyyy-mm-dd hh:mm:ss[.fff] 
- 21 或 121 (*) ODBC 规范（带毫秒） yyyy-mm-dd hh:mm:ss[.fff] 
- 126(***) ISO8601 yyyy-mm-dd Thh:mm:ss.mmm（不含空格） 
- 130* Hijri**** dd mon yyyy hh:mi:ss:mmmAM 
- 131* Hijri**** dd/mm/yy hh:mi:ss:mmmAM 

* 默认值（style 0 或 100、9 或 109、13 或 113、20 或 120、21 或 121）始终返回世纪数位 (yyyy)。
** 当转换为 datetime时输入；当转换为字符数据时输出。
*** 专门用于 XML。对于从 datetime或 smalldatetime 到 character 数据的转换，输出格式如表中所示。对于从 float、money 或 smallmoney 到 character 数据的转换，输出等同于 style 2。对于从 real 到 character 数据的转换，输出等同于 style 1。
****Hijri 是具有几种变化形式的日历系统，Microsoft® SQL Server™ 2000 使用其中的科威特算法。

重要 默认情况下，SQL Server 根据截止年份 2049 解释两位数字的年份。即，两位数字的年份 49 被解释为 2049，而两位数字的年份 50 被解释为 1950。许多客户端应用程序（例如那些基于 OLE 自动化对象的客户端应用程序）都使用 2030 作为截止年份。SQL Server 提供一个配置选项（"两位数字的截止年份"），借以更改 SQL Server 所使用的截止年份并对日期进行一致性处理。然而最安全的办法是指定四位数字年份。


当从 smalldatetime 转换为字符数据时，包含秒或毫秒的样式将在这些位置上显示零。当从 datetime 或 smalldatetime 值进行转换时，可以通过使用适当的 char 或 varchar 数据类型长度来截断不需要的日期部分。

（21）DATEDIFF
释义：计算两个时间点间的时间
SELECT DATEDIFF(DAY, '2008-12-30', '2008-12-29') AS DIFFDATE
结果：
DiffDate 
-1

（22）DATEADD
DATEADD() 函数在日期中添加或减去指定的时间间隔。
DATEADD(datepart, number, date)
datepart 参数可以是下列的值：

datepart     缩写
年           yy, yyyy
季度         qq, q
月           mm, m
年中的日     dy, y
日           dd, d
周           wk, ww
星期         dw, w
小时         hh
分钟         mi, n
秒           ss, s
毫秒         ms
微妙         mcs
纳秒         ns

DATEADD(day, -1, '2013-10-10')     --2013-10-10的前一天

（23）Datename和Datepart
语法：
DATENAME ( datepart, date )
DATEPART( datepart, date )
描述：
datename获取周：datename(w, date)返回“星期几”，而datepart(w, date)则返回数值，如星期一则返回2；
datename(datepart, date)获取月份，Datepart(datepart, date)获取月分对应值，如一月为1。
获取一年中第多少天：datename(dy, date) 或datepart(dy, date)

参数datepart可取值：
年：yy, yyyy；
月：m, mm
季：q, qq
第几周：dw
周几：wk, w
一年中第几天：dy
日期中的天：day, dd
时、分、秒：hh, mi, ss


（24）pivot
1）功能
PIVOT用于将列值旋转为列名（即行转列），在SQL Server 2000可以用聚合函数配合CASE语句实现

2）语法
PIVOT的一般语法是：PIVOT(聚合函数(列) FOR 列 in (…) )AS P
完整语法：
table_source
PIVOT(
  聚合函数（value_column）
  FOR pivot_column
  IN(<column_list>)
)
UNPIVOT用于将列明转为列值（即列转行），在SQL Server 2000可以用UNION来实现
完整语法：
table_source
UNPIVOT(
  value_column
  FOR pivot_column
  IN(<column_list>)
)

注意：PIVOT、UNPIVOT是SQL Server 2005 的语法，使用需修改数据库兼容级别，在数据库属性->选项->兼容级别改为   90

3）例
如：
姓名       课程       分数
---------- ---------- -----------
张三       语文        74
张三       数学        83
张三       物理        93
李四       语文        74
李四       数学        84
李四       物理        94

<1>使用SQL Server 2005静态SQL
select * from tb pivot(max(分数) for 课程 in (语文,数学,物理)) a
<2>使用SQL Server 2005动态SQL
declare@sqlvarchar(8000)
–-获得课程集合
select @sql=isnull(@sql + ',' , '') + 课程 from tb group by 课程
set @sql='select * from tb pivot (max(分数) for 课程 in (' + @sql + ')) a'
exec(@sql)

※此处“for in”语法中的in与“where column in”中的in不同
“for in”语法中的in，其后格式为：“item1, item2”或“[item1], [item2]”
“where column in”中的in，其后格式为：“'item1', 'item2'”
∴select column1 from table where column1 in 'item1', 'item2'                                            --正确
select column1 from table pivot (sum(column3) for column2 in ([item1_column2], [item2_column2]) )        --正确
select column1 from table pivot (sum(column3) for column2 in (item1_column2, item2_column2) )            --正确
select column1 from table pivot (sum(column3) for column2 in ('item1_column2', 'item2_column2') )        --错误

（25）RIGHT
RIGHT('0'+ltrim(MONTH(GETDATE())),2)

（26）ROW_NUMBER/OFFSET
--ROW_NUMBER
SELECT * FROM  (
    SELECT ShopName, ROW_NUMBER() OVER(ORDER BY ShopName)  as R  FROM Shop
) t  WHERE R>100000 AND R<=100050

--OFFSET
SELECT ShopName FROM Shop ORDER BY ShopName
OFFSET 100000 ROW FETCH NEXT 50 ROW ONLY

B、.NET数据库操作（以OleDB为例）
1、建立连接：OleDbConnection
数据库初始化模版：
    public static string sql="";
    public static string strCon = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" + Application.StartupPath + "/default.mdb"; 
    public static OleDbConnection objConn = new OleDbConnection(strCon);
    public static OleDbDataAdapter dr=new OleDbDataAdapter(sql, objConn);

数据库操作前的初始化模版：
    ds.Clear();
    DataBind();


另：配置文件中设置连接字符串示例
此示例演示如何从配置文件中检索部分连接字符串并通过设置 SqlConnectionStringBuilder 的 DataSource、UserID 和 Password 属性完成该连接字符串。  配置文件定义如下。<configuration>
  <DbProviderFactories>
    <remove invariant="Npgsql" />
    <add name="Npgsql Data Provider" invariant="Npgsql" description=".Net Framework Data Provider for Postgresql Server" type="Npgsql.NpgsqlFactory, Npgsql" />
    <add name="SQLite Data Provider" invariant="System.Data.SQLite" description=".Net Framework Data Provider for SQLite" type="System.Data.SQLite.SQLiteFactory, System.Data.SQLite" />
    <add name="Informix Data Provider" invariant="IBM.Data.Informix" description=".Net Framework Data Provider for Informix" type="IBM.Data.Informix.IfxFactory, IBM.Data.Informix" />
    <add name="DB2 Data Provider" invariant="IBM.Data.DB2.iSeries" description=".Net Framework Data Provider for DB2 iSeries" type="IBM.Data.DB2.iSeries.DB2Factory, IBM.Data.DB2.iSeries" />
    <add name="Firebird Data Provider" invariant="FirebirdSql.Data.FirebirdClient" description="Firebird" type="FirebirdSql.Data.FirebirdClient.FirebirdClientFactory, FirebirdSql.Data.FirebirdClient"/>
    <add name="Oracle Data Provider" invariant="Oracle.DataAccess.Client" description=".Net Framework Data Provider for Oracle" type="Oracle.DataAccess.Client.OracleClientFactory, Oracle.DataAccess" />
  </DbProviderFactories>
  <connectionStrings>
    <clear/>
    <remove invariant="Npgsql"></remove>
    <add name="partialConnectString1" connectionString="Initial Catalog=Northwind;" providerName="System.Data.SqlClient" />
    <add name="partialConnectString2" connectionString="Data Source=|DataDirectory|School-Prod.sdf;" providerName="System.Data.SqlClient" />
  </connectionStrings>
<configuration>
要添加System.Configuration.dll引用 
private static void BuildConnectionString(string dataSource, string serverName, string userName, string userPassword)
{
    // Retrieve the partial connection string named databaseConnection
    // from the application's app.config or web.config file.
    ConnectionStringSettings settings = ConfigurationManager.ConnectionStrings["partialConnectString"];

    if (null != settings)
    {
        // Retrieve the partial connection string.
        string connectString = settings.ConnectionString;
        Console.WriteLine("Original: {0}", connectString);

        // Create a new SqlConnectionStringBuilder based on the
        // partial connection string retrieved from the config file.
        SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);

        // Supply the additional values.
        builder.DataSource = dataSource;
        builder.DataSource = serverName;
        builder.IntegratedSecurity = false;
        builder.UserID = userName;
        builder.Password = userPassword;
        Console.WriteLine("Modified: {0}", builder.ConnectionString);
    }

    //另用来连接Entity Data Model的连接字符串的生成
    EntityConnectionStringBuilder entityBuilder = new EntityConnectionStringBuilder();
    entityBuilder.Provider = providerName;
    entityBuilder.ProviderConnectionString = providerString;
    entityBuilder.Provider = providerName;
    entityBuilder.Metadata = "res://*/Modelmysample.csdl|res://*/Modelmysample.ssdl|res://*/Modelmysample.msl";
}




2、数据集：dataset
DataSet ds=new DataSet();
ds.Dispose();释放
ds.Clear();清空
ds.Reset();重置为其初始状态
ds.Tables["人员库"].Rows.Count.ToString();
dr.Fill(ds, "人员库");添加
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
        //将表"人员库"填入ds内，表取名为"人员"
        sql="select * from 人员库 order by ID";
        dr.SelectCommand.CommandText=sql;
        dr.Fill(ds, "人员");
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子

3、DataTable
自定义DataTable

    DataTable DT = new DataTable();
    DT.Columns.Add(new DataColumn("Category", typeof(string)));
    DT.Columns.Add(new DataColumn("Item", typeof(string)));
    DT.Columns.Add(new DataColumn("Rate", typeof(string)));
    
    DataRow dr = DT.NewRow();
    dr["Category"] = "";
    dr["Item"] = "";
    dr["Rate"] = "";
    DT.Rows.Add(_dr);
    

4、DataAdapter、OleDbDataAdapter 
OleDbDataAdapter dr=new OleDbDataAdapter(sql, objConn);
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
string sql="select * from 人员库 where ID = 1";
OleDbDataAdapter dr=new OleDbDataAdapter(sql, objConn);
sql="select * from 人员库 where ID = 2";
dr.SelectCommand.CommandText=sql;
dr.Fill(ds, "人员库表");
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
那么，ds中实际保存的还是"select * from 人员库 where ID = 1"的内容，而不是"select * from 人员库 where ID = 2"的内容。即每次想要变更dr的sql后，都需要重新定义一次dr，才能改变dr的sql。

----------------------------------------------------------------
DataAdapter使用的时候可以不显式的打开或关闭连接，这是因为DataAdapter能够自动的处理该任务。将数据记录Fill到DataSet前，会自动打开连接，操作完成后，连接会恢复到Fill之前的状态。
----------------------------------------------------------------

5、OleDbCommand、SqlCommand、OleDbSqlCommand 
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
    string sql = "update 当月数据 set 生产奖总额=26651 where 编号=1";
    OleDbCommand comm = new OleDbCommand(sql, objconn);
    comm.ExecuteNonQuery();
例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子例子
（1）ExecuteNonQuery() 方法
作用：执行SQL语句并返回命令影响的数据库行数，如不影响返回-1
int jl=comm.ExecuteNonQuery();
（2）ExecuteReader() 方法
作用：执行SQL语句并返回一个DataReader 
SqlDataReader reader = cmd.ExecuteReader
            if (reader.Read())
            {
                _info.Text = reader["title"].ToString();
            }
            reader.Close();
（3）ExecuteScalar() 方法
作用：执行SQL语句，返回首行首列，返回的类型为 object，所以在获取返回值时要对返回的对象进行类型转换
//执行查询并取出执行结果
int jl = (Int32)comm.ExecuteScalar();//关闭数据库连接
con.Close();
if (jl > 0) {}//如果查询结果大于零
（4）ExecuteXmlReader() 方法
作用：执行的 SQL SELECT 语句返回 XML 数据。



6、CommandBuilder
（1）概念
    SQl语句生成器，它在oleDb是一个叫做oleDbCommandBuilder的类，它能够根据DataAdapter的SelectCommand属性自动的生成InsertCommand，UpdateCommand与DeleteCommand，当然一个很重要的前提是数据库表要又主键，而且dataAdapter 的SelectCommand属性已被赋值。使用它大概需要一下的几个步骤：
  1）建立数据库连接MyConnection
  2）实例化OleDbDataAdapter对象
  3）建立一个DataSet对象，并把执行select语句得到的记录添加到其中 
  4）建立OleDbCommandBuilder对象！ 并让它与我们前面的OleDbDataAdapter对象关联！语句如下：OleDbCommandBuilder MyCommandBuild = new OleDbCommandBuilder(MyDataAdapter); 
  5）对DataSet中包含表的特定记录进行增加、删除、修改
  6）执行OleDbDataAdapter对象的Update命令更新数据库，语句如下： MyDataAdapter.Update(ds, "notes"); 
  7）关闭数据库连接
（2）使用条件
  1）要求表要有主键或只有一列。
  2）由于是自动生成更新语句，使用前要预先设定DataAdapter的select语句，并将之与CommandBuilder关联，以确定要进行处理的数据源。
（3）重新关联
    将 CommandBuilder 与 DataAdapter 关联后，可以重新定义sql命令，如 dr.SelectCommand.CommandText="select * from 人员库 order by ID"; ，但应用 CommandBuilder.RefreshSchema;方法来刷新由 CommandBuilder 用于自动生成命令的架构信息。
（4）解除关联
    如果调用 Dispose()，则会解除 SqlCommandBuilder 与 SqlDataAdapter 的关联，并且不再使用所生成的命令。一次只能将一个 SqlDataAdapter 与一个 SqlCommandBuilder 对象（或相反）互相关联。
    另外，将 CommandBuilder 与 DataAdapter 关联后，可以使用 Form1.dr.UpdateCommand = cmdbuilder.GetUpdateCommand() 获取相应的 Command 命令，之后系统就会自动把dr.UpdateCommand.CommandText填上。
（5）Update数据库的方法
1）通过OleDbCommand更新
通过comm执行.ExecuteNonQuery()语句，如更新
    OleDbCommand comm = new OleDbCommand(sql, objConn);
    comm.CommandText="update 当月数据 set 生产奖总额=26651 where 编号=1";
    objConn.Open();
    comm.ExecuteNonQuery();
    objConn.Close();
2）通过OleDbDataAdapter更新（将OleDbCommand传递给OleDbDataAdapter）
通过dr执行.ExecuteNonQuery()语句，如UpdateCommand更新
    string sql = "update 当月数据 set 生产奖总额=26651 where 编号=1";
    OleDbCommand comm = new OleDbCommand(sql, objConn);
    dr.UpdateCommand = comm;
    //此时也可以重新设置sql的值，如dr.UpdateCommand.CommandText="update 当月数据 set 生产奖总额=" + textBox1.Text;
    Form1.objConn.Open();
    dr.UpdateCommand.ExecuteNonQuery();
    Form1.objConn.Close();
3）通过将OleDbCommandBuilder与DataAdapter关联，自动生成update语句，实现将DataSet更新到数据库（要求表要有主键或只有一列）
    string sql = "select * from 人员库 where ID = 1";
    OleDbDataAdapter dr = new OleDbDataAdapter(sql, objConn);
    OleDbCommandBuilder cb = new OleDbCommandBuilder(dr);      //生成sql对应的CommandBuilder增、删、改命令
    
    //DataAdapter执行Update的时候，会检测作为参数的DataSet与数据库之间的差别，如果DataSet与数据库有改变，那就执行更新操作，否则就不会执行(执行了也没用)，所以，要看到Update的效果，就必须先改变DataSet里面的值
    DataSet ds = new DataSet();
    dr.Fill(ds);
    ds.Tables[0].Rows[0][0] = "test";
    dr.Update(ds, "人员库");
    
    //之后也可以重新设置sql的值，如dr.SelectCommand.CommandText="select * from 人员库 order by ID"; ，但应用CommandBuilder.RefreshSchema;方法来刷新由 CommandBuilder 用于自动生成命令的架构信息。
    dr.SelectCommand.CommandText="select * from 人员库 order by ID";
    cb.RefreshSchema();
    dr.Update(ds, "人员库");
————————————————————————————————
    string cmd = "select * from [" + sheetName + "]";    
    OleDbDataAdapter adapter = new OleDbDataAdapter(cmd, conn);    
    OleDbCommandBuilder cmdBuilder = new OleDbCommandBuilder(adapter);    
    cmdBuilder.QuotePrefix = "[";    
    cmdBuilder.QuoteSuffix = "]";    
    DataSet ds = new DataSet();    
    adapter.Fill(ds, "Table1");    
    
    CopyDataTable(dt, ds.Tables[0]);    
    
    adapter.Update(ds, "Table1");    
————————————————————————————————
※如需更新dataGrid1前提是：dataGrid1.DataSource=Chart.ds.Tables[0];//将dataGrid1与ds绑定（即dataGrid1上所显示即为实时的ds，再将ds更新到数据库）

（6）OleDbCommandBuilder详解
DataAdapter 的 Update 方法可调用来将DataSet中的更改解析回数据源
    OleDbDataAdapter 不会自动生成为了使对 DataSet 所作的更改和相关联的数据源协调起来所必须的 SQL 语句。但是，如果设置了 OleDbDataAdapter 的 SelectCommand 属性，那么就可以创建 OleDbCommandBuilder 对象，来自动生成 SQL 语句以更新单表。然后，OleDbCommandBuilder 将生成其他任何未设置的 SQL 语句。
    每当设置了 DataAdapter 属性，OleDbCommandBuilder 就将其本身注册为 RowUpdating 事件的侦听器。一次只能将一个 OleDbDataAdapter 与一个 OleDbCommandBuilder 对象（或相反）互相关联。
    为了生成 INSERT、UPDATE 或 DELETE 语句，OleDbCommandBuilder 会自动使用 SelectCommand 属性来检索所需的元数据集。如果在检索元数据后（例如在第一次更新后）更改 SelectCommand，则应调用 RefreshSchema 方法来更新元数据。
    OleDbCommandBuilder 还使用由 SelectCommand 引用的 Connection、CommandTimeout 和 Transaction 属性。如果修改了任何这些属性或者替换了 SelectCommand 本身，用户则应调用 RefreshSchema。否则，InsertCommand、UpdateCommand 和 DeleteCommand 属性都保留它们以前的值。
    如果调用 Dispose，则会解除 OleDbCommandBuilder 与 OleDbDataAdapter 的关联，并且不再使用所生成的命令。
    OleDbDataAdapter 不会自动生成为了使对 DataSet 所作的更改和相关联的数据源协调起来所必须的 SQL 语句。但是，如果设置了 OleDbDataAdapter 的 SelectCommand 属性，那么就可以创建 OleDbCommandBuilder 对象，来自动生成 SQL 语句以更新单表。然后，OleDbCommandBuilder 将生成其他任何未设置的 SQL 语句。
    每当设置了 DataAdapter 属性，OleDbCommandBuilder 就将其本身注册为 RowUpdating 事件的侦听器。一次只能将一个 OleDbDataAdapter 与一个 OleDbCommandBuilder 对象（或相反）互相关联。
    为了生成 INSERT、UPDATE 或 DELETE 语句，OleDbCommandBuilder 会自动使用 SelectCommand 属性来检索所需的元数据集。如果在检索元数据后（例如在第一次更新后）更改 SelectCommand，则应调用 RefreshSchema 方法来更新元数据。
    OleDbCommandBuilder 还使用由 SelectCommand 引用的 Connection、CommandTimeout 和 Transaction 属性。如果修改了任何这些属性或者替换了 SelectCommand 本身，用户则应调用 RefreshSchema。否则，InsertCommand、UpdateCommand 和 DeleteCommand 属性都保留它们以前的值。


7、SqlParameter
（1）准备：sql server中变量要先申明后赋值：
局部变量用一个@标识，全局变量用两个@(常用的全局变量一般都是已经定义好的);
申明局部变量语法：declare @变量名 数据类型;例如：declare @num int;
赋值：有两种方法式(@num为变量名，value为值)
set @num=value; 或 select @num=value;
如果想获取查询语句中的一个字段值可以用select给变量赋值，如下：
select @num=字段名 from 表名 where ……
mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以了。
第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量
第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where ……
注意上面两种赋值符号，使用set时可以用“=”或“:=”，但是使用select时必须用“:=赋值”
（2）使用方法
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
////实例化Command对象 
SqlConnection objConn = new SqlConnection("Data Source=(local);Initial Catalog=AspNetStudy;Persist Security Info=True;User ID=sa;Password=sa"
string sql="insert into temp_grc_time(grc_id, auto_timeout,upd_date) values (@grc_id,@auto_timeout,@upd_date)";
SqlCommand cmd = new SqlCommand(sql, objConn); 

////给Command对象添加查询参数
//※Value不能赋值为null，而应该用DBNull.Value代替，否则将抛出“过程或函数 'CheckDBNull' 需要参数 '@xxxx'，但未提供该参数。”的异常。
//.Net框架规定：IDataParameter在向服务器发送 null 参数值时，用户必须指定 DBNull，而不是 null。系统中的 null 值是一个没有值的空对象。DBNull 用于表示 null 值。
//DBNull和Null的区别，Null是.net中无效的对象引用；DBNull是一个类，DBNull.Value是它唯一的实例，它指数据库中数据为空(<NULL>)时，在.net中的值。
//第一种添加查询参数的例子（逐条添加）
        SqlParameter para = new SqlParameter("@grc_id", SqlDbType.Numeric, 10);
        para.Value = model.grc_id;
        cmd.Parameters.Add(para);
        
        para = new SqlParameter("@auto_timeout", SqlDbType.Numeric, 10);
        para.Value = model.auto_timeout;
        cmd.Parameters.Add(para);
        
        para = new SqlParameter("@upd_date", SqlDbType.TimestampTZ, 20);
        para.Value = DateTime.Now;
        cmd.Parameters.Add(para);

//第二种添加查询参数的例子（一次性添加）
        SqlParameter[] parameters = {
            new SqlParameter("@grc_id", SqlDbType.Numeric, 10),
            new SqlParameter("@auto_timeout", SqlDbType.Numeric, 10),
            new SqlParameter("@upd_date", SqlDbType.TimestampTZ, 20),
        };
        parameters[0].Value = model.grc_id;
        parameters[1].Value = model.auto_timeout;
        parameters[2].Value = DateTime.Now;
        cmd.Parameters.Add(parameters);//添加参数 

/////使用Command对象
//1（直接使用）
cmd.ExecuteNonQuery();
//2（当sql为insert时，可以通过DataAdapter将数据导入DataSet）
//实例化DataAdapter
SqlDataAdapter dr = new SqlDataAdapter(command);
dr.Fill(ds, "人员");
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

------------object obj = DbHelperSQL.GetSingle(strSql.ToString(), parameters);
----------hsTal.Add(strSql.ToString(), parameters);GrcDB.DbHelperSQL.ExecuteSqlTran(hsTal);
------------DbHelperSQL.ExecuteSql(strSql.ToString(), parameters);
            if (obj == null)
            {
                return 1;
            }
            else
            {
                return Convert.ToInt32(obj);
            }
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


8、SqlBulkCopy
SqlServer批量插入
    //源表sourceDT，目标表destinationTableName
    public void InsertByBulkCopy(DataTable sourceDT, string destinationTableName)
    {
        using (SqlConnection connection = new SqlConnection(_dbConnectionString))
        {
            connection.Open();
            using (SqlBulkCopy bulkcopy = new SqlBulkCopy(connection))
            {
                foreach (DataColumn col in sourceDT.Columns)
                {
                    bulkcopy.ColumnMappings.Add(new SqlBulkCopyColumnMapping(col.ColumnName, col.ColumnName));      //源列名，目标列名
                }

                bulkcopy.DestinationTableName = destinationTableName;                                               //目标表
                bulkcopy.WriteToServer(sourceDT);                                                                   //源表
            }
        }
    }


dapper批量插入
要用到DapperExtensions库，上码：
       /// <summary>  
       /// 批量插入功能  
       /// </summary>  
       public void InsertBatch<T>(IDbConnection conn, IEnumerable<T> entityList, IDbTransaction transaction = null) where T : class  
       {  
           var tblName = string.Format("dbo.{0}", typeof(T).Name);  
           var tran = (SqlTransaction)transaction;  
           using (var bulkCopy = new SqlBulkCopy(conn as SqlConnection, SqlBulkCopyOptions.TableLock, tran))  
           {  
               bulkCopy.BatchSize = entityList.Count();  
               bulkCopy.DestinationTableName = tblName;  
               var table = new DataTable();  
               DapperExtensions.Sql.ISqlGenerator sqlGenerator = new SqlGeneratorImpl(new DapperExtensionsConfiguration());  
               var classMap = sqlGenerator.Configuration.GetMap<T>();  
               var props = classMap.Properties.Where(x => x.Ignored == false).ToArray();  
               foreach (var propertyInfo in props)  
               {  
                   bulkCopy.ColumnMappings.Add(propertyInfo.Name, propertyInfo.Name);  
                   table.Columns.Add(propertyInfo.Name, Nullable.GetUnderlyingType(propertyInfo.PropertyInfo.PropertyType) ?? propertyInfo.PropertyInfo.PropertyType);  
               }  
               var values = new object[props.Count()];  
               foreach (var itemm in entityList)  
               {  
                   for (var i = 0; i < values.Length; i++)  
                   {  
                       values[i] = props[i].PropertyInfo.GetValue(itemm, null);  
                   }  
                   table.Rows.Add(values);  
               }  
               bulkCopy.WriteToServer(table);  
           }  
       }  

mysql批量插入
MySqlBulkLoader 

9、数据库Close与Dispose区别（与Stream不同）
SqlConnection conn = new SqlConnection("Data Source=.\\SQLExpress;Integrated Security=SSPI;"); 
conn.Open(); 
（1）
conn.Close(); 
conn.Open();// 成功 
（2）
conn.Dispose(); 
conn.Open(); // 出错
（3）
conn.Dispose(); 
conn.ConnectionString = "Data Source=.\\SQLExpress;Integrated Security=SSPI;"; 
conn.Open(); // 成功 

10、DataTable
DataTable
DataRowCollection:DataTable.Rows
DataRow:DataRowCollection[i]=DataTable.Rows[i]
string:DataRowCollection[i][j]=DataTable.Rows[i][j]

dt.Columns.Add("num", typeof(int));
DataRow dr=dt.NewRow();
dr[0]=1;


11、引用POSTGRESQL
（1）引用
First, in order to access Npgsql objects more easily (i.e. Intellisense in Visual Studio .Net), you need to instruct the compiler to use the Npgsql namespace. As you manipulate data retrieved by Npgsql, classes in System.Data will also be required. In C#, add this directive to the appropriate page or class:

using System.Data;
using Npgsql;
If you are using ASP.NET without code-behind files, you may need to add the following lines in top of your ASPX pages:

<%@ Assembly name="System.Data" %>
<%@ Assembly name="Npgsql" %>

（2）操作
To establish a connection to a server located at IP 127.0.0.1, port 5432, as user "joe", with password "secret", on database "joedata", open NpgsqlConnection with the following connection string:

using System;
using System.Data;
using Npgsql;

public class NpgsqlUserManual
{
  public static void Main(String[] args)
  {
    NpgsqlConnection conn = new NpgsqlConnection("Server=127.0.0.1;Port=5432;User Id=joe;Password=secret;Database=joedata;");
    conn.Open();
    conn.Close();
  }
}

12、Excel操作
Provider=Microsoft.Jet.OleDb.4.0;Data Source=Excel文件位置;Extended Properties='Excel 8.0;HDR=NO;'
在 Extended Properties 中，Excel 8.0 表示为版本号，Microsoft Jet 4.0 OLE DB Provider 支持 Excel 3.0，4.0，5.0，8.0 数据库类型。也就是说它不能连接 Excel 2007 的文件，对于 Excel 2007 文件，可以将其保存为 97-2003 的格式。
HDR=NO 表示 Excel 区域不包含标题，也就是说区域的第一行就是数据行，此时使用 F1 表示第一个字段，使用 F2 表示第二个字段，以此类推。


Provider=Microsoft.ACE.OLEDB.12.0;Data Source=Excel2007文件位置;Extended Properties='Excel 12.0;HDR=NO;'


方法一，使用 Excel 中的表名加美元符号。
使用 SQL 来操作 Excel 没有太多特殊的，但最特殊的一点是 SQL 语句 FROM 后面的表名
string sql = @"select * from [Sheet1$]";

方法二，在 Excel 中指定区域。
打开 Excel，选中要操作的一个或多个单元格，单击右键，单击“命名单元格区域”，假如我们将其命名为 Range1，在 SQL 语句中 Range1 就是表名了。
string sql = @"update [Range1] set F1='foo'";
执行上述语句后，区域 Range1 中的第一列内容就全部变成 foo 了。

方法三，在 SQL 语句中指定区域。
在 Excel 的表名后加美元符号，再加起始单元格编号，冒号，结束单元格编号。
string sql = @"update [Sheet1$C2:D10] set F1='foo'";
如果起始单元格和结束单元格相同，则表示只处理该单元格。


C、事务（TRANSACTION）
1、概念
（1）定义：数据库事务是指作为单个逻辑工作单元执行的一系列操作。
事务是一个不可分割的工作逻辑单元，在数据库系统上执行并发操作时事务是做为最小的控制单元来使用的。他包含的所有数据库操作命令作为一个整体一起向系提交或撤消，这一组数据库操作命令要么都执行，要么都不执行。
（2）功能
数据库事务正是用来保证这种情况下交易的平稳性和可预测性的技术。 
（3）特性
事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID(原子性、一致性、隔离性和持久性)属性： 
· 原子性 
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。 
· 一致性 
事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。 
· 隔离性 
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。 
· 持久性 
 事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。 
DBMS的责任和我们的任务 
    企业级的数据库管理系统（DBMS）都有责任提供一种保证事务的物理完整性的机制。就常用的SQL Server2000系统而言，它具备锁定设备隔离事务、记录设备保证事务持久性等机制。因此，我们不必关心数据库事务的物理完整性，而应该关注在什么情况下使用数据库事务、事务对性能的影响，如何使用事务等等。 

2、开发语言环境
（1）.net用法
在.net框架中主要有两个命名空间(namespace)用于应用程序同数据库系统的交互：System.Data.SqlClient和System.Data.OleDb。前者专门用于连接Microsoft公司自己的SQL Server数据库，而后者可以适应多种不同的数据库。这两个命名空间中都包含有专门用于管理数据库事务的类，分别是System.Data.SqlClient.SqlTranscation类和System.Data.OleDb.OleDbTranscation类。
步骤
  try
  {
     //建立连接并打开 
    SqlConnection myConn = GetConn(); 
    myConn.Open(); 
     //获得Transaction事务对象
     SqlTransaction myTran = myConn.BeginTransaction(); 
     //设置SqlCommand命令时，赋予Transaction事务对象
    myComm.Connection = myConn; 
    myComm.Transaction = myTran; 
     //进行数据库操作
     //定位到pubs数据库 
    myComm.CommandText = "USE pubs"; 
    myComm.ExecuteNonQuery();
    //更新数据，将所有的计算机类图书 
    myComm.CommandText = "UPDATE roysched SET royalty = royalty * 1.10 WHERE title_id LIKE 'Pc%'"; 
    myComm.ExecuteNonQuery(); 

    //提交事务 
    myTran.Commit(); 
  }
  catch
  {
    //数据库操作错误时，回滚Transaction事务对象
    myTran.Rollback();
  }
※回滚操作可利用Save设置存储点，利用Rollback回滚至该存储点
myTran.Save("NoUpdate"); 
myTran.Rollback("NoUpdate"); 

步骤
using (var scope = new TransactionScope())
{
    try
    {
        //...
        scope.Complete();
    }
    catch(Exception ex)
    {
        Transaction.Current.Rollback();
        Transaction.Current.Dispose();
    }
}


注意，如下的SQL语句不允许出现在事务中： 
ALTER DATABASE 修改数据库 
BACKUP LOG 备份日志 
CREATE DATABASE 创建数据库 
DISK INIT 创建数据库或事务日志设备 
DROP DATABASE 删除数据库 
DUMP TRANSACTION 转储事务日志 
LOAD DATABASE 装载数据库备份复本 
LOAD TRANSACTION 装载事务日志备份复本 
RECONFIGURE 更新使用 sp_configure 系统存储过程更改的配置选项的当前配置（sp_configure 结果集中的 config_value 列）值。 
RESTORE DATABASE 还原使用BACKUP命令所作的数据库备份 
RESTORE LOG 还原使用BACKUP命令所作的日志备份 
UPDATE STATISTICS 在指定的表或索引视图中，对一个或多个统计组（集合）有关键值分发的信息进行更新 



3、数据库环境
（1）postgresql用法
BEGIN;                                              --事务开始
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';
SAVEPOINT my_savepoint;                             --存储点
UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';
ROLLBACK TO my_savepoint;                           --回滚到存储点

-- ...

COMMIT;                                             --提交事务
ROLLBACK;                                           --整体回滚

（2）sqlserver用法
BEGIN TRAN[SACTION] [<transaction name> | <@transaction variable>]
COMMIT TRAN[SACTION] [<transaction name> | <@transaction variable>]
ROLLBACK TRAN[SACTION] [<transaction name> | <savepoint name> | <@transaction variable> | <@savepoint variable>]
SAVE TRAN[SACTION] [<savepoint name> | <@savepoint variable>]
WAITFOR DELAY '00:00:30' --等待30秒

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
 BEGIN TRANSACTION
    update ******
    delete *****
 commit TRANSACTION
 if @@error>0 
   begin
     rollback TRANSACTION 
     raiserror('产生异常',16,1)
     return
   end
 END

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

6、事务隔离级别
（1）现象
SQL 标准用三个必须在并发的事务之间避免的现像定义了四个级别的事务隔离。这些不希望发生的现像是：
I.脏读
一个事务读取了另一个未提交事务写入的数据。
例：
---------------------------------------------------------
实例A
begin tran
update table set money=103 where name='A'
waitfor delay '00:00:10'                            -- 等待10秒
update table set money=104 where name='A'
commit tran
实例B
set transaction isolation level read uncommitted
begin tran
select money from table where name='A'
commit tran
◆最终结果是103，而不是104，这就是脏数据，可知如果我们把第二个连接中的事务隔离级别设置为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ或者SERIALLZABLE就可以避免这种情况发生。
---------------------------------------------------------
II.不可重复读 
一个事务重新读取前面读取过的数据，发现该数据已经被另一个已提交事务修改。
---------------------------------------------------------
实例A
set transaction isolation level read committed
begin tran
select money from table where name='A'              -- 取到money!=10
waitfor delay '00:00:10'                            -- 等待10秒
select money from table where name='A'              -- 取到money==10
commit tran
实例B
begin tran
update table set money=10 where name='A'
commit tran
◆第一个连接中两次返回账号的余额不一样，第一次是100，第二次是10，这就是典型的“非重复读”，如果把事务的隔离级别设置为REPEATABLE READ或者SERIALLZABLE可以防止此类问题。
---------------------------------------------------------
III.幻读 
一个事务重新执行一个查询，返回一套符合查询条件的行，发现这些行因为其它最近提交的事务而发生了改变。
---------------------------------------------------------
实例A
begin tran
select * from table
waitfor delay '00:00:10'                            --等待10秒
select * from table
commit tran
实例B
begin tran
insert into table values(300,'a')
commit tran
◆两次查询的结果不一样，这就是典型的“幻象读”问题，可知解决方法为把隔离级别设置为SERIALLZABLE即可。
---------------------------------------------------------

（2）隔离级别
SQL 事务隔离级别
隔离级别                        脏读          不可重复读       幻读 
读未提交READ UNCOMMITTED        可能          可能             可能 
读已提交READ COMMITED           不可能        可能             可能 
可重复读REPEATABLE READ         不可能        不可能           可能 
可串行化SERIALLZABLE            不可能        不可能           不可能 


在 PostgreSQL 里，你可以请求四种可能的事务隔离级别中的任意一种。但是在内部，实际上只有两种独立的隔离级别，分别对应读已提交和可串行化。如果你选择了读未提交的级别，实际上你用的是读已提交，在你选择可重复读级别的时候，实际上你用的是可串行化，所以实际的隔离级别可能比你选择的更严格。这是 SQL 标准允许的：四种隔离级别只定义了哪种现像不能发生，但是没有定义那种现像一定发生。

D、锁
1.种类
I.大类
•共享锁、读锁、s锁（Shared Lock）：共享，只读。共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。
•排他锁、独占锁、写锁、x锁（Exclusive Lock）：独享，修改。独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，SQL Server 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。
•更新锁（Update Lock）：仅与共享锁共享，其他独享，只读。更新锁是为了防止死锁而设立的。当SQL Server 准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server 确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。 
•乐观锁（Optimistic Lock）：乐观锁假定在处理数据时，不需要在应用程序的代码中做任何事情就可以直接在记录上加锁、即完全依靠数据库来管理锁的工作。一般情况下，当执行事务处理时SQL Server会自动对事务处理范围内更新到的表做锁定。
•悲观锁（Pessimistic Lock）：悲观锁对数据库系统的自动管理不感冒，需要程序员直接管理数据或对象上的加锁处理，并负责获取、共享和放弃正在使用的数据上的任何锁。
★共享锁即在select 时自动产生，排它锁在insert，update以及delete时自动产生，而更新锁不会自动产生。更新锁的作用是防止多个事务执行同样的sql查询及修改导致的死锁，比如两个事务同时执行一个sql查询，而共享锁之间是兼容的，所以没问题，而其中一个事务执行完查询要更新语句，此时共享锁自动转化为排它锁，而此时另一个事务的查询还未结束，所以共享锁还在，而排它锁与共享锁不兼容，所以就无法转化为排它锁（此时仍然保持着共享锁，并没有释放《除非事务结束》），只能等到另一个事务结束后释放这个共享锁，可这个事务查询执行完后，也要执行更新语句及相关记录资源也要转换为排它锁，（实验证明任何锁在事务提交或回滚之前是不会释放的，不过可以相互转化！因为事务具有原子性！）而这个排它锁与另一个事务的共享锁同样不兼容，所以两个事务相互等待释放共享锁，而转换为排它锁来更新资源，就导致了死锁。更新锁可以避免这种死锁的产生，因为更新锁之间是不兼容的，所以一个事务获取了更新锁后，另一个事务就不能再获取更新锁了，不像共享锁可以同时获取，从而导致相互等待释放的后果，更新锁从开始就避免了同时锁定资源的可能性，所以完全避免了相互等待，也就完全避免了死锁！

II.小类
锁定提示                                 描述  
HOLDLOCK        将共享锁保留到事务完成，而不是在相应的表、行或数据页不再需要时就立即释放锁。HOLDLOCK 等同于 SERIALIZABLE。
NOLOCK          不要发出共享锁，并且不要提供排它锁。当此选项生效时，可能会读取未提交的事务或一组在读取中间回滚的页面。有可能发生脏读。仅应用于 SELECT 语句。等同于 READUNCOMMITTED。
PAGLOCK         在通常使用单个表锁的地方采用页锁。
READCOMMITTED   用与运行在提交读隔离级别的事务相同的锁语义执行扫描。默认情况下，SQL Server 2000 在此隔离级别上操作。
READPAST        跳过锁定行。此选项导致事务跳过由其它事务锁定的行（这些行平常会显示在结果集内），而不是阻塞该事务，使其等待其它事务释放在这些行上的锁。READPAST 锁提示仅适用于运行在提交读隔离级别的事务，并且只在行级锁之后读取。仅适用于 SELECT 语句。
READUNCOMMITTED 等同于 NOLOCK。
REPEATABLEREAD  用与运行在可重复读隔离级别的事务相同的锁语义执行扫描。
ROWLOCK         使用行级锁，而不使用粒度更粗的页级锁和表级锁。
SERIALIZABLE    用与运行在可串行读隔离级别的事务相同的锁语义执行扫描。等同于 HOLDLOCK。
TABLOCK         使用表锁代替粒度更细的行级锁或页级锁。在语句结束前，SQL Server 一直持有该锁。但是，如果同时指定 HOLDLOCK，那么在事务结束之前，锁将被一直持有。
TABLOCKX        使用表的排它锁。该锁可以防止其它事务读取或更新表，并在语句或事务结束前一直持有。
UPDLOCK         读取表时使用更新锁，而不使用共享锁，并将锁一直保留到语句或事务的结束。UPDLOCK 的优点是允许您读取数据（不阻塞其它事务）并在以后更新数据，同时确保自从上次读取数据后数据没有被更改。
XLOCK           使用排它锁并一直保持到由语句处理的所有数据上的事务结束时。可以使用 PAGLOCK 或 TABLOCK 指定该锁，这种情况下排它锁适用于适当级别的粒度


2.兼容性
锁兼容性控制多个事务能否同时获取同一资源上的锁。如果资源已被另一事务锁定，则仅当请求锁的模式与现有锁的模式相兼容时，才会授予新的锁请求。
首先，兼容性是针对不同事务的，一个事务就没有兼容性的概念了，类似于多线程与单线程，试想单线程还会有死锁吗，直接就转化了！
其中共享锁跟排它锁不兼容，而排它锁跟谁都不兼容，更新锁跟共享锁兼容，其他都不兼容。我想不兼容的锁相互等待就会导致死锁，也是死锁的唯一原因吧。

兼容性（简版）
------------------------------------
请求模式            IS S U IX SIX X
意向共享 (IS)        Y Y Y  Y  Y  N
共享 (S)             Y Y Y  N  N  N
更新 (U)             Y Y N  N  N  N
意向排他 (IX)        Y N N  Y  N  N
意向排他共享 (SIX)   Y N N  N  N  N
排他 (X)             N N N  N  N  N
------------------------------------

兼容性（完全版，使用下表可以确定 Microsoft SQL Server 2005 中所有可用的锁模式的兼容性。）
-----------------------------------------------------------------------------------------------------------------------------------------
        NL  SCH-S   SCH-M   S   U   X   IS  IU  IX  SIU SIX UIX BU  RS-S    RS-U    RI-N    RI-S    RI-U    RI-X    RX-S    RX-U    RX-X
NL       N      N       N   N   N   N    N   N   N    N   N   N  N     N       N       N       N       N       N       N       N       N
SCH-S    N      N       C   N   N   N    N   N   N    N   N   N  N     I       I       I       I       I       I       I       I       I
SCH-M    N      C       C   C   C   C    C   C   C    C   C   C  C     I       I       I       I       I       I       I       I       I
S        N      N       C   N   N   C    N   N   C    N   C   C  C     N       N       N       N       N       C       N       N       C
U        N      N       C   N   C   C    N   C   C    C   C   C  C     N       C       N       N       C       C       N       C       C
X        N      N       C   C   C   C    C   C   C    C   C   C  C     C       C       N       C       C       C       C       C       C
IS       N      N       C   N   N   C    N   N   N    N   N   N  C     I       I       I       I       I       I       I       I       I
IU       N      N       C   N   C   C    N   N   N    N   N   C  C     I       I       I       I       I       I       I       I       I
IX       N      N       C   C   C   C    N   N   N    C   C   C  C     I       I       I       I       I       I       I       I       I
SIU      N      N       C   N   C   C    N   N   C    N   C   C  C     I       I       I       I       I       I       I       I       I
SIX      N      N       C   C   C   C    N   N   C    C   C   C  C     I       I       I       I       I       I       I       I       I
UIX      N      N       C   C   C   C    N   C   C    C   C   C  C     I       I       I       I       I       I       I       I       I
BU       N      N       C   C   C   C    C   C   C    C   C   C  N     I       I       I       I       I       I       I       I       I
RS-S     N      I       I   N   N   C    I   I   I    I   I   I  I     N       N       C       C       C       C       C       C       C
RS-U     N      I       I   N   C   C    I   I   I    I   I   I  I     N       C       C       C       C       C       C       C       C
RI-N     N      I       I   N   N   N    I   I   I    I   I   I  I     C       C       N       N       N       N       C       C       C
RI-S     N      I       I   N   N   C    I   I   I    I   I   I  I     C       C       N       N       N       C       C       C       C
RI-U     N      I       I   N   C   C    I   I   I    I   I   I  I     C       C       N       N       C       C       C       C       C
RI-X     N      I       I   C   C   C    I   I   I    I   I   I  I     C       C       N       C       C       C       C       C       C
RX-S     N      I       I   N   N   C    I   I   I    I   I   I  I     C       C       C       C       C       C       C       C       C
RX-U     N      I       I   N   C   C    I   I   I    I   I   I  I     C       C       C       C       C       C       C       C       C
RX-X     N      I       I   C   C   C    I   I   I    I   I   I  I     C       C       C       C       C       C       C       C       C
图例：
N       不冲突
I       非法
C       冲突
NL      没有锁
SCH-S   架构稳定性锁
SCH-M   架构修改锁
S       共享
U       更新
X       排他
IS      意向共享
IU      意向更新
IX      意向排他
SIU     共享意向更新
SIX     共享意向排他
UIX     更新意向排他
BU      大容量更新
RS-S    共享范围-共享
RS-U    共享范围-更新
RI-N    插入范围-空
RI-S    插入范围-共享
RI-U    插入范围-更新
RI-X    插入范围-排他
RX-S    排他范围-共享
RX-U    排他范围-更新
RX-X    排他范围-Exclusive
-----------------------------------------------------------------------------------------------------------------------------------------

3.nolock、readpast
nolock只适用于select语句
（1）打开两个查询窗口：其中一个执行下面语句：
create table a (id int ,name nvarchar(20))
go
begin tran
insert a values ('1','a')               --开启一个事务，而不提交也不回滚，此时insert 语句产生的排它锁是不会释放的
（2）在另一个窗口中执行：
select COUNT(*) from a with(nolock)     --无锁查询，会查出结果为1，先设置「事务隔离级别」为可「脏读 (dirty read)」，类似于SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;SELECT * FROM Orders WHERE OrderID=10248;
select COUNT(*) from a with(readpast)   --忽略所有有锁的记录，此时为0
然后执行select * from a --此时是查不出结果的，会无限地等待下去，因为排它锁未释放，默认查询的共享锁与之不兼容，所以就一直等待排它锁的释放，才会返回结果，即使表中已有许多数据，而排它锁只锁了一条记录，但是，查询语句也要等待这一条记录的锁的释放，才会返回结果。 这便是人工手动设置的因为排它锁未释放而导致的死锁（不是相互等待，而是一方无尽的等待！）。



nolock和with(nolock)的几个小区别：
1:SQL05中的同义词，只支持with(nolock);
2:with(nolock)的写法非常容易再指定索引。
跨服务器查询语句时不能用with (nolock) 只能用nolock，同一个服务器查询时则with (nolock)和nolock都可以用，比如
select * from [IP].a.dbo.table1 with (nolock) 这样会提示用错误
select * from a.dbo.table1 with (nolock) 这样就可以




4.锁超时
SET LOCK_TIMEOUT 5000
select @@LOCK_TIMEOUT

LOCK_TIMEOUT 0      #如果你希望当不能获得锁时进程立即中止
LOCK_TIMEOUT -1     #如果你想要将timeout重新置为无限期




如果请求锁资源超时的话，语句将会中止，你将得到以下Error Message：
Server: Msg 1222, Level 16, State 52, Line 1
Lock request time out period exceeded.







SELECT.... FOR UPDATE [OF cols] [NOWAIT/WAIT] [SKIP LOCKED]
 OF cols：只锁定指定字段所在表的RS，而没有指定的表则不会锁定，只会在多表联合查询时出现；
 NOWAIT：语句不会hold，而是直接返回错误ORA-00054: resource busy and acquire with NOWAIT specified；
 WAIT N：语句被hold N秒，之后返回错误ORA-30006: resource busy; acquire with WAIT timeout expired；
 SKIP LOCKED：不提示错误，而是直接返回no rows selected；
 以上几个选项可以联合使用的，比较推荐的有：
 SELECT.... FOR UPDATE NOWAIT：对同一RS执行该SQL时，直接返回错误；
 SELECT.... FOR UPDATE NOWAIT SKIP LOCKED：对同一RS执行该SQL时，直接返回空行；
 PS：当RS被LOCK住之后，只对同样请求LOCK的语句有效，对无需LOCK的SELECT语句并没有任何影响； 


•共享锁（表级锁）
―锁定表 
―仅允许其他用户执行查询操作，不允许执行插入、更新和删除操作 
―多个用户可以同时在同一表中放置此锁 
―排他锁与此相反
― lock table table_name in share mode [nowait]; 
― rollback 和commit 命令释放锁 
― [nowait|wait n] 关键字告诉其他用户不用等待或等待n秒 


•排他锁（表级锁）
―锁定表 
―仅允许其他用户执行查询操作，不允许执行插入、更新和删除操作 
―在同一时间仅允许一位用户在表上放置排他锁，共享锁与此相反
―共享锁与此相反
― lock table table_name in exclusive mode [nowait]; 

 
•共享更新锁（行级锁）
―锁定要被更新的行，防止其他用户在更新之前操作此行
―允许其他用户同时查询、插入、更新未被锁定的行 
―允许多个用户同时锁定表的不同行 
―在 SELECT 语句中使用“FOR UPDATE”子句，可以强制使用共享更新锁 
― lock table table_name in share update mode [nowait]; 
― select * from goods where gid=1001 for update [of column1, column2] 

5.其它
SELECT * FROM sys.dm_tran_locks         --查询整个数据库的锁定和阻塞详细信息：
sp_lock                                 --查询当前加锁信息
sp_lock 88                              --查询88线程的加锁信息
KILL 53                                 --杀进程


E、函数
1.
2.
3.建立自定义函数
（1）标量函数
create function ret1()
returns int
as
begin
declare @a int=1;
return @a;
end
go

（2）标量函数
create function F_Round2(@goal decimal(30, 10))
returns decimal(30, 2)
as
begin
return CAST(ROUND(@goal, 2) as decimal(30, 2))
end

（3）表值函数
create function F_鼎信区域日收入情况(@year int)
returns table
as
return(
            select *
            from  mytable
)

（4）表值函数
在返回table的函数中执行sql语句
CREATE FUNCTION [dbo].[INSERTINTO] 
(
    @a int,
    @b varchar(1000)
)
RETURNS @temp Table
(
    ID int IDENTITY PRIMARY KEY,
    Name varchar(1000)
)
AS
BEGIN
    Declare @intLen = LEN(@b)
    If(@intLen > 2)
    Begin
        Insert Into @temp (ID, Name) values (@a, @b)
    End
    return
END



F、存储过程（SQL Server为例）
1、概念
SQL Server提供了一种方法，它可以将一些固定的操作集中起来由SQL Server数据库服务器来完成，以实现某个任务，这种方法就是存储过程。

2、优点
1．存储过程的优势
（1） 能实现模块化程序设计。存储过程是根据实际功能的需要创建的一个程序模块，并被存储在数据库中。以后用户要完成该功能，只要在程序中直接调用该存储过程即可，而无需再编写重复的程序代码。存储过程可由数据库编程方面的专门人员创建，并可独立于程序源代码而进行修改和扩展。
（2） 使用存储过程可以提高执行效率。由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。
当客户程序需要访问服务器上的数据时，一般要经过5个步骤：
 ● 查询语句被发送到服务器；
 ● 服务器编译T-SQL语句；
 ● 优化产生查询执行计划；
 ● 数据库引擎执行查询；
 ● 执行结果发回客户程序。
如果执行存储在客户端本地的T-SQL程序，那么每次执行该程序时，对于程序中的每一条语句都要经过以上5个步骤。而存储过程在创建时就被编译和优化，当存储过程第一次被执行时，SQL Server为其产生查询计划并将其保存在内存中，这样以后在调用该存储过程时就不必再进行编译，即以上5个步骤中的第2步和第3步就被省略了，这能大大改善系统的性能。
（3） 减少网络流量。一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信速率。一个需要数百行T-SQL代码的操作，如果将其创建成存储过程，那么使用一条调用存储过程的语句就可完成该操作。这样就可避免在网络上发送数百行代码，从而减少了网络负荷。
（4） 可作为安全机制使用。通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。管理员可以不授予用户访问存储过程中涉及的表的权限，而只授予执行存储过程的权限。这样，既可以保证用户通过存储过程操纵数据库中的数据，又可以保证用户不能直接访问存储过程中涉及的表。用户通过存储过程来访问表，所能进行的操作是有限制的，从而保证了表中数据的安全性。

3、各种操作
（1）切换数据库
use [myDataBase]
go

（2）判断是否存在
if exists(select name from sysobjects where name='sp_show' and type='P')
drop procedure sp_show

（3）建立存储过程
1）不返回
create procedure sp_name
@param varchar(50)
as
begin
  ...
end


2）返回值类型
create procedure sp_name
@param varchar(50)
as
begin
  return @param
end

declare @show varchar(50)
exec @show=sp_name 'ab'
print @show


3）返回表类型
create procedure sp_name
@param table
as
begin
  exec ('select * from ...')        --不需要加return
  return (select * from...)
end

declare @t table
exec @t=sp_show 'ab'


4、例
use [dbt]
go

print 'Then we will create a procedure.'
go

if exists(select name from sysobjects where name='sp_show' and type='P')
drop procedure sp_show
go

create procedure sp_show
@content varchar(10)
as
begin
  declare @str varchar(10)=@content
  print @str
  declare @lenno int=len(@tmp)
  if @lenno>5 print 'more than 5'
  else if @lenno=5 print 'equal to 5'
  else if @lenno=0 print 'no string'
  else print 'less than 5'
  --declare @str int=(select count(*) from xxtable)
  return @lenno
end




use dbt
go

declare @dd int
exec @dd=sp_show 'ab'
print @dd
go


5、if语法
if @a is not null and @a=1
  begin
    --
  end
else
  begin
    --
  end

¤三元表达式：
    select case when 1<2 then 'yes' else 'no' end





6、while语法
    while @F_利润最早年<=@F_利润当前年
    begin
      exec sp1_睿信年利润各分类 @F_利润最早年
      set @F_利润最早年=@F_利润最早年+1

      BREAK
      CONTINUE
    end
    waitfor delay '00:00:01' --每隔一秒再执行 可用参数变量替换

★在带有游标的过程中使用 WHILE
以下的 WHILE 结构是名为 count_all_rows 过程中的一部分。下例中，该 WHILE 结构测试用于游标的函数 @@FETCH_STATUS 的返回值。因为 @@FETCH_STATUS 可能返回 –2、-1 或 0，所以，所有的情况都应进行测试。如果某一行在开始执行此存储过程以后从游标结果中删除，将跳过该行。成功提取 (0) 后将执行 BEGIN...END 循环内部的 SELECT 语句。
USE pubs
DECLARE tnames_cursor CURSOR
FOR
    SELECT TABLE_NAME 
    FROM INFORMATION_SCHEMA.TABLES
OPEN tnames_cursor
DECLARE @tablename sysname
--SET @tablename = 'authors'
FETCH NEXT FROM tnames_cursor INTO @tablename
WHILE (@@FETCH_STATUS <> -1)
BEGIN
    IF (@@FETCH_STATUS <> -2)
    BEGIN    
       SELECT @tablename = RTRIM(@tablename) 
       EXEC ('SELECT ''' + @tablename + ''' = count(*) FROM ' 
             + @tablename )
       PRINT ' '
   END
    FETCH NEXT FROM tnames_cursor INTO @tablename
END
CLOSE tnames_cursor
DEALLOCATE tnames_cursor









DECLARE @CategoryName NVCHAR(255), @KindName NVARCHAR(255, @FruitName NVARCHAR(255))

DECLARE cursor_fruit CURSOR FOR
 SELECT [CategoryName], [KindName], [FruitName]
 FROM [dbo].[udf_Fruit]

OPEN cursor_fruit
  FETCH NEXT FROM cursor_fruit
  INTO @CategoryName, @KindName, @FruitName

  WHILE @@FETCH_STATUS = 0
  BEGIN
    PRINT @CategoryName + ' ' + @KindName + ' ' + @FruitName
    FETCH NEXT FROM cursor_fruit
    INTO @CategoryName, @KindName, @FruitName
  END
CLOSE cursor_fruit

DEALLOCATE cursor_fruit

木本落叶果树 仁果类果树 苹果
木本落叶果树 仁果类果树 梨
木本落叶果树 仁果类果树 海棠果
木本落叶果树 仁果类果树 山楂
木本落叶果树 仁果类果树 木瓜
木本落叶果树 核果类果树 桃
木本落叶果树 核果类果树 李
木本落叶果树 核果类果树 杏
木本落叶果树 核果类果树 樱桃
木本落叶果树 浆果类果树 猕猴桃
木本落叶果树 浆果类果树 树莓
木本落叶果树 浆果类果树 石榴
木本落叶果树 浆果类果树 葡萄
木本落叶果树 坚果类果树 核桃
木本落叶果树 坚果类果树 板栗
木本落叶果树 坚果类果树 榛子
木本落叶果树 坚果类果树 银杏
木本落叶果树 柑果类果树 柿
木本落叶果树 柑果类果树 枣
木本落叶果树 柑果类果树 柑
木本落叶果树 柑果类果树 橘
木本落叶果树 柑果类果树 橙
木本落叶果树 柑果类果树 柚








------------------------------------------------
truncate table TestP
declare @index int
set @index=0
while (@index<100000)
begin
   ...
   set @index=@index+1
end
commit
------------------------------------------------
7、获取最后id值
返回上面操作的数据表最后row的IDENTITY 列的值；
select SCOPE_IDENTITY() as id       --仅限{}内
select id = SCOPE_IDENTITY()        --仅限{}内
select @@identity                   --全局的，整个数据库
SELECT @@ROWCOUNT                   --全局的，整个数据库

G、开发
1.POSTGRESQL
POSTGRESQL备份、还原功能
    //构建执行的命令
    StringBuilder sbcommand = new StringBuilder();
    sb.AppendFormat("\"D:\\Program Files\\PostgreSQL\\9.1\\bin\\pg_dump.exe\" -h 10.192.122.201 -p 5432 -U postgres -Ft -b -v -f {0}", "D:\\backup.tar");
    String command = sbcommand.ToString();
    //获取pg_dump.exe所在路径
    String appDirecroty = @"C:\Program Files\pgsql\bin";
    StartCmd(appDirecroty, command);
    string backtime = time.ToString("yyyy年MM月dd日HH点mm分ss秒");
    string sql = "insert into backup(version, date, path)values('1.0.7','" + backtime + "','" + path2 + "')";
    MainFrmClient mfClient = new MainFrmClient();
    mfClient.ExecSql(sql);
    DataBind();
    MessageBox.Show("恭喜，备份成功！");





//数据库还原
    OpenFileDialog file = new OpenFileDialog();
    file.Title = "打开文件";
    file.Filter = "备份文件(*.backup)|";
    file.InitialDirectory = "D:\\backup\\"; //默认路径
    file.Multiselect = false;
    if (file.ShowDialog() == DialogResult.OK)
    {
        //构建执行的命令
        StringBuilder sbcommand = new StringBuilder();
        sbcommand.AppendFormat("pg_restore.exe -h localhost -p 5556 -U pgs -d test -v \"{0}\"", file.FileName);
        String command = sbcommand.ToString();
        //获取pg_dump.exe所在路径
        String appDirecroty = @"C:\Program Files\pgsql\bin";
        StartCmd(appDirecroty, command);
        MessageBox.Show("恭喜，还原成功！");
    }

2..net中使用
    using (SqlConnection connection = new SqlConnection(ConnStr))
    {
        DataSet dataResult = new DataSet();
        SqlDataAdapter adapter = new SqlDataAdapter();
        adapter.SelectCommand = new SqlCommand(queryString, connection);
        adapter.SelectCommand.CommandType = CommandType.StoredProcedure;
        adapter.SelectCommand.CommandTimeout = 3600;
        adapter.SelectCommand.Parameters.AddRange(Params);
        adapter.Fill(dataResult);
        return dataResult;
    }




H、连接池
1、起源
    数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。
  很多人认为SqlConnection的连接是不耗时的，理由是循环执行SqlConnection.Open得到的平均时间几乎为0，但每次首次open时，耗时又往往达到几个毫秒到几秒不等，这又是为什么呢？
    首先我们看一下 MSDN 上的权威文档上是怎么说的
    Connecting to a database server typically consists of several time-consuming steps. A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.
    以上摘自 http://msdn.microsoft.com/en-us/library/8xx3tyca%28VS.80%29.aspx
也就是说物理连接建立时，需要做和服务器握手，解析连接字符串，授权，约束的检查等等操作，而物理连接建立后，这些操作就不会去做了。这些操作是需要一定的时间的。所以很多人喜欢用一个静态对象存储 SqlConnection 来始终保持物理连接，但采用静态对象时，多线程访问会带来一些问题，实际上，我们完全不需要这么做，因为 SqlConnection 默认打开了连接池功能，当程序 执行  SqlConnection.Close 后，物理连接并不会被立即释放，所以这才出现当循环执行 Open操作时，执行时间几乎为0。
2、概念
数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量?使用情况，为系统开发?测试及性能调整提供依据。
3、原理
    连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。
4、连接池的分配与释放
    连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。
对于连接的管理可使用空闲池。即把已经创建但尚未分配出去的连接按创建时间存放到一个空闲池中。每当用户请求一个连接时，系统首先检查空闲池内有没有空闲连接。如果有就把建立时间最长(通过容器的顺序存放实现)的那个连接分配给他(实际是先做连接是否有效的判断，如果可用就分配给用户，如不可用就把这个连接从空闲池删掉，重新检测空闲池是否还有连接);如果没有则检查当前所开连接池是否达到连接池所允许的最大连接数(maxConn)，如果没有达到，就新建一个连接，如果已经达到，就等待一定的时间(timeout)。如果在等待的时间内有连接被释放出来就可以把这个连接分配给等待的用户，如果等待时间超过预定时间timeout，则返回空值(null)。系统对已经分配出去正在使用的连接只做计数，当使用完后再返还给空闲池。对于空闲连接的状态，可开辟专门的线程定时检测，这样会花费一定的系统开销，但可以保证较快的响应速度。也可采取不开辟专门线程，只是在分配前检测的方法。

5、举例
string connectionString = "Data Source=192.168.10.2; Initial Catalog=News; Integrated Security=True;Pooling=False;";
SqlConnection 默认是打开连接池的，如果要强制关闭，我们需要在连接字符串中加入 Pooling=False
关闭连接池后，平均每次连接大概要耗时4个毫秒左右，这个就是建立物理连接的平均耗时。
打开连接池后，第一次耗时是119ms，首次执行的时间变成了0ms，这说明连接池机制发生了作用，SqlConnection Close 后，物理连接并没有被关闭，所以10秒后再执行，连接几乎没有用时间。
但我们发现一个有趣的现象，10分钟后，首次连接时间变成了6ms，这个和前面不打开连接池的测试用时几乎一样，也就是说10分钟后，物理连接被关闭了。那么我们有没有办法始终保持物理连接呢？方法是有的。连接池设置中有一个最小连接池大小，默认为0，我们把它设置为大于0的值就可以保持若干物理连接始终不释放了。
其实只要在连接字符串中加入一个 Min Pool Size=n 就可以了。
当 Min Pool Size = 1  时，除了首次连接用时5ms以外，即便过了10分钟，用时还是0ms，物理连接没有被关闭。

注：在IIS中将对应的应用程序池的Process Model/Idle Time-out(minutes)设置为0。默认为20分钟，如果此时间内没有访问，IIS将回收应用程序池，相当于应用程序被重启，所有全局变量，session，物理连接都将被清空。

ConnectionCount < Min Pool Size
是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；
复用原有的物理连接，断开后，连接不被释放

ConnectionCount : [Min Pool Size，Max Pool Size]
创建一个新的物理连接，断开后，不立即释放，等待被复用，如果在timeout内仍未被再次连接，则释放

ConnectionCount > Max Pool Size
是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作
等待分配一个连接，不会创建连接



I、序列
1、创建
CREATE SEQUENCE -- 定义一个新序列发生器
语法
CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]
    [ OWNED BY { table.column | NONE } ]
参数
TEMPORARY 或 TEMP ：如果声明了这个修饰词，那么该序列对象只为这个会话创建，并且在会话结束的时候自动删除。在临时序列存在的时候，除非用模式修饰的名字引用，否则同名永久序列是不可见的(在同一会话里)。
name ：将要创建的序列名(可以用模式修饰)
increment ：可选子句 INCREMENT BY increment 指定序列的步长。一个正数将生成一个递增的序列，一个负数将生成一个递减的序列。缺省值是 1 。
minvalue ：NO MINVALUE（默认） 可选的子句 MINVALUE minvalue 指定序列的最小值。如果没有声明这个子句或者声明了 NO MINVALUE ，那么递增序列的缺省为 1 ，递减序列的缺省为 -263-1 。
maxvalue ：NO MAXVALUE（默认） 可选的子句 MAXVALUE maxvalue 指定序列的最大值。如果没有声明这个子句或者声明了 NO MAXVALUE ，那么递增序列的缺省为 263-1 ，递减序列的缺省为 -1 。
start ：可选的子句 START WITH start 指定序列的起点。缺省初始值对于递增序列为 minvalue ，对于递减序列为 maxvalue 。
cache ：可选的子句 CACHE cache 为快速访问而在内存里预先存储多少个序列号。最小值(也是缺省值)是 1 ，表示一次只能生成一个值，也就是说没有缓存。
CYCLE ：NO CYCLE CYCLE（默认） 选项可用于使序列到达 maxvalue 或 minvalue 时可循环并继续下去。也就是如果达到极限，生成的下一个数据将分别是 minvalue 或 maxvalue 。
如果声明了 NO CYCLE ，那么在序列达到其最大值之后任何对 nextval 的调用都强返回一个错误。如果既没有声明 CYCLE 也没有声明 NO CYCLE ，那么 NO CYCLE 是缺省。
OWNED BY table.column
OWNED BY NONE 
OWNED BY 选项将序列关联到一个特定的表字段上。这样，在删除那个字段或其所在表的时候将自动删除绑定的序列。指定的表和序列必须被同一个用户所拥有，并且在在同一个模式中。默认的 OWNED BY NONE 表示不存在这样的关联。
例：
创建一个叫 serial 的递增序列，从 101 开始：
CREATE SEQUENCE serial START 101;
从 105 重新开始一个叫 serial 的序列：
ALTER SEQUENCE serial RESTART WITH 105;

2、函数
函数 返回类型 描述 
nextval(regclass) bigint 递增序列并返回新值 
currval(regclass) bigint 返回最近一次用nextval获取的指定序列的数值 
lastval() bigint 获取最近一次用 nextval 拿到的数值 
setval(regclass, bigint) bigint 设置序列的当前数值 
setval(regclass, bigint, boolean) bigint 设置序列的当前数值以及 is_called 标志 


J、OID
PostgreSQL在内部使用对象标识符(OID)作为各种系统表的主键。同时，系统不会给用户创建的表增加一个 OID 系统字段(除非在建表时声明了 WITH OIDS 或者配置参数 default_with_oids 设置为开启)。oid 类型代表一个对象标识符。除此以外 oid 还有几个别名：regproc, regprocedure, regoper, regoperator, regclass, regtype 。表8-19显示了概览。
目前 oid 类型用一个四字节的无符号整数实现。因此，它不够提供大数据库范围内的唯一性保证，甚至在单个的大表中也不行。因此，我们不鼓励在用户创建的表中使用 OID 字段做主键。OID 最好只是用于系统表。
OID 别名类型除了输入和输出过程之外没有自己的操作。这些过程可以为系统对象接受和显示符号名，而不仅仅是类型 oid 将要使用的行数值。别名类型允许我们简化为对象查找 OID 值的过程。比如，检查和一个表 mytable 相关的 pg_attribute 行，我们可以这样写

SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
而不用
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');


K、索引
（1）介绍
    索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引可快速访问数据库表中的特定信息。
（2）索引组成
·SQL Server中的数据也是按页（8KB）存放  
·索引：是SQL Server编排数据的内部方法。它为SQL Server提供一种方法来编排查询数据。 
·索引页：数据库中存储索引的数据页；索引页类似于汉语字（词）典中按拼音或笔画排序的目录页。 
·索引的作用：通过使用索引，可以大大提高数据库的检索速度，改善数据库性能。 
（3）索引类型
SQL SERVER中有多种索引类型。
按存储结构区分：“聚集索引（又称聚类索引，簇集索引）”，“分聚集索引（非聚类索引，非簇集索引）”
按数据唯一性区分：“唯一索引”，“非唯一索引”
按键列个数区分：“单列索引”，“多列索引”。

·唯一索引：唯一索引不允许两行具有相同的索引值 
唯一索引不允许两行具有相同的索引值。 
如果现有数据中存在重复的键值，则大多数数据库都不允许将新创建的唯一索引与表一起保存。当新数据将使表中的键值重复时，数据库也拒绝接受此数据。例如，如果在stuInfo表中的学员员身份证号(stuID)列上创建了唯一索引，则所有学员的身份证号不能重复。 
提示：创建了唯一约束，将自动创建唯一索引。尽管唯一索引有助于找到信息，但为了获得最佳性能，建议使用主键约束或唯一约束。

·主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 
在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。 

聚集索引为物理索引、非聚集索引为逻辑索引，聚集索引为数据的存储顺序，非聚集索引是逻辑索引既对聚集索引的索引
这里解释下：查询中用到的列无论是一列还是多列不在索引覆盖范围查询开销基本上一样，每条记录均只需要一次书签查找开销，不会说因为查询3只有一个Age列，查询4有Age、Gender、CreateTime 3列不在索引覆盖范围而导致额外的开销　

（数据信息以索引字段顺序，物理连续存放）
·聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 
在聚集索引中，表中各行的物理顺序与键值的逻辑（索引）顺序相同。表只能包含一个聚集索引。例如：汉语字（词）典默认按拼音排序编排字典中的每页页码。拼音字母a，b，c，d……x，y，z就是索引的逻辑顺序，而页码1，2，3……就是物理顺序。默认按拼音排序的字典，其索引顺序和逻辑顺序是一致的。即拼音顺序较后的字（词）对应的页码也较大。如拼音“ha”对应的字(词)页码就比拼音“ba”对应的字(词)页码靠后

聚集索引是一种对磁盘上实际数据重新组织以按指定的一列或多列值排序。像我们用到的汉语字典，就是一个聚集索引，比如要查“张”，我们自然而然就翻到字典的后面百十页。然后根据字母顺序跟查找出来。这里用到微软的平衡二叉树算法，即首先把书翻到大概二分之一的位置，如果要找的页码比该页的页码小，就把书向前翻到四分之一处，否则，就把书向后翻到四分之三的地方，依此类推，把书页续分成更小的部分，直至正确的页码。
由于聚集索引是给数据排序，不可能有多种排法，所以一个表只能建立一个聚集索引。科学统计建立这样的索引需要至少相当与该表120%的附加空间，用来存放该表的副本和索引中间页，但是他的性能几乎总是比其它索引要快。
由于在聚集索引下，数据在物理上是按序排列在数据页上的，重复值也排在一起，因而包含范围检查（bentween,<,><=,>=）或使用group by 或order by的查询时，一旦找到第一个键值的行，后面都将是连在一起，不必在进一步的搜索，避免啦大范围的扫描，可以大大提高查询速度。


（通过行与索引字段的映射关系表进行查询）
·非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 
如果不是聚集索引，表中各行的物理顺序与键值的逻辑顺序不匹配。聚集索引比非聚集索引（nonclustered index）有更快的数据访问速度。例如，按笔画排序的索引就是非聚集索引，“1”画的字（词）对应的页码可能比“3”画的字（词）对应的页码大（靠后）。 
提示：SQL Server中，一个表只能创建1个聚集索引，多个非聚集索引。设置某列为主键，该列就默认为聚集索引 


sqlserver默认情况下建立的索引是非聚集索引，他不重新组织表中的数据，而是对每一行存储索引列值并用一个指针指向数据所在的页面。他像汉语字典中的根据‘偏旁部首’查找要找的字，即便对数据不排序，然而他拥有的目录更像是目录，对查取数据的效率也是具有的提升空间，而不需要全表扫描。
一个表可以拥有多个非聚集索引，每个非聚集索引根据索引列的不同提供不同的排序顺序。




（2）格式
CREATE [UNIQUE] [CLUSTERED| NONCLUSTERED ]
INDEX index_name ON { table | view } ( column [ ASC | DESC ] [ ,...n ] )
[with[PAD_INDEX][[,]FILLFACTOR=fillfactor]
 [[,]IGNORE_DUP_KEY]
 [[,]DROP_EXISTING]
 [[,]STATISTICS_NORECOMPUTE]
 [[,]SORT_IN_TEMPDB]
]
[ ON filegroup ]
说明：
CREATE INDEX命令创建索引各参数说明如下：
UNIQUE：用于指定为表或视图创建唯一索引，即不允许存在索引值相同的两行。
CLUSTERED：用于指定创建的索引为聚集索引。
NONCLUSTERED：用于指定创建的索引为非聚集索引。
index_name：用于指定所创建的索引的名称。
table：用于指定创建索引的表的名称。
view：用于指定创建索引的视图的名称。
ASC|DESC：用于指定具体某个索引列的升序或降序排序方向。
Column：用于指定被索引的列。
PAD_INDEX：用于指定索引中间级中每个页（节点）上保持开放的空间。
FILLFACTOR = fillfactor：用于指定在创建索引时，每个索引页的数据占索引页大小的百分比，fillfactor的值为1到100。
IGNORE_DUP_KEY：用于控制当往包含于一个唯一聚集索引中的列中插入重复数据时SQL Server所作的反应。
DROP_EXISTING：用于指定应删除并重新创建已命名的先前存在的聚集索引或者非聚集索引。
STATISTICS_NORECOMPUTE：用于指定过期的索引统计不会自动重新计算。
SORT_IN_TEMPDB：用于指定创建索引时的中间排序结果将存储在 tempdb 数据库中。
ON filegroup：用于指定存放索引的文件组。








CREATE UNIQUE INDEX name ON table (column [, ...]);
一旦你创建了索引，那么就不需要更多干涉了：当系统认为用索引比顺序的表扫描快的时候它就会使用索引。不过你可能必须经常性地运行 ANALYZE 命令以更新统计信息，好让查询规划器能够做出有训练有素的判断。




例：
CREATE TABLE test1 (
    id integer,
    content varchar
);
SELECT content FROM test1 WHERE id = constant;
    通常，数据库系统不得不一行一行地扫描整个 test1 表以寻找所有匹配的记录。如果在 test1 里面有许多行，但是只返回少数几行(可能是零行或一行)，那么上面这个方法可就很差劲了。
    如果我们让数据库系统在 id 列上维护一个索引用于定位匹配的行。这样，数据库系统只需要在搜索树中走少数的几层就可以找到匹配行。
CREATE INDEX test1_id_index ON test1 (id);索引名字 test1_id_index 可以自由选择，但是应该选那些稍后可以让你回忆起索引含义的名字。
CREATE CLUSTERED INDEX test1_id_index ON test1 (id);





（3）管理索引
Exec sp_helpindex BigData   --查看索引定义
Exec sp_rename 'BigData.idx_mobiel','idx_big_mobiel'  --将索引名由'idx_mobiel' 改为'idx_big_mobiel'
drop index BigData.idx_big_mobiel  --删除bigdata表中的idx_big_mobiel索引
dbcc showcontig(bigdata,idx_mobiel) --检查bigdata表中索引idx_mobiel的碎片信息
dbcc indexdefrag(Test,bigdata,idx_mobiel)  --整理test数据库中bigdata表的索引idx_mobiel上的碎片
update statistics bigdata  --更新bigdata表中的全部索引的统计信息
----------------------------------
--查询某一张表的索引

SELECT   索引名称=a.name  
,表名=c.name  
,索引字段名=d.name  
,索引字段位置=d.colid  
FROM   sysindexes   a  
JOIN   sysindexkeys   b   ON   a.id=b.id   AND   a.indid=b.indid  
JOIN   sysobjects   c   ON   b.id=c.id  
JOIN   syscolumns   d   ON   b.id=d.id   AND   b.colid=d.colid  
WHERE   a.indid   NOT IN(0,255)  
-- and   c.xtype='U'   and   c.status>0 --查所有用户表  
AND   c.name='message' --查指定表  
ORDER BY   c.name,a.name,d.name 
----------------------------------

（4）索引的设计原则
对于一张表来说索引的有无和建立什么样的索引，要取决与where字句和Join表达式中。
<1>索引应选择既不太多、也不太少的键，最好能把数据均匀的分成若干份。当以此索引作为查询条件时，即可缩小查询的范围。
<2>对某个键创建的索引，会加速对该键的查询，对其它查询没有帮助。
<3>系统一般会给主键字段自动建立聚集索引。
<4>有大量重复值且经常有范围查询和排序、分组的列，或者经常频繁访问的列，考虑建立聚集索引。
<5>在一个经常做插入操作的表中建立索引，应使用fillfactor(填充因子)来减少页分裂，同时提高并发度降低死锁的发生。如果在表为只读表，填充因子可设为100.
<6>在选择索引键时，尽可能采用小数据类型的列作为键以使每个索引页能容纳尽可能多的索引键和指针，通过这种方式，可使一个查询必需遍历的索引页面降低到最小，此外，尽可能的使用整数做为键值，因为整数的访问速度最快。


（5）修改SQL Server索引种子
方式一
DBCC CHECKIDENT
(
  table_name
  [, { NORESEED | { RESEED [,new_reseed_value ] } } ]
 )
 [ WITH NO_INFOMSGS ]

参数：
table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。
NORESEED:指定不应更改当前标识值。
RESEED:指定应该更改当前标识值。
new_reseed_value:用作标识列的当前值的新值。
WITH NO_INFOMSGS:取消显示所有信息性消息。

dbcc checkident('[datacenter].[dbo].[SearchLog]',noreseed)
dbcc checkident('[datacenter].[dbo].[SearchLog]',reseed,1)

方式二
print IDENT_SEED('table')       --获取种子值
print IDENT_INCR('table')       --获取自增量
print IDENT_CURRENT('table')    --获取最后生成的标识值

L、分区（分表、分库）
1.概念及作用
    一般情况下，我们建立数据库表时，表数据都存放在一个文件里。
    但是如果是分区表的话，表数据就会按照你指定的规则分放到不同的文件里，把一个大的数据文件拆分为多个小文件，还可以把这些小文件放在不同的磁盘下由多个cpu进行处理。这样文件的大小随着拆分而减小，每个分区可以单独管理，可以不依赖其他分区而单独发挥作用，还得到硬件系统的加强，自然对我们操作数据是大大有利的。
    所以大数据量的数据表，对分区的需要还是必要的，因为它可以提高select效率，还可以对历史数据经行区分存档等。但是数据量少的数据就不要凑这个热闹啦，因为表分区会对数据库产生不必要的开销，除啦性能还会增加实现对象的管理费用和复杂性。
    但是分区表只能把数据分散到同一机器的不同磁盘中，也就是还是依赖于一个机器，不能从根本上解决问题。理想的解决办法是把数据分散到不同的机器中，通过多个机器上的CPU,I/O的并行处理来提高性能。

2.步骤
（1）创建文件组
alter database <数据库名> add filegroup <文件组名>
（2）创建数据文件，并添加到文件组
alter database <数据库名称> add file <数据标识> to filegroup <文件组名称>
--<数据标识> （name:文件名，fliename:物理路径文件名，size:文件初始大小kb/mb/gb/tb，filegrowth:文件自动增量kb/mb/gb/tb/%,maxsize:文件可以增加到的最大大小kb/mb/gb/tb/unlimited）
（3）创建分区函数
create partition function 分区函数名(<分区列类型>) as range [left/right] for values (每个分区的边界值,....) 
（4）创建分区方案
create partition scheme <分区方案名称> as partition <分区函数名称> [all]to (文件组名称,....) 
（5）创建分区索引
--创建分区索引语法
create <索引分类> index <索引名称> 
on <表名>(列名)
on <分区方案名>(分区依据列名)
（6）创建分区表
create table <表名> (
  <列定义>
)on<分区方案名>(分区列名)

3.实例
（0）创建数据库
create database testSplit
（1）创建文件组
alter database testSplit add filegroup ByIdGroup1
alter database testSplit add filegroup ByIdGroup2
alter database testSplit add filegroup ByIdGroup3
（2）创建数据文件，并添加到文件组
alter database testSplit add file (name=N'ById1',filename=N'J:\Work\数据库\data\ById1.ndf',size=5Mb,filegrowth=5mb) to filegroup ByIdGroup1
alter database testSplit add file (name=N'ById2',filename=N'J:\Work\数据库\data\ById2.ndf',size=5Mb,filegrowth=5mb) to filegroup ByIdGroup2
alter database testSplit add file (name=N'ById3',filename=N'J:\Work\数据库\data\ById3.ndf',size=5Mb,filegrowth=5mb) to filegroup ByIdGroup3
（3）创建分区函数
CREATE PARTITION FUNCTION [bgPartitionFun](int) AS RANGE LEFT FOR VALUES (N'1000000', N'2000000', N'3000000')
（4）创建分区方案
CREATE PARTITION SCHEME [bgPartitionSchema] AS PARTITION [bgPartitionFun] TO ([PRIMARY], [ByIdGroup1], [ByIdGroup2], [ByIdGroup3])
（5）创建分区索引
CREATE CLUSTERED INDEX [ClusteredIndex_on_bgPartitionSchema_635342971076448165] ON [dbo].[BigOrder] 
(
    [OrderId]
)WITH (SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF) ON [bgPartitionSchema]([OrderId])
（6）创建分区表
create table BigOrder (
   OrderId              int                  identity,
   orderNum             varchar(30)          not null,
   OrderStatus          int                  not null default 0,
   OrderPayStatus       int                  not null default 0,
   UserId               varchar(40)          not null,
   CreateDate           datetime             null default getdate(),
   Mark                 nvarchar(300)        null
)on bgPartitionSchema(OrderId)

M、分片
    Sharding不是一个某个特定数据库软件附属的功能，而是在具体技术细节之上的抽象处理，是水平扩展(Scale Out，亦或横向扩展、向外扩展)的解决方案，其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。
1.应用场景
    任何技术都是在合适的场合下能发挥应有的作用。 Sharding 也一样。联机游戏、IM、BSP 都是比较适合 Sharding 的应用场景。其共性是抽象出来的数据对象之间的关联数据很小。比如IM ，每个用户如果抽象成一个数据对象，完全可以独立存储在任何一个地方，数据对象是 Share Nothing 的；再比如 Blog 服务提供商的站点内容，基本为用户生成内容(UGC)，完全可以把不同的用户隔离到不同的存储集合，而对用户来说是透明的。
    这个"Share Nothing" 是从数据库集群中借用的概念，举例来说，有些类型的数据粒度之间就不是 "Share Nothing" 的，比如类似交易记录的历史表信息，如果一条记录中既包含卖家信息与买家信息，如果随着时间推移，买、卖家会分别与其它用户继续进行交易，这样不可避免的两个买卖家的信息会分布到不同的 Sharding DB 上，而这时如果针对买卖家查询，就会跨越更多的 Sharding ，开销就会比较大。
    Sharding 并不是数据库扩展方案的银弹，也有其不适合的场景，比如处理事务型的应用就会非常复杂。对于跨不同DB的事务，很难保证完整性，得不偿失。所以，采用什么样的 Sharding 形式，不是生搬硬套的。
    我们知道每台机器无论配置多么好它都有自身的物理上限，所以当我们应用已经能触及或远远超出单台机器的某个上限的时候，我们惟有寻找别的机器的帮助或者继续升级的我们的硬件，但常见的方案还是横向扩展, 通过添加更多的机器来共同承担压力。我们还得考虑当我们的业务逻辑不断增长，我们的机器能不能通过线性增长就能满足需求？Sharding可以轻松的将计算，存储，I/O并行分发到多台机器上，这样可以充分利用多台机器各种处理能力，同时可以避免单点失败，提供系统的可用性，进行很好的错误隔离。 
    综合以上因素，数据切分是很有必要的，且我们在此讨论的数据切分也是将MySql作为背景的。基于成本的考虑，很多公司也选择了Free且Open的MySql。对MySql有所了解的开发人员可能会知道，MySQL 5 之后才有了数据表分区功能，那么在此之前，很多 MySQL 的潜在用户都对 MySQL 的扩展性有所顾虑，而是否具备分区功能就成了衡量一个数据库可扩展性与否的一个关键指标(当然不是唯一指标)。数据库扩展性是一个永恒的话题，MySQL 的推广者经常会被问到：如在单一数据库上处理应用数据捉襟见肘而需要进行分区化之类的处理，是如何办到的呢? 答案也是Sharding，也就是我们所说的数据切分方案。 
    我们用免费的MySQL和廉价的Server甚至是PC做集群，达到小型机+大型商业DB的效果，减少大量的资金投入，降低运营成本，何乐而不为呢？所以，我们选择Sharding，拥抱Sharding。 

2.分割技术（也包括分区）
·垂直分割就是按列进行分割，即把一条记录分开多个地方保存，每个子表的行数相同。
例如表T1，可以把id和name放到数据文件p1，把qty放到数据文件p2。

·水平分割就是按记录进分分割，不同的记录可以分开保存，每个子表的列数相同。
像表T1，可以把id为单数的放到数据文件P1，双数的放到数据文件P2

·表散列与水平分割相似，但没有水平分割那样的明显分割界限，
它由哈希函数和键值决定一条记录的保存文件，这样是为了IO更加均衡。

3.Sharding与数据库分区(Partition)的区别
　　有的时候，Sharding 也被近似等同于水平分区(Horizontal Partitioning)，网上很多地方也用水平分区来指代 Sharding，但我个人认为二者之间实际上还是有区别的。的确，Sharding 的思想是从分区的思想而来，但数据库分区基本上是数据对象级别的处理，比如表和索引的分区，每个子数据集上能够有不同的物理存储属性，还是单个数据库范围内的操作，而 Sharding 是能够跨数据库，甚至跨越物理机器的

            Sharding                    Partition
存储依赖  可跨越DB、物理机器        可跨越空间、不同的无理属性
数据划分  常见为时间、范围、面向服务等  范围、Hash、列表、混合分区
存储方式  分布式                     集中式
扩展性    Scale Out                    Scale Up
可用性    无单点                      存在单点（DB本身）
价格      低廉                         适中（DAS）昂贵（SAN）
应用场景  常见于Web2.0网站              传统网站


N、触发器
在一个 PL/pgSQL 函数当做触发器调用的时候，系统会在顶层的声明段里自动创建几个特殊变量。有如下这些：
NEW 
数据类型是 RECORD ；该变量为行级触发器中的 INSERT/UPDATE 操作存储新数据行。在语句级别的触发器里，这个变量是 NULL 。
OLD 
数据类型是 RECORD ；该变量为行级触发器中的 UPDATE/DELETE 操作存储旧数据行。在语句级别的触发器里，这个变量是 NULL 。
TG_NAME 
数据类型是 name ；该变量包含实际触发的触发器名。
TG_WHEN 
数据类型是 text ；是一个由触发器定义决定的字符串(BEFORE 或 AFTER)。
TG_LEVEL 
数据类型是 text ；是一个由触发器定义决定的字符串(ROW 或 STATEMENT)。
TG_OP 
数据类型是 text；是一个说明激活触发器的操作的字符串(INSERT, UPDATE, DELETE)。
TG_RELID 
数据类型是 oid ；是激活触发器调用的表的对象标识(OID)。
TG_RELNAME 
数据类型是 name ；是激活触发器调用的表的名称。反对使用，并会在将来的版本中消失，推荐使用 TG_TABLE_NAME 。
TG_TABLE_NAME 
数据类型是 name ；是激活触发器调用的表的名称。
TG_TABLE_SCHEMA 
数据类型是 name ；是激活触发器调用的表的模式。
TG_NARGS 
数据类型是 integer ；是在 CREATE TRIGGER 语句里面赋予触发器过程的参数的个数。
TG_ARGV[] 
数据类型是 text 的数组；是 CREATE TRIGGER 语句里的参数。下标从 0 开始记数。非法下标(小于 0 或者大于等于 tg_nargs)导致返回一个 NULL 值。
一个触发器函数必须返回 NULL 或者是一个与激活触发器运行的表的记录/行结构完全相同的数据。

因 BEFORE 触发的行级别触发器可以返回一个 NULL ，告诉触发器管理器忽略对该行剩下的操作，也就是说，随后的触发器将不再执行，并且不会对该行产生 INSERT/UPDATE/DELETE 动作)。如果返回了一个非 NULL 的行，那么将继续对该行数值进行处理。请注意，返回一个和原来的 NEW 不同的行数值将修改那个将插入或更新的行(不过在 DELETE 的情况下无效)。可以用一个值直接代替 NEW 里的某个数值并且返回之，或者也可以构建一个全新的记录/行再返回。
BEFORE 或 AFTER 语句级别的触发器，或者一个 AFTER 行级别的触发器的返回值将总是被忽略；它们也可以返回 NULL 来忽略返回值。不过，任何这种类型的触发器仍然可以通过抛出一个错误来退出整个触发器操作。

例1. 一个 PL/pgSQL 触发器过程
下面的示例触发器的作用是：任何时候表中插入或更新了行，当前的用户名和时间都记录入行中。并且它保证给出了雇员名称并且薪水是一个正数。
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- 检查是否给出了 empname 和 salary
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- 必须付帐给谁?
        IF NEW.salary < 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- 记住何时何人的薪水被修改了
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;
CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();


例2. 一个用于审计的 PL/pgSQL 触发器过程
一个向表里记录变化的方法涉及创建一个新表，然后为后来发生的每次插入、更新或者删除动作保存一行。这个方法可以当作对一个表的审计。例37-3显示了一个 PL/pgSQL 写的审计触发器过程的例子。
这个例子触发器保证了在 emp 表上的任何插入、更新、删除动作都被记录到了 emp_audit 表里(也就是审计)。当前时间和用户名会被记录到数据行里，以及还有执行的操作。
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit( 
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- 在 emp_audit 里创建一行，反映对 emp 的操作，
        -- 使用特殊变量 TG_OP 获取操作类型。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();



例3. 一个维护概要表的 PL/pgSQL 触发器过程
触发器的一个用途是维持另外一个表的概要。生成的概要可以用于在某些查询中代替原始表(通常可以大大缩小运行时间)。这个技巧经常用于数据仓库，这个时候，需要测量的表(叫事实表)可能会非常巨大。例37-4演示了一个 PL/pgSQL 触发器过程的例子，它为某个数据仓库的一个事实表维护一个概要表。
下面的模式有一部分是基于 The Data Warehouse Toolkit 里面的 Grocery Store 例子。
--
-- 主表-时间维以及销售事实。
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);
CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12, 2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12, 2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);
--
-- 摘要表-根据时间的销售。
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15, 2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15, 2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);
--
-- 在 UPDATE, INSERT, DELETE 的时候根新概要字段的函数和触发器。
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15, 2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15, 2);
    BEGIN
        -- 计算增/减量。
        IF (TG_OP = 'DELETE') THEN
            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;
        ELSIF (TG_OP = 'UPDATE') THEN
            -- 禁止改变 time_key 的更新(可能并不是很强制，因为 DELETE + INSERT 是大多数可能产生的修改)。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -> % not allowed', OLD.time_key, NEW.time_key;
            END IF;
            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;
        ELSIF (TG_OP = 'INSERT') THEN
            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;
        END IF;
        -- 用新数值插入或更新概要行。
        <<insert_update>>
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;
            EXIT insert_update WHEN found;    
            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key, 
                            amount_sold, 
                            units_sold, 
                            amount_cost)
                    VALUES ( 
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );
                EXIT insert_update;
            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- 什么也不做
            END;
        END LOOP insert_update;

        RETURN NULL;
    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;
CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();
INSERT INTO sales_fact VALUES(1, 1, 1, 10, 3, 15);
INSERT INTO sales_fact VALUES(1, 2, 1, 20, 5, 35);
INSERT INTO sales_fact VALUES(2, 2, 1, 40, 15, 135);
INSERT INTO sales_fact VALUES(2, 3, 1, 10, 1, 13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;


O、性能
0.统计
set statistics time on
  --...
set statistics time off

消息：
------------------------------------------
SQL Server 分析和编译时间: 
   CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。

 SQL Server 执行时间:
   CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。
SQL Server 分析和编译时间: 
   CPU 时间 = 3 毫秒，占用时间 = 3 毫秒。

(18 行受影响)

 SQL Server 执行时间:
   CPU 时间 = 0 毫秒，占用时间 = 6 毫秒。
------------------------------------------

1.select * from TableX where id in ('1,2,3,4')
=>select * From TableX where id in (select id from TableY)
in后面尽量避免字符串形式，应将其转化为Table类型

2.select * from TableX where price * 0.8 > 80
=>select * from TableX where price > 80 / 0.8
避免在where条件中对字段进行计算（包括函数操作）

3.select * from Table
=>select id, sex, age, name from Table
避免使用select *无用字段

4.select * from Table
=>select * from Table with(nolock)
尽量使用with(nolock)无锁查询

5.select * from Table height > 1.5 and birthday = '2013-01-01'
=>select * from Table birthday = '2013-01-01' and height > 1.5
sql server的查询条件执行顺序为从左至右，所以应把能够过滤更多顺序的条件放在前面。（Oracle是从右至左）

6.select job, avg(sal) from emp group by job having job='PRESIDENT' or job='MANAGER'
=>select job, avg(sal) from emp where job='PRESIDENT' or job='MANAGER' group by job
先筛选缩小数据范围，再做查询

7.select * from TableX where TableX.id in (select id from TableY)
=>select * from TableX where exists (select id from TableY where TableX.Id = TableY.Id)
使用exists代替in，大体上效率排序exists>in>join

100.处理百万级以上数据提高查询速度的方法
(1)应考虑在where条件涉及的列上建立索引，避免全表扫描
(2)避免在where子句中使用!=或<>操作符，避免全表扫描
(3)避免在where子句中对字段进行null值判断，避免全表扫描
(4)避免在where子句中使用or来连接条件，避免全表扫描
(5)避免使用like,in
(6)避免使用大事务操作，提高并发能力



P、其它
1.SQL2008关于c001f011的错误解决办法
从 ICLassFactory 为CLSID为{17BCA6E8-A95D-497E-B2F9-AF6AA475916F}的COM组件创建实例失败，原因是出现以下错误：c001f011.(Microsoft.SqlServer.ManagedDTS)
解决方法：
(x86)
c:\windows\system32\regsvr32 "C:\Program Files\Microsoft SQL Server\100\DTS\Binn\dts.dll"
(x64)
c:\windows\syswow64\regsvr32 "C:\Program Files (x86)\Microsoft SQL Server\100\DTS\Binn\dts.dll"


2.Web.config中连接字符串加密的方法
◆加密EncryptWebConfig.bat
@echo off
C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis.exe -pef "connectionStrings" "D:\Program Files\Microsoft\.NET Pet Shop 4.0\Web"
PAUSE
◆解密DecryptWebConfig.bat
@echo off
C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis.exe -pdf "connectionStrings" "D:\Program Files\Microsoft\.NET Pet Shop 4.0\Web"
PAUSE

其中，"connectionStrings"是加密或解密结点的名称，"D:\Program Files\Microsoft\.NET Pet Shop 4.0\Web"是Web.config所在位置

2.临时表
临时表：表名前使用一个#号，临时表是局部的，使用两个#号，临时表是全局的，在断开连接后sql会自动删除。
select name from tempdb.dbo.sysobjects where type='u' and name like '#table_睿信季度收入各分类同环比%'
select * from dbo.sysobjects where id = object_id(N'[#table_睿信季度收入各分类同环比]') and OBJECTPROPERTY(id, N'IsUserTable') = 1
这时候你会看到所有的临时表，不过这里的名称一般是你设定的临时表名开头后边有一串________________0000000000132这样的字符，这是为了避免多用户使用同一临时表名时发生冲突。

3.权限
以下语句可查看所有权限，如建表，删表等。
SELECT * FROM fn_builtin_permissions(default);

4.三种东西永远不要放到数据库里
（1）图片，文件，二进制数据
问题：
对数据库的读/写的速度永远都赶不上文件系统处理的速度
数据库备份变的巨大，越来越耗时间
对文件的访问需要穿越你的应用层和数据库层
方案：
（2）短生命期数据
方案：
使用redis，statsd/graphite， Riak，它们都是干这种事情更合适的工具
（3）日志文件
问题：
争夺用户需要的数据库资源
方案：
不要把日志数据和产品数据存放到一个数据库里
使用一些比如Splunk Loggly或纯文本文件来存放你的日志数据


5.锁信息
SELECT * FROM sys.dm_tran_locks         --查询整个数据库的锁定和阻塞详细信息：
sp_lock                                 --查询当前加锁信息
sp_lock 88                              --查询88线程的加锁信息
KILL 53                                 --杀进程



6.统计信息
set statistics time on
  --...
set statistics time off

消息：
------------------------------------------
SQL Server 分析和编译时间: 
   CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。

 SQL Server 执行时间:
   CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。
SQL Server 分析和编译时间: 
   CPU 时间 = 3 毫秒，占用时间 = 3 毫秒。

(18 行受影响)

 SQL Server 执行时间:
   CPU 时间 = 0 毫秒，占用时间 = 6 毫秒。
------------------------------------------

7.
var arrs= ['test1','test2','test3'];  
var instring = "'"+arrs.join("','")+"'";  
var sql = "select * from table where CreateUser in ("+instring+")";  
select * from table where CreateUser in ('test1','test2','test3')  

8.正在执行的sql语句
select text from sys.dm_exec_requests er cross apply  sys.dm_exec_sql_text(er.sql_handle)

9.@@IDENTITY与SCOPE_IDENTITY()
·SELECT @@IDENTITY
·SELECT SCOPE_IDENTITY()
@@IDENTITY and SCOPE_IDENTITY return the last identity value generated in any table in the current session. However, SCOPE_IDENTITY returns the value only within the current scope; @@IDENTITY is not limited to a specific scope.
∴还是SCOPE_IDENTITY()更安全


十一、ASP.NET功能
O、预编译原理
1.动态编译
以编码方式部属站点，当访问一个页面时，会编译该页面所在目录的所有文件，编译生成的文件默认生成于以下路径：
%SystemRoot%\Microsoft.NET\Framework\v2.0.50727\Temporary ASP.NET Files
也可在web.config中指定生成位置：
<compilation tempDirectory="d:\MyTempFiles" />

在ASP.NET 1.x时代，Web page采用的是aspx + code behind的模式，实质上aspx和Code behind是一种继承的关系：
aspx文件：
    <!-- Codebehind值表示对应的Code behind文件，Inherits值表示对应的Code behind类 -->
    <%@ Page Language="C#" AutoEventWireup="false" Codebehind="Default.aspx.cs" Inherits="_Default" %>
aspx.cs文件：
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
        }
        protected void btnRefresh_Click(object sender, EventArgs e)
        {
            this.Response.Write("The click event of \"Refresh\" button is fired");
        }
    }


A、System.Text
比如System.Text.Encoding.Default或者System.Text.Encoding.UTF8

Random rd = new Random(Guid.NewGuid().GetHashCode())
rd.Next();


GetHashCode()





B、System.IO.File（包含System.Windows.Forms中的）
1、FileDialog
（1）打开File
using System.Windows.Forms;
OpenFileDialog OF=new OpenFileDialog();     //声明OpenFileDialog
OF.InitialDirectory=                        //设置OpenFileDialog初始路径
OF.Filter="XLS数据库|*.XLS|所有文件|*.*";   //设置OpenFileDialog打开文件的类型
if(OF.ShowDialog().ToString()=="OK")
if(OF.ShowDialog().ToString()=="Cancel")    //取得OpenFileDialog的返回值"OK"、"Cancel"
OF.FileName                                 //OpenFileDialog所选文件名（文件全名，包括全路径）


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    private void button4_Click(object sender, System.EventArgs e)
    {
        OleDbDataAdapter dr=new OleDbDataAdapter(sql, Form1.objConn);
        OpenFileDialog OF=new OpenFileDialog();
        OF.InitialDirectory=Application.StartupPath;
        OF.Filter="XLS数据库|*.XLS|所有文件|*.*"; 
    }
    System.IO.Path.GetFileName(OF.FileName);
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



（2）File另存为
using System.Windows.Forms;
SaveFileDialog SF=new SaveFileDialog();     //声明SaveFileDialog
SF.InitialDirectory=                        //设置SaveFileDialog初始路径
SF.Filter="MDB数据库|*.MDB|所有文件|*.*";   //设置SaveFileDialog保存文件的类型
if(SF.ShowDialog().ToString()=="OK")
if(SF.ShowDialog().ToString()=="Cancel")    //取得SaveFileDialog的返回值"OK"、"Cancel"
SF.FileName                                 //SaveFileDialog所选文件名（文件全名，包括全路径）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    private void menuItem7_Click(object sender, System.EventArgs e)
    {
        
        SaveFileDialog SF=new SaveFileDialog();                 //声明一个SaveFileDialog保存对话框
        SF.InitialDirectory=Application.StartupPath;            //设置SaveFileDialog对话框的初始路径
        SF.Filter="MDB数据库|*.MDB|所有文件|*.*";               //设置SaveFileDialog保存文件的类型            
        if (SF.ShowDialog().ToString()=="OK")                   //取得SaveFileDialog的返回值            
        {
            if (System.IO.Path.GetFileName(SF.FileName)=="default.mdb") MessageBox.Show("正在使用此文件！");
            else
            {
                System.IO.Path.GetFileName(SF.FileName);
                System.IO.File.Copy("default.mdb", SF.FileName, true);
            }
        }

    }
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

2、File上传
FileUpload控件
.aspx
runat="server"是有区别的.使用了runat="server"的form编译后，action必定是指向本身的网页。而没
有加runat="server"的form可以指向一个网页。
<！--如果file框没有加runat="server"，则form里一定要加上 enctype="multipart/form-data"这样才可以实现上传文件到服务器;使用了server和没有使用  -->
    <form name="form1" method="post" enctype="multipart/form-data" action="requestfile/asprece.aspx">
        <input type="file" runat="server" name="file1" style="width:160px;" />
        或<asp:FileUpload runat="server" ID="file1" />
        <input type="submit" name="Submit" value="添加" />
    </form>
.cs
      HttpPostedFile fp= this.file_fileload.PostedFile;
      HttpPostedFile fp= Request.Files["file1"];
      if (this.file_fileload.HasFile)
      {
          string filename = System.IO.Path.GetFileName(fp.FileName);
          string pPath = System.IO.Path.Combine(this.Server.MapPath("~/Pad/Image/padbg/"), "id.txt");
          fp.SaveAs(pPath);
      }
    使用FileUpload控件上传文件时对文件大小的限制可以在配置文件中配置。具体配置在System.Web配置节中添加< httpRuntime maxRequestLength = " 10240 " /> 即可。maxRequestLength:指示 ASP.NET 支持的最大的上载文件的大小。该限制可用于防止用户向服务器张贴容量过大的文件而导致拒绝服务。所指定的大小以 KB 为单位。默认值为4096 KB (4 MB)。



3、File文件操作
using System.IO;
File.Copy("default.mdb", SF.FileName, true);          //将default.mdb复制为SF.FileName，覆盖
File.Move("default.mdb", SF.FileName, true);          //将default.mdb移动为SF.FileName
if(File.Exists("c:/abc.txt"))          //判断文件是否存在
File.Delete("c:/abc.txt")          //删除文件
File.GetAttributes
File.GetCreationTime
File.GetLastAccessTime
File.GetLastWriteTime
File.SetAttributes("c:/abc.txt", FileAttributes.Normal);   //取消文件的属性
File.SetCreationTime
File.SetLastAccessTime
File.SetLastWriteTime

File.Open  //返回一个FileStream
File.OpenRead  //返回一个FileStream
File.OpenWrite  //返回一个FileStream
File.OpenText  //返回一个StreamReader
File.ReadAllText  //返回一个string
File.ReadAllLines  //返回一个string[]
File.ReadAllBytes  //返回一个byte[]
File.
File.
File.

FileInfo fi=new FileInfo("c:\\1.txt");
fi.Attributes
fi.CopyTo("destFileName", overwrite)
fi.Create();  //返回一个FileStream
fi.CreateText()  //返回一个StreamWrite
fi.CreationTime
fi.Delete
fi.Directory  //返回一个DriveInfo
fi.DirectoryName
fi.Exists
fi.Extension
fi.FullName
fi.IsReadOnly
fi.LastAccessTime
fi.LastWriteTime
fi.Length
fi.Name
fi.MoveTo("destFileName")
fi.OpenRead()  //返回一个FileStream
fi.OpenWrite()  //返回一个FileStream
fi.OpenText()  //返回一个StreamReader






C、Directory文件夹操作
1、各类操作
using System.IO;
if(Directory.Exists("d:/abc/"))                                      // 判断目录是否存在
string[] fileList = Directory.GetFileSystemEntries(srcPath);         // 得到源目录的文件列表，该里面是包含文件以及目录路径的一个数组

DirectoryInfo DirI=new DirectoryInfo();
DirI.Root
DirI.Parent  //返回一个DirectoryInfo
其他操作见File，大致相同

2、各类目录的获取
System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName   // 获取模块的完整路径。
System.Environment.CurrentDirectory                                  // 获取和设置当前目录(该进程从中启动的目录)的完全限定目录。
->C:\Program Files (x86)\IIS Express
System.AppDomain.CurrentDomain.BaseDirectory                         // 获取“程序”的基目录，当当前执行路径非程序路径时可用。（Windows服务中可取得程序的真实目录，而非C:\WINDOWS\system32，也非bin目录）
->D:\TFS\A4商务产品研发\WebSites\PayRiskControl\Src\PRCWebApi\
System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase      // 获取和设置包括该应用程序的目录的名称。
System.Reflection.Assembly.GetEntryAssembly().Location               // 获取当前“入口”所在应用程序集文件位置（Windows服务中可取得程序的真实目录，而非C:\WINDOWS\system32）
System.Reflection.Assembly.GetCallingAssembly().Location             // 获取当前“执行方法”应用程序集，调用它的应用程序集文件位置（Windows服务中可取得程序的真实目录，而非C:\WINDOWS\system32）
System.Reflection.Assembly.GetExecutingAssembly().Location           // 获取当前“执行方法”所在应用程序集文件位置（Windows服务中可取得程序的真实目录，而非C:\WINDOWS\system32）
//¤如A->B->C：在C的方法中，执行GetEntryAssembly得到A，执行GetCallingAssembly得到B，执行GetExecutingAssembly得到C
->C:\Windows\Microsoft.NET\Framework\v4.0.30319\Temporary ASP.NET Files\root\c01c54cf\bf1fffff\assembly\dl3\24b8c51d\b8ab9440_6744d201\PRCWebApi.dll
HttpRuntime.AppDomainAppPath                                         // 获取网站的路径
->D:\TFS\A4商务产品研发\WebSites\PayRiskControl\Src\PRCWebApi\
System.Web.HttpContext.Current.Server.MapPath("~")                   // 取得web应用程序的根目录
->D:\TFS\A4商务产品研发\WebSites\PayRiskControl\Src\PRCWebApi\
System.Web.Hosting.HostingEnvironment.MapPath("~")                   //
->D:\TFS\A4商务产品研发\WebSites\PayRiskControl\Src\PRCWebApi\
System.Web.HttpContext.Current.Request.PhysicalApplicationPath       //
->D:\TFS\A4商务产品研发\WebSites\PayRiskControl\Src\PRCWebApi\
System.Windows.Forms.Application.StartupPath                         // 获取启动了应用程序的可执行文件的路径。
System.Windows.Forms.Application.ExecutablePath                      // 获取启动了应用程序的可执行文件的路径及文件名
System.IO.Directory.GetCurrentDirectory()                            // 获取应用程序的当前工作目录。
->C:\Program Files (x86)\IIS Express
System.IO.Path.DirectorySeparatorChar.ToString();                    // 获得操作系统用于分隔目录和父目录的分隔符，在这里没有使用"/"，这是因为对于windows操作系统这是正确的，但对于linux和unix则不然。（js中用）
windows下，路径分隔符是\但是\在Java中是转义字符，所以用\\代表一个\ ，可是如果这么写，就跨不了平台了比如在Linux下，就执行不了，因此不推荐这种写法，2.可以这样写/ ，无论是在Windows还是Linux，写"正斜杠"/都没问题3.但是也不好，最好的方式是：使用java.io.File类的常量 separator，会获取当前操作系统的路径分隔符，这就没事了比如你那个路径可以写成：String separator = File.separator;"D:" + separator + "User" + separator + "IT011"  字符串拼接就行，后面我不写了


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
C# WinForm中AppDomain.CurrentDomain.Bas
获取网站根目录的方法有几种如：
Server.MapPath(Request.ServerVariables["PATH_INFO"])
Server.MapPath("/")
Server.MapPath("")
Server.MapPath(".")
Server.MapPath("../")
Server.MapPath("..") 
Page.Request.ApplicationPath
运行结果：
C:\Inetpub\wwwroot\EnglishClub\manage\WebForm1.aspx
C:\Inetpub\wwwroot\
C:\Inetpub\wwwroot\EnglishClub\manage
C:\Inetpub\wwwroot\EnglishClub\manage
C:\Inetpub\wwwroot\EnglishClub\
C:\Inetpub\wwwroot\EnglishClub
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例C# WinForm中AppDomain.CurrentDomain.BaseDirectory与Application.StartupPath的区别示例如下:

private void Frm_Server_Load(object sender, EventArgs e)
        {
            MessageBox.Show(AppDomain.CurrentDomain.BaseDirectory);
            MessageBox.Show(Application.StartupPath );
         }

说明:

1.   AppDomain.CurrentDomain.BaseDirectory 返回结果为: D:\mycode\

     Application.StartupPath 返回结果为: D:\mycode

2.  Application.StartupPath 只能用于WinForm窗体中，而AppDomain.CurrentDomain.BaseDirectory既可以用于WinForm窗体中，也可以用于类库DLL文件中.
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



D、DriveInfo操作
DriveInfo di=new DriveInfo("");
di.DriveFormat
di.DriveType
di.RootDirectory
di.TotalSize
di.VolumeLabel
         //获取磁盘剩余空间大小(盘符)
    public long GetHardDiskFreeSpace(string str_HardDiskName)
    {
        long freeSpace = new long();
        str_HardDiskName = str_HardDiskName + ":\\";
        System.IO.DriveInfo[] drives = System.IO.DriveInfo.GetDrives();
        foreach (System.IO.DriveInfo drive in drives)
        {
            if (drive.Name == str_HardDiskName)
            {
                freeSpace = drive.TotalFreeSpace / (1024 * 1024 * 1024);
            }
        }
        return freeSpace;
    } 


E、Path
using System.IO;
Path.Combine(this.Server.MapPath("~/Pad/Image/padbg/"), "filename.ext");  //将两个字符串组合成一个路径
Path.GetFileName(SF.FileName)      //返回指定路径字符串的文件名和扩展名，即取得SF.FileName的文件名和扩展名
Path.GetFileName(fileposted.FileName)  //从完全路径中取得文件名
Path.GetExtension(filename).ToLower() == ".png"    //取得文件名扩展名

Path.GetFileNameWithoutExtension
Path.GetFullPath
Path.GetDirectoryName
Path.IsPathRooted

this.Server.MapPath("~/Pad/Image/padbg/")    //将指定的相对或虚拟路径映射到服务器上相应的物理目录上。
服务器<asp:image runat="server" id="Image1"  ImageUrl="~/Images/SampleImage.jpg" />   //Web 应用程序根目录用“~”表示
客户端<img src="/Images/SampleImage.jpg" />    //客户端元素中网站根目录用“/”表示











F、Response
Context 中的部分对象也已升级为 Page 中的顶级对象。例如，Context.Response.Write与Page.Response.Write 指的是同一个对象
HttpContext.Current.Response.Write("<script language=javascript>alert('输入时间不合理，请重新输入！');</script>");
Response.Redirct                                //页面跳转
1.页面跳转
页面重定向的要领通常有如下三种：
  （1）Response.Redirect("Url")；服务器之间跳转
  （2）Server.Transfer("URL")；同一服务器的页面跳转，推荐
    Response.Redirect需要client端再发起一个请求。server.transfer就很好地解决了这些问题。它是从server端直接向下一页发起请求，不需要client再次发送请求.如果你的网页非常依赖response.redirect，这个小小的改变可以提高将近25%的效率。（根据微软文档）。
    Server.Transfer方法把执行流程从当前的ASPX文件转到同一服务器上的另一个ASPX页面。调用Server.Transfer时，当前的ASPX页面终止执行，执行流程转入另一个ASPX页面，但新的ASPX页面仍使用前一ASPX页面创建的应答流。如果用Server.Transfer方法实现页面之间的导航，浏览器中的URL不会改变，因为重定向完全在服务器端进行，浏览器根本不知道服务器已经执行了一次页面变换。
    默认情况下，Server.Transfer方法不会把表单数据或查询字符串从一个页面传递到另一个页面，但只要把该方法的第二个参数设置成True，就可以保留第一个页面的表单数据和查询字符串。
    同时，使用Server.Transfer时应注意一点：目标页面将使用原始页面创建的应答流，这导致ASP.NET的机器验证检查（MachineAuthentication Check，MAC）认为新页面的ViewState已被篡改。因此，如果要保留原始页面的表单数据和查询字符串集合，必须把目标页面Page指令的EnableViewStateMac属性设置成False。
server.Transfer()有一个不足就是:当用户在a.aspx中提交了一个表单，然后用Server.Transfer()进入 b.aspx，这时如果用户刷新一下页面，浏览器便会问用户是否“重试”发送表单，如果用户点击“是”，那么，表单中的数据被重新发送到服务器。如发送表单的作用就是为了向数据库中插入一条记录，结果导不希望发生的事——同一表单被多次加入到数据库中。
  （3）Server.Excute("URL")；允许当前的ASPX页面执行一个同一Web服务器上的指定ASPX页面，当指定的ASPX页面执行完毕，控制流程重      新返回原页面发出Server.Execute调用的位置。这种页面导航方式类似于针对ASPX页面的一次函数调用，被调用的页面能够访问发出调用页面的表单数据和查询字符串集合，所以要把被调用页面Page指令的EnableViewStateMac属性设置成False。
    与最多见的Response.Redirct("URL")相比Server.Transfer("URL")有三个优点一
    优点：
    一、它在服务器端直接重定向，不用像response.Redirect一样先与阅读器通信再重定向，效率高。
    二、它可以传递上一个页面的提交值。比如：A页面提交值到B页面，B页面Transfer到C页面，C页面同样可以收到A页面提交的值。
    三、可以潜藏 url。
    缺点：(2005-1-10修改)
    不能刷新页面，比如：A页面提交登录信息到B页面，B页面处理后Transfer再到A，A页面得不到刷新，指定了过期也不可以。如果A、B页面不在同一个目录下，我们还会发觉更多意想不到的结果，运用相对链接的图片、超链接的指向都改动了，造成这种原由是B页面读取A页面内容却以B页面的身份输出，所以路径改动了。
    在Asp.Net中有四种页面跳转导航方式，该如何 为你的页面选择一个呢？
     ·如果要让用户来决定何时转换页面以及转到哪一个页面，超级链接最适合。
     ·如果要用程序来控制转换的目标，但转换的时机由用户决定，运用 Web服务器的HyperLink控件，动态配置其NavigateUrl属性。
     ·如果要把用户连接到另一台服务器上的资源，运用 Response.Redirect。
     ·用Response.Redirect把用户连接到非ASPX的资源，例如Html页面。
     ·如果要将查询字符串作为URL的一部分保留，运用 Response.Redirect。
     ·如果要将执行流程转入同一Web服务器的另一个ASPX页面，应当运用 Server.Transfer而不是Response.Redirect，因为Server.Transfer能够防止不必要的网络通信，从而获得更好的性能和阅读效果。
Server.Transfer不支持虚拟路径





response.redirect 这个跳转页面的方法跳转的速度不快，因为它要走2个来回（2次postback），但他可以跳转到任何页面，没有站点页面限制（即可以由雅虎跳到新浪），同时不能跳过登录保护server.transfer 速度快，只需要一次postback ，但是。。。。他必须是在同一个站点下，因为它是server的一个方法。另外，他能跳过登录保护sever.execute 这个方法主要是用在页面设计上面，而且他必须是跳转同一站点下的页面。这个方法是需要将一个页面的输出结果插入到另一个aspx页面的时候使用，大部分是在表格中，将某一个页面类似于嵌套的方式存在于另一页面。




2.在两个ASPX页面传值
源页面
private void Button1_Click(object sender, System.EventArgs e)
{ 
  url= "anotherwebform.aspx?name=" + TextBox1.Text + "&email=" + TextBox2.Text; 
  Response.Redirect(url); 
}

目标页面
private void Page_Load(object sender, System.EventArgs e) 
{ 
  Label1.Text=Request.QueryString["name"]; 
  Label2.Text=Request.QueryString["email"]; 
} 


3.直接保存文件到客户端
（1）从服务器下载到本地“另存为文件”
        StreamReader sr = new StreamReader(Server.MapPath("source.xml"));
        string temp = sr.ReadToEnd();

        Response.ClearHeaders();
        Response.AppendHeader("Content-Disposition", "attachment;filename=" + @"target.xml"); 
        Response.ContentType = "application/octet-stream";                                          //默认为该类型，可不加
        Response.Write(temp);
        Response.End();

（2）从服务器下载到本地显示“Image文件”
    System.IO.MemoryStream ms = new System.IO.MemoryStream();
    System.Drawing.Image img = System.Drawing.Image.FromFile(Server.MapPath("未命名.jpg"));
    img.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
    Response.ContentType = "image/Png";
    Response.ClearContent();
    Response.BinaryWrite(ms.ToArray());
    img.Dispose();

（3）从服务器读取图片，显示在页面上
protected void Page_Load(object sender, EventArgs e)
{
    FileStream fs = new FileStream(Server.MapPath("未命名.jpg"), FileMode.Open);       //将图片文件存在文件流中
    long fslength = fs.Length;                                                         //流长度
    byte[] b = new byte[(int)fslength];                                                //定义二进制数组
    fs.Read(b, 0, (int)fslength);                                                      //将流中字节写入二进制数组中
    fs.Close();                                                                        //关闭流
    Response.ContentType = "image/jpg";                                                //没有这个会出现乱码
    Response.BinaryWrite(b);                                                           //将图片输出在页面
} 

Response.BinaryWrite()不能与Response.Write()一起使用。

this.Response.Flush();






4.Flush
Response对象之Flush方法，立即发送缓冲区中的输出。如果未将 Response.Buffer 设置为 TRUE，则该方法将导致运行时错误。语法：Response.Flush；注释：如果在 ASP 页上调用 Flush 方法，则服务器将响应该页上保持活动的请求。应用于Response对象。 
关于Buffer，这里有段介绍。Buffer从英文直译过来的意思是“缓冲区”，这里我们将它称为缓冲，因为它不仅是个名词，还是个动词。 
    缓冲区是存储一系列的数据的地方，客户端所获得的数据可以从程序的执行结果直接输出，也可以从缓冲区输出。但是这两种方式在速度上是有差异的：在web中，当一个asp程序被请求的次数不多时，二者基本上没有什么差异，至少我们感觉不出来。但是当有很多人请求一个asp程序时，速度可就不一样了。如果没有缓冲区，那么每个请求asp程序的人的客户端所得到的结果都是asp程序执行一次所得到的结果，而如果预先将asp程序缓冲，那么每个客户端所得到的结果就是缓冲区的结果，不是执行一次程序的结果。比如有1000个用户同时访问一个asp页面，如果这个asp程序没有缓冲，那么程序将被执行一千次，这样服务器的负荷就回加大，从而导致客户端打开页面速度变慢；如果这个asp程序被缓冲了，那么结果就不一样了，每个客户端直接从缓冲区获得数据，服务器将不会因为访问增加而增加程序执行次数，因此客户端打开页面的速度也就比上一种情况要快。这就是Buffer的好处。 
关于Response.clear，Clear 方法删除缓冲区中的所有 HTML 输出。但 Clear 方法只删除响应正文而不删除响应标题。可以用该方法处理错误情况。请注意，如果未将 Response.Buffer 设置为 TRUE，则该方法将导致运行时错误。语法：Response.Clear；应用于Response对象。 
好了，想实现立即输出的效果，只要在循环体内的希望输出提示信息后加上Response.Flush和Response.Clear就可以了。如： 

<% 
for i=1 to 2000 
for i1=1 to 3000 
''空循环，延长每次执行时间 
next 
Response.write i&")" 
Response.Flush 
Response.Clear 
next 
%> 
上述asp语句，你执行后，会发现输出是逐个逐个输出的，执行一次，就输出一次。 
但我在网上看到有人说，“很多时候，我们发现即使我们使用了Response.Flush()，但是并没有将前面的信息发到客户端来显示。呈献给我们的依然是白屏。经过反复的测试，我得出一个结论：就是flush的内容至少要有256字节。也就是只有编译产生了至少256字节的数据，才能在执行Response.Flush()以后将信息发到客户端并显示。” 
很奇怪，上述我给出的语句确确实实是实现了逐个显示的效果的，并没有事先输出256个字节，大家可以把上述语句另存为记事本运行看看，效果是逐行显示的。本人所列观点，仅代表flymorn个人观点，不挪作他用。 
如果你确实需要事先输出256个字节，可以如下： 
<% 
dim liji 
for i=1 to 256 
liji=liji&"<!--先产生256个字符-WWW.PIAOYI.ORG-->" 
if len(liji)>=256 then exit for 
next 
%> 
如果你有不同的看法，或有不同的试验结果，欢迎与我一起讨论。 
详细出处参考：http://www.jb51.net/article/15371.htm



G、Request
ASP.net获取当前url各种属性(文件名、参数、域名 等)的方法 
假设当前页完整地址是：http://www.test.com/aaa/bbb.aspx?id=5&name=kelli
"http://"是协议名
"www.test.com"是域名
"aaa"是站点名
"bbb.aspx"是页面名（文件名）
"id=5&name=kelli"是参数
（1）获取 完整url （协议名+域名+站点名+文件名+参数）
string url=Request.Url.ToString();
url= http://www.test.com/aaa/bbb.aspx?id=5&name=kelli
（2）获取 站点名+页面名+参数：
string url=Request.RawUrl;
(或 string url=Request.Url.PathAndQuery;)
url= /aaa/bbb.aspx?id=5&name=kelli
（3）获取 站点名+页面名：
string url=HttpContext.Current.Request.Url.AbsolutePath;
(或 string url= HttpContext.Current.Request.Path;)
url= aaa/bbb.aspx
（4）获取 域名：
string url=HttpContext.Current.Request.Url.Host;
url= www.test.com
（5）获取 参数：
string url= HttpContext.Current.Request.Url.Query;
url= ?id=5&name=kelli










H、Server
1、编码
2、编码
·Html解码函数：Server.HtmlDecode()
将Html代码转化为普通文本显示，如<H1></H1>不会被当作功能性文字被使用，而是普通文本。将"<"转换为"&lt;"，">"转换为"&gt;"等
·Html编码函数：Server.HtmlEncode()
同HtmlEncode相反
·Url解码函数：Server.UrlDecode()
将Url代码转化为普通文本显示，如?&不会当作网址的连接字符，而是普通文本。将符号转换为16进制表示，如"&"转换为"%26"，"/"转换为"%2F"，":"转换为"%3A"，"="转换为"%3D"，"?"转换为"%3F"等
·Url编码函数：Server.UrlEncode()
同UrlEncode相反

Server.MapPath("~/Pad/Image/padbg/")    //将指定的相对或虚拟路径映射到服务器上相应的物理目录上。



I、System.Windows.Froms
（1）程序入口
    static void Main() 
    {
        Application.Run(new Form1());
    }
    System.Windows.Forms.Application.Exit();//------------关闭

（2）键盘模拟
1）按键代码
<1>单键
  键   代码     
  BACKSPACE   {BACKSPACE}、{BS}   或   {BKSP}     
  BREAK   {BREAK}     
  CAPS   LOCK   {CAPSLOCK}     
  DEL   或   DELETE   {DELETE}   或   {DEL}     
  DOWN   ARROW（下箭头键）   {DOWN}     
  END   {END}     
  ENTER   {ENTER}   或   ~     
  ESC   {ESC}     
  HELP   {HELP}     
  HOME   {HOME}     
  INS   或   INSERT   {INSERT}   或   {INS}     
  LEFT   ARROW（左箭头键）   {LEFT}     
  NUM   LOCK   {NUMLOCK}     
  PAGE   DOWN   {PGDN}     
  PAGE   UP   {PGUP}     
  PRINT   SCREEN   {PRTSC}（保留，以备将来使用）     
  RIGHT   ARROW（右箭头键）   {RIGHT}     
  SCROLL   LOCK   {SCROLLLOCK}     
  TAB   {TAB}     
  UP   ARROW（上箭头键）   {UP}     
  F1   {F1}     
  F2   {F2}     
  F3   {F3}     
  F4   {F4}     
  F5   {F5}     
  F6   {F6}     
  F7   {F7}     
  F8   {F8}     
  F9   {F9}     
  F10   {F10}     
  F11   {F11}     
  F12   {F12}     
  F13   {F13}     
  F14   {F14}     
  F15   {F15}     
  F16   {F16}     
  数字键盘加号   {ADD}     
  数字键盘减号   {SUBTRACT}     
  数字键盘乘号   {MULTIPLY}     
  数字键盘除号   {DIVIDE}   
<2>组合键
+代表SHIFT（SHIFT="+"） 
^代表CTRL（CTRL="^"）
%代表ALT（ALT="%"） 

2）模拟按键
using System.Windows.Forms.SendKeys;
SendKeys.Send("A");
SendKeys.Flush(); //使用 Flush 等待应用程序处理键盘敲击以及消息队列中的其他操作系统消息
System.Threading.Thread.Sleep(100);
其它：
SendKeys.Send("{Backspace}");
SendKeys.Send("{Home}");
SendKeys.Send("{Enter}");
SendKeys.Send("+{Home}");


（3）MessageBox提示框
using System.Windows.Forms;
1、MessageBox.Show( context.Request.Params[2].ToString() );   //弹出对话框
2、MessageBox.Show(msg, "Warning", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);//弹出对话框在最前端（类似js的alert()）
3、if (MessageBox.Show("确定要删除当前行数据？", "", MessageBoxButtons.OKCancel) == DialogResult.OK)




J、取得IP的方法：
1.取得客户端IP
（1）不穿透代理
    Request.ServerVariables.Get("Remote_Addr").ToString();
（2）可穿透代理
    public static string getIP(HttpContext rq)
    {
        string userIP;
        HttpRequest Request = HttpContext.Current.Request;
        // 如果使用代理，获取真实IP   
        if (rq.Request.ServerVariables["HTTP_X_FORWARDED_FOR"] != "") userIP = rq.Request.ServerVariables["REMOTE_ADDR"];
        else
            userIP = rq.Request.ServerVariables["HTTP_X_FORWARDED_FOR"];
        if (userIP == null || userIP == "")
            userIP = rq.Request.UserHostAddress;
        return userIP;
    }

2.通过网卡获取IP
    NetworkInterface[] adapters = NetworkInterface.GetAllNetworkInterfaces();//获取本机所有网卡对象
    foreach (NetworkInterface adapter in adapters)
    {
        if (adapter.Description.Contains("Virtual"))//枚举条件：描述中包含"Virtual"
        {
            IPInterfaceProperties ipProperties = adapter.GetIPProperties();//获取IP配置
            UnicastIPAddressInformationCollection ipCollection = ipProperties.UnicastAddresses;//获取单播地址集
            foreach (UnicastIPAddressInformation ip in ipCollection)
            {
                if (ip.Address.AddressFamily == AddressFamily.InterNetwork)//只要ipv4的
                    ipAddress = ip.Address;//获取ip
            }
        }
    }




3.取得本机（服务器）IP
using System.Net;
    private List<string> GetLocalIp()
    {
        string hostname = Dns.GetHostName();
        //IPHostEntry ipEntry = Dns.GetHostEntry(hostname);    //新方法，支持IPv6
        IPHostEntry ipEntry = Dns.GetHostByName(hostname);     //旧方法，仅支持IPv4
        foreach (IPAddress ipa in IpEntry.AddressList)
        {
            if (ipa.AddressFamily == AddressFamily.InterNetwork)
                lstIPAddress.Add(ipa.ToString());            
        }
        return lstIPAddress;                                   // result: 192.168.1.17 ......
    }

4.取得外网 IP Address
    private string GetExtranetIPAddress()
    {
        HttpWebRequest request = HttpWebRequest.Create("http://www.whatismyip.com.tw") as HttpWebRequest;
        request.Method = "GET";
        request.ContentType = "application/x-www-form-urlencoded";
        request.UserAgent = "Mozilla/5.0";
        string ip = string.Empty;
        WebResponse response = request.GetResponse();
        using (StreamReader reader = new StreamReader(response.GetResponseStream()))
        {
            string result = reader.ReadToEnd();
            string pattern = @"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}";
            ip = Regex.Match(result, pattern).ToString();
        }
        return ip; // result: 210.125.21.xxx
    }

5.监听ip端口
    public static void RunServer() 
    {
        // 建立X509凭证
        ServerCertificate = new X509Certificate(Certificate, "ssl");
        // 监听任何IP Address来的讯息
        listener = new TcpListener(System.Net.IPAddress.Any, 17170);
        // 开启监听
        listener.Start();
    
        while (IsRun)
        {
            TcpClient client = listener.AcceptTcpClient();
    
            ProcessClient(client);
        }
    }

6.接收客户端讯息处理并回复
    private static void ProcessClient(TcpClient pClient)
    {
        SslStream sslStream = new SslStream(pClient.GetStream(), true);
    
        // 取得连接者 IP 与 Port
        IPEndPoint point = pClient.Client.RemoteEndPoint as IPEndPoint;
        string ip = point.Address.ToString(); // result: 127.0.0.1
        string port = point.Port.ToString(); // result: 55236
    
        // do something...
    }

7.ping某一个IP或HostName
        /// <summary>
        /// 测试是否能够Ping通某一个IP或HostName
        /// </summary>
        /// <param name="IpOrHostName">IP或HostName</param>
        /// <param name="TestData">发送的数据</param>
        /// <param name="Timeout">超时时间</param>
        /// <param name="Times">发送次数</param>
        /// <returns></returns>
        private static bool PingTest(string IpOrHostName, string TestData, int Timeout, int Times)
        {
            bool b = false;
            byte[] buf = ASCIIEncoding.UTF8.GetBytes(TestData);
            PingReply pReply;
            for (int i = 0; i < Times; i++)
            {
                Ping p = new Ping();
                PingOptions pOptions = new PingOptions();
                pOptions.DontFragment = true;
                pReply = p.Send(IpOrHostName, Timeout, buf, pOptions);
                if (pReply.Status == System.Net.NetworkInformation.IPStatus.Success)
                {
                    b = true;
                    break;
                }
            }
            return b;
        }

K、Cookie
0、概念
（1）什么是Cookie
   Cookie是在Web上用于存储客户系统信息的对象。所有的信息都以每行一个Cookie的形式存放在客户端的一个名为cookies.txt的文件里。Cookie在HTTP头标(客户和服务器用来标识自身的分组)中在客户机与服务器之间传输。
   Cookie由某个WWW网页在某客户机上进行设置。比如，某个WWW网页已在一个用户的计算机上设置了一个Cookie，其中存储的信息是该用户的身份号(随机赋予该用户的唯一标识)，当该用户的浏览器连接该WWW站点时，站点要求浏览器将Cookie送回，他的身份号就通过Cookie 传递给该网页所在的WWW服务器。服务器上的一个CGI程序查找一个
服务器端的文件以确定关于他的预设内容。
   当某个服务器在客户的计算机上设置Cookie后，请注意如果要让Cookie信息确实写入文件，必须关闭浏览器。在浏览器未关闭之前，任何新的或变化的Cookie都存放在内存中。
（2）Cookie的特性
   每个Cookie包含有6个元素，常用的有:name、value、expires、domain和secure。这些元素存放了这个Cookie的作用范围及实际的数据。
   1）name  这是每一个Cookie必须有的元素，它是该Cookie的名字。name元素是一个不含分号、逗号和空格的字符串。其命名方式与变量命名相同。
   2）value  value也是每个Cookie必须有的元素，它是该Cookie的值。value元素是实际存放于Cookie中的信息。它是由任何字符构成的字符串。
   3）expires  expires是一个Cookie的过期时间。没有设置expires元素的Cookie在用户断开连接后过期，但在用户关闭浏览器之前Cookie依然存在。
   Cookie有一个过期时间并等于它会从Cookie.txt文件中被删除。在它的位置被用来存放另一个Cookie前，它依然存在着。过期的Cookie只是不被送往要求使用它的服务器。
   expire是一个串，它的形式如下:
   Wdy, DD-Mon-YY HH:MM:SS GMT
   expires元素是可选的。
   4）domain  domain是设置某个Cookie的Web网页所在的计算机的域名。这样，由一个站点创建的Cookie不会影响到另一个站点上的程序。对于较高层的域名如.com, .edu,或.mil,域名中至少有两个分隔符(.)。而对于较低层的域名如.cn, .uk或.ca，域名中至少有3个分隔符。demain元素自动地被设为网页所在站点的基本域名。比如，你的网页位于http://www.dscga.com/～user，则该网页创建的Cookie缺省地对域dscga.com有效。如果你希望你的Cookie 只应用于服务器www3.dscya.com，那么你必须在设置Cookie的时候指定。
   只有拥有域名的站点才能为那个域名设置Cookie
   5）path  一个Cookie可以被指定为只针对一个站点的某一层次。如果一个Web站点要区分已注册的和未注册的客户，就可以为已经注册的客户设置Cookie，当注册过的客户访问该站点时，他就可以访问到只对注册客户有效的页面。
   path是可选项，如果没有指定path，将被缺省地设置为设置Cookie的页面的路径。
   6）secure标志  secure是一个布尔值(真或假)。它的缺省值为假。如果它被设为真值， 这个Cookie只被浏览器认为是安全的服务器所记住。 
（3）关于Cookie的一些限制 
   一个站点能为一个单独的客户最多设置20个Cookie。如果一个站点有两个服务器(如ww w.dscga.com和www3.dscga.com)但没有指定域名，Cookie的域名缺省地是dscga.com。如果指定了确切的服务器地址，则每个站点可以设置20个Cookie--而不是总共20个。不仅每个服务器能设置的Cookie数目是有限的，而且每个客户机最多只能存储300个Cookie。如果一个客户机已有300个Cookie，并且一个站点在它上面又设置了一个新Cookie，那么，先前存在的某一个Cookie将被删除。
   每个Cookie也有自身的限制。Cookie不得超过4KB(4096bytes)，其中包括名字和其他信息。
（4）domain表示的是cookie所在的域，默认为请求的地址，如网址为www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。
（5）path表示cookie所在的目录，asp.net默认为/，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。
（6）浏览器会将domain和path都相同的cookie保存在一个文件里，cookie间用*隔开。
（7）含值键值对的cookie：以前一直用的是nam=value单键值对的cookie，一说到含多个子键值对的就蒙了。现在总算弄清楚了。含多个子键值对的cookie格式是name=key1=value1&key2=value2。可以理解为单键值对的值保存一个自定义的多键值字符串，其中的键值对分割符为&，当然可以自定义一个分隔符，但用asp.net获取时是以&为分割符。

1、写入
  //定义一个cookie
        HttpCookie myCookie = new HttpCookie("MyCook");
  //当要跨域名访问的时候，给cookie指定域名即可，格式为.xxx.com
        myCookie.Domain = ".xxx.com";
  //设置过期时间
        myCookie.Expires = DateTime.Now.AddMinutes(1);//或myCookie.Expires = DateTime.Now.Add(ts);
  //"设置"cookie值（不带key，整个cookie的value）
        myCookie.Value = "myCookieValue";
  //"追加"cookie（带key，单一key的value）
        myCookie.Values.Add("c1", "username1");
        myCookie.Values.Add("c2", "username2");
  //两种方法二选一
    //将这个cookie"设置"到cookies
        HttpContext.Current.Response.Cookies.Add(myCookie);
    //将这个cookie"追加"到cookies
        Response.AppendCookie(myCookie);
※请注意"设置"与"追加"的区别
执行：
Response.Write(Request.Cookies["MC"].Values);
结果：
myCookieValue&c1=username1&c2=username2
2、读取
        Request.Cookies["MyCook"].Values[0]
        Request.Cookies["MyCook"].Values["c1"]
3、修改
//修改整个Cookie的value（不带key）
        myCookie.Value = "myCookieValue";

//修改Cookie单一key的value（带key）
  方法一：
        myCookie.Values["c1"] = "username1";
  方法二：
        myCookie.Values.Set("c2", "username2");
4、清除（清除后将无此cookie）
（1）直接设置当前cookie过期
        TimeSpan ts = new TimeSpan(-1, 0, 0, 0);
        Request.Cookies["MyCook"].Expires = DateTime.Now.Add(ts);//删除整个Cookie，只要把过期时间设置为现在
        Response.AppendCookie(cok);

（2）设置一个过期cookie覆盖当前cookie
        HttpCookie myCookie = new HttpCookie(CookieName);
        myCookie.Expires = now.AddYears(-2);
        Response.Cookies.Add(myCookie);
（3）Cookie 第二天就过期的写法：
写法一（24小时后过期）
HttpCookie cookie = new HttpCookie("cftea", "1"); 
DateTime expiresDateTime = DateTime.Now.AddDays(1); 
cookie.Expires = expiresDateTime;
写法二（当日0时后过期）
HttpCookie cookie = new HttpCookie("cftea", "1"); 
DateTime expiresDateTime = DateTime.Now.AddDays(1); 
expiresDateTime = new DateTime(expiresDateTime.Year, expiresDateTime.Month, expiresDateTime.Day);
cookie.Expires = expiresDateTime;


5、删除（删除后cookie值为空）
（1）删除整个Cookie的value（不带key）
        myCookie.Value.Remove(0);
（2）删除Cookie单一key的value（带key）
        Request.Cookies["MyCook"].Values.Remove("userid");//移除键值为userid的值
6、与cookie关联的域--Domain
（1）来由
    最开始，只有一个www的站点和一个wap的站点，不存在web网站和wap网站的cookie共享问题。所以，对于cookie的domain，分别设置成www.***.com和wap.***.com就OK了。
后来，因为业务的扩大，web站点增加了，比如多了一些blog.***.com、arti.***.com之类，为了实现web站点的cookie共享，就需要对cookie的domain重新设置了。最简单的办法就是将其设置为.***.com。
    不过，问题就这么产生了，wap网站不能登陆了。因为我叙述的原因，大家可能一下子就能猜到问题的所在，cookie的domain设置有问题？不错，正是在这个地方出问题了。手机对于cookie的访问似乎更加严格，只有url的host部分和cookie的domain完全匹配，它才会将这些cookie发送到服务器端，这样的话，才能保持手机端和服务器端的正常通信。
    问题找到了，解决办法也非常简单。只要在登陆时对请求的服务器名称进行判断，如果是wap站点的请求，cookie的domain就直接设置成wap.***.com即可。
（2）使用
        HttpCookie myCookie = new HttpCookie("MyCook");
        myCookie.Domain = 


7、httponly类型cookie
将cookie设置成HttpOnly是为了防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。
Microsoft Internet Explorer 6 版的 Service Pack 1 (含) 以後版本支援 Cookie 的 HttpOnly 屬性，可以幫助減輕將導致竊取 Cookie 的跨站台之指令碼處理攻擊。


取得httponly类型cookie的方法
            //1
            MessageBox.Show(webrequest.GetResponse().Headers.Get("Set-Cookie").ToString());
            //2
            webrequest.CookieContainer = new CookieContainer();
            webrequest.GetResponse(); 
            
            CookieContainer coo1 = webrequest.CookieContainer;
        或foreach(Cookie cookie in response.Cookies)



            List<Cookie> cooL = GetAllCookies(coo1);
            foreach (Cookie c in cooL)
            {
                MessageBox.Show(c.Value.ToString());
            }
            MessageBox.Show(webrequest.CookieContainer.Count.ToString());

myHttpOnlyCookie.HttpOnly = true;

8、CookieContainer
HTTP协议规定的Header是不可以从HttpWebResponse.Headers里面取得。
request.CookieContainer = new CookieContainer();
response = request.GetResponse();
这时候request.CookieContainer里面就包含了Server返回的Cookies。接下来的Request可以重用这个CookieContainer。


（1）cookie类型转换成CookieContainer类型
using System.Net;
        public CookieContainer getcookies(string ThisDomain, string cookieStr)
        {
            CookieContainer myCookieContainer = new CookieContainer();

            //String的Cookie要转成Cookie型，并放入CookieContainer中
            string[] cookstr = cookieStr.Split(';');
            foreach (string str in cookstr)
            {
                string[] cookieNameValue = str.Split('=');

                Cookie ck = new Cookie(cookieNameValue[0].Trim().ToString(), cookieNameValue[1].Trim().ToString());
                ck.Domain = ThisDomain;

                //必须写对
                myCookieContainer.Add(ck);
            }
            return myCookieContainer;
        }

（2）CookieContainer类型转换成cookie类型，并保存到文件
在开HTTP方式提交数据时，有的要登录才能发送数据，如果每次都登录，那就有点浪费时间了，因为网络的问题，很多时间都花来回传输数据上，如果登录后把CookieContainer保存到文件或数据库那就会快很多了。
保存CookieContainer考虑到两种方法，一种是把CookieContainer序列化，再保存，用的时候再反序列化；另一种是遍历出所有的Cookie，再把内容读出来，用的时候再构建新有Cookie，再添加到CookieContainer。经过考虑，决定用第二种，因为Cookie会有时间限制，如果单单的序列化后保存，就有可能会过期，而后一种则可以自己设置时间。

以下的代码可以适用于很多场合，包括论坛，社区，甚至某些邮箱等。当然此处我只是举例，将内容保存到一个文本文件，而实际可可以保存到数据库或其他地方。

首先，我们用一个方法把CookieContainer所有的Cookie读出来，此方法的代码：
public static List<Cookie> GetAllCookies(CookieContainer cc)
        {
            List<Cookie> lstCookies = new List<Cookie>();

            Hashtable table = (Hashtable)cc.GetType().InvokeMember("m_domainTable",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField |
                System.Reflection.BindingFlags.Instance, null, cc, new object[] { });

            foreach (object pathList in table.Values)
            {
                SortedList lstCookieCol = (SortedList)pathList.GetType().InvokeMember("m_list"
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField
                    | System.Reflection.BindingFlags.Instance, null, pathList, new object[] { });
                foreach (CookieCollection colCookies in lstCookieCol.Values)
                    foreach (Cookie c in colCookies) lstCookies.Add(c);
            }

            return lstCookies;
        }
然后我们再保存到文件：
 StringBuilder sbc = new StringBuilder();
            List<Cookie> cooklist = GetAllCookies(CookieContainer);
            foreach (Cookie cookie in cooklist)
            {
                sbc.AppendFormat("{0};{1};{2};{3};{4};{5}\r\n",
                cookie.Domain,cookie.Name, cookie.Path, cookie.Port, 
                cookie.Secure.ToString(), cookie.Value);
            }

            FileStream fs = File.Create("d:\\chinarencookies.txt");
            fs.Close();
            File.WriteAllText("d:\\chinarencookies.txt", sbc.ToString(), System.Text.Encoding.Default);
读出所有Cookie
string[] cookies = File.ReadAllText("d:\\chinarencookies.txt", System.Text.Encoding.Default).Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
            foreach (string c in cookies)
            {
                string[] cc = c.Split(";".ToCharArray());
                Cookie ck = new Cookie(); ;
                ck.Discard =false;
                ck.Domain = cc[0];
                ck.Expired =true;                
                ck.HttpOnly = true;
                ck.Name = cc[1];
                ck.Path = cc[2];
                ck.Port = cc[3];
                ck.Secure = bool.Parse(cc[4]);
                ck.Value = cc[5];
                CookieContainer.Add(ck);
            }


L、System.Diagnostics.Process
1.常用进程操作
◆Process[] proList = Process.GetProcessesByName("EXCEL");                               //通过进程名称获得进程
◆Process.Start(System.Reflection.Assembly.GetExecutingAssembly().Location);             //重新开启当前程序
◆Process.Start("http://www.Microsoft.com");                                             //在当前窗口打开
◆Process.Start("Iexplore.exe", "http://www.csdn.net");                                  //如果在新窗口中打开可以加上要执行的文件及参数的形式
◆Process.Start("cmd", "/k echo 'ok'");
◆Process.Start("explorer", "C:\\windows\\system32");
◆Process.Start("shutdown", "/l");                                                        //注销计算机
◆Process.Start("shutdown", "/r");                                                        //重起计算机
◆Process p = System.Diagnostics.Process.GetProcessById(k);                              //通过进程Id获得进程
◆p.Kill();                                                                              //杀死该进程
◆p.PriorityClass = System.Diagnostics.ProcessPriorityClass.BelowNormal;                 //设置该进程的优先度

例：（杀死Excel进程）
    [DllImport("User32.dll", CharSet = CharSet.Auto)]
    public static extern int GetWindowThreadProcessId(IntPtr hwnd, out int ID);
    public static void Kill(Microsoft.Office.Interop.Excel._Application excel)
    {
        excel.Quit();
        IntPtr t = new IntPtr(excel.Hwnd);
        int k = 0;
        GetWindowThreadProcessId(t, out k);
        System.Diagnostics.Process p = System.Diagnostics.Process.GetProcessById(k);
        p.Kill();
    }

2.执行DOS命令
（1）方法一
//调用win32函数ShellExecute。
using System.Runtime.InteropServices;
[DllImport("shell32.dll")]
private static extern IntPtr ShellExecute(IntPtr hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, Int32 nShowCmd);
在按钮的单击事件处理程序中调用前面生明的ShellExecute函数：
ShellExecute(IntPtr.Zero, "open", "c:\\windows\\notepad.exe", null, null, 1);       //文件名可以不加后缀，如"c:\\windows\\notepad"。

（2）方法二
    //创建进程
    public static string StartCmd(string workingDirectory, string command)
    {
        string output;
        Process p = new Process();                          //创建进程对象
        p.StartInfo.FileName = "cmd.exe";                   //设定需要执行的命
        p.StartInfo.Arguments = "/C " + command;            //设定参数，其中的“/C”表示执行完命令后马上退出
        p.StartInfo.WorkingDirectory = workingDirectory;
        p.StartInfo.UseShellExecute = false;                //不使用系统外壳程序启动
        p.StartInfo.RedirectStandardInput = true;           //重定向输入
        p.StartInfo.RedirectStandardOutput = true;          //重定向输出
        p.StartInfo.CreateNoWindow = true;                  //不创建窗口
        p.Start();
        p.StandardInput.WriteLine(command);
        p.StandardInput.WriteLine("exit"); 

        p.WaitForExit();                                    //这里无限等待进程结束
        p.WaitForExit(milliseconds);                        //这里等待进程结束，等待时间为指定的毫秒
        output = p.StandardOutput.ReadToEnd();              //读取进程的输出
        p.Close();
    }


3.判断ie是否启动
例
    Process[] processes;  
    processes = System.Diagnostics.Process.GetProcesses();  
  
    foreach (Process currentProcess in processes)  
    {  
        if (currentProcess.ProcessName == "iexplore")  
        {  
             lbl_State.Text = "Is Open";  
             break;  
         }  
         else  
         {  
              lbl_State.Text = "Not Open";  
          }  
    }  

M、System.Web.HttpContext.Current
1、概念
    一般在web应用程序里，你的程序都是为了处理客户端过来的http请求而执行的，当前正在处理的这个请求的一些上下文信息就保存在一个HttpContext对象里，你通过HttpContext的“静态”属性Current得到当前这个上下文，然后去取你需要的信息，比如查询字符串等。

2、使用
（1）使用其他的对像如：Request, Response, Session, Application, Cookies对象也可用下面的语句取得：  
  HttpContext.Current.Request   
  HttpContext.Current.Response
  HttpContext.Current.Session
  HttpContext.Current.Session["aaa"]
  HttpContext.Current.Application
  string cookieheader = (string)HttpContext.Current.Application["cookieheader"];
  HttpContext.Current.Cookies
（2）在没有继承page的类中，应该这样写
  HttpContext.Current.Server
  HttpContext.Current.Server.MapPath
  Page p=(Page)HttpContext.Current.Handler;
  HttpContext.Current.Response
  HttpContext.Current.Request
  HttpContext.Current.Session
  HttpContext.Current.Cookies
  HttpContext.Current.Application
  HttpContext.Current.Catche

3、HttpContext.Current.Response.Write()和Page.Response.Write()有什么区别？
MSDN上解释如下:
HttpContext.Current.Response为当前 HTTP 响应获取 HttpResponse 对象，在不同的时候这个的返回值是不一样的。
Page.Response(也就是第二个)获取与该 Page 对象关联的 HttpResponse 对象。该对象使您得以将 HTTP 响应数据发送到客户端，并包含有关该响应的信息。
通常在类中如果该类不继承System.Web.UI.Page类，可以直接用HttpContext.Current.Response，因为Current是静态属性可以直接使用，而Page则需要实例化. 
如果请求的是同一个页面，它们是一样的。HttpContext.Current.Response能获取到网站当前任何页面正在相应的请求的Response对象，而Page.Response只是当前页面。

对于HttpContext.Current.Response，有可能这一秒是获取到的是甲用户的Response对象，下一秒就是乙用户的Response对象了，它永远是服务器当前处理当前请求的Response对象，这个对象可能是针对不同用户或者不同页面的请求。

而Page.Response永远是处理当前页面时的Response对象page.response只能在当前页使用
而httpcontext.current.response可在任何地方使用另外根据根据页面的生命周期：
 protected void Page_PreInit(object sender, EventArgs e)
    {
        Response.Write("Page_PreInit...<br/>");
    }    protected void Page_Init(object sender, EventArgs e)
    {
        Response.Write("Page_Init...<br/>");
    }
    protected void Page_InitComplete(object sender, EventArgs e)
    {
        Response.Write("Page_InitComplete...<br/>");
    }    protected void Page_PreLoad(object sender, EventArgs e)
    {
        Response.Write("Page_PreLoad...<br/>");
    }    protected void Page_Load(object sender, EventArgs e)
    {
        Response.Write("Page_Load...<br/>");
    }    protected void Page_LoadComplete(object sender, EventArgs e)
    {
        Response.Write("Page_LoadComplete...<br/>");
    }
    protected void Page_PreRender(object sender, EventArgs e)
    {
        Response.Write("Page_PreRender...<br/>");
    }
  
    protected void Page_PreRenderComplete(object sender, EventArgs e)
    {
        Response.Write("Page_PreRenderComplete...<br/>");
    }
    protected void Page_SaveStateComplete(object sender, EventArgs e)
    {
        Response.Write("Page_SaveStateComplete...<br/>");
    }
    protected void Page_Unload(object sender, EventArgs e)
    {
        //Response.Write("Page_Unload...<br/>");
        HttpContext.Current.Response.Write("Page_Unload...<br/>");
    }
    protected void Page_Disposed(object sender, EventArgs e)
    {    }
只有在Disposed以后，页面才被销毁。
那么在Page_Unload的时候，Page对象还是在的，那为什么就不能Page.Response.Write...了呢？答案：Page_Unload:
在卸载阶段，页及其控件已被呈现，因此无法对响应流做进一步更改。如果尝试调用方法（如 Response.Write 方法），则该页将引发异常。
Response.Write()默认是page的.
HttpContext.Current.Response是当前线程上下文件的response对象答案：用Reflector打开看，Page上的Response属性内部存储是_response变量。有一个私有函数ProcessPageCleanup()专门负责在页面逻辑完成时做一些清理工作，其中包括_response = null。在Page的处理主函数，也就是ProcessPage()当中，会在处理完后调用ProcessPageCleanup()。

4、HttpContext保存在哪
protected void Page_Load(object sender, EventArgs e)
{
    HttpContext context1 = HttpContext.Current;
    HttpContext context2 = System.Runtime.Remoting.Messaging.CallContext.HostContext as HttpContext;
    bool isEqual = object.ReferenceEquals(context1, context2);
    Response.Write(isEqual);
}
结果：True
从这段代码来看，HttpContext其实是保存在CallContext.HostContext这个属性中。

5、HttpContext的生命周期
    在一个ASP.NET程序中，“几乎”任何时候，我们都可以访问HttpContext.Current得到一个HttpContext对象，为什么可以到处访问HttpContext.Current呢？
    因为ASP.NET会为每个请求分配一个线程，这个线程会执行我们的代码来生成响应结果，即使我们的代码散落在不同的地方（类库），线程仍然会执行它们，所以，我们可以在任何地方访问HttpContext.Current获取到与【当前请求】相关的HttpContext对象，毕竟这些代码是由同一个线程来执行的嘛，所以得到的HttpContext引用也就是我们期待的那个与请求相关的对象。 
    但是，还有一些线程却不是为了响应请求而运行，例如：
        1. 定时器的回调。
        2. Cache的移除通知。
        3. APM模式下异步完成回调。
        4. 主动创建线程或者将任务交给线程池来执行。 
    在以上这些情况中，如果线程执行到HttpContext.Current，会返回null
    在1，2二种情况中，访问HttpContext.Current将会返回null。因为很有可能任务在运行时根本没有任何请求发生。了解异步的人应该能很容易理解第3种情况（就当是个结论吧），第4种情况就更不需要解释了，因为确实不是当前线程。






N、Page
（1）服务端执行js语句
RegisterClientScriptBlock：在页面内容前注册脚本；
RegisterStartupScript：在页面内容后注册脚本；
RegisterClientScriptInclude：在页面内容前引用外部脚本；

1）RegisterStartupScript
//RegisterStartupScript把脚本放在ASP.NET页面的底部，而不是顶部。也就是说，该脚本查找、调用页面控件的时候使用。
this.Page.ClientScript.RegisterStartupScript(Page.GetType(), " message ", " <script language='javascript' defer='defer'>alert('Please input name!');history.back();</script> " );

2）RegisterClientScriptBlock
this.Page.RegisterClientScriptBlock把JavaScript函数放在页面的顶部。也就是说，该脚本用于在浏览器中启动页面。

    StringBuilder sb = new StringBuilder();
    sb.AppendLine("<script type='text/javascript'>")
        .AppendLine(" function setSomeGroupArgs(args) { ")
        .AppendFormat("  document.getElementById('{0}').value = args;", v.ClientID).AppendLine()
        //.AppendFormat("  document.getElementById('{0}').value = '';", v.ClientID).AppendLine()
        .AppendLine("  $.fn.colorbox.close();")
        //.AppendFormat("  document.getElementById('{0}').checked = false;", c.ClientID).AppendLine()
        .AppendLine(" }")
        .AppendLine("</script>");
        
    this.Page.ClientScript.RegisterClientScriptBlock(Page.GetType(), "setSomeGroupArgs", sb.ToString());

3）RegisterClientScriptInclude


说明
1.RegisterClientScriptBlock和RegisterStartupScript推荐使用 RegisterStartupScript，特别是当注册的脚本要调用页面的元素或函数时，如果使用 RegisterClientScriptBlock可能会发生元素/函数还没加载完毕导致出错。
2.使用发现如果页面缺少服务器端表单<form id="form1" runat="server"></form>会导致脚本注册不成功，也发现其实RegisterClientScriptBlock 就是将脚本注册到<form id="form1" runat="server">后，RegisterStartupScript是将脚本注册到</form>前。
特别是当注册的脚本要调用页面的元素或函数时，如果使用 RegisterClientScriptBlock可能会发生元素/函数还没加载完毕导致出错。
可以"window.onload=fun{}"



十三、LINQ
1.格式：
from [type] id in source
[join [type] id in source on expr equals expr [into subGroup]]
[from [type] id in source | let id = expr | where condition]
[orderby ordering, ordering, ordering...]
select expr | group expr by key
[into id query]


from p in db.Products                                   //分解
group p by p.CategoryID into g  
where p.CategoryID > 0                                  //条件
select new {                                            //生成
        g.Key, NumProducts = g.Count() 
        }; 


from p in db.Employees
select new
{
    LastName = p.LastName,
    TitleOfCourtesy = p.TitleOfCourtesy
} into EmployeesList
orderby EmployeesList.TitleOfCourtesy ascending
select EmployeesList;
------------------------------------------------
//左连接
                var leftJoinResult = from c in myTestDBEntities.tb_Class  
                               join s in myTestDBEntities.tb_Student  
                               on c.classid equals s.classid into joinedResult  
                               from jr in joinedResult.DefaultIfEmpty()  
                               select new  
                               {  
                                   ClassId = c.classid,  
                                   ClassName = c.classname,  
                                   Teacher = c.teacher != null ? c.teacher : string.Empty,  
                                   StudentId = jr.id != null ? jr.id : 0,  
                                   StudentName = jr.name != null ? jr.name : string.Empty,  
                                   StudentAge = jr.age != null ? jr.age : 0,  
                                   StudentScore = jr.score != null ? jr.score : 0,  
                               };  
//连接
                var joinResult = from c in myTestDBEntities.tb_Class  
                          join s in myTestDBEntities.tb_Student  
                          on c.classid equals s.classid  
                          select new  
                          {  
                               ClassId = c.classid,  
                               ClassName = c.classname,  
                               Teacher = c.teacher != null ? c.teacher : string.Empty,  
                               StudentId = s.id,  
                               StudentName = s.name,  
                               StudentAge = s.age,  
                               StudentScore = s.score != null ? s.score : 0,  
                           };  
//右连接
                var rightJoinResult = from s in myTestDBEntities.tb_Student  
                               join c in myTestDBEntities.tb_Class  
                               on s.classid equals c.classid into joinedResult  
                               from jr in joinedResult.DefaultIfEmpty()  
                               select new  
                               {  
                                   StudentId = s.id,  
                                   StudentName = s.name,  
                                   StudentAge = s.age,  
                                   StudentScore = s.score != null ? s.score : 0,  
                                   ClassId = jr.classid != null ? jr.classid : 0,  
                                   ClassName = jr.classname != null ? jr.classname : string.Empty,  
                                   Teacher = jr.teacher != null ? jr.teacher : string.Empty,  
                               };  

------------------------------------------------
★两种形式
List<T> ls = ...;
var ls_new1 = ls.Where( t=> t.Id > 10 );                 //单句
var ls_new2 = ls.Where( t=> { return t.Id > 10; } );     //多句


2.说明
LINQ的查询执行遵循以下原则：
    •延迟执行：LINQ都是延迟执行，在执行LINQ方法（如Where、OrderBy）时，不会执行LINQ查询，直到查询结果被使用、赋值时。
    •重复执行：由于是延迟执行，也就是调用的时候才去执行，这样每被调用一次就被执行一次。
    •有些查询比较耗时（比如在对一个非常大的sequence进行查询或者从远程数据库获取数据时），为了性能考量，我们并不希望一个查询会被反复执行这时可以使用 ToArray、ToList、ToDictionary 这些LINQ扩展方法将查询结果转换成集合保存在一个集合数组里，这时候不会出现多次查询，而只是一次查询。









3.详解
<1>定位
List<int> arr = new List<int>() { 1, 2, 6, 4, 5, 6, 3 };
加上OrDefault后缀表示如为空，则返回该类型的默认值（null或0）
•First[OrDefault]
用法：arr.First( c => c==2 );
说明：返回第一条断言等于true的记录
•Last[OrDefault]
用法：arr.Last( c => c==2 );
说明：返回最后一条断言等于true的记录
•Single[OrDefault]
用法：arr.Single( c => c==2 );
说明：返回“仅有的一条”断言等于true的记录
•ElementAt[OrDefault]
用法：arr.ElementAt(2);
说明：返回索引为2的记录

<2>判断
•All
用法：bool b = arr.All( a => a > 2 );
说明：当所有断言为true时，返回true

•Any
用法：bool b = arr.Any( a => a > 2 );
说明：当任意断言为true时，返回true

•TrueForAll
用法：arr.TrueForAll(p => p.Name == p.Name);
说明：

•Contains
用法：bool b = arr.Contains(2);
说明：当包含目标对象时，返回true

•SequenceEqual
用法：bool b = arr.SequenceEqual(arr);
说明：当与目标对象以相同顺序匹配时，返回true

•DefaultIfEmpty
用法：List<int> emptyScores = new List<int>(); 
      foreach( int score in emptyScores.DefaultIfEmpty() ){};
      或foreach( int score in emptyScores.DefaultIfEmpty(50) ){};
说明：当目标对象为空时，返回Default集合

<3>排序
•OrderBy\ThenBy
用法：arr.OrderBy( c => c.Category );
说明：先以OrderBy顺序正序，再以ThenBy顺序正序

•OrderByDescending\ThenByDescending
用法：arr.OrderBy( c => c.Category );
说明：先以OrderByDescending顺序倒序，再以ThenByDescending顺序倒序

•Reverse
用法：arr.Reverse( c => c.Category );
说明：反排

<3>筛选
List<int> arr = new List<int>() { 1, 2, 3, 4, 5, 6, 7 };
•Where
用法：List<int> arr_new = arr.Where(a => { return a > 3; })
说明：返回满足给定条件的子集，SQL对应语法也是Where

※LINQ to Entities 不识别方法“Boolean Contains(Int32)”
IQueryable<int> TestTables=...;
//或IList<int> TestTables=...;
IList<int> ids = new List<int> { 2, 3, 4 };
var list = TestTables.Where(a => ids.Contains(a.RID)).ToList();
然而，运行发现系统会抛出如下异常：  
LINQ to Entities 不识别方法“Boolean Contains(Int32)”，因此该方法无法转换为存储表达式。 
究其原因，是Contains是IList类型的扩展方法而linq无法转换过来。所以上述办法就无法得到我们想要的结果（虽然编译不会有错）。 
解决方法：
IEnumerable<HR> HRList = ...;
IList<int> ids = new List<int> { 2, 3, 4 };
var list = HRList.AsEnumerable().Where(a => ids.Contains(a.RID)).ToList();

•OfType
用法：arr.OfType<int>();
说明：根据指定类型，筛选集合中的元素
•Cast
用法：arr.Cast<string>();
说明：将非IEnumerable(非泛型)的派生对象转换成IEnumerable<T>对象，比OfType少了一层过滤的功能
•Take
用法：arr.Take(2);
说明：返回前N条记录,丢弃剩余部分,SQL对应语法为Where ROW_NUMBER()或者TOP n子查询
•TakeWhile
用法：arr.TakeWhile( a => a > 2 );
TakeWhile：返回输入序列中的所有元素直到断言等于true,无SQL对应语法
•Skip
用法：arr.Skip(2);
说明：跳过前N条记录, 返回剩余部分, SQL对应语法为Where ROW_NUMBER()或者NOT IN(Select Top N…)
•SkipWhile
用法：arr.SkipWhile( a => a > 2 );
说明：跳过输入序列中的元素直到断言等于true, 返回剩下的所有元素, 无SQL对应语法
•Distinct
用法：arr.Distinct();
说明：返回无重复的集合元素,SQL对应语法为Select Distinct

•DistinctBy
用法：
arr.DistinctBy(a => a.Id);
arr.DistinctBy(a => new { a.Id, a.Name });
说明：返回无重复的集合元素, SQL对应语法为Select Distinct
public static IEnumerable<TSource> DistinctBy<TSource, TKey> (this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
{
    HashSet<TKey> seenKeys = new HashSet<TKey>();
    foreach (TSource element in source)
    {
        if (seenKeys.Add(keySelector(element)))
        {
            yield return element;
        }
    }
}


<4>计算
•Count/LongCount
用法：arr.Count( c => c > 2 );
说明：返回符合条件的记录数
•Max
用法：arr.Max( c => c.Age );
说明：返回符合条件的记录中的最大值
•Min
用法：arr.Min( c => c.Age );
说明：返回符合条件的记录中的最小值
•Sum
用法：arr.Sum( c => c.Age );
说明：返回符合条件的记录之和
List<int> arr = new List<int>() { 1, 2, 3, 4, 5, 6, 7 };
var result = arr.Where(a => { return a > 3; }).Sum();
//同(from v in arr where v > 3 select v).Sum();
•Average
用法：arr.Average( c => c.Age );
说明：返回符合条件的记录的平均值
•Agregate
用法：
说明：

<5>投影
•说明样例
class School
{
  public IList<Class> Classes = new List<Class>();
}
class Class
{
  public IList<Student> Students = new List<Student>();
}
class Student
{
  public string Name;
  public int Sex;
}

School s = new School();
for(int i=0;i<5;i++)
{
  s.Classes.Add(new Class());
}
s.Classes[0].Students.Add(new Student( 1, "a0" ));
s.Classes[1].Students.Add(new Student( 0, "b0" ));
s.Classes[2].Students.Add(new Student( 0, "c0" ));
s.Classes[2].Students.Add(new Student( 0, "c1" ));
s.Classes[2].Students.Add(new Student( 1, "c2" ));

•Select
用法：arr.Select<int, string>(a => a.ToString());
说明：将“序列”投影到新序列中。上例中：新序列是一个IEnumerable<String>的集合
结果：
IEnumerable<<IList>Student> x = s.Classes.Select(item=>item.Students);    //映射“多个班级”中的“同学群”
即:IEnumerable<Students> x = s.Classes.Select(item=>item.Students);       //返回List<Students>类型

var rows = list.Select(s => new                                           //此处可使用new {}匿名类型，也可使用new xxClass {}已知类型
    {
        Id = s.Id,
        s.Title,
        s.Author,
        Trade = GetTradeNames(s.Trade),
        s.ReleaseState,
        s.ReleaseDate,
        s.CancelReleaseDate,
        FirstCategory = s.Category.Level == 2 ? s.Category.Parent.Name : "",
        SecondCategoryName = s.Category.Level == 2 ? s.Category.Name : "",
    });



•SelectMany
用法：arr.SelectMany<int, string>(a => { return new List<string>() { "a", a.ToString() }; });
说明：将“序列中的所有子元素”投影到新序列中，最终把所有子元素合并
区别：两者都是被一个“父集合”调用，用于“父集合”包含“子集合”的情况，Select的返回值是“子集合”，SelectMany的返回值是“子集合”内的各元素
结果：
IEnumerable<Student> x = s.Classes.SelectMany(item=>item.Students);       //返回List<Student>类型


<6>分组
•GroupBy
用法：arr.GroupBy( c => c.Category );
说明：按给定条件分组返回记录，GroupBy是延迟加载
返回值类型：IEnumerable<IGrouping<TKey, TSource>>
例：
    List<MA>() list = new List<MA>();
    list.Add(new MA { ma001 = "A", ma002 = "1" });
    list.Add(new MA { ma001 = "A", ma002 = "2" });
    list.Add(new MA { ma001 = "A", ma002 = "3" });
    list.Add(new MA { ma001 = "A", ma002 = "4" });
    list.Add(new MA { ma001 = "B", ma002 = "11" });
    list.Add(new MA { ma001 = "B", ma002 = "12" });
    list.Add(new MA { ma001 = "B", ma002 = "13" });
    list.Add(new MA { ma001 = "C", ma002 = "21" });
    list.Add(new MA { ma001 = "C", ma002 = "22" });
    IEnumerable<IGrouping<string, MA>> listG = list.GroupBy(p => p.ma001);
    /*
      list的结构是A---(A, 1)
                   |--(A, 2)
                   |--(A, 3)
                   |--(A, 4)
                  B---(B, 11)
                   |--(B, 12)
                   |--(B, 13)
                  C---(C, 21)
                   |--(C, 22)
    */

•ToLookUp
用法：arr.ToLookUp( c => c.Category );
说明：按给定条件分组返回记录，与GroupBy唯一的不同，ToLookUp是非延迟加载

•Join（类似于T-SQL中的inner join）
用法：var newT = t1s.Join(t2s, item1 => item1.pKey, item2 => item2.pKey, (item1, item2) => new { t2 = item1.c1, t3 = item2.c2 }).ToList();
说明：组合两个集合的字段，并映射为新的集合
List<T1> t1s = new List<T1>() { new T1() { pKey = "t", c1 = "t1", c2 = "t2" } };
List<T2> t2s = new List<T2>() { new T2() { pKey = "t", c1 = "t1", c2 = "t2" } };
var newT = t1s.Join(                                                                //第一个集合
                t2s,                                                                //第二个集合
                item1 => item1.pKey,                                                //第一个集合的主键
                item2 => item2.pKey,                                                //第二个集合的主键
                (item1, item2) => new { t2 = item1.c1, t3 = item2.c2 }              //映射为新集合的方式
        ).ToList();



<7>操作
•Concat
用法：arr1.Concat(arr2);
说明：连接，不去重

•Union
用法：arr1.Union(arr2);
说明：并集，去重

•Intersect
用法：arr1.Intersect(arr2);
说明：取交集

•Except
用法：arr1.Except(arr2);
说明：从arr1中排除arr2中的元素，arr2可以大于arr1
★arr1.Except(arr2) 与 arr2.Except(arr1) 结果不同

•Aggregate
用法：arr1.Aggregate("AggregateValue：", (current, next) => current.key + "," + next.key);    //["key1", "key2", "key3", "key4"] -> "key1, key2, key3, key4"
说明：取得聚合值

•ForEach（仅List类）
用法：arr.ForEach(p => p.Name = p.Name + "Mother");
说明：遍历集合中的每个元素，并进行指定的操作

<8>转换
·ToArray - 将集合转换为数组；不延迟
·ToList - 将集合转换为List<T>集合；不延迟
·ToDictionary - 将集合转换为<K, V>集合；不延迟
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
•listViewItems = (
        from p in problems
        select new
            {
                Key = p.Key,
                Value = from i in p.Value.Items
                        select new ListViewItem
                                {
                                    Token = i.Token,
                                    IsFatalError = i.IsFatal,
                                    Checked = false,
                                    Line = i.Token.Position.Line,
                                    Description = i.Description,
                                    BackgroundBrush = i.IsFatal 
                                                        ? Brushes.Red 
                                                        : null
                                }
            }
    ).ToDictionary(x => x.Key, x => x.Value);

•Dictionary<Guid, int> dic = lst.ToDictionary(new Func<Test, Guid>(c => c.Id), new Func<Test, int>(c => c.Num));
•Dictionary<Guid, int> dic = lst.ToDictionary(c => c.Id, c => c.Num);                               //如果觉得上面的写法太复杂，还可以简化为
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例







//申明一个整形数组
int[] num = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
//查询数组中元素值大于1的集合
//传统方式
            ArrayList listArr = new ArrayList();
            foreach (int i in num)
            {
                if (i < 1)
                {
                    listArr.Add(i);
                }
            }

//LINQ方式
            //匿名类型方式
            var list = from _num in num
                       where _num > 1
                       select _num;


<9>生成集合
•Range
用法：System.Linq.Enumerable.Range(0, 10);
说明：使用Range操作符来生成从0到9的整数序列
•Repeat
用法：System.Linq.Enumerable.Repeat(0, 10);
说明：使用Repeat来生成一个包含10个0的序列

<10>Attach
LINQ引入了Attach方法，通过它可以将修改的对象附加到Data Context中。Attach方法具有三个重载版本，如下所示：
Attach(Object entity): 以未修改状态将实体附加到DataContext中；
Attach(Object entity, bool asModified): 以修改或未修改状态将集合中的所有实体附加到DataContext中；
Attach(Object entity, Object orginal): 通过指定实体及其原始状态，以修改或未修改状态将实体附加到 DataContext。.
Attach方法通常用来将反序列化的实体与DataContext的一个新实体关联。但我们也可以将一个DataContext中的实体关联到另外一个DataContext中。在修改或删除操作中，这一方法是非常有用的。
Attach方法只负责将实体与DataContext的一个新实例进行关联，并跟踪实体的变化。在提交修改时，DataContext会检查映射的数据库中实际的值，然后再根据传递进来的实体更新或删除记录。







4.DataTable转集合
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
            DataTable dt = new DataTable();
            dt.Columns.Add("C1");
            dt.Columns.Add("C2");
            dt.Columns.Add("C3");
            DataRow dr1 = dt.NewRow();
            dr1[0] = "r1c1";
            dr1[1] = "r1c2";
            dr1[2] = "r1c3";

            DataRow dr2 = dt.NewRow();
            dr2[0] = "r2c1";
            dr2[1] = "r2c2";
            dr2[2] = "r2c3";

            dt.Rows.Add(dr1);
            dt.Rows.Add(dr2);

            Console.WriteLine(dt.AsEnumerable().ElementAt(0).Field<string>("C1"));
            Console.ReadKey();
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例














十二、控件
A、介绍
组件包括控件，还有一些类，
控件一些做好的供你用的可视化的对象，像按钮什么的，
com：是一种协议，使不同厂家生产的activex控件能互用，
插件：对ide的补充，
ActiveX：一种其他厂家或编制者生产的自定义的控件，



组件是可以将生成的DLL文件随意的放在另一套系统中使用，不用拷贝源代码。
用户控件，只能在本项目内使用。
组建可以添加到Tool工具箱内，而用户控件则不能。
他们的使用方法都是拖拽。


在visual studio 2005中添加组件和控件 
在工具栏上点右键->"选择项..."在弹出的对话框中选择"COM组件" 点浏览.. 
如果你已经注册了animation控件的话 就会看到Anibutton Control选项 勾选即可添加到工具栏中.



B、客户端控件与服务器端控件
对于服务器按钮控件（即<asp:Button>类型的按钮）：
服务器响应事件：OnClick
客户端响应属性：OnClientClick

对于html按钮控件（即<input type="button" runat="server">）
服务器响应事件：OnServerClick
客户端响应事件：onclick



C、服务器端控件
0、动态加载控件

        Button btn = new Button();
        btn.ID = "saveData";
        btn.Text = "保存";
        form1.Controls.Add(btn);


1、button
（1）.PerformClick方法
WinForm，按钮有Button.PerformClick方法，可以模拟用户单击鼠标，如：
button1.performclick();
（2）.InvokeMember方法
HtmlElement btnSubmit = webBrowser1.Document.All[controlName];
btnSubmit.InvokeMember("click");
再如：
if (vTag.Name.ToString() == "Submit") vTag.InvokeMember("click");
对button1执行click



2、comboBox
（1）属性
（2）行为
（3）方法


（2）动作
comboBox3_SelectedIndexChanged
1）添加项
    comboBox3.Items.Add("职名");
    comboBox3.SelectedIndex=0;
    
    
    Form4 form4 = new Form4();
    form4.Show();



DropDownStyle=
DropDown：控件可输入
dropdownlist：控件不可输入









3、dataGrid
当前项
    comboBox1.Text=ds.Tables["人员库"].Rows[dataGrid1.CurrentRowIndex]["职名"].ToString();
    dataGrid1.DataSource=ds.Tables["人员库"];















4、webBrowser
webBrowser1.Document.All[i].InvokeMember("click");
对页面上的元素执行click

webBrowser1.Document.All[i].innerText="张飞";
webBrowser1.Document.All[i].SetAttribute("value", "张飞");
此两种方法效果是一样的


（1）定义一个WebBrowser
webwebBrowser1.DocumentText = _
    "<html><head>" & _
    "<script language=""JavaScript""  type=""text/javascript""  src=""""></script>" & _
    "</head><body>" & _
    "<button onclick=""window.external.Test('called from script code')"" > " & _
    "call client code from script code</button>" & _
    "</body></html>" 

（2）配置功能参数
<1>C#防止WebBrowser在新窗口中打开链接页面
在日常的开发中，大家有时需要用WebBrowser加载URL，来实现某些功能。而这时，我们就不希望所打开的页面中的链接，在新窗口中打开，因为这样的话，实际上是用系统默认的浏览器打开了，从而脱离了你的WebBrowser，也就不能被你所控制了。
要解决这个问题，可以使用下面的方法：
假设WebBrowser的Name是 webBrowser1
private void webBrowser1_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
{
    //将所有的链接的目标，指向本窗体
    foreach (HtmlElement archor in this.webBrowser1.Document.Links)
    {
        archor.SetAttribute("target", "_self");
    }
    //将所有的FORM的提交目标，指向本窗体
    foreach (HtmlElement form in this.webBrowser1.Document.Forms)
    {
        form.SetAttribute("target", "_self");
    }
    }
    private void webBrowser1_NewWindow(object sender, CancelEventArgs e)
    {
        e.Cancel = true;
    }
记得将 WebBrowser 的 AllowWebBrowserDrop 设为 false将 WebBrowser 的 WebBrowserShortcutsEnabled 设为 false将 WebBrowser 的 IsWebBrowserContextMenuEnabled 设为 false

<target="_blank">




（3）WebBrowser 抓图获取网页验证码
在.NET的WINFORM开发中，大家可能都比较熟悉了WINFORM控件的 DrawToBitmap 方法。但是，如果你使用 WebBrowser 的时候，却发现没有 DrawToBitmap 这个功能，然而，WebBrowser 实际上是有这个功能的， 只是在VS IDE的智能提示列表里面没有显示。
网页中的验证码，其实是通过一个独立的页面来输出的，例如 CSDN 的登录验证码地址为： http://passport.csdn.net/ShowExPwd.aspx
我们下面用WebBrowser获取这个图片，显示在窗体的PictureBox上。

this.webBrowser1.Navigate("http://passport.csdn.net/ShowExPwd.aspx");private void webBrowser1_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
{
    Bitmap bmp = new Bitmap(200, 200);
    webBrowser1.DrawToBitmap(bmp, new Rectangle(0, 0, 300, 300));
    this.pictureBox1.Image = bmp;
}

（4）C#利用mshtml的COM接口，将WebBrowser中的验证码图片读入内存
2009年2月21日 16:40 
浮出水面者 我要盖楼 
在做发贴机，灌水机，自动登录等情况时，如果遇到图片验证码的情形，就需要做验证码分析了，这时将验证码图片读入内存或保存在本地，就是必须的了
当然，使用WebClient直接download验证码图片回来，是可以实现的，但是这样的话，实际上是请求了2次验证码，而直接从webbrowser中，将验证码提取出来的话，就可以免去一次网络通信，而且，也可以应付一些网站的每次随验证码动态返回的其他附属验证信息对自动登录造成的影响。
.NET 自带的 WebBrowser 控件，使用起来可以说是相当方便了，微软 已经对其进行了比较完美的封装，但所谓“有得必有失”，正是这种封装，也使得该控件的一些底层信息，全都看不到了。
我们要实现的功能，就是利用了IE的DOM，这个在 WebBrowser 中，就无能为力了， 所以，我们这里要使用 mshtml 这个COM对象。
先添加对 mshtml 的引用， 在 COM 页上， 选择 Microsoft HTML Object Library 
使用命名空间  using mshtml; 
核心代码 
HTMLDocument html = (HTMLDocument)this.webBrowser1.Document.DomDocument;
//下面代码中，获取图片的方式有很多，因为比较简单，我就不列举了，直接用ID来做为例子的
IHTMLControlElement img = (IHTMLControlElement)webBrowser1.Document.Images["MzImgExpPwd"].DomElement;
IHTMLControlRange range = (IHTMLControlRange)((HTMLBody)html.body).createControlRange();
range.add(img);
range.execCommand("Copy", false, null);
img = null;
range = null;
html = null;
if (Clipboard.ContainsImage())
{
this.pictureBox1.Image = Clipboard.GetImage();
}
else
{
MessageBox.Show("执行不成功");
}
Clipboard.Clear();



WebBrowserDocumentCompletedEventArgs e
webBrowser1.ScriptErrorsSuppressed = true;



（5）在WebBrowser中设置Cookie
public partial class WebBrowserControl : Form
{
        private String url;

        [DllImport("wininet.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool InternetSetCookie(string lpszUrlName, string lbszCookieName, string lpszCookieData);

        public WebBrowserControl(String path)
        {
            this.url = path;
            InitializeComponent();

            // set cookie
            InternetSetCookie(url, "JSESSIONID", Globals.ThisDocument.sessionID);

            // navigate
            webBrowser.Navigate(url);
        }       
}







5、Execl操作

    //创建Application对象
    Excel.Application xApp=new Excel.ApplicationClass();
    xApp.Visible=true;


    //得到WorkBook对象, 可以用两种方式之一: 下面的是打开已有的文件
    Excel.Workbook xBook=xApp.Workbooks._Open(OF.FileName, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value); 


    //指定要操作的Sheet，两种方式：
    Excel.Worksheet xSheet=(Excel.Worksheet)xBook.Sheets["呈报表"];
    //Excel.Worksheet xSheet=(Excel.Worksheet)xApp.ActiveSheet;


    //对单元格操作
    xSheet.get_Range("C" + (n-1), Missing.Value).Value2=ds.Tables["人员库"].Rows[n-1]["职名"];
    xSheet.get_Range("C" + (n-1), Missing.Value).Interior.ColorIndex=6;


    //定位光标位置
    try
    {
        localExecl=int.Parse(Interaction.InputBox("请输入'呈报表'人员名单的起始行!\n默认为第206行.", "单元格起始位置", "206", this.Location.X+100, this.Location.Y+100).ToString());       //Excel中弹出输入框
    }
    catch
    {
        if (localExecl==0) return;
    }


--------------------------------------------------------------------
        public static DataSet InExecl(string filePath)
        {
            DataSet ds = new DataSet();
            string connStr = "Provider = Microsoft.Jet.OLEDB.4.0; Data Source = " + filePath + ";Extended Properties=\"Excel 8.0;HDR=Yes;IMEX=1\"";
            OleDbConnection myConn = new OleDbConnection(connStr);
            string strSQL = " SELECT * FROM [Sheet1$]";
            myConn.Open();
            OleDbDataAdapter myCommand = new OleDbDataAdapter(strSQL, myConn);
            DataSet myDataSet = new DataSet();
            myCommand.Fill(myDataSet, "[Sheet1$]");
            myConn.Close();
            return myDataSet;
        }
--------------------------------------------------------------------


6、word操作
//在项目引用里添加上对Microsoft Word 11.0 object library的引用

    private void button1_Click(object sender, System.EventArgs e)
      {
    //调用打开文件对话框获取要打开的文件WORD文件，RTF文件，文本文件路径名称
    OpenFileDialog opd = new OpenFileDialog();
    opd.InitialDirectory = \"c:\\\\\";
    opd.Filter = \"Word文档(*.doc)|*.doc|文本文档(*.txt)|*.txt|RTF文档(*.rtf)|*.rtf|所有文档(*.*)|*.*\";
    opd.FilterIndex = 1;

    if (opd.ShowDialog() == DialogResult.OK && opd.FileName.Length > 0)
    {

    //建立Word类的实例，缺点:不能正确读取表格，图片等等的显示
    Word.ApplicationClass app = new Word.ApplicationClass();
    Word.Document doc = null;
    object missing = System.Reflection.Missing.Value;

    object FileName = opd.FileName;
    object readOnly = false;
    object isVisible = true;
    object index = 0;
    try
    {
     doc = app.Documents.Open(ref FileName, ref missing, ref readOnly,
      ref missing, ref missing, ref missing, ref missing, ref missing,
      ref missing, ref missing, ref missing, ref isVisible, ref missing,
      ref missing, ref missing, ref missing);

     doc.ActiveWindow.Selection.WholeStory();
     doc.ActiveWindow.Selection.Copy();
     //从剪切板获取数据
     IDataObject data=Clipboard.GetDataObject();
     this.richTextBox1.Text=data.GetData(DataFormats.Text).ToString();

    }
    finally
    {
     if (doc != null)
     {
      doc.Close(ref missing, ref missing, ref missing);
      doc = null;
     }

     if (app != null)
     {
      app.Quit(ref missing, ref missing, ref missing);
      app = null;[Page]
       }
      }

    }

   }





7、TextBox控件
需要将TextBox控件作为密码输入框时，应该将控件的什么属性设置为Password
可以有2种方法：
1  可以把UseSystemPasswordChar的属性值设置为True   就可以作为密码框用
2  可以直接在PasswoerdChar属性框里输入*  这样你输入的数值就全是以*号形式出现的.
是TextMode属性设置为Password 


8、递归控件
（1）递归所有控件
使用递归对页面control树进行完全遍历，并对每一个control进行处理。递归算法如下:
传入page的this.Controls
对每一个control，如果control没有包含子control，进行处理。 
如果包含，递归调用这个函数处理子control 
    private void InitialControl(ControlCollection objControlCollection)
    {
        foreach (System.Web.UI.Control objControl in objControlCollection)
        {
            if (objControl.HasControls())
            {
                InitialControl(objControl.Controls);
            }
            else
            {
                if (objControl is System.Web.UI.WebControls.TextBox)
                {
                    ((TextBox)objControl).Text = String.Empty;
                }
            }
        }
    }
（2）递归某一类控件
foreach (CheckBox c in tableLayoutPanel12.Controls)


9、PictureBox
Image.FromFile("test.jpg");



十三、绘图
A、概念
画图的基本原理是：
新建bitMap位图对象，并在BitMap上创建Graphic画布，然后使用Graphic的一系列Draw方法，通过Pen或者画刷Brush在画布上创作。
创作完毕的BitMap可以直接输出为stream对象，或者输出为文件，或者进行格式转换。
B、创建Bitmap对象
条件：
using System.Drawing.Text;//提供画GDI+图形的高级功能  
using System.Drawing.Drawing2D;//提供画高级二维，矢量图形功能  
using System.Drawing.Imaging;//提供画GDI+图形的高级功能 
1、创建Bitmap对象一
    {
        //  准备位图
        Bitmap Bm = new Bitmap(4600, 3000);
        g = Graphics.FromImage(Bm);
        g.Clear(Color.Snow);
        this.pictureBox1.Image = Bm;
        //  准备画笔
        Pen thinpRed =new Pen(Color.Red, 1);//细红
    
        Pen thickGreen=new Pen(Color.Green, 2);//粗绿
    
        Pen dashedRed =new Pen(Color.Red, 1);//虚红
        dashedRed.DashCap=DashCap.Round;
        dashedRed.DashStyle=DashStyle.Dash;
    
        Pen thickdashedRed =new Pen(Color.Red, 2);//粗虚红
        thickdashedRed.DashCap=DashCap.Round;
        thickdashedRed.DashStyle=DashStyle.Dash;
    
        //  画粗竖线（60分钟）
        g.DrawLine(thickGreen, new Point(0, 20), new Point(0, 1200));
        for (int i=0; i<=25; i++)
        {
            g.DrawLine(thickGreen, new Point(-60+i*180, 20),new Point(-60+i*180, 1200));
        }
    }

2、创建Bitmap对象二
    //  根据屏幕大小创建一个与之相同大小的Bitmap对象
    [ System.Runtime.InteropServices.DllImportAttribute ( "gdi32.dll" ) ]
    private static extern IntPtr CreateDC ( 
        string lpszDriver, // 驱动名称 
        string lpszDevice, // 设备名称 
        string lpszOutput, // 无用，可以设定位"NULL" 
        IntPtr lpInitData  // 任意的打印机数据 
    ) ; 


    //  定义画笔
    IntPtr dc1 = CreateDC ( "DISPLAY" , null , null , ( IntPtr ) null ) ; 
    //  创建显示器的DC 
    Graphics g1 = Graphics.FromHdc ( dc1 ) ; 
    //  由一个指定设备的句柄创建一个新的Graphics对象 
    Bitmap BmFull = new Bitmap( Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height, g1 ) ; 
    //  定义窗口位置
    this.Width = BmFull.Width-50;
    this.Height = BmFull.Height-50;
    this.Location = new Point(0, 0);


C、改变位图大小
    void ResizeBitmap(Bitmap BitmapInput, int NewWidth, int NewHeight) 
    { 
        // Clone a Clone of the Bitmap object.
        Rectangle CloneRect = new Rectangle(0, 0, NewWidth, NewHeight);
        System.Drawing.Imaging.PixelFormat CloneFormat = Chart.Bm.PixelFormat;
        Bm = Bm.Clone(CloneRect, CloneFormat);
        // Draw the cloned portion of the Bitmap object.
    } 
ResizeBitmap(Bm , Bm.Width , GraphicHeigh);

D、打印
1、打印一
条件：using System.Drawing.Printing;
    private void printDocument1_PrintPage(object sender, System.Drawing.Printing.PrintPageEventArgs e)
    {
    
        {
            // page
            if (page <= 4600/794+1)
            {
                e.Graphics.DrawImage((Image)Bm, new Rectangle(0, 0, 820, 1123), 802*(page-1)-20, 0, 812, Bm.Height, System.Drawing.GraphicsUnit.Pixel);
                e.HasMorePages=true;
                if (page == 4600 / 794 + 1)
                {
                    e.HasMorePages = false;
                    page=0;
                }
                page++;
            }
        }
    }
说明：
e.Graphics.DrawImage((Image)Bm, new Rectangle(0, 0, 820, 1123 ), 802*(page-1)-20, 0, 812, Bm.Height, System.Drawing.GraphicsUnit.Pixel);
用纸范围new Rectangle(0, 0, 820, 1123),
打印范围802*(page-1)-20, 0, 812, Bm.Height


2、打印二
PrintDialog pd = new PrintDialog();
pd.ShowDialog();



E、取得图片的宽和高
System.Drawing.Image img = System.Drawing.Image.FromFile(Server.MapPath("example.gif"));
int width = img.Width;
int height = img.Height;
img.Dispose();
or
Bitmap bmp = new Bitmap(Server.MapPath("example.jpg"));
int width = bmp.Width;
int height = bmp.Height;
bmp.Dispose();

F、颜色
string System.Drawing.ColorTranslator
功能：将指定的 Color 结构翻译成 HTML 字符串颜色表示形式。
方法：
ColorTranslator.FromHtml("#FF0000") 或 ColorTranslator.FromHtml("Red");
ColorTranslator.ToHtml(Color.Red)

enum System.ConsoleColor
功能：指定定义控制台前景色和背景色的常数

G、图片转换为Image
Image img = Image.FromFile("test.jpg");




十四、ASP.NET配置文件
A、Global.asax配置
在ASP.NET的Web应用程序中使用Global.asax文件时，注意，一个Web应用程序只能有唯一的Global.asax文件，其位置是Web应用程序的启动点目录。
1、Global.asax事件处理程序的执行顺序
    当用户请求ASP.NET程序后，就会替每位用户建立Session时间和Application对象，接着检查ASP.NET应用程序是否含有Global.asax文件。如果有Global.asax文件，就将它编译成继承HttpApplication类的.NET Framework 类，然后在执行 ASP.NET 文件的程序代码前触发Application_Start 事件，执行 Global.asax 文件的 Application_Start()事件处理程序，并建立 Session对象，因为 Global.asax 文件存在，接着执行 Session_Start()事件处理程序。
    当Session 时间超过 TimeOut 属性的设定(默认20分钟)或执行 Abandon()方法，表示 Session 时间结束，就触发 Session_End事件执行 Session_End()事件处理程序，处理程序是在关闭 Session 对象前执行。
Web 服务器如果关机，在关闭 Application 对象前就会执行 Application_End()事件处理程序，当然也会结束所有用户的 Session 时间，执行所有用户的 Session_End()事件处理程序。

                                        Application和Session对象的事件处理程序
   事件处理程序                                            说    明
Application_Start()

Application_Error()  当产生未能处理错误时，触发 Application_Error 事件 
Session_Start()      当用户建立 Session 时间时，就触发 Session_Star 事件，如果有 50 位用户，就触发 50 次事件，每个事件是独立触发的，不会互相影响，通常用来初始化用户专用的 Session 变量
Session_End()        当用户在默认时间内没有进入其他ASP.NET 程序时，就会触发此事件，时间是由 TimeOut 属性设定，通常是善后用途的程序代码，例如将 Session 变量存入数据库或文本文件


1.Application_Start（程序启动）           当第 1 位用户进入 ASP.NET 程序时，Application_Start 事件就触发，在触发后，就算有成千上万位用户进入网站都不会重新触发，除非 Web 服务器关机。通常用来初始化 Application 变量，例如初始的访客计数
2.Application_BeginRequest（开始请求）
3.Application_AuthenticateRequest(验证鉴别身份，身份通过后授权）
4.Application_AuthorizeRequest（授权）
5.Application_ResolveRequestCache（授权后读取缓存服务）
6.Application_AcquireRequestState（获得请求状态）
7.Application_PreRequestHandlerExecute（请求执行）
8.Application_PostRequestHandlerExecute（事件执行后触发）
9.Application_ReleaseRequestState（执行完所有事件后触发）
10.Application_UpdateRequestCache（更新程序请求的缓存数据）
11.Application_EndRequest（结束一个请求事件）
12.Application_PreSendRequestHeaders（发送给客户端头预处理）
13.Application_End()    当 Web 服务器关机时，Application_End 事件就会触发


2、使用
（1）记录人数
在application_start事件中添加如下代码:
Application.Lock();
Application["count"]=0;//记录人数      //Application.Add("count", 0);
Application.UnLock();
在session_start事件中添加如下代码：
Application.Lock();
Application["count"]=Convert.ToInt32(Application["count"])+1;
Application.UnLock();

在session_end事件中添加如下代码：
Application.Lock();
Application["count"]=Convert.ToInt32(Application["count"])-1;
Application.UnLock();
所有时间均要在Global.asax.cs中编写 

（2）页面URL重定向
在application_start事件中添加如下代码:
string oldUrl = HttpContext.Current.Request.RawUrl;
this.Context.RewritePath(newUrl);

补充：
要让session_onend执行的充分条件：
（1）至少有一个request成功完整地执行
（2）至少存储一些data在session state中。可以通过session变量或者加上session_onstart来实现。
最后声明一点，session_onend只在InProc模式中支持，也就是说，只在session data在asp.net worker process中时支持。


B、Web.config配置
1.文件结构
<configuration>
    <appSettings>
        <add key="k" value="88"/>   //System.Configuration.ConfigurationSettings.AppSettings["k"];
    </appSettings>


    <system.web>
        <!-- 
        用于支持上传大文件，默认支持4Ｍ，现在修改为400Ｍ
        httpRuntime是配置asp.net http运行时设置，以确定如何处理对asp.net应用程序的请求。
        executionTimeout：表示允许执行请求的最大时间限制，单位为秒
        maxRequ或者指示是否代之以将相对重定向发送到客户端。如果为 True，则所有不是完全限定的重定向都将自动转换为完全限定的格式。false 是默认选项。
        minFreeThreads：表示指定允许执行新请求的自由线程的最小数目。ASP.NET 为要求附加线程来完成其处理的请求而使指定数目的线程保持自由状态。默认值为 8。
        minLocalRequestFreeThreads：表示ASP.NET 保持的允许执行新本地请求的自由线程的最小数目。该线程数目是为从本地主机传入的请求而保留的，以防某些请求在其处理期间发出对本地主机的子请求。这避免了可能的因递归重新进入 Web 服务器而导致的死锁。
        appRequestQueueLimit：表示ASP.NET 将为应用程序排队的请求的最大数目。当没有足够的自由线程来处理请求时，将对请求进行排队。当队列超出了该设置中指定的限制时，将通过“503 - 服务器太忙”错误信息拒绝传入的请求。
        enableVersionHeader：表示指定 ASP.NET 是否应输出版本标头。Microsoft Visual Studio 2005 使用该属性来确定当前使用的 ASP.NET 版本。对于生产环境，该属性不是必需的，可以禁用。
        -->
        <httpRuntime executionTimeout="60" maxRequestLength="400000" useFullyQualifiedRedirectUrl="true" minFreeThreads="8" minLocalRequestFreeThreads="4" appRequestQueueLimit="100" enableVersionHeader="true"/>
        <pages buffer="true" enableViewState="false" />
        <custemErrors defaultRedirect="url" mode="On|Off|RemoteOnly">
            <error statusCode="NO." redirect="url"/>
        </custemErrors>
        <compilation defaultLanguage="c#" debug="true">
            <assemblies>
                <add assembly="System.Transactions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
                <add assembly="System.Data.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
                <add assembly="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
                <add assembly="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>
                <add assembly="Microsoft.JScript, Version=10.0.0.0, Culture=neutral, PublicKeyToken=B03F5F7F11D50A3A"/>
            </assemblies>
        </compilation>
        <authentication mode="Windows|Forms|Passport|None">
            <forms name="authWeb" loginUrl="login.aspx" protection="All|None" timeout="30">
                <credentials passwordFormat="Clear|MD5|SHA1">
                    <user name="aaa" password="aaa">
            </forms>
        </authentication>
        
        <identity impersonate="true" userName="taihe\guolei.yu" password="copy!me&amp;491!"/>
        
        <authorization>
            <deny users="?,a" />//匿名用户
            <allow users="*" />//所有用户
        </authorization>
        
        <trace enabled="true" pageOutput="true" />
        <configuration>
            <compilation debug="true|false" />
        </configuration>
        <!-- 
        必要屬性
        mode 指定儲存工作階段狀態的位置。
        Off 指示不啟用工作階段狀態。
        InProc 指示在本機儲存工作階段狀態。
        StateServer 指示在遠端伺服器儲存工作階段狀態。
        SQLServer 指示在 SQL Server 儲存工作階段狀態。
        選擇性屬性
        cookieless 指定是否應該使用不含 Cookie 的工作階段來識別用戶端工作階段。 
        true 指示應該使用不含 Cookie 的工作階段。 
        false 指示不應該使用不含 Cookie 的工作階段。預設為 false。
        timeout 指定在棄置工作階段之前工作階段可閒置 (Idle) 的分鐘數。預設值是 20。
        stateConnectionString指定在遠端儲存工作階段狀態的伺服器名稱和連接埠。例如，「tcpip=127.0.0.1:42424」。當 mode 是 StateServer 時就需要這個屬性。
        sqlConnectionString 指定 SQL Server 的連接字串。例如，「data source=localhost;Integrated Security=SSPI;Initial Catalog=northwind」。當 mode 是 SQLServer 時就需要這個屬性。
        stateNetworkTimeout在使用 StateServer 模式儲存工作階段狀態時，指定在放棄工作階段前，Web 伺服器和狀態伺服器之間的 TCP/IP 網路連接可以閒置多少秒。預設值是 10。
        備註
        1.使用 StateServer 模式 
        （1）確定已在將儲存工作階段狀態資訊的遠端伺服器執行 ASP.NET 狀態服務。這項服務是用 ASP.NET 安裝的，而且根據預設會位於 <Drive>:\systemroot\Microsoft.NET\Framework\version\aspnet_state.exe。
        （2）在應用程式的 Web.config 檔案中，設定 mode=StateServer 和設定 stateConnectionString 屬性。例如，stateConnectionString="tcpip=dataserver:42424"。
        2.使用 SQLServer 模式 
        （1）在執行 SQL Server 且將會儲存工作階段狀態的電腦上，執行 InstallSqlState.sql (根據預設會安裝於 <Drive>:\systemroot\Microsoft.NET\Framework\version)。如此會建立稱為 ASPState 的資料庫，其中具有新的預存程序，且 ASPStateTempApplications 和 ASPStateTempSessions 資料表在 TempDB 資料庫中。
        （2）在應用程式的 Web.config 檔案中，設定 mode=SQLServer 和設定 sqlConnectionString 屬性。例如，sqlConnectionString="data source=localhost;Integrated Security=SSPI;Initial Catalog=northwind"。
        -->
        <sessionState mode="Off|InProc|StateServer|SQLServer"
                      cookieless="true|false"
                      timeout="number of minutes"
                      stateConnectionString="tcpip=server:port"
                      sqlConnectionString="sql connection string"
                      stateNetworkTimeout="number of seconds"/>
    </system.web>

</configuration>

※注意：
在XML元素中，“<”和“&”是非法的。
“<”会产生错误，因为解析器会把该字符解释为新元素的开始，此时可使用"&lt;"代替。
“&”也会产生错误，因为解析器会把该字符解释为字符实体的开始，此时可使用"&amp;"代替。
如：
endpoint address="" behaviorConfiguration="RestBehavior" binding="webHttpBinding"
          bindingConfiguration="" contract="DailyReport.Web.IRESTService&lt;T>" />

※注意：
默认情况下web.config修改后，asp.net程序会被重启。为了防止程序重启，要修改machine.config 文件。
machine.config默认在C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\CONFIG目录下。
<section name="appSettings" type="System.Configuration.AppSettingsSection, System.Configuration, Version=2.0.0.0,Culture=neutral,  PublicKeyToken=b03f5f7f11d50a3a" 
  restartOnExternalChanges="false" requirePermission="false" />
restartOnExternalChanges设置为false，程序就不会重启了。

2.后台使用方法
（1）服务端
//设置用户名为cookie，参数1用户名，参数2有效期为永久
System.Web.Security.FormsAuthentication.SetAuthCookie(_username, false);//暂时的false，永久的true设置cookie
response.redirect(...)

//设置用户名为cookie后，重定向至ReturnUrl页面，参数1用户名，参数2有效期为永久，相当于以上两句
System.Web.Security.FormsAuthentication.RedirectFromLoginPage(_username, false);//暂时的false，永久的true

//登出（删除用户名cookie）
System.Web.Security.FormsAuthentication.SignOut();

//使用<authentication\forms>中的<users>进行验证，参数1用户名，参数2密码
System.Web.Security.FormsAuthentication.Authenticate(_username, _password)==true|false

//转换为MD5编码
System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(_username, "MD5");
（2）客户端
    ////以下为基于Forms验证的处理代码，其他验证方式请根据具体情况处理登录成功后的代码
    FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(1, userinfo.UserId.ToString(), System.DateTime.Now, System.DateTime.Now.AddYears(10), true, "/");
    string AuthBase64 = "Basic " + Library.Ciphering.Base64.EncodingString(string.Format("{0}:{1}", User, PWD));
    new HttpClient().DefaultRequestHeaders.Add("Authorization", AuthBase64);

    string cookieValue = FormsAuthentication.Encrypt(ticket);
    HttpCookie loginCookie = new HttpCookie(FormsAuthentication.FormsCookieName, cookieValue);
    Context.Response.Cookies.Add(loginCookie);
    Response.Redirect("~/Default.aspx");




//custemErrors错误代码跳转
public class UploadError : System.Web.UI.Page
{
  private void Page_Load(object sender, System.EventArgs e)
  {
    Exception ex = Server.GetLastError();
  if (ex != null)
  {
  Response.Redirect("../error.aspx");
  }
  else //前台错误ex为空值
  { 
    Response.Redirect("uploadexcel.aspx?err=1"); //重新跳转到上传页面，加上err参数是为了显示错误信息
  }
}


public class uploadexcel : System.Web.UI.Page
{
    private void Page_Load(object sender, System.EventArgs e)
    {
        if (Request["err"] == "1")
        {
        Page.RegisterStartupScript("budget", "<script language = javascript>alert('Upload file has failed ! File size is too large !')</script>");
        }
    }
}

3.配置文件的操作
ConfigurationManager与ConfigurationSettings的区别：
在.net 1.0版本中，使用ConfigurationSettings类来读取配置文件(web/app.config)；而在.net 2.0中，使用ConfigurationManager类来读取配置文件;

（1）读取Key-Value
  <appSettings>
    <add key="ServerType" value="IIS7" />
  </appSettings>
  if (ConfigurationManager.AppSettings[key] == null)

（2）获取Configuration
1）App.config
    System.Configuration.Configuration config = System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel.None);
    
    // 也可指定位置文件进行读取
    ExeConfigurationFileMap map = new ExeConfigurationFileMap(){ ExeConfigFilename = @"C:\App1.config" };
    System.Configuration.Configuration config = ConfigurationManager.OpenMappedExeConfiguration(map, ConfigurationUserLevel.None);
2）App.config
    直接使用ConfigurationManager
3）全局applicationHost.config
    Microsoft.Web.Administration.Manage manage = new Microsoft.Web.Administration.ServerManager();
    System.Configuration.Configuration config = manage.GetApplicationHostConfiguration();
4）单个网站web.config
    Microsoft.Web.Administration.Manage manager = new Microsoft.Web.Administration.ServerManager();
    System.Configuration.Configuration config = manager.GetWebConfiguration("Default Web Site");

（3）读取Section
<configuration>
  <configSections>
  </configSections>
  <AppPoolGroup>
    <AppPool>
      <add key="v2.0,Integrated" value="2" />
      <add key="v2.0,Classic" value="2" />
      <add key="v3.0,Integrated" value="2" />
      <add key="v3.0,Classic" value="2" />
      <add key="v4.0,Integrated" value="2" />
      <add key="v4.0,Classic" value="2" />
      <add key="None,Integrated" value="2" />
      <add key="None,Classic" value="2" />
    </AppPool>
  </AppPoolGroup>
</configuration>
ConfigurationSection section = ConfigurationManager.GetSection("AppPoolGroup/AppPool");
NameValueCollection configCollection = (NameValueCollection)section.GetCollection();
string key = configCollection.AllKeys[index];

ConfigurationSection section = ConfigurationManager.GetSection("AppPoolGroup/AppPool");
ConfigurationElementCollection eleCollection = section.GetCollection();
ConfigurationElement ele = eleCollection.where(it => it.Attributes[key] == "None,Classic");


（4）修改
System.Configuration.Configuration config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
...     //修改
config.Save(ConfigurationSaveMode.Modified);
ConfigurationManager.RefreshSection(sectionName);       //配置文件默认首次读取，以后不会默认更改，如果程序已经运行，这时你修改了配置文件，就必须调用该方法以刷新到最新修改

（5）
如果你的程序是对其它程序的配置文件进行操作，代码如下：
ExeConfigurationFileMap filemap = new ExeConfigurationFileMap();
filemap.ExeConfigFilename = filePath;       //配置文件路径
config = ConfigurationManager.OpenMappedExeConfiguration(filemap, ConfigurationUserLevel.None);

（6）添加
    <location path="00000000000001df" overrideMode="Deny">
        <system.webServer>
            <directoryBrowse enabled="false" />
            <httpErrors errorMode="Detailed">
                <clear />
                <error statusCode="401" subStatusCode="0" prefixLanguageFilePath="" path="/error/401.htm" responseMode="ExecuteURL" />
                <error statusCode="403" subStatusCode="0" prefixLanguageFilePath="" path="/error/403.htm" responseMode="ExecuteURL" />
                <error statusCode="404" subStatusCode="0" prefixLanguageFilePath="" path="/error/404.htm" responseMode="ExecuteURL" />
                <error statusCode="405" subStatusCode="0" prefixLanguageFilePath="" path="/error/405.htm" responseMode="ExecuteURL" />
                <error statusCode="406" subStatusCode="0" prefixLanguageFilePath="" path="/error/406.htm" responseMode="ExecuteURL" />
                <error statusCode="412" subStatusCode="0" prefixLanguageFilePath="" path="/error/412.htm" responseMode="ExecuteURL" />
                <error statusCode="500" subStatusCode="0" prefixLanguageFilePath="" path="/error/500.htm" responseMode="ExecuteURL" />
                <error statusCode="501" subStatusCode="0" prefixLanguageFilePath="" path="/error/501.htm" responseMode="ExecuteURL" />
                <error statusCode="502" subStatusCode="0" prefixLanguageFilePath="" path="/error/502.htm" responseMode="ExecuteURL" />
            </httpErrors>
            <defaultDocument>
                <files>
                    <clear />
                    <add value="index.html" />
                    <add value="index.aspx" />
                    <add value="index.asp" />
                    <add value="Default.aspx" />
                </files>
            </defaultDocument>
            <security>
                <ipSecurity enableReverseDns="true" />
            </security>
        </system.webServer>
    </location>
    
    
    ConfigurationSection cs = configuration.GetSection("system.webServer/httpErrors", model.UUID);
    cs.OverrideMode = OverrideMode.Deny;            //这里表示，如果用户在自己的WEB.CONFIG里设置了属性，也不会起作用    
    cs.SetAttributeValue("errorMode", "Detailed");
    
    
    ConfigurationElementCollection eles = cs.GetCollection();eles.Clear();   
    ConfigurationElement errorElement = eles.CreateElement("error");
    errorElement["statusCode"] = statusCode;
    errorElement["subStatusCode"] = subStatusCode;
    errorElement["prefixLanguageFilePath"] = prefixLanguageFilePath;
    errorElement["path"] = path;
    errorElement["responseMode"] = responseMode;
    eles.Add(errorElement);


（6）动态读取Config配置文件
    using System.Configuration;

    Uri uri = new Uri(Path.GetDirectoryName(Assembly.GetExecutingAssembly().CodeBase));
    ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap
    {
        ExeConfigFilename = Path.Combine(uri.LocalPath
        , Assembly.GetExecutingAssembly().FullName.Split(',')[0] + ".exe.config")
    };
    Configuration assemblyConfig = ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);
    if (assemblyConfig.HasFile)
    {
        AppSettingsSection section = (assemblyConfig.GetSection("appSettings") as AppSettingsSection);
        string valueA = section.Settings["keyA"].Value;
        string valueB = section.Settings["keyB"].Value;
    } 


（7）解锁IIS的applicationHost.config配置文件模块
dos下执行：%windir%/system32/inetsrv/appcmd unlock config -section:system.webServer/modules










4.兼容性
旧版本的 .NET 程序可以通过配置 <supportedRuntime> 元素在 CLR 4.0 运行。以4.0为例，如要在4.0环境中运行2.0的程序，应在config文件中加入以下内容：
<?xml version="1.0" encoding="utf-8" ?>
 <configuration>
   <startup>
     <supportedRuntime version="v4.0.30319" sku=".NETFramework,Version=v4.0" />
     <supportedRuntime version="v2.0.50727"/>
   </startup>
 </configuration>

C、缓存之Page.Cache
输出缓存
HTML：<%@ OutputCache Duration="5" VaryByParam="none" %>
后台使用：
response.Write()


Response.Cache是 System.Web.HttpCachePolicy，用于设置缓存特定的 HTTP 标头的方法和用于控制 ASP.NET 页输出缓存的方法。比如设置浏览器客户端缓存等



this.Cache.Insert("mynum", 1000);
this.Cache["mynum"].ToString();
if (this.Cache["mynum"]==null)

数据缓存（页面级）
0、对象来源
在HttpRuntime类中加了一个静态属性Cache，这样，我们就可以在任意地方使用Cache的功能。而且，ASP.NET还给它增加了二个“快捷方式”，通过这二个对象也可以访问到HttpRuntime.Cache：
·Page.Cache
·System.Web.HttpContext.Current.Cache
注意：这三者是在访问同一个对象。Page.Cache访问了System.Web.HttpContext.Current.Cache，而System.Web.HttpContext.Current.Cache又直接访问HttpRuntime.Cache 

1、添加缓存
（1）通过指定其键和值将项添加到缓存中 
Cache["txt"] = "a";
（2）通过使用 Insert(重载Insert方法)方法将项添加到缓存中 
Cache.Insert("txt", "a");
下列代码显示如何设置相对过期策略。它插入一个项，该项自上次访问后 10 分钟过期。注意 DateTime.MaxValue 的使用，它表示此项没有绝对过期策略。
DateTime absoluteExpiration=DateTime.MaxValue;
TimeSpan slidingExpiration=TimeSpan.FromMinutes(10);
Cache.Insert("txt", "a", null, absoluteExpiration, slidingExpiration, System.Web.Caching.CacheItemPriority.High, null);
（3）使用 Add 方法将项添加到缓存中 
Add 方法与 Insert 方法具有相同的签名，但它返回表示您所添加项的对象
DateTime absoluteExpiration=DateTime.MaxValue;
TimeSpan slidingExpiration=TimeSpan.FromMinutes(10);
Object Ojb=(string)Cache.Add("txt", "a", null, absoluteExpiration, slidingExpiration, System.Web.Caching.CacheItemPriority.High, null);
string str=(string)Ojb;
Response.Write(str);
（4）Add、Insert区别：
然而，它们有一点小的区别：当要加入的缓存项已经在Cache中存在时，Insert将会覆盖原有的缓存项目，而Add则不会修改原有缓存项（调用失败）。也就是说：如果您希望某个缓存项目一旦放入缓存后，就不要再被修改，那么调用Add确实可以防止后来的修改操作。 而调用Insert方法，则永远会覆盖已存在项（哪怕以前是调用Add加入的）。

从另一个角度看，Add的效果更像是 static readonly 的行为，而Insert的效果则像 static 的行为。
注意：我只是说【像】，事实上它们比一般的static成员有着更灵活的用法。

由于缓存项可以让我们随时访问，看起来确实有点static成员的味道，但它们有着更高级的特性，比如： 缓存过期（绝对过期，滑动过期），缓存依赖（依赖文件，依赖其它缓存项），移除优先级，缓存移除前后的通知等等。 后面我将会分别介绍这四大类特性。


2、取得缓存
（1）取得单一Cache
方式1：
string str=(string)Cache.Get("txt");
Response.Write(str);
方式2：
string str1=(string)Cache["txt1"];
Response.Write(str1);
（2）取得Cache中所有数据
方式1：
System.Text.StringBuilder sb=new System.Text.StringBuilder("", 100);
foreach(DictionaryEntry Caches in Cache)
{
    sb.Append("key=").Append(Caches.Key.ToString()).Append(" ");
    sb.Append("value=").Append(Caches.Value.ToString()).Append(" ");
}
Response.Write(sb.ToString());
方式2：
        public static ArrayList GetAllCacheKey()
        {
            ArrayList arrList = new ArrayList();
            IDictionaryEnumerator enumerator = _cache.GetEnumerator();
            if (enumerator != null)
            {
                while (enumerator.MoveNext())
                {
                    arrList.Add(enumerator.Key);
                }
            }
            return arrList;
        }
（3）查看Cache中的项数
int Count=Cache.Count;
Response.Write(Count.ToString());

3、删除缓存
（1）将单一数据从缓存中删除
Cache.Remove("txt");
（2）清空所有缓存
    public static void Clear()
    {
        System.Collections.IDictionaryEnumerator CacheEnum = System.Web.HttpContext.Current.Cache.GetEnumerator();
        while (CacheEnum.MoveNext())
        {
            System.Web.HttpContext.Current.Cache.Remove(CacheEnum.Key.ToString());
        }
    }


4、生命周期
ASP.NET 缓存中的数据是易失的，即不能永久保存。由于以下任一原因，缓存中的数据可能会自动移除：
（1）永不过期
直接赋值缓存的Key和Value即可
（2）绝对过期
缓存放入Cache时，指定一个具体的时间。当时间到达指定的时间的时，缓存项自动从Cache中移除。
（3）相对(滑动)过期
DateTime absoluteExpiration =DateTime.Now.AddHours(1);
//DateTime.Now.AddDays(5)
//DateTime.Now.Ticks 是指从DateTime.MinValue之后过了多少时间，10000000为一秒
Cache.Insert("txt3", "aa", null, absoluteExpiration, System.Web.Caching.Cache.NoSlidingExpiration);//也可以TimeSpan.Zero;

某些缓存项，我们可能只希望在有用户在访问时，就尽量保留在缓存中，只有当一段时间内用户不再访问该缓存项时，才移除它， 这样可以优化内存的使用，因为这种策略可以保证缓存的内容都是【很热门】的。
TimeSpan slidingExpiration=TimeSpan.FromHours(1);
Cache.Insert("txt4", "4", null, System.Web.Caching.Cache.NoAbsoluteExpiration, slidingExpiration);//也可以DateTime.MaxValue;
另：如果创建的弹性到期时间小于零或大于一年，则将引发异常

注意：以上二个选项分别对应Add, Insert方法中的DateTime absoluteExpiration, TimeSpan slidingExpiration这二个参数，如果都使用Noxxxxx这二个选项，那么缓存项就一直保存在缓存中。（或许也会被移除），这二个参数都是成对使用的，但不能同时指定它们为一个【有效】值，最多只能一个参数值有效。 当不使用另一个参数项时，请用Cache类定义二个static readonly字段赋值。
※NoAbsoluteExpiration与NoSlidingExpiration
.NET2.0 中 System.Web.Caching.Cache.NoAbsoluteExpiration相当于.NET1.1中DateTime.MaxValue
.NET2.0 中 System.Web.Caching.Cache.NoSlidingExpiration相当于.NET1.1中TimeSpan.Zero

（4）缓存已满。
（5）依赖项发生更改
（6）从缓存中显式删除项
（7）调用 Remove 方法，以传递要移除的项的键。







5、缓存优先级
缓存项的优先等级

当承载 asp.net 应用程序的 Web 服务器缺少内存时，Cache 将有选择地清除项来释放系统内存。当向缓存添加项时，可以为其分配与缓存中存储的其他项相比较的相对优先级。在服务器处理大量请求时，分配了较高优先级值的项被从缓存删除的可能性较小，而分配了较低优先级值的项则更有可能被删除。

缓存Cache["txt5"]优先等级设为最高等级，在服务器释放系统内存时，该缓存项最不可能被删除。
Cache.Insert("txt5", "5", null,
System.Web.Caching.Cache.NoAbsoluteExpiration,
System.Web.Caching.Cache.NoSlidingExpiration,
System.Web.Caching.CacheItemPriority.High, null);


6、缓存项时通知应用程序的回调方法
ASP.NET 提供 CacheItemRemovedCallback 委托。它定义编写事件处理程序时使用的签名，当从缓存中删除项时，该事件处理程序将进行响应。
public void onRemove()
{}
CacheItemRemovedCallback callBack = new CacheItemRemovedCallback(onRemove);
System.Web.HttpContext.Current.Cache.Add("cacheName", dt, dep_xmlFile, DateTime.Now.AddDays(5), TimeSpan.Zero, CacheItemPriority.High, callBack);



7、各种缓存方案的共存
ASP.NET Cache是一种缓存技术，然而，我们在ASP.NET程序中还可以使用其它的缓存技术，这些不同的缓存也各有各自的长处。由于ASP.NET Cache不能提供对外访问能力，因此，它不可能取代以memcached为代表的分布式缓存技术， 但它由于是不需要跨进程访问，效率也比分布式缓存的速度更快。如果将ASP.NET Cache设计成【一级缓存】， 分布式缓存设计成【二级缓存】，就像CPU的缓存那样，那么将能同时利用二者的所有的优点，实现更完美的功能以及速度。

其实缓存是没有一个明确定义的技术，一个static变量也是一个缓存，一个static集合就是一个缓存容器了。 这种缓存与ASP.NET Cache相比起来，显然static变量的访问速度会更快，如果static集合不是设计得很差的话， 并发的冲突也可能会比ASP.NET Cache小，也正是因为这一点，static集合也有着广泛的使用。 然而，ASP.NET Cache的一些高级功能，如：过期时间，缓存依赖（包含文件依赖），移除通知，也是static集合不具备的。 因此，合理地同时使用它们，会让程序有着最好的性能，也同时拥有更强大的功能。




D.缓存之System.Runtime.Caching（FrameWork）
using System.Runtime.Caching;

namespace WPFCaching
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, RoutedEventArgs e)
        {
            //建立缓存
            ObjectCache cache = MemoryCache.Default;
            string fileContents = cache["filecontents"] as string;

            if (fileContents == null)
            {
                //创建一个新的 CacheItemPolicy 对象
                CacheItemPolicy policy = new CacheItemPolicy();
                //指定缓存项将在 10 秒后过期。如果未提供任何逐出或过期信息，则默认值为 InfiniteAbsoluteExpiration，这意味着缓存项永远不会仅基于绝对时间而过期。 相反，缓存项仅当存在内存压力时才过期。 最佳做法是，您应始终明确提供一个绝对过期或可调过期
                policy.AbsoluteExpiration =
                    DateTimeOffset.Now.AddSeconds(10.0);

                List<string> filePaths = new List<string>();
                filePaths.Add("c:\\cache\\cacheText.txt");
                //将新的 HostFileChangeMonitor 对象添加到缓存项的更改监视器集合
                policy.ChangeMonitors.Add(new
                    HostFileChangeMonitor(filePaths));

                // Fetch the file contents.
                fileContents = File.ReadAllText("c:\\cache\\cacheText.txt") + "\n" + DateTime.Now.ToString();
                //将文件内容作为 CacheItem 实例插入到缓存对象中
                cache.Set("filecontents", fileContents, policy);

            }
            MessageBox.Show(fileContents);


        }
    }
}



E、各种缓存比较
     方法            信息量大小               保存时间               应用范围              保存位置 
Application           任意大小          整个应用程序的生命期         所有用户              服务器端 
Session           小量、简单的数据         用户活动时间＋            单个用户              服务器端
                                     一段延迟时间(一般为20分钟)
Cookie            小量、简单的数据        可以根据需要设定           单个用户               客户端 
Viewstate         小量、简单的数据       一个Web页面的生命期         单个用户               客户端 
Cache                 任意大小             可以根据需要设定          所有用户              服务器端 
隐藏域            小量、简单的数据       一个Web页面的生命期         单个用户               客户端 
查询字符串        小量、简单的数据       直到下次页面跳转请求        单个用户               客户端 
Web.Config文件  不变或极少改变的小量数据  直到配置文件被更新         单个用户              服务器端 

1、Application
（1）Application用来保存所有用户共用的信息；
（2）在Asp时代，如果要保存的数据在应用程序生存期内不会或者很少发生改变，那么使用Application是理想的选择。但是在Asp.net开发环境中我们把类似的配置数据放在Web.config中；
（3）如果要使用Application要注意的是所有的写操作都要在Application_OnStart事件中完成（global.Asax），尽管可以使用Application.Lock()避免了冲突，但是它串行化了对Application的请求，会产生严重的性能瓶颈；
（4）不要使用Application保存大数据量信息；
（5）代码：
Application["UserID"] = "test";//写 
string UserName = Application["UserID"].ToString();//读 
 
2、Session
（1）Session用来保存每一个用户的专有信息；
（2）Session的生存期是用户持续请求时间加上一段时间（一般是20分钟左右）；
（3）Session信息是保存在Web服务器内存中的，保存数据量可大可小；
（4）Session超时或者被关闭将自动释放数据信息；
（5）由于用户停止使用应用程序之后它仍在内存中存留一段时间，因此这种方法效率较低；
（6）代码：
Session["UserID"] = "test";//写 
string UserName = Session["UserID"].ToString();//读 
 
3、Cookie
（1）Cookie用来保存客户浏览器请求服务器页面的请求信息；
（2）我们可以存放非敏感的用户信息，保存时间可以根据需要设置；
（3）如果没有设置Cookie失效日期，它的生命周期保存到关闭浏览器为止；
（4）Cookie对象的Expires属性设置为MinValue表示永不过期；
（5）Cookie存储的数据量受限制，大多数的浏览器为4K因此不要存放大数据；
（6）由于并非所有的浏览器都支持Cookie，数据将以明文的形式保存在客户端；
（7）代码：
Resopnse.Cookies["UserID"] = "test";//写 
string UserName = Resopnse.Cookies["UserID"].ToString();//读 
 
4、ViewState
（1）ViewState用来保存用户的状态信息，有效期等于页面的生命周期；
（2）可以保存大量数据但是要慎用，因为会影响程序性能；
（3）所有的Web服务器控件都是用ViewState在页面PostBack期间保存状态；
（4）不需要则关闭 @page 里面设置EnableViewState=false；
（5）代码：
ViewState["ID"] = "test";//写 
string ID = ViewState["ID"].ToString();//读 
 
5、Cache
（1）Cache用于在Http请求期间保存页面或者数据；
（2）Cache的使用可以大大的提高整个应用程序的效率；
（3）它允许将频繁访问的服务器资源存储在内存中，当用户发出相同的请求后，服务器不是再次处理而是将Cache中保存的数据直接返回给用户；
（4）可以看出Cache节省的是时间（服务器处理时间）；
（5）Cache实例是每一个应用程序专有的，其生命周期==该应用程序周期，应用程序重启将重新创建其实例；
（6）注意：如果要使用缓存的清理、到期管理、依赖项等功能必须使用Insert 或者Add方法方法添加信息；
（7）代码：
Cache["ID"] = "test"; 或者 Cache.Insert("ID", "test");//写 
string ID = Cache["ID"].ToString();//读 
 
6、Hidden
（1）Hidden控件属于html类型的服务器控件，始终处于隐藏状态；
（2）每一次提交的时候它会和其他服务器控件一起提交到服务器端；
（3）代码：
Hidden.Value = "king";//写 
string id = Hidden.Value; 要使用Runat=server//读 
 
7、查询字符串
（1）查询字符串的方式是将要传递的值连接在URL后面；
（2）一般用于页面之间传递信息；
（3）由于URL的长度有一定的限制，因此不能传递太大的信息；
（4）安全性不是很好。
（5）代码：
Response.Redirect("List.aspx?id=123&name=abc");//传值页面 
string name = Request.QueryString["name"]; string id = Request.QueryString["id"];//取值页面 

·题外话
COOKIE 是本地文件，是40大盗在阿里巴巴家做的记号， 
或者是送牛奶的人在你家门口钉的箱子。 
SESSION 是服务器端内存，是你洗澡时浴池发给你的钥匙。 
自己专用，可以开自己的好多箱子。 
APPLICATION 是公共浴池。 
在这里能看见所有人，包括ppmm哦：）。    




Z、app_offline.htm
    如果你要维护网站怎么办？关闭首页？停掉IIS？或者切换域名到其它服务器？这些都不是最好的办法。 
    其实asp.net内置了一个简单的方法，从asp.net 2.0开始在站点根目录下，只要放置一个App_Offline.htm文件，那么所有对网站的请求都将转向App_Offline.htm。【注：只有ap.net文件受影响，静态页等不在范围内】
 







十五、反射、进程、应用程序域、程序集
I、

A.前言
1.什么是Type？
通常实例化一个对象格式为：
    //等号前半部分是声明“某一类型”的对象，后半部分是为该对象“赋值”，即有了类型和值才是一个完整的对象
    MClass mClass = null;
    //如果不知道对象的值，可以使用变量代替，如：int obj;
    //如果不知道对象的类型，可以使用T代替，如：T obj;
    //即，对值的占位符是对象，类型的占位符是T
Type 与T类似，不过是用于反射

2.介绍
    反射是一种机制，通过这种机制我们可以知道一个未知类型的类型信息。比如，有一个对象a，这个对象不是我们定义的，也许是通过网络捕捉到的，也许是使用泛型定义的，但我们想知道这个对象的类型信息，想知道这个对象有哪些方法或者属性什么的．甚至我们想进一步调用这个对象的方法．关键是现在我们只知道它是一个对象，不知道它的类型，自然不会知道它有哪些方法等信息．这时我们该怎么办？反射机制就是解决这么一个问题的．通过反射机制我们可以知道未知类型对象的类型信息．
    如果是肤浅的理解，反射实际上就是得到程序集中的属性和方法。

//程序集包含模块，而模块包含类型，类型又包含成员，反射则提供了封装程序集、模块和类型的对象。我们可以使用反射动态地创建类型的实例，将类型绑定到现有对象或从现有对象中获取类型，然后调用类型的方法或访问其字段和属性。反射通常具有以下用途。

//（1）使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。
//（2）使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。
//（3）使用ConstructorInfo了解构造方法的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。使用Type的GetConstructors或GetConstructor方法来调用特定的构造方法。
//（4）使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。使用Type的GetMethods或GetMethod方法来调用特定的方法。
//（5）使用FiledInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。
//（6）使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。
//（7）使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。
//（8）使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。

//System.Reflection.Emit命名空间的类提供了一种特殊形式的反射，可以在运行时构造类型。
//反射也可用于创建称为类型浏览器的应用程序，使用户能够选择类型，然后查看有关选定类型的信息。
//此外，Jscript等语言编译器使用反射来构造符号表。System.Runtime.Serialization命名空间中的类使用反射来访问数据并确定要永久保存的字段，System.Runtime.Remoting命名空间中的类通过序列化来间接地使用反射。

B.实现步骤
以下是反射的具体步骤，如果是普通类型（非程序集）的反射，不需要加载程序集。
通过Activator，利用反射进行动态加载和调用DLL。
0、导入
using System.Reflection;
1、加载Assembly
（1）Assembly assembly = Assembly.LoadFrom(assemblyFile);                    //通过dll的路径加载程序集，同时将此程序集所依赖的程序集加载进来，需后辍名.dll
（2）Assembly assembly = Assembly.LoadFile(assemblyFile);                    //只加载指定文件，并不会自动加载依赖程序集
（3）Assembly assembly = Assembly.Load("程序集");                            //通过“全局程序集缓存GAC(Global Assembly Cache)”加载程序集，返回类型是一个Assembly（强命名程序集格式样例：System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089）
（4）Assembly assembly = Assembly.GetAssembly(type);                         //得到该类型所在的程序集
（5）Assembly assembly = Assembly.GetExecutingAssembly();                    //得到当前程序集
2、取得Type
加载dll后，需要使用dll的中某个类。
（1）取得类的类型
Type type = assembly.GetType("namespace.typeName");                          //利用类型的命名空间和名称获得类型
//或
Type type = assembly.GetType("namespace.typeName, assemblyName");            //利用类型的命名空间和名称获得类型
Type type = new className().GetType();
（2）取得程序集中所有类的类型
Type[] types = assembly.GetTypes();
Type[] types = new className().GetTypes();
（3）Type type = typeof(classType);
（4）Type type = Type.GetType("typeName");
（5）创建范型类型
Type listType = typeof(List<>).MakeGenericType(_type);
IList list = Activator.CreateInstance(listType) as IList;

3.1、非实例化（即静态成员）
取得静态变量，或执行静态方法
（1）取得静态成员
MemberInfo[] memberinfo = type.GetMember("Name");
（2）取得所有静态成员
MemberInfo[] memberinfos = type.GetMembers();
（3）执行静态方法
BindingFlags bindingflags = BindingFlags.DeclaredOnly
            | BindingFlags.Public
            | BindingFlags.NonPublic
            | BindingFlags.Instance
            | BindingFlags.IgnoreCase
            | BindingFlags.InvokeMethod
            | BindingFlags.Static;
type.InvokeMember("MehtodName", bindingflags, null, null, null);

3.2、实例化（静态成员不需此步）
需要实例化类型，才可以使用，参数可以人为的指定，也可以无参数，静态实例可以省略。
此部分与JAVA有区别：
C#：
type->实例
或type->Constructor->实例
JAVA：
class->实例
或class->Constructor->实例
（1）无参类型
    Object instance = Activator.CreateInstance(type);                                       //取得该类型的实例
    Object instance = Activator.CreateInstance("assemblyName", "namespaceName.typeName")
（2）有参类型
    Object instance = Activator.CreateInstance(type, construParamValues[]);                 //利用指定的参数，取得该类型的实例
    或               
    ConstructorInfo constructor = type.GetConstructor(construParamsType[]);             
    //constructor.GetParameters()                                                           //可获取构造方法参数
    Object instance = constructor.Invoke(construParamValues);               
4.获取类型中的内容
Method/event/Property->Field->Member

4.1、获取类型中的方法（※可视为反射的核心）             
（1.1）取得方法               
    MethodInfo mInfo = type.GetMethod("MehtodName");                                        //通过方法名称获得方法
    MethodInfo[] mInfos = type.GetMethods();                                                //获取该类型下所包含的方法信息 
    mInfos.ReturnType == typeof(void);                                                      
（1.2）执行方法（※※※※※  最终核心部分  ※※※※※）             
然后对方法进行调用，多态性利用参数进行控制               
    mInfo.Invoke(instance, paramsType[]);                                                   //根据参数直线方法，返回值就是原方法的返回值
------------------------------------------------------------------------------------------------------------------------
（2）直接执行方法
type.InvokeMember("MehtodName", bindingflags, null, instance, null);
4.2、取得类型中的属性（不包括字段）
    PropertyInfo mpi = type.GetProperty("Name");                                            //根据指定的属性名称，获得属性值
    PropertyInfo[] mpis = type.GetProperties();                                             //取得类型中的所有属性
    //取得属性值
    mpi.GetValue(instance, null);
    //设置属性值
    mpi.SetValue(instance, "dinglang", null);
                
4.3、取得类型中的字段（包括其下的属性）
    FieldInfo mpi = type.GetField("Name");                                                  //根据指定的属性名称，获得属性值，默认是NonPublic的
    FieldInfo mpi = type.GetField("Name", BindingFlags.NonPublic);                          //根据指定的属性名称，获得属性值，默认是NonPublic的
    FieldInfo mpi = type.GetTypeInfo().GetDeclaredField("Name");                            //与GetField的区别在于可取得包括NonPublic类型的字段，基本同上
    FieldInfo[] mpis = type.GetFields();                                                    //取得类型中的所有属性
    //取得字段值
    mpi.GetValue(instance, null)
    //设置字段值
    mpi.SetValue(instance, "dinglang", null);

4.4、获取类型中的接口
（1）取得接口
Type[] iInfos = typeof(instance).GetInterfaces();
Type iInfo = typeof(instance).GetInterface("IDisposable");

C.反射的性能
    一般情况下，使用反射来调用方法或者访问字段和属性是比较慢的，这有一下几个原因：
·在查找期望的成员时，绑定操作会导致许多次的字符串比较。
·在传递参数时，我们要首先构造一个数组并初始化其中的元素。然后在内部方法调用时，反射机制又要从数组中提取参数，并将它们放到堆栈上。
·CLR必须检查被传入的参数个数和对应的类型是否正确无误。
·CLR必须确保调用者有适当的安全许可来访问成员。
基于以上原因，我们最好避免使用反射来访问类型成员。另外，如果我们正在编写的应用程序要动态地定位和构造类型，我们应该遵循以下几点原则：
·让类型继承自一个编译时已经确定的基类型。然后在运行时构造一个该类型的实例，并将其引用存放在一个声明类型为其基类的变量中，最后调用基类型中定义的虚方法。
·让类型实现一个编译时已经确定的接口类型。然后在运行时构造一个该类型的实例，并将其引用存放在一个声明类型为其接口类型的变量中，最后调用接口类型中定义的方法。相对上面使用基类型的做法，我个人更喜欢使用接口的方式，因为我们选择的基类型并不是在所有情况下都能正常工作得很好。
·让类型实现的方法的名称和原型匹配一个编译时已经确定的委托类型。（译注：这里的说法是不正确的，只需要方法的原型和委托类型相匹配就可以了，无需匹配方法名称。）然后在运行时构造一个该类型的实例，并用该实例对象和方法的名称构造一个委托的实例，最后通过委托对象来调用期望的方法。这种技巧在三种技巧中需要的工作量最多，尤其在我们需要对一个类型的多个方法进行调用时，工作量会急剧上升。另外注意，通过委托来调用一个方法比直接调用一个类型或接口的方法要慢一些。
在使用上面三种技巧的时候，强烈建议大家将基类型、接口类型或委托类型定义在自己的程序集中，以减少可能出现的版本问题。要了解这种做法的更多信息，可以参见“设计支持插件组件的应用程序”。




D.实例
例1
    double d =  10;
    Type t = d.GetType();
    t.GetProperty("propertyName");

例2
    Type t = Type.GetType("System.Double");

例3
 using System;
 using System.Reflection;
 
 namespace TypeInfoTest
 {
      public class Program
     {
         static void Main(string[] args)
         {
             GetTypeInfo(" TypeInfoTest.Program");
             Console.ReadKey();
         }
 
         private static void GetTypeInfo(string className)
         {
             try
             {
                 Type type = Type.GetType(className);
                 Console.WriteLine("类型名：" + type.Name);
                 Console.WriteLine("类的全名:" + type.FullName);
                 Console.WriteLine("命名空间名:" + type.Namespace);
                 Console.WriteLine("程序集名：" + type.Assembly);
                 Console.WriteLine("模块名：" + type.Module);
                 Console.WriteLine("基类名" + type.BaseType);
                 Console.WriteLine("运行时映射类名：" + type.UnderlyingSystemType);
                 Console.WriteLine("是否是类:" + type.IsClass);
                 Console.WriteLine("是否是从COM类型库导入的："+type.IsImport);//是否应用了ComImportAttribute属性
                 Console.WriteLine("是否是泛型类型："+type.IsGenericType);
                 Console.WriteLine("是否是接口：" + type.IsInterface);
                 Console.WriteLine("是否是抽象类：" + type.IsAbstract);
                 Console.WriteLine("是否是数组类：" + type.IsArray);
                 Console.WriteLine("是否是值类型：" + type.IsValueType);
                 Console.WriteLine("是否是基本类型：" + type.IsPrimitive);
                 Console.WriteLine("是否是公共类型:"+type.IsPublic);
                 Console.WriteLine("关联的属性："+type.Attributes);
                 Console.WriteLine("句柄："+type.TypeHandle);
                 Console.WriteLine("===============MakeArrayType=================");
                 Type t = typeof(Program).MakeArrayType();
                 Console.WriteLine("Program类型的数组: {0}", t);
                 t = typeof(Program).MakeArrayType(2);
                 Console.WriteLine("Program类型的数组: {0}", t);
                 try
                 {
                     t = typeof(Program).MakeArrayType(-1);
                 }
                 catch (Exception ex)
                 {
                     Console.WriteLine("{0}", ex);
                 }
                 Console.WriteLine("===============MakeArrayType=================");
                 Console.WriteLine("\n===============.GetMethods=================");
                 MethodInfo[] Minfos = typeof(Program).GetMethods();
                 foreach (MethodInfo i in Minfos)
                 {
                     Console.WriteLine(i.Name);
                 }
                 Console.WriteLine("===============.GetMethods=================\n");
                 #region "类的公共成员"
                 Console.WriteLine("类的公共成员：");
                 foreach (MemberInfo info in type.GetMembers())
                 {
                     Console.WriteLine("\t{0} ：{1}", info.MemberType, info);
                 } 
                 #endregion
                 #region "类的字段成员"
                 Console.WriteLine("\t类的字段成员:");
                 if (type.GetFields().Length > 0)
                 {
                     foreach (FieldInfo field in type.GetFields())
                     {
                         Console.WriteLine("\t{0} ：{1}", field.MemberType, field);
                     }
                 }
                 else
                 {
                     Console.WriteLine("该类型不包含字段！");
                 }
                 #endregion
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
     }
 }


E、DLL动态链接库
1、概念
动态链接库（也称为DLL，即为“Dynamic Link Library”的缩写）是Microsoft Windows最重要的组成要素之一，打开Windows系统文件夹，你会发现文件夹中有很多DLL文件，Windows就是将一些主要的系统功能以DLL模块的形式实现。
动态链接库是不能直接执行的，也不能接收消息，它只是一个独立的文件，其中包含能被程序或其它DLL调用来完成一定操作的函数(方法。注：C#中一般称为“方法”)，但这些函数不是执行程序本身的一部分，而是根据进程的需要按需载入，此时才能发挥作用。
DLL只有在应用程序需要时才被系统加载到进程的虚拟空间中，成为调用进程的一部分，此时该DLL也只能被该进程的线程访问，它的句柄可以被调用进程所使用，而调用进程的句柄也可以被该DLL所使用。在内存中，一个DLL只有一个实例，且它的编制与具体的编程语言和编译器都没有关系，所以可以通过DLL来实现混合语言编程。DLL函数中的代码所创建的任何对象（包括变量）都归调用它的线程或进程所有。
下面列出了当程序使用 DLL 时提供的一些优点：
1）使用较少的资源
当多个程序使用同一个函数库时，DLL 可以减少在磁盘和物理内存中加载的代码的重复量。这不仅可以大大影响在前台运行的程序，而且可以大大影响其他在 Windows 操作系统上运行的程序。
2）推广模块式体系结构
DLL 有助于促进模块式程序的开发。这可以帮助您开发要求提供多个语言版本的大型程序或要求具有模块式体系结构的程序。模块式程序的一个示例是具有多个可以在运行时动态加载的模块的计帐程序。
3）简化部署和安装
当 DLL 中的函数需要更新或修复时，部署和安装 DLL 不要求重新建立程序与该 DLL 的链接。此外，如果多个程序使用同一个 DLL，那么多个程序都将从该更新或修复中获益。当您使用定期更新或修复的第三方 DLL 时，此问题可能会更频繁地出现。

2、各类
（1）托管与非托管
托管DLL，说白了，就是 完全由.NET托管代码实现的DLL，完全依赖于 .NET 平台的 CLR 运行。托管DLL，受.NET CLR管控，支持内存自动回收等的，对于.NET平台是安全DLL
非托管DLL，是指完全或者部分 不是用.NET代码实现，不依赖于.NET平台即可运行，例如 COM方式 的DLL，不支持自动回收内存，对于.NET平台而言，也是非安全可控的。
一般可以认为：非托管代码主要是基于win 32平台开发的DLL，activeX的组件，托管代码是基于.net平台开发的。
（2）普通dll、com组件dll、.net类库dll
dll是动态链接库里面有好多方法（c语言叫函数），如果调用c语言编写的普通dll，那么就要用dllimport，典型的像windows api函数都是c语言编写的dll所以都要dllimport。
·C语言编写的普通dll，要用dllimport
·com组件dll，“添加引用”后，使用using
com是一种与语言无关的windows规范，里面不光有方法还有一些遵照规范的描述性信息，比如有哪些方法，叫什么名字等。所以这种遵守windows统一规范的动态链接库就不需要dllimport了，就可以“添加引用”来用，而且还可以用对象浏览器来看里面都有哪些方法，而对象浏览器里的这些信息就是编写那些动态链接库的人遵照com规范写进去的，所以对象浏览器可以读出来看到。然后就可以using来用了，就像用普通的.net类库一样，因为和com的操作vs都封装好了，典型的像flash组件就是。
·.net类库dll，“添加引用”后，使用using

3、调用
（1）静态调用DLL中的托管函数
1）引用
.net下有的命名空间可以直接using，比如System.IO；
有的就必须添加.net引用后才能using，比如System.Drawing，必须“添加引用”找到System.drawing确定，才能using System.Drawing；
因为System.IO命名空间在System.dll这个程序集里面，System.dll这个程序集包括了好多的命名空间而不只一个。
而System.IO命名空间就在System.dll程序集里面，所以就不用添加引用了。
每个.net程序至少要包括一个引用“System”，就是这么来的。因为System.dll程序集下面有好多常用的功能了。
而像System.Drawing就不在System.dll程序集里，所以要单独添加引用“System.Drawing”，其实是添加的System.Drawing.dll这个程序集。
2）using
3）调用

※解决dll版本冲突的问题
未能加载文件或程序集“xxx, Version=x.x.x.x, Culture=neutral, PublicKeyToken=xxxxxxxxxxxx”或它的某一个依赖项。系统找不到指定的文件

查看dll版本
SN -T "D:\project\liberary\External\log4net.dll"

场景模拟：
本工程引用Newtonsoft.Json.6.0，引用的第三方某个dll依赖Newtonsoft.Json.9.0
★将高版本降为低版本，高版本迁就低版本
<!-- web.config/app.config -->
<runtime>
  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">  
      
      <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30AD4FE6B2A6AEED" culture="neutral"/>  
      <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="6.0.0.0"/>  
    </dependentAssembly>  
  </assemblyBinding>  
</runtime>

★指定版本xxxx.csproj
引用->Newtonsoft.Json.6->特定版本->True

个人理解：通过<dependentAssembly>的方式，指定当前项目生成并使用哪一个版本的dll。

官方解释：
https://docs.microsoft.com/zh-cn/visualstudio/msbuild/resolveassemblyreference-task
- SpecificVersion： Boolean 值。
如果为 true，则在 Include 特性内指定的确切名称必须匹配。
如果为 false，则具有同一简单名称的任何程序集都将起作用。
如果 SpecificVersion 未指定，则该任务会检查项中 Include 特性的值。 如果该特性是一个简单名称，则其行为方式如同 SpecificVersion 是 false。 如果该特性是一个强名称，则其行为方式如同 SpecificVersion 是 true。
当与引用项类型搭配使用时， Include 特性必须是要解析的程序集的完整合成名称。 仅当合成名称完全匹配 Include 特性时才解析该程序集。
如果项目面向 .NET Framework 版本，且引用了为更高版本 .NET Framework 编译的程序集，则该引用仅当 SpecificVersion 设置为 true。
如果项目面向配置文件，且引用的程序集不位于该配置文件中，则该引用仅当 SpecificVersion 设置为 true。


★两种版本共存
<!-- publicKeyToken相同 -->
<runtime>
  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">  
    <dependentAssembly>  
        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
        <codeBase version="9.0.0.0" href="E:\ConsoleApp2\packages\Newtonsoft.Json.9.0.1\lib\net45\Newtonsoft.Json.dll" />
        <!-- 此场景可不加该条，因为一个启动项目默认会加入该项目的直接引用dll的codeBase配置项 -->
        <codeBase version="6.0.0.0" href="E:\ConsoleApp2\packages\Newtonsoft.Json.6.0.4\lib\net45\Newtonsoft.Json.dll" />
    </dependentAssembly>  
  </assemblyBinding>  
</runtime>
或
<!-- publicKeyToken不同 -->
<runtime>
  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">  
    <dependentAssembly>  
        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
        <codeBase version="9.0.0.0" href="E:\ConsoleApp2\packages\Newtonsoft.Json.9.0.1\lib\net45\Newtonsoft.Json.dll" />
    </dependentAssembly>  
    <dependentAssembly>  
        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
        <codeBase version="6.0.0.0" href="E:\ConsoleApp2\packages\Newtonsoft.Json.6.0.4\lib\net45\Newtonsoft.Json.dll" />
    </dependentAssembly>  
  </assemblyBinding>  
</runtime>



（2）动态调用DLL中的托管函数
见“反射”程序集部分。

（3）静态调用DLL中的非托管函数
1）DllImport定义
    DllImport是System.Runtime.InteropServices命名空间下的一个属性类，其功能是提供从非托管DLL导出的函数的必要调用信息。
    DllImport属性应用于方法，要求最少要提供包含入口点的dll的名称。
    DllImport的定义如下： 
    [AttributeUsage(AttributeTargets.Method)]
    public class DllImportAttribute: System.Attribute
    {
        /* 单个定位参数 */
        public DllImportAttribute(string dllName) {...}           //定位参数为dllName
        /* 六个命名参数 */
        public CallingConvention CallingConvention;               //指示入口点的调用约定，缺省值：CallingConvention.Winapi，即Stdcall（同Winapi）
                                                                  //如：CallingConvention=CallingConvention.Winapi、CallingConvention.StdCall]
                                                                  //在C++里是__stdcall的形式，其它如__cdecl，__fastcall
        public CharSet CharSet;                                   //指示入口点采用的字符集，缺省值：CharSet.Auto，如：CharSet=CharSet.Ansi
        public string EntryPoint;                                 //指示入口点名称，缺省值：方法本身的名称
        public bool ExactSpelling;                                //指示EntryPoint是否必须与指示的入口点的拼写完全匹配，缺省值：false，如：ExactSpelling=false
        public bool PreserveSig;                                  //指示方法的签名是被保留还是被转换，缺省值：true，如：PreserveSig=true
                                                                  //当签名被转换时，它被转换为一个具有 HRESULT 返回值和该返回值的一个名为 retval 的附加输出参数的签名
        public bool SetLastError;                                 //指示方法是否保留Win32的FindLastError方法的返回值，缺省值：false，如：SetLastError=true，
        public string Value { get {...} }
    } 

2）DllImport格式
    [DllImport("dllfilename"), EntryPoint="entrypointmethoed", CharSet=CharSet.Ansi]
    public static extern int mymethod(ParamList);

[DllImport("Dll文件")]
修饰符 extern 返回变量类型 方法名称 （参数列表）
其中：
DLL文件：包含定义外部方法的库文件。
修饰符： 访问修饰符，除了abstract以外在声明方法时可以使用的修饰符。
返回变量类型：在DLL文件中需调用方法的返回变量类型。
方法名称：在DLL文件中需调用方法的名称。
参数列表：在DLL文件中需调用方法的列表。

注意：需要在程序声明中使用System.Runtime.InteropServices命名空间。
      DllImport只能放置在方法声明上，且调用DLL中的非托管函数是全局的、静态的、外部的函数
      DLL文件必须位于程序当前目录或系统定义的查询路径中（即：系统环境变量中Path所设置的路径）。
      返回变量类型、方法名称、参数列表一定要与DLL文件中的定义相一致。
      它是一次性属性类。 
3）用法示例：
例1：
    [DllImport("kernel32")]
    private static extern long WritePrivateProfileString(string section, string key, string val, string filePath);    //这是用来写入ini文件的一个win32api。
例2：
    [DllImport("User32", EntryPoint="MessageBoxA", CallingConvention=CallingConvention.StdCall)]
    public static extern int MsgBox (System.IntPtr handle, System.String msg, System.String caption, System.UInt32 type);
例3：
    [DllImport("wininet.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern bool InternetSetCookie(string lpszUrlName, string lbszCookieName, string lpszCookieData);


4）例子
<1>Count.cpp
// 导出函数，使用“ _stdcall ” 标准调用
extern "C" _declspec(dllexport)int _stdcall count(int init);
int _stdcall count(int init)
{
  //count 函数，使用参数 init 初始化静态的整形变量 S ，并使 S 自加 1 后返回该值
  static int S=init;
  S++;
  return S;
}
编译后，得到Count.dll

<2>.cs
[DllImport("Count.dll")]
static extern int count(int init);
 
MessageBox.Show("用 DllImport 调用 DLL 中的 count 函数， \n 传入的实参为 0 ，得到的结果是：" + count(0).ToString(), "挑战杯");
MessageBox.Show("用 DllImport 调用 DLL 中的 count 函数， \n 传入的实参为 5 ，得到的结果是：" + count(5).ToString() + "\n 结果可不是想要的 6 哦！！！", "挑战杯");
MessageBox.Show("所得结果表明：\n 用 DllImport 调用 DLL 中的非托管 \n 函数是全局的、静态的函数！！！", "挑战杯");


（4）动态调用DLL中的非托管函数
1）相关Win32Api
因为C#中使用DllImport是不能像动态load/unload assembly那样，所以只能借助API函数了。在kernel32.dll中，与动态库调用有关的函数包括[3]：
  ①LoadLibrary（或MFC 的AfxLoadLibrary），装载动态库。
  ②GetProcAddress，获取要引入的函数，将符号名或标识号转换为DLL内部地址。
  ③FreeLibrary（或MFC的AfxFreeLibrary），释放动态链接库。
它们的原型分别是：
  ①HMODULE LoadLibrary(LPCTSTR lpFileName);                           //lpFileName：被调用dll的文件名
  ②FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName);       //hModule：被调用dll的句柄（指针）；lpProcName：被调用dll的函数
  ③BOOL FreeLibrary(HMODULE hModule);                                 //hModule：被调用dll的句柄（指针）
可以用IntPtr hModule = LoadLibrary(“Count.dll”);来获得Dll的句柄，用IntPtr farProc = GetProcAddress(hModule, "_count@4"); 来获得函数的入口地址。
知道函数的入口地址后，怎样调用这个函数呢？因为在C#中是没有函数指针的，没有像C++那样的函数指针调用方式来调用函数，所以我们得借助其它方法。经过研究，发现我们可以通过结合使用System.Reflection.Emit及System.Reflection.Assembly里的类和函数达到我们的目的。为了以后使用方便及实现代码的复用，我们可以编写一个类。


2）步骤
<1>LoadLibrary（或MFC 的AfxLoadLibrary），装载动态库。
  IntPtr hModule = LoadLibrary("Count.dll")
<2>GetProcAddress，获取要引入的函数，将符号名或标识号转换为DLL内部地址。
  IntPtr farProc = GetProcAddress(hModule, "_count@4");
<3>Marshal.GetDelegateForFunctionPointer，将非托管函数指针转换为委托。
  public delegate int CountDelegate(int init);
  CountDelegate count = (CountDelegate)Marshal.GetDelegateForFunctionPointer(farProc, typeof(CountDelegate));
  count(888);
<4>FreeLibrary（或MFC的AfxFreeLibrary），释放动态链接库。
  FreeLibrary(hModule);


3）例子
using System.Runtime.InteropServices; // 用 DllImport 需用此 命名空间
using System.Reflection; // 使用 Assembly 类需用此 命名空间
using System.Reflection.Emit; // 使用 ILGenerator 需用此 命名空间

public class dld  //（dynamic loading dll）
/// <summary>
/// 参数传递方式枚举，ByValue 表示值传递，ByRef 表示址传递
/// </summary>
public enum ModePass
{
  ByValue = 0x0001,
  ByRef = 0x0002
}
 



声明LoadLibrary、GetProcAddress、FreeLibrary及私有变量hModule和farProc：
/// <summary>
/// 原型是 :HMODULE LoadLibrary(LPCTSTR lpFileName);
/// </summary>
/// <param name="lpFileName">DLL 文件名 </param>
/// <returns> 函数库模块的句柄 </returns>
[DllImport("kernel32.dll")]
static extern IntPtr LoadLibrary(string lpFileName);

/// <summary>
/// 原型是 : FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName);
/// </summary>
/// <param name="hModule"> 包含需调用函数的函数库模块的句柄 </param>
/// <param name="lpProcName"> 调用函数的名称 </param>
/// <returns> 函数指针 </returns>
[DllImport("kernel32.dll")]
static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

/// <summary>
/// 原型是 : BOOL FreeLibrary(HMODULE hModule);
/// </summary>
/// <param name="hModule"> 需释放的函数库模块的句柄 </param>
/// <returns> 是否已释放指定的 Dll</returns>
[DllImport("kernel32", EntryPoint="FreeLibrary", SetLastError=true)]
static extern bool FreeLibrary(IntPtr hModule);

/// <summary>
/// Loadlibrary 返回的函数库模块的句柄
/// </summary>
private IntPtr hModule = IntPtr.Zero;

/// <summary>
/// GetProcAddress 返回的函数指针
/// </summary>
private IntPtr farProc = IntPtr.Zero;
 



（5）嵌入DLL的调用（实际与“动态调用DLL中的托管函数”相同）
DLL文件作为资源嵌入在C#程序中，我们只要读取该资源文件并以“byte[]”返回，然后就用“Assembly Load(byte[]);” 得到DLL中的程序集，如下：
1）形成byte[]的dll
using System.IO; // 对文件的读写需要用到此命名空间
using System.Reflection; // 使用 Assembly 类需用此命名空间
using System.Reflection.Emit; // 使用 ILGenerator 需用此命名空间
 
// 记录要导入的程序集
static Assembly MyAssembly;

// 添加LoadDll方法
private byte[] LoadDll(string lpFileName)
{
   Assembly NowAssembly = Assembly.GetEntryAssembly();
   Stream fs = null;
   try
   {
      // 尝试读取资源中的 DLL
      fs = NowAssembly.GetManifestResourceStream(NowAssembly.GetName().Name + "." + lpFileName);
   }
   finally
   {
      // 如果资源没有所需的 DLL ，就查看硬盘上有没有，有的话就读取
      if (fs == null && !File.Exists(lpFileName)) throw(new Exception("找不到文件:" + lpFileName));
      else if(fs == null && File.Exists(lpFileName))
      {
          FileStream Fs = new FileStream(lpFileName, FileMode.Open);
          fs = (Stream)Fs;
      }
   }
   byte[] buffer = new byte[(int) fs.Length];
   fs.Read(buffer, 0, buffer.Length);
   fs.Close();
   return buffer; // 以 byte[] 返回读到的 DLL
}
添加UnLoadDll方法来卸载DLL：
public void UnLoadDll()
{
   // 使 MyAssembly 指空
   MyAssembly = null;
}
 

2）调用该byte[]的dll
if(MyAssembly == null || MyAssembly.GetName().Name != Namespace)
        MyAssembly = Assembly.Load(LoadDll(lpFileName));


（6）结论
使用DLL有很多优点，如：节省内存和减少交换操作；开发大型程序时可以把某些模块分配给程序员，程序员可以用任何一门他所熟悉的语言把该模块编译成DLL文件，这样可以提高代码的复用，大大减轻程序员的工作量。当然DLL也有一些不足，如在提要中提及的问题。所以，如何灵活地调用DLL应该是每位程序员所熟知的。
C# 语言有很多优点，越来越多的人开始使用它来编程。但是，C#还有一些不足，如对不少的底层操作是无能为力的，只能通过调用Win32 DLL 或C++等编写的DLL；另外，一般认为C#程序的保密性不够强，因为它容易被Reflector 反编译而得到部分源码，所以需要使用混合编程加强C#程序的保密性，而把DLL嵌入C#程序并实现动态调用的方法是比较理想的方法，因为可以把DLL文件先用某一算法进行加密甚至压缩后再作为资源文件添加到C#程序中，在程序运行时才用某一算法进行解压解密后才进行加载，所以即使用反编译软件，也只能得到一个资源文件，且这个资源文件是用一个复杂算法进行加密过的，不可能再次对资源文件中的内容进行反编译，从而大大加强了代码的保密性。


II、应用程序域与程序集
应用程序结构分为（进程）—应用程序域（AppDomain）—程序集—模块—类型—成员几个层次，公共语言运行库加载器管理应用程序域，这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。
A、概念
1、应用程序域（AppDomain）
.NET结构中，每个应用程序都有一个边界：应用程序域。使用托管IL代码，运行库就不能访问同一个进程中另一个应用程序的内存，多个应用程序可以运行在一个进程的多个应用程序域。
进程4711：应用程序域A：1、2
          应用程序域B：1
进程4712：应用程序域C：2

2、程序集（Assembly）
程序集（Assembly）是.NET程序的最小组成单位。每个程序集都有自己的名称、版本等信息。程序集通常表现为一个文件（.exe或.dll文件），这样的程序集被称为单文件程序集，这种程序集是最常见的。程序集也可以由多个文件组成，每个文件都是一个模块文件或者是一个资源文件，这样的程序集被称为多文件程序集。

（1）程序集结构：
 ------------------------
 |     ------------     |
 |     |程序集清单|     |
 |     ------------     |
 |     ------------     |
 |     |类型元数据|     |
 |     ------------     |
 |     ------------     |
 |     | MSIL代码 |     |
 |     ------------     |
 |     ------------     |
 |     |   资源   |     |
 |     ------------     |
 ------------------------

（2）程序集的两种部署方式：
1.“私有程序集”：通常我们将程序集保存在应用程序配套的目录下，被引用时，需显式指定该程序集的位置。
2.“弱命名程序集”：初始默认的程序集都是私有程序集，这是一种“弱命名程序集”，弱命名程序集“仅靠名称确定唯一性”。在弱命名的情况下，CLR会忽略程序集的版本号，只是当需要使用程序集的时候使用文化信息。
3.“共享（全局）程序集”：当我们有多套程序共同引用同一个程序集时，可将程序集保存在一个公共的“全局程序集缓存（GAC）”中（位于windows/assembly目录），以达到共同引用的目的。GAC使得很多程序可以共享程序集，这也从整体上减少了使用的物理内存。
4.“强命名程序集”：为了保护和区分不同的共享程序集（因为程序集有可能是多个人开发的但是程序集名称一样），我们必须在共享程序集上加密钥签名。如果密钥签名不同即使两个组件的名称、版本、文化相同也不是同一组件。
CLR通过下面的信息来确定它的唯一性：
  1>文件名，但是不包括扩展名。
  2>版本号 Version 如 1.0.232.1
  3>文化 Cultrue 如 "en_us"
  4>公钥的散列值，PublicKeyToken 如b03f5f7f11d50a3a

强命名程序集 = 弱命名程序集 + 密钥签名 + 版本信息
强命名程序集：包括程序集名称、版本信息Version、文化Culture、公共密钥，如：
System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089

★强命名程序集的密钥签名制作
第一步，制作密钥签名文件
将目录转换到当前dll文件的目录下然后执行：sn -k filename.snk
第二步，生成带密钥签名的dll文件
选择当前项目-属性然后给项目选择密钥签名然后重新编译程序
第三步，将dll文件移到GAC中
将新生成的AssemblyT.dll文件拖放到windows/assembly下我们既可以引用了。

（3）程序集的编译：
1.命令：csc File.cs ，功能：编译 File.cs以产生 File.exe，另一种写法：csc/out:MyFile.exe File.cs，可以自定义编译生成的执行文件名称
2.命令：csc /target:library File.cs ，功能：编译 File.cs 以产生 File.dll，另一种写法：csc /target:library /out:MyFile.dll  File.cs，可以自定义编译生成的库文件名称
3.命令：csc /define:DEBUG /optimize /out:File2.exe *.cs ，功能：通过使用优化和定义 DEBUG 符号，编译当前目录中所有的 C# 文件，输出为 File2.exe
4.命令：csc /target:library /out:File2.dll /warn:0 /nologo /debug *.cs ，功能：编译当前目录中所有的 C# 文件，以产生File2.dll 的调试版本，不显示任何徽标和警告
5.命令：csc /target:library /out:Something.xyz *.cs ，功能：将当前目录中所有的 C# 文件编译为Something.xyz（一个DLL）

 - 编译器选项 -                     -   输出文件   -   
  /out:<文件>                       输出文件名（默认值：包含主类的文件或第一个文件的基名称）   
  /target:exe                       生成控制台可执行文件（默认）  (缩写:   /t:exe)   
  /target:winexe                    生成Windows可执行文件         (缩写:   /t:winexe)   
  /target:library                   生成库                        (缩写:   /t:library)   
  /target:module                    生成能添加到其他程序集的模块  (缩写:   /t:module)   
  /define:<符号列表>                定义条件编译符号              (缩写:   /d)   
  /doc:<文件>                       要生成的XML文档文件    
  /recurse:<通配符>                 根据通配符规范，包括当前目录和子目录下的所有文件   
  /reference:<文件列表>             从指定的程序集文件引用元数据  (缩写:   /r)   
  /addmodule:<文件列表>             将指定的模块链接到此程序集中   
-   资源文件    -
  /win32res:<文件>                  指定Win32资源文件(.res)   
  /win32icon:<文件>                 使用该图标输出   
  /resource:<资源信息>              嵌入指定的资源                (缩写:   /res)   
  /linkresource:<资源信息>          将指定的资源链接到此程序集中  (缩写:   /linkres)   
-   代码调试    -   
  /debug[+|-]                       发出调试信息   
  /debug:{full|pdbonly}             指定调试类型（“full”是默认类型，可以将调试程序附加到正在运行的程序）   
  /optimize[+|-]                    启用优化                      (缩写:   /o)   
  /incremental[+|-]                 启用增量编译                  (缩写:   /incr)   
-   错误和警告   -   
  /warnaserror[+|-]                 将警告视为错误   
  /warn:<n>                         设置警告等级(0-4)             (缩写:   /w)   
  /nowarn:<警告列表>                禁用特定的警告消息   
-   语言   -   
  /checked[+|-]                     生成溢出检查   
  /unsafe[+|-]                      允许“不安全”代码   
-   杂项   -   
  @<文件>                           读取响应文件以获得更多选项   
  /help                             显示此用法信息                (缩写:   /?)   
  /nologo                           取消编译器版权信息   
  /noconfig                         不要自动包含CSC.RSP文件   
-   高级   -   
  /baseaddress:<地址>               要生成的库的基址   
  /bugreport:<文件>                 创建一个“错误报告”文件   
  /codepage:<n>                     指定打开源文件时要使用的代码页   
  /utf8output                       UTF-8编码的输出编译器消息   
  /main:<类型>                      指定包含入口点的类型（忽略所有其他可能的入口点）   (缩写:   /m)   
  /fullpaths                        编译器生成完全限定路径   
  /filealign:<n>                    指定用于输出文件节的对齐方式   
  /nostdlib[+|-]                    不引用标准库(mscorlib.dll)   
  /lib:<文件列表>                   指定要在其中搜索引用的附加目录


B、在应用程序域中加载程序集，并对类进行实例化
1、在当前应用程序域中加载程序集，并对类进行实例化
    string name = "Zhaopin.Framework.Core.Configuration.XmlConfig.XmlConfigSource, Zhaopin.Framework";
    
    public static T CreateInstance<T>(string classfullname)
    {
        try {
            string[] typeNames = name.Split(new char[] { ',' }, 1);
            if (typeNames.Length == 1) {
            //在“当前应用程序域”的当前程序集中创建某一类型的实例
                Type type0 = Type.GetType(typeNames[0]);
                return Activator.CreateInstance(type0) as RobotBase;
            }
            else if (typeNames.Length > 1) {
            //在“当前应用程序域”的指定程序集中创建某一类型的实例
                Type type0 = Type.GetType(typeNames[0]);
                Type type1 = Type.GetType(typeNames[1]);
                Assembly assembly = Assembly.Load(type0);
                return assembly.CreateInstance(type1) as RobotBase;
            }
        }
    }

2、在新应用程序域中加载程序集，并对类进行实例化
（1）新建AppDomain
    //简单版
    AppDomain newAppDomain = AppDomain.CreateDomain("New AppDomain");
    //复杂版
    AppDomainSetup setup = new AppDomainSetup();
    setup.ApplicationName = "ApplicationLoader";
    setup.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory;
    setup.PrivateBinPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "private");
    setup.CachePath = setup.ApplicationBase;
    setup.ShadowCopyFiles = "true";
    setup.ShadowCopyDirectories = setup.ApplicationBase;
    AppDomain newAppDomain = AppDomain.CreateDomain("New AppDomain", null, setup);
（2）在新建AppDomain中，实例化程序集中的类
   //无参执行程序集
   newAppDomain.ExecuteAssembly("AssemblyA.exe");
   //无参实例化程序集中的类
   newAppDomain.CreateInstanceAndUnwrap("myDll", "myNameSpace.myClass");
   //有参实例化程序集中的类
   newAppDomain.CreateInstance("myDll", "myNameSpace.myClass", true, System.Reflection.BindingFlags.CreateInstance, null, new object[] {7, 3}, null, null, null).Unwrap();
   //无参实例化当前程序集中的类
   newAppDomain.CreateInstance(Assembly.GetExecutingAssembly().GetName().FullName, typeof(myClass).FullName).Unwrap();
   //CreateInstanceAndUnwrap()等同于CreateInstance().Unwrap()，表示实例化后，执行构造方法

   按值封送
   mySpacename.myClass必须标注可序列化[Serializable]
   object instance = (object)CreateInstanceAndUnwrap(...);
   按引用封送
   mySpacename.myClass必须继承MarshalByRefObject
   MarshalByRefObject instance = (MarshalByRefObject)CreateInstanceAndUnwrap(...);
（3）调用类实例的方法
   已获得实例，要调用实例的方法，见“反射”部分。
（4）卸载应用程序域
   AppDomain.Unload(newAppDomain);

※注意：加载程序集时使用类似"xxx.xxx"格式代表的字符串是程序集的名称，是在建立类库时在类库的项目中点右键属性在这个里面设置的“应用程序集名称”，“不是物理文件的名称”，物理文件件的名称是"xxx.xxx.dll"，如果Assembly.Load()静态方法里面你如果添入物理名称的话，它会显示找不到文件FileNotFond 运行结果 System.RunTime.Remoting.ObjectHandle

C、相关语法
1、AppDomain
AppDomain curentDomain = AppDomain.CurrentDomain;

2、ObjectHandle
（1）简单解释
ObjectHandle用来包装按值封送对象引用，从而使它们可以通过间接寻址返回。
（2）详细解释（其实就是延迟加载）
ObjectHandle允许我们在一个应用程序中创建一个对象，然后将其传递到其他应用程序域中，但是却不用立即强制将定义对象类型的程序集加载到它们中。当我们要访问对象时，我们首先要调用ObjectHandle的Unwrap方法。只有当Unwrap方法被调用时，包含类型元数据的程序集才会被加载。如果该程序集不能被加载，Unwrap方法将抛出一个System.Runtime.Remoting.RemotingException异常。注意Unwrap方法必须在对象的生存期结束之前被调用：默认时间为5分钟。
（3）补充解释
ObjectHandle包含在System.Runtime.Remoting命名空间中，可见它是Remoting相关的，实际上ObjectHandle类只是一个对原类型进行了一个包装以便进行封送。

ObjectHandle ObjectHandleCurrent = Activator.CreateInstance("AssemblyCurrent", "namespaceCurrent.ClassCurrent");
object ObjectCurrent = ObjectHandleCurrent.Unwrap();

ObjectHandle ObjectHandleA = Activator.CreateInstanceFrom("AssemblyA", "namespaceA.ClassA");
object ObjectA = ObjectHandleA.Unwrap();

3、Activator 类 (System)的静态方法CreateInstance。
（1）CreateInstance
CreateInstance(Type type)返回的是object类型，而Activator.CreateInstance(string assemblyName, string typeName)返回的是一个System.Runtime.Remoting.ObjectHandle对象，必须进行一次Unwrap()才能返回Object类型，进而可以强制转换成我们需要的类型。注意，在此之前的CreateInstance只是创建了一个创建对象的构造器，而非真正的创建了对象。
  1）CreateInstance 方法从当前所运行的程序集创建类型的实例。 
  CreateInstance的第一个参数说明是程序集的名称，为null时表示当前程序集；
                  第二个参数说明要创建的类型名称。
  2）CreateInstanceFrom 方法从包含程序集的文件创建实例

另：T t = Activator.CreateInstance<T>();              //也支持范型

4、动态加载与静态加载
DALFactory默认是每一层封装到一个程序集（独立项目）组件里。通过反射机制创建对象实例。
//从程序集创建对象实例
string path = System.Configuration.ConfigurationSettings.AppSettings["DAL"];//数据层的程序集名称
return (IDbObject)Assembly.Load(path).CreateInstance(path+".DbObject");
如果你的数据层不是单独的程序集，可以采用如下方法加载：
//使用与指定参数匹配程度最高的构造方法来创建指定类型的实例
string path = System.Configuration.ConfigurationSettings.AppSettings["DAL"];
string TypeName = path + ".DbObject";
Type objType = Type.GetType(TypeName, true);
return (IDbObject)Activator.CreateInstance(objType);




D、例释
1、加载
（1）文件一：AssemblyA.exe
对象：被用于调用的程序集
作用：此处被分为无参数方法和有参数方法两部分
using System;
namespace Wrox.ProCSharp.Assemblies.AppDomains
{
  public class Demo
  {
    public Demo(int val1, int val2)
    {
       Console.Write("Constructor with the values {0}, {1}" + " in domain {2} called", val1, val2, AppDomain.CurrentDomain.FriendlyName);
    }
  }
  class Program
  {
    static void Main()
    {
       Console.WriteLine("Main in domain {0} called", AppDomain.CurrentDomain.FriendlyName);
    }
  }
}
result:
Main in domain AssemblyA.exe called.
Press any key to continue ...


（2）文件二：DomainTest.exe
对象：用于加载并调用程序集的类
作用：在同一线程中，显示当前AppDomain名称，在新建AppDomain中调用程序集无参数、有参数方法
using System;
namespace Wrox.ProCSharp.Assemblies.AppDomains
{
  class Program
  {
    static void Main()
    {
       AppDomain currentDomain = AppDomain.CurrentDomain;//另外，每个线程都有一个默认的AppDomain，可以通过Thread.GetDomain()来得到
       Concole.WriteLine(currentDomain.FriendlyName);

       AppDomain secondDomain = AppDomain.CreateDomain("New AppDomain");
       //无参调用
       secondDomain.ExecuteAssembly("AssemblyA.exe");
       //有参调用
       secondDomain.CreateInstance("AssemblyA", "Wrox.ProCSharp.Assemblies.AppDomains.Demo", true, System.Reflection.BindingFlags.CreateInstance, null, new object[] {7, 3}, null, null, null);
    }
  }
}
无参result1:
DomainTest.exe
Main in domain New AppDomain called.

有参result2:
DomainTest.exe
Constructor with the values 7, 3 in domain New AppDomain called
Press any key to continue ...


2、卸载
using System;
using System.Runtime.Remoting;
namespace Wrox.ProCSharp.Assemblies
{
  public class CodeDriverInAppDomain
  {
     public string CompileAndRun(string code, out bool hasEror)
     {
        AppDomain codeDomain = AppDomain.CreateDomain("CodeDriver");
        CodeDriver codeDriver = (CodeDriver)codeDomain.CreateInstanceAndUnwrap("DynamicCompileWPF", "Wrox.ProCSharp.Assemblies.CodeDriver");
        //相当于CodeDriver codeDriver = Activator.CreateInstance(codeDomain, "DynamicCompileWPF", "Wrox.ProCSharp.Assemblies.CodeDriver").Unwrap();
        string result = codeDriver.CompileAndRun(code, out hasError);
        AppDomain.Unload(codeDomain);//关键点
        return result;
     }
  }
}

CodeDom是在.NET1.0，在新版本中又加入了更强大的CodeAnalysis

E、嵌入的资源
1.手动嵌入的资源
可将一个图片、xml等文件的生成操作设为“嵌入的资源”
Assembly _assembly = System.Reflection.Assembly.GetExecutingAssembly();
string resourceName = "<namespace>.<subfolders>.<image name>.<extension>(<命名空间>.<文件夹>.<图片名>.<后缀>)";
Stream stream = _assembly.GetManifestResourceStream(resourceName);
※通过_assembly.GetManifestResourceNames()可获取资源清单

2..net提供的访问嵌入式资源
（1）创建资源文件Resources.resx
（2）添加资源，可以是字符串、文字、图片、文件等
（3）获取资源：命名空间.Properties.Resources.ResourceManager


IV、动态编译
A、动态编译
  0、引用空间域名
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using Microsoft.CSharp;
  using System.CodeDom.Compiler;
  using System.Reflection;
namespace makenamespace
{
    public class makeDll
    {
        public void makeaDll()
        {
            // 1.声明一个CSharpCodePrivoder对象
            CSharpCodeProvider objCSharpCodePrivoder = new CSharpCodeProvider();

            // 2.声明CompilerParameters，编译过程的各种参数封装于此
            CompilerParameters objCompilerParameters = new CompilerParameters();
            objCompilerParameters.ReferencedAssemblies.Add("System.dll");          //添加程序集
            objCompilerParameters.GenerateExecutable = false;                      //生成可执行文件
            objCompilerParameters.GenerateInMemory = true;                         //内存中生成

            //objCompilerParameters.IncludeDebugInformation = false;                 //生成调试信息
            //objCompilerParameters.CompilerOptions = "/target:library /optimize";   //编译器选项设置

            // 3.分析编译结果，如果编译成功则执行
            //方式一            
            CompilerResults cr = objCSharpCodePrivoder.CompileAssemblyFromSource(objCompilerParameters, GenerateCode());
            //方式二
            CompilerResults cr = objCSharpCodePrivoder.CompileAssemblyFromDom(objCompilerParameters, GenerateDom());
            
            // 3.1.CompilerResults--Error
            if (cr.Errors.HasErrors)
            {
                Console.WriteLine("编译错误：");
                foreach (CompilerError err in cr.Errors)
                {
                    Console.WriteLine(err.ErrorText);
                }
            }
            // 3.2.CompilerResults--OK
            else
            {
                // 通过反射，调用HelloWorld的实例
                Assembly objAssembly = cr.CompiledAssembly;
                object objHelloWorld = objAssembly.CreateInstance("DynamicCodeGenerate.HelloWorld");

                MethodInfo objMI = objHelloWorld.GetType().GetMethod("OutPut");

                Console.WriteLine(objMI.Invoke(objHelloWorld, null));
            }

            Console.ReadLine();
        }

        // 4.1 生成代码
        string GenerateCode()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("using System;");
            sb.Append(Environment.NewLine);
            sb.Append("namespace DynamicCodeGenerate");
            sb.Append(Environment.NewLine);
            sb.Append("{");
            sb.Append(Environment.NewLine);
            sb.Append("      public class HelloWorld");
            sb.Append(Environment.NewLine);
            sb.Append("      {");
            sb.Append(Environment.NewLine);
            sb.Append("          public string OutPut()");
            sb.Append(Environment.NewLine);
            sb.Append("          {");
            sb.Append(Environment.NewLine);
            sb.Append("               return \"Hello world!\";");
            sb.Append(Environment.NewLine);
            sb.Append("          }");
            sb.Append(Environment.NewLine);
            sb.Append("      }");
            sb.Append(Environment.NewLine);
            sb.Append("}");

            string code = sb.ToString();
            Console.WriteLine(code);
            Console.WriteLine();

            return code;
        }

        // 4.2 生成CodeCompileUnit
        CodeCompileUnit GenerateDom(string url)
        {
            Stream stream = wc.OpenRead(url);
            ServiceDescription description = ServiceDescription.Read(stream);
            ServiceDescriptionImporter descriptionImporter = new ServiceDescriptionImporter();
            descriptionImporter.AddServiceDescription(description, "", "");
            CodeNamespace codeNamespace = new CodeNamespace(@namespace);

            CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
            codeCompileUnit.Namespaces.Add(codeNamespace);
            descriptionImporter.Import(codeNamespace, codeCompileUnit);
        }
    }

}


B、改进动态编译
一切看起来很好，我们可以编译代码并把代码加载到当前应用程序域中来参与我们的活动，但你是否想过去卸载掉这段程序呢？更好的去控制程序呢？另外，当你运行这个程序很多遍的时候，你会发现占用内存很大，而且每次执行都会增大内存使用。是否需要来解决这个问题呢？当然需要，否则你会发现这个东西根本没用，我需要执行的一些大的应用会隔离到一个小的范围内，称为Application Domain。当一个应用程序运行时，Application Domains将所有的程序集/组件集加载到当前的应用程序域中，并根据需要来调用。而对于动态生成的代码/程序集，我们看起来好像并没有办法去管理它。其实不然，我们可以用Application Domain提供的管理程序集的办法来动态加载和移除Assemblies来达到我们的提高性能的目的。具体怎么做呢，在前边的基础上增加以下步骤：
·创建另外一个Application Domain
·动态创建（编译）代码并保存到磁盘
·创建一个公共的远程调用接口
·创建远程调用接口的实例。并通过这个接口来访问其方法。
换句话来讲就是将对象加载到另外一个AppDomain中并通过远程调用的方法来调用。所谓远程调用其实也就是跨应用程序域调用，所以这个对象（动态代码）必须继承于

MarshalByRefObject类。为了复用，这个接口被单独提到一个工程中，并提供一个工厂来简化每次的调用操作：



 



2、通过AppDomain加载程序，可以控制程序的加载与卸载
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Reflection;

namespace DynamicCompiler
{
    public class Program
    {
        static void Main(string[] args)
        {
            // makenamespace.makeDll.makeaDll 2. modify to
            // objCompilerParameters.GenerateInMemory = false;
            // objCompilerParameters.OutputAssembly = "DynamicalCode.dll";
            // Generate Dll
            new makenamespace.makeDll().makeaDll();
  
            // 1. Create an addtional AppDomain
            AppDomainSetup objSetup = new AppDomainSetup();
            objSetup.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory;
            AppDomain objAppDomain = AppDomain.CreateDomain("MyAppDomain", null, objSetup);

            // 2. Invoke the method by using Reflection
            MarshalByRefObject instance = (MarshalByRefObject)objAppDomain.CreateInstance(Assembly.GetExecutingAssembly().GetName().FullName, typeof(transition).FullName).Unwrap();         //precondition : add "DynamicCompiler.transition : MarshalByRefObject"
            if (instance == null)
            {
                this.txtResult.Text = "Error: " + "Couldn't load class.";
                return;
            }
            Console.ReadLine();
            MethodInfo mInfo = instance.GetType().GetMethod("InvokeDll");
            mInfo.Invoke(instance, null);

            // 3. Dispose the objects and unload the generated DLLs.
            AppDomain.Unload(objAppDomain);
            instance = null;
            System.IO.File.Delete("DynamicalCode.dll");
        }
    }

 

    public class transition : MarshalByRefObject
    {
        public void InvokeDll()
        {
            AppDomainSetup objSetup = new AppDomainSetup();
            objSetup.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory;
            AppDomain objAppDomain = AppDomain.CreateDomain("MyAppDomain", null, objSetup);

            object instance = (object)objAppDomain.CreateInstance("DynamicalCode", "DynamicCodeGenerate.HelloWorld").Unwrap();  //precondition : add "Dynamicly.HelloWorld : MarshalByRefObject"
            MethodInfo mInfo = instance.GetType().GetMethod("OutPut");
            mInfo.Invoke(instance, null);
            AppDomain.Unload(objAppDomain);


            //Assembly assem = Assembly.LoadFrom("DynamicalCode.dll");
            //Type type = assem.GetType("DynamicCodeGenerate.HelloWorld");
            //MethodInfo mInfo = type.GetMethod("OutPut");
            //mInfo.Invoke(Activator.CreateInstance(type), null);
        }
    }
}




十六、调试
A、性能
1、TickCount
说明：从操作系统启动到现在所经过的毫秒数，精度为1毫秒，经简单测试发现其实误差在大约在15ms左右
缺点：返回值是uint,最大值是2的32次方，因此如果服务器连续开机大约49天以后，该方法取得的返回值会归零
使用：
方式一
Environment.TickCount;//获取系统启动后记录的毫秒数
方式二（本质上相同）
[DllImport("kernel32")]
static extern uint GetTickCount();

public void Test()
{
    uint s1 = GetTickCount();
    Thread.Sleep(8000);
    uint s2 = GetTickCount();
}

2、
CodeTimer.Initialize();
CodeTimer.Time("Normal", 10000, () => EvenSquare(source));
CodeTimer.Time("Fast", 10000, () => EvenSquareFast(source)); 

3、DateTime.Now.Ticks
      long ticks = DateTime.Now.Ticks;
      DateTime now = new DateTime(ticks);
      Console.WriteLine(now.ToString("yyyy-MM-dd hh:mm:ss"));

4、QueryPerformanceCounter
说明：
//用于得到高精度计时器（如果存在这样的计时器）的值。微软对这个API解释就是每秒钟某个计数器增长的数值。
//如果安装的硬件不支持高精度计时器，函数将返回false需要配合另一个API函数QueryPerformanceFrequency。
[DllImport("kernel32.dll ")]
static extern bool QueryPerformanceCounter(ref long lpPerformanceCount);

//返回硬件支持的高精度计数器的频率，如果安装的硬件不支持高精度计时器，函数将返回false。
[DllImport("kernel32")]
static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);

使用：
long a = 0;
QueryPerformanceFrequency(ref a);
long b = 0, c = 0;
QueryPerformanceCounter(ref b);
Thread.Sleep(2719);
QueryPerformanceCounter(ref c);
Console.WriteLine((c - b) / (decimal)a);  //单位秒


5、Stopwatch
说明：就是对QueryPerformanceCounter的封装
System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch.StartNew();
watch.Start();                  //开始或继续测量某个时间间隔的运行时间。
watch.Stop();                   //停止测量某个时间间隔的运行时间。
watch.Restart();                //停止时间间隔测量，将运行时间重置为零，然后开始测量运行时间。
watch.Reset();                  //停止时间间隔测量，并将运行时间重置为零。
watch.ElapsedMilliseconds       //获取当前实例测量得出的总运行时间（以毫秒为单位）。
watch.IsRunning                 //获取一个指示 System.Diagnostics.Stopwatch 计时器是否在运行的值。
Stopwatch.StartNew();           //对新的 System.Diagnostics.Stopwatch 实例进行初始化，将运行时间属性设置为零，然后开始测量运行时间。


6、
-t Ping the specified host until stopped.To see statistics and continue - type Control-Break;To stop - type Control-C. 
-a Resolve addresses to hostnames. 
ping -a 192.168.1.21 


B、动态获取运行的行数
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
//line 8
namespace ConsoleLine
{
    class Program
    {
        static void Main(string[] args)
        {
            GetLineParent();
            Console.WriteLine("---------------------------------");
            GetExceptionLine();
            Console.WriteLine("---------------------------------");
            GetLine("In FX4.5");
            Console.WriteLine("---------------------------------");
            Console.ReadKey();
        }
//line 23
        public static void GetLineParent()
        {
            GetLineChildren();
        }
        public static void GetLineChildren()
        {
            StackTrace st = new StackTrace(true);
            StackFrame sfChildren = st.GetFrame(0);
            int lineChildren = sfChildren.GetFileLineNumber();
            string funChildren = sfChildren.GetMethod().Name;
            Console.WriteLine("function" + " (" + funChildren + ")" + " at line " + lineChildren);
            StackFrame sfParent = st.GetFrame(1);
            int lineParent = sfParent.GetFileLineNumber();
            string funParent = sfParent.GetMethod().Name;
            Console.WriteLine("function" + " (" + funParent + ")" + " at line " + lineParent);
            StackFrame sfRoot = st.GetFrame(1);
            int lineRoot = sfRoot.GetFileLineNumber();
            string funRoot = sfRoot.GetMethod().Name;
            Console.WriteLine("function" + " (" + funRoot + ")" + " at line " + lineRoot);
        }
//line 44
        public static void GetExceptionLine()
        { 
            try
            {
                throw new Exception();
            }
            catch(Exception ex)
            {
                StackTrace st = new StackTrace(ex, true);
                StackFrame sf = st.GetFrame(0);
                string fun = st.GetFrame(0).GetMethod().Name;
                int line = sf.GetFileLineNumber();
                Console.WriteLine("function" + " (" + fun + ")" + " at line " + line);
            }
        }
//line 60
        //In FrameWork 4.5
        static void GetLine(string message,
            [CallerLineNumber] int lineNumber = 0,
            [CallerMemberName] string caller = null,
            [CallerFilePath] string filepath= null)
        {
            Console.WriteLine("function" + " (" + caller + ")" + " at line " + lineNumber);
        }

    }
}

Result:
function (GetLineChildren) at line 30
function (GetLineParent) at line 26
function (GetLineRoot) at line 26
---------------------------------
function (GetExceptionLine) at line 49
---------------------------------
function (Main) at line 19
---------------------------------



+++++++++++++++++++
public static void WriteSysLog(string content)
{
    const int level = 1000;

    MethodBase method = MethodBase.GetCurrentMethod();                          //但一般情况下是获取方法的上一级调用方，于是应用以下方式
    //或
    int skipFrameNO = 1;
    bool fNeedFileInfo = false;
    StackTrace sTrace = new StackTrace(fNeedFileInfo);
    //index:0为本身的方法；1为调用方法；2为其上上层，依次类推
    StackFrame sFrame = sTrace.GetFrame(skipFrameNO);
    MethodBase method = sFrame.GetMethod();
    //或
    MethodBase method = new StackFrame(skipFrameNO, fNeedFileInfo).GetMethod();

    string systemModule = Environment.NewLine;
    systemModule += "模块名:" + method.Module.ToString() + Environment.NewLine;
    systemModule += "命名空间名:" + method.DeclaringType.Namespace + Environment.NewLine;
    //仅有类名
    systemModule += "类名:" + method.DeclaringType.FullName + Environment.NewLine;
    systemModule += "方法名:" + method.Name;

}

因而可以得知.NET程序的执行顺序：
System.Threading.ThreadHelper.ThreadStart()
System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()
System.AppDomain._nExecuteAssembly(Assembly assembly, String[] args)
然后进入方法Main中。 

相关类：
在System.Diagnostics 命名空间中的 StackTrace 类 ，表示一个堆栈跟踪，它是一个或多个堆栈帧的有序集合。
在System.Diagnostics 命名空间中的 StackFrame 类 ，提供关于 StackFrame（表示当前线程的调用堆栈中的一个函数调用）的信息。
在System.Reflection 命名空间中的 MethodBase 类 ，提供有关方法和构造方法的信息。
另外，从 MethodBase 类 还可以获取很多其他属性，可以自行定位到System.Reflection.MethodBase 查看。
使用反射可以遍历获得类的所有属性名，方法名，成员名，其中一个有趣的小例子：通过反射将变量值转为变量名本身 
+++++++++++++++++++



C、调试
1、IE浏览器下Fiddler无法本地调试的问题
首先我们应该了解，这个无法本地调试的问题并不是个BUG，微软官方是有给出过解释的，这是源于IE浏览器和.NET框架对于本地请求是不走代理的，因而Fiddler无法检测数据。当然，你也可以使用Firefox浏览器进行调试，目前fiddler的最新版本已经支持Firefox。不过这里我们也给出了在IE浏览器下的解决方案。
（1）使用机器名代替localhost或者12.7.0.1，例如，你之前使用http://localhost:8081/mytestpage.aspx来访问，那换成 http://machinename:8081/mytestpage.aspx来访问。
（2）还有就是修改“%system32%\drivers\etc\hosts”文件了，把127.0.0.1后的localhost改成其它字符串，例如改为local，原来的访问地址http://localhost:8081/mytestpage.aspx就可以简单地写为http://local:8081/mytestpage.aspx，然后就可以调试了。
（3）修改规则：Rules/Custom Rules/
（4）更新规则代码（找到OnBeforeRequest并添加）：
static function OnBeforeRequest(oSession:Fiddler.Session){
    if (oSession.HostnameIs("MYAPP")) { oSession.host = "127.0.0.1:8081"; }
}
然后就可以通过http://myapp来访问。
（5）如果嫌上面那样改代码麻烦的话，最简单的就是直接在URL中的localhost或者127.0.0.1后面加上一个句点符号“.”来访问，即http://localhost.(http://127.0.0.1.)。
    总之就是别使用localhost或者127.0.0.1来访问，给它设置个别名用来访问。
★Firefox浏览器下Fiddler的使用方法：
首先下载fiddler的最新版本并且进行安装，记得要重新启动Firefox，在右下角就会出现一个该 fiddler extension 的功能操作状况:
这个代表安装完成了Fiddler for Firefox的extension了，其中Fiddler: OFF指的是Fiddler Application没有开起来，由于该extension不能直接发起 Fiddler Application，所以手动从程序集里来启用这个application，该状态就会变成Fiddler: ON的状态了，并能顺利收集到Firefox的request及response资料了。

2、远程调试 
（1）位置
C:\Program Files\Microsoft Visual Studio 12.0\Common7\IDE\Remote Debugger\x64
（2）条件
1.你需要在远程机器上安装远程调试监控Visual Studio Remote Debugging Monitor
2.远程调试监控必须以管理员身份运行，并且用户必须属于管理员组
3.在你运行监控时，会开启一个新的服务，该服务的名字必须用Visual Studio的Attach to Progress窗口的Qualifier组合框的值

1.远程和本地机器上的防火墙必须允许Visual Studio和远程调试监控之间能够通信
2.想要调试，PDB文件是关键；为了能够让VisualStudio自动加载它们，必须满足以下条件：
1）本地的PDB文件必须可用（在远程机器的相同路径下放置一个对应的模块）。
2) 远程机器上的托管PDB文化必须可用。
远程调试监控下载：



3、windbg
（1）通过procdump抓取dump文件
procdump -c 70 -s 5 -ma -n 3 w3wp
  - 当系统 CPU 使用率持续 5 秒超过 70% 时，连续抓 3 个 Full Dump。
procdump outlook -p "\Processor(_Total)\% Processor Time" 80
  - 当系统 CPU 使用率超过 80%，抓取 Outlook 进程的 Mini Dump。
procdump -ma outlook -p "\Process(Outlook)\Handle Count" 10000
  - 当 Outlook 进程 Handle 数超过 10000 时抓取 Full Dump
procdump -ma 4572
  - 直接生成进程号位 4572 的 Full Dump。

（2）windbg
·设置符号表
运行 WinDbg 软件，然后按【Ctrl+S】弹出符号表设置窗，将“SRV*C:\Symbols*
http://msdl.microsoft.com/download/symbols”
粘贴在输入框中，点击确定即可。点击确定之前，请先确认文件夹是否已被新建。

·打开第一个 Dump 文件
使用【Ctrl+D】快捷键，或者点击 WinDbg 界面上的【File=>Open Crash Dump...】按钮，来打开一个 Dump 文件。
当你想打开第二个 Dump 文件时，可能因为上一个分析记录未清除，导致无法直接分析 Dump 文件，此时你可以使用快捷键【Shift+F5】来关闭上一个对 Dump 文件的分析记录。　　

·加载sos扩展命令
打开VS20XX开发人员命令提示，并输入：where sos.dll，查看sos.dll所在位置
.load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll

·
!runaway 命令查看线程使用 CPU 时间情况
!clrstack 命令来查看当前的调用堆栈信息
!dso 命令来查看堆栈上的所有对象详细信息

·



十七、数据结构与序列化
适合人类编写：ini > toml > yaml > json > xml > plist
可以存储的数据复杂度：xml > yaml > toml ~ json ~ plist > ini

A.JSON（此处以js为例）
1.什么是JSON
    首先，json不是什么文档，他只是相当于int，string，double这种类型， 不同点就是json为内存使用的变量类型，int之流是我们编码时使用的， 相同点是，你可以把json理解为一种实体model，有限定格式存储数据，总体归纳为键值对例：
{ "城市":"北京", "面积":16800, "人口":1600, "List":[{"a":"1", "b":"2"}, {"a":"3", "b":"4"}] } 
所有json最外层都是一个大括号，中间每个字段以键值对的形式存在，逗号分隔，集合使用中括号包含，引用Newtonsoft.Json.dll可以对变量model什么的进行序列化和反序列化的。

2.JSON访问
（1）JSON
书写AJAX的时候，经常需要解析从服务器返回的一串字符串，这里简单介绍服务器返回字符的两种格式，及JS对它们的解析方法。
JSON即JS对象标记（JavaScript Object Notation），是一种以JS声明对象的方式组合的一串字符串。
JS可以按以下方式定义对象：
var obj =
{
     id: 2,
     name: 'n'
};
alert(obj.name);
这样就定义了对象 obj， 它有两个公共属性id和name，可以用 obj.id 的方式直接访问其属性值。
（2）JSON数组
从服务器获取数据时往往不止一个对象，这就需要用到对象数组，JS中对象数组可以用 [] 来定义，如下：
var objs = [{ id: 1, name: 'n_1' }, { id: 2, name: 'n_2'}];
alert(objs[0].id);
这样就定义了对象数组 objs, 它包含两个对象，可以用索引来访问，如 objs[0] 将引用到第一个对象。

3.JSON转化
（1）JSON数组
到这里你或许已经想到服务器返回的字符串格式是怎样的，但字符串毕竟是字符串，我们需要将其转换为可以利用JS操作的变量。这就用到 eval 函数，请看下例：
var objs = eval("[{ id: 1, name: 'n_1' }, { id: 2, name: 'n_2'}]");
alert(objs[0].id); // return 1
好了，服务器端你只要以格式：[{ id: 1, name: 'n_1' }, { id: 2, name: 'n_2'}] 返回字符串，在客户端就可以利用 eval() 执行返回的字符串，获得对象数组。以下用AJAX做一个简单的例子。用js取json的代码如下：
       var objs = eval(request.responseText);
       alert(objs.length); // 2
       alert(objs[0].id);  // 1
       alert(objs[1].name);// 'n_2'
再添加一个测试按钮即可以看到效果：
<input type="button" value="GetJson" onclick="getJson();" />
（2）JSON字符串
但有时，会遇到Json数据是自己拼接的情况，用js直接读，发现读出来的数据都是undefined...也就是说，像
var tmp = "{name1:'name1', name2:'name2'}";的情况，js是把它当作字符串，而不是JSON数据来处理的。所以，当需要我们把它转化为JSON形数据时，如果直接写：tmp = eval(tmp) 则会报"缺少;"的错误。应该是：tmp =eval("(" + tmp + ")");，然后再使用tmp.name1;就可以了。

B、XML
1、转义符
（1）PCDATA
PCDATA 指的是被解析的字符数据（Parsed Character Data）。XML 解析器通常会解析 XML 文档中所有的文本。
假如在 XML 文档中放置了一个类似 "<" 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此不能这样写：
<message>if salary < 1000 then</message>
为了避免此类错误，需要把字符 "<" 替换为实体引用，就像这样：
<message>if salary &lt; 1000 then</message>

在 XML 中有 5 个预定义的实体引用：
&lt; < 小于 
&gt; > 大于 
&amp; & 和号 
&apos; ' 省略号 
&quot; " 引号 
注释：严格地讲，在 XML 中仅有字符 "<"和"&" 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。 


（2）CDATA
XML 解析器通常会解析 XML 文档中所有的文本。CDATA 部分中的所有内容都会被解析器忽略。
//<![CDATA[

//]]>      
CDATA标签中字符文本是不作为html被再次转义的。比如'& nbsp;'将不像其他地方那样被转换成空格。通常CDATA里面放一些‘一字不改的数据’，比如源代码，比如Javascript源码。
例：
<script>
<![CDATA[
function matchwo(a, b)
{
if (a < b && a < 0) then
  {
  return 1;
  }
else
  {
  return 0;
  }
}
]]>
</script>





.net类库提供了多种读写xml文件的方式，每一种方式都有其优点和 缺点，因而有其实用性。
下面列出微软.net类库提供的读写xml文件个类及其特点：
类名称                                优点                              缺点
XmlReader                快速、高效、可扩展                   只读，只向前，需要人工验证
XmlDocument              可往返、可读写、支持XPath筛选        比XmlReader慢
XPathNavigator           可往返，支持XPath和XSLT              只读
XPathDocument            比XmlDocument，优化支持XPath和XSLT   比XmlReader慢

2、XmlReader与XmlWrite
（1）XmlReader

<?xml version="1.0" encoding="utf-8" ?>
<Menus>
  <Menu title="常用网址">
    <item name="天下网" url="http://www.netskycn.com" id="1">这就是天下网</item>
    <item name="微软" url="http://www.microsoft.com" id="2">这就是微软</item>
  </Menu>
</Menus>



      XmlReader xmlReader = XmlReader.Create(@"d:\menu.xml");
            while (xmlReader.Read())
            {
                textBox1.Text+=("节点类型：" + xmlReader.NodeType);
                textBox1.Text+="\r\n";
                switch (xmlReader.NodeType)
                {
                    case XmlNodeType.XmlDeclaration:
                        for (int i = 0; i < xmlReader.AttributeCount; i++)
                        {
                            xmlReader.MoveToAttribute(i);
                            textBox1.Text+=("属性：" + xmlReader.Name + "=" + xmlReader.Value);
                            textBox1.Text+=" ";
                            if (i==xmlReader.AttributeCount-1) textBox1.Text+="\r\n";
                        }
                        break;
                    case XmlNodeType.Attribute:
                        for (int i = 0; i < xmlReader.AttributeCount; i++)
                        {
                            xmlReader.MoveToAttribute(i);
                            textBox1.Text+=("属性：" + xmlReader.Name + "=" + xmlReader.Value);
                            textBox1.Text+="\r\n";
                        }
                        break;
                    case XmlNodeType.CDATA:
                        textBox1.Text+=("CDATA:" + xmlReader.Value);
                        textBox1.Text+="\r\n";
                        break;
                    case XmlNodeType.Element:
                        textBox1.Text+=("节点名称：" + xmlReader.LocalName);
                        textBox1.Text+="\r\n";
                        for (int i = 0; i < xmlReader.AttributeCount; i++)
                        {
                            xmlReader.MoveToAttribute(i);
                            textBox1.Text+=("属性：" + xmlReader.Name + "=" + xmlReader.Value);
                            textBox1.Text+=" ";
                            if (i==xmlReader.AttributeCount-1) textBox1.Text+="\r\n";
                        }                       
                        break;
                    case XmlNodeType.EndElement:
                        textBox1.Text+=("节点名称：" + xmlReader.LocalName);
                        textBox1.Text+="\r\n";
                        break;
                    case XmlNodeType.Comment:
                        textBox1.Text+=("Comment:" + xmlReader.Value);
                        textBox1.Text+="\r\n";
                        break;
                    case XmlNodeType.Whitespace:
                        textBox1.Text+=("<br>");
                        textBox1.Text+="\r\n\r\n";
                        break;
                    case XmlNodeType.ProcessingInstruction:
                        textBox1.Text+=("ProcessingInstruction:" + xmlReader.Value);
                        textBox1.Text+="\r\n";
                        break;
                    case XmlNodeType.Text:
                        textBox1.Text+=("Text:" + xmlReader.Value);
                        textBox1.Text+="\r\n";
                        break;
                }
            }
            xmlReader.Close();


节点类型：XmlDeclaration
属性：version=1.0 属性：encoding=utf-8 
节点类型：Whitespace
<br>

节点类型：Element
节点名称：Menus
节点类型：Whitespace
<br>

 节点类型：Element
 节点名称：Menu
 属性：title=常用网址 
 节点类型：Whitespace
 <br>

  节点类型：Element
  节点名称：item
  属性：name=天下网 属性：url=http://www.netskycn.com 属性：id=1 
  节点类型：Text
  Text:这就是天下网
  节点类型：EndElement
  节点名称：item
  节点类型：Whitespace
  <br>

  节点类型：Element
  节点名称：item
  属性：name=微软 属性：url=http://www.microsoft.com 属性：id=2 
  节点类型：Text
  Text:这就是微软
  节点类型：EndElement
  节点名称：item
  节点类型：Whitespace
  <br>

 节点类型：EndElement
 节点名称：Menu
 节点类型：Whitespace
 <br>

节点类型：EndElement
节点名称：Menus


（2）XmlWrite
XmlWriter 表示一个编写器，该编写器提供一种快速、非缓存和只进的方式来生成包含 XML 数据的流或文件。
假设要写入以下结构的XML：

<?xml version="1.0" encoding="UTF-8"?>
<BookList>
<Book category="计算机" id="1" name="书籍1">这是一本书</Book>
</BookList>


XmlWriter xmlWriter = XmlWriter.Create("config.xml");       //首先使用XmlWriter的静态成员函数Create创建一个xmlWriter对象，Create函数的参数为XML的文件名
//然后开始写XML文档
xmlWriter.WriteStartDocument();
xmlWriter.WriteStartElement("BookList");      //写入BookList元素
xmlWriter.WriteStartElement("Book");      //写入Book元素

xmlWriter.WriteStartAttribute("name");       //写入Book元素的name属性
xmlWriter.WriteValue("书籍1");        //写入name属性的值
xmlWriter.WriteEndAttribute();
xmlWriter.WriteStartAttribute("id");       //写入Book元素的id属性
xmlWriter.WriteValue("1");        //写入id属性的值
xmlWriter.WriteEndAttribute();
xmlWriter.WriteStartAttribute("category");       //写入Book元素的category属性
xmlWriter.WriteValue("计算机");        //写入category属性的值
xmlWriter.WriteEndAttribute();
xmlWriter.WriteString("这是一本书");

xmlWriter.WriteEndElement();        //结束Book元素的写入
xmlWriter.WriteEndElement();        //结束BookList元素的写入
xmlWriter.WriteEndDocument();       //结束XML文档的写入
xmlWriter.Flush();          //将XML文档写入磁盘（冲刷缓冲区）
xmlWriter.Close();          //关闭XML文档



WriteString()与WriteRaw()的区别 
    WriteString("More >")生成的Xml是More &gt 
    WriteRaw("More >")生成的xml是More > 
    也就是说WriteString会把敏感字符转换为转义字符，而WriteRaw()则是直接写入，不做任何处理

3、XmlDocument
（1）加载XML
加载XML比较常用的有三种方法：
public virtual void Load(string filename);
public virtual void Load(Stream inStream);
public virtual void LoadXml(string xml);

using System.Xml; 
//初始化一个xml实例 
XmlDocument xml = new XmlDocument();
//导入指定xml文件 
xml.Load(path); 
xml.Load(HttpContext.Current.Server.MapPath("~/file/bookstore.xml"));              //加载XML文件
xml.Save(Server.MapPath("~/file/bookstore.xml"));                                  //保存XML文件
//加入XML的声明段落，<?xml version="1.0" encoding="gb2312"?>
XmlDeclaration xmldecl = xml.CreateXmlDeclaration("1.0", "gb2312", null); 

（2）取得指定的节点对象(XmlNode)

XmlNode node;
node = xml.SelectSingleNode("/Root");                                              //获取Root节点 
node = xml.SelectSingleNode("/Root/News[@id='0002836']");                          //获取/Root下id为0002836的News:   
node = xml.SelectSingleNode("/Root/News/BodyText[text()='这段文字是正文']");       //获取含有BodyText名为“这段文字是正文”的BodyText:
node = xml.SelectSingleNode("/Root/News[BodyText/text()='这段文字是正文']");       //获取含有BodyText名为“这段文字是正文”的News:
XmlNodeList nodelist;
nodelist = node.ChildNodes;                                                        //获取节点下所有直接子节点 
nodelist = xml.SelectNodes("/Root/News");                                          //获取同名同级节点集合 
string id=node.Attributes["id"].Value;                                             //获取指定节点的指定属性值 
string content=node.InnerText;                                                     //获取指定节点中的文本 

检索
node.FirstChild;                                                                   //返回XmlNode对象，表示取得当前节点下的第一个子节点。
node.NextSibling;                                                                  //返回XmlNode对象，表示取得当前节点的下一个兄弟节点。
node.PreviousSibling;                                                              //返回XmlNode对象，表示取得当前节点的上一个兄弟节点。
node.LastChild;                                                                    //返回XmlNode对象，表示取得当前节点下的最后一个子节点。
node.SelectSingleNode();                                                           //返回XmlNode对象，根据节点元素名称返回当前节点下的第一个子节点。
node.SelectNodes();                                                                //返回XmlNodeList集合对象，根据节点元素名称返回当前节点下该名称的所有子节点。
node.HasChildNodes;                                                                //判断该节点下是否有子节点 

添加
XmlElement node=xml.CreateElement("News");                                         //生成一个新节点 
node.AppendChild(node);                                                            //为指定节点添加子节点
node.InsertBefore(node, root.ChildeNodes[i]);                                      //将节点加到指定节点下某个子节点前 
node.SetAttribute("id", "11111");                                                  //为指定节点的新建属性并赋值
node.Attributes.Append(xd.CreateAttribute("name"));                                //添加属性
node.Attributes["name"].Value = "张三";                                            //添加属性

移除
xml.RemoveChild(xmlnode);

修改
xd.InnerXml = "...."

把数据库中表的内容转存为XML文件
SqlConnection conn = new SqlConnection("server=.;database=mydb;uid=sa;pwd=123");
SqlCommand cmd = conn.CreateCommand();
//把列的内容作为属性，根元素名子为<root>
cmd.CommandText = "select * from student for xml auto, root('root')"; 
conn.Open();
XmlReader xr = cmd.ExecuteXmlReader();
XmlDocument dd = new XmlDocument();
dd.Load(xr); ;
XmlNode xx = dd.FirstChild;   //取得根元素
XmlDeclaration xd = dd.CreateXmlDeclaration("1.0", "utf-8", "yes");   //创建XML声明
dd.InsertBefore(xd, xx);   //在根元素前加入XML声明
dd.Save(Server.MapPath("tt.config"));
conn.Close();

XmlNodeList xnlListOne = doc.selectNodes("//Nodes/Node"); 
XmlNodeList xnlListTwo = doc.selectSingleNode("//Nodes").ChildNodes; 

乍一看，xnlListOne和xnlListTwo都是获取当前Xml文档中的Node数组，如果我们没有变动该Xml文档，则两者没有任何不同，但是一旦我们在后面的操作中添加或者删除了其中的Node节点的话，情况就不一样了，变动后，当我们使用我们前面获取的xnlListOne和xnlListTwo进行遍历操作的时候，我们会发现，前者不会有任何变动，而后者会根据文档内容的变动而实时更新！ 


4、System.Xml.Linq.XElement
<objects>
  <object id="person" type="ConsoleApplication1.Person, ConsoleApplication1">
    <!--属性值类型注入-->
    <property name="Name" value="Liu Dong"/>
    <property name="Age" value="27"/>
  </object>

  <object id="personDao" type="ConsoleApplication1.PersonDao, ConsoleApplication1">
    <!--构造器注入-->
    <constructor-arg name="intProp" value="1"/>
    <property name="Entity" ref="person" />
  </object>
</objects>

//读
using System.Xml.Linq;
using System.Reflection;
    string fileName = ".\\objects.xml";
    XElement root = XElement.Load(fileName);
    IEnumerable<XElement> objects = root.Elements("object");
    foreach (XElement obj in objects)
    {
        if (obj.Element("constructor-arg") == null) continue;
        string id, classname;
        id = obj.Attribute("id").Value;
        classname = obj.Attribute("type").Value.Split(',')[0];
        //classname = "personDao";
        Type type = Type.GetType(classname);
        object instance = Activator.CreateInstance(type, new object[] { 1223 });

        string methedname;

        MethodInfo method = type.GetMethod("ToString");
        string result = method.Invoke(instance, null) as string;
        Console.WriteLine(result);
        SQLiteConnection conn = null;
        conn.Open();
        
    }


//写
    XDocument doc = new XDocument(new XDeclaration("1.0", "UTF-8", "false"));
    XElement root = new XElement("OrderContractInfo");
    root.Add(new XElement("ID", this.ID));
    root.Add(new XElement("CustAddress", this.CustAddress));
    root.Add(new XElement("CustContact", this.CustContact));
    root.Add(new XElement("TotalAmount", this.TotalAmount));
    doc.Add(root);
    using (MemoryStream ms = new MemoryStream())
    {
        using (StreamWriter sw = new StreamWriter(ms, Encoding.UTF8))
        {
            doc.Save(sw, SaveOptions.DisableFormatting);
            byte[] bs = ms.ToArray();
            return System.Text.Encoding.UTF8.GetString(bs);
        }
    }




C、yaml
1.设计目的
1>容易人类阅读
2>适合表示程序语言的数据结构
3>可用于不同程序间交换数据
4>支持泛型工具
5>支持串行处理？
6>丰富的表达能力和可扩展性
7>易于使用

2.样例
#样例一
site: 
    name: sina 
    url : http://www.sina.com.cn
---
site:
    name: google
    url : http://www.google.com

#样例二
---
site: {name: sina, url: http://www.sina.com.cn}
---
site: {name: google, url: http://www.google.com}

3.基本语法
YAML的设计者认为在配置文件中所要表达的数据内容有三种类型：标量(Scalar，如字符串和整数等)、序列（Sequence，如数组）和Mapping（类似hash的key/value pair）。
大小写敏感
使用缩进表示层级关系
缩进时不允许使用Tab键，只允许使用空格。
缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

（1）单体
yaml：
animal: pets
json：
{animal: 'pets'}
（2）嵌套
yaml：
zoo:{animal: pets, employee: york}
json：
{zoo:{animal: 'pets', employee: 'york'}}

（3）集合
集合
yaml：
- Cat
- Dog
- Goldfish
json：
[ 'Cat', 'Dog', 'Goldfish' ]

集合
yaml：
animal: [Cat, Dog]
json：
{ animal: [ 'Cat', 'Dog' ] }

子集合
yaml：
-
 - Cat
 - Dog
 - Goldfish
json：
[ [ 'Cat', 'Dog', 'Goldfish' ] ]


（5）复合结构
yaml：
languages:
 - Ruby
 - Perl
 - Python 
websites:
 YAML: yaml.org 
 Ruby: ruby-lang.org 
 Python: python.org 
 Perl: use.perl.org
json：
{ languages: [ 'Ruby', 'Perl', 'Python' ],
  websites: 
   { YAML: 'yaml.org',
     Ruby: 'ruby-lang.org',
     Python: 'python.org',
     Perl: 'use.perl.org' } }

（6）纯量
数字
yaml：
number: 12.30
json：
{ number: 12.30 }

空
yaml：
parent: ~ 
json：
{ parent: null }

时间：采用 ISO8601 格式
yaml：
iso8601: 2001-12-14t21:59:43.10-05:00
json：
{ iso8601: new Date('2001-12-14t21:59:43.10-05:00') }

时间：采用复合 ISO8601 格式的年、月、日表示
yaml：
date: 1976-07-31
json：
{ date: new Date('1976-07-31') }

（6）字符串（默认类型）
字符串
yaml：
str: 这是一行字符串
json：
{ str: '这是一行字符串' }

字符串（含空格等特殊字符）
yaml：
str: '内容： 这是''字符串'''
json：
{ str: '内容: 这是''字符串''' }

（7）其它
yaml：

json：

补充：
#       注释
---     文档间隔



D、序列化
1.Newtonsoft
（1）序列化与反序列化
string content = Newtonsoft.Json.JsonConvert.SerializeObject(obj);
Object obj = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(content);
（2）忽略null字段
JsonConvert.SerializeObject(message, Formatting.None, new Newtonsoft.Json.JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore })

（3）补充
1）枚举
·Newtonsoft默认对枚举成员是将其序列化为对应的枚举名称（字符串）
·Newtonsoft默认对枚举属性是将其序列化为对应的值（数值），除非在该属性上标注特性“[JsonConverter(typeof(StringEnumConverter))]”

2）去除时间中带T的方法
    在WebApiConfig的Register中加入以下代码
    //配置返回的时间类型数据格式
    GlobalConfiguration.Configuration.Formatters.JsonFormatter.SerializerSettings.Converters.Add(
        new Newtonsoft.Json.Converters.IsoDateTimeConverter()
        {
            DateTimeFormat = "yyyy-MM-dd hh:mm:ss"
        }
    );

[JsonProperty(PropertyName = "名字")]
[JsonIgnore]
[JsonProperty(PropertyName = "Data", DefaultValueHandling = DefaultValueHandling.Ignore)]
[JsonObject(Newtonsoft.Json.MemberSerialization.OptIn)]
OptOut	默认值，类中所有公有成员会被序列化，如果不想被序列化，可以用特性JsonIgnore
OptIn	默认情况下，所有的成员不会被序列化，类中的成员只有标有特性JsonProperty的才会被序列化，当类的成员很多，但客户端仅仅需要一部分数据时，很有用
[JsonConverter(typeof(StringEnumConverter))]
默认枚举的序列化后值为数字，使用该方式，可得到字符串类型的序列化值

（4）简化版
int[] jArray = JArray.Parse(jsonString);    
T t=  new Newtonsoft.Json.Linq.JObject(dropObject)[key].ToObject<T>();

2.XmlSerializer
[XmlRoot("cat")]
//类似WCF中的ServiceKnownType，但ServiceKnownType是声明在接口上，表明“该接口”可能为XX类型，而XmlInclude声明在“类”上，表明“此类中的对象”可能为XX类型
[XmlInclude(typeof(Eye))]
public class Cat{
    //定义Color属性的序列化为cat节点的属性
    [XmlAttribute("color")]
    public string Color { get; set; }
    //要求不序列化Speed属性
    [XmlIgnore]
    public int Speed { get; set; }
    //设置Saying属性序列化为Xml子元素
    [XmlElement("saying")]
    public string Saying { get; set; }
    //设置Child集合序列化为Xml子元素
    [XmlArray("children"),XmlArrayItem("child")]
    public Child[] Children { get; set; }
    //对应类上声明的[XmlInclude(typeof(Eye))]，表明该Organ对象可能为Eye类型
    public object Organ;
}

（1）序列化
    XmlSerializer serializer = new XmlSerializer(obj.GetType());
    MemoryStream ms = new MemoryStream();
    serializer.Serialize(ms, obj);
    byte[] buffer = ms.Read(buffer, 0, ms.Length);
    string objString = Encoding.UTF8.GetString(buffer);

（2）反序列化
    XmlSerializer serializer = new XmlSerializer(type);
    byte[] buffer = Encoding.GetEncoding("UTF-8").GetBytes(objString);
    MemoryStream ms = new MemoryStream(buffer, 0, buffer.Length, false);
    object obj = serializer.Deserialize(ms);





十八、资源回收与效率性能
A、资源回收
托管资源是指由CLR管理分配和释放的资源，一般是托管内存，而非托管资源是由系统分配和释放的资源，一般地在CLR里new 一个对象或者分配一个数组都不需要手动去释放内存，而如windows里的句柄资源常常需要手动释放，如字体、刷子、DC等
定义类时，可以使用两种机制来自动释放非托管资源：

1、在类中实现System.IDisponsable接口
    推荐使用System.IDisposable接口替代析构函数。IDisposable接口定义了一个模式，为释放未托管的资源提供了确定机制，并避免了产生析构函数固有的与垃圾收集器相关的问题。它声明了一个Dispose()方法，不带参数，返回void，如下：
 class MyClass : IDisposable
 {
     public void Dispose()
     {
          // implementation
     }
 }
    通过调用Dispose()方法，可以显示释放因对象直接使用的所有未托管资源。然而，如果代码如下：
     MyClass theInstance = new MyClass();
     // do something
     theInstance.Dispose();
    这样，在这个过程中可能出现异常，使得释放资源失败，可以采用try来捕捉异常：
     MyClass theInstance = null;
     try
     {
         theInstance = new MyClass();
         // do your processing
     }
     finally
     {
         if (theInstance != null)
         {
             theInstance.Dispose();
         } 
     }
    但这又使得代码比较长。那么，我们可以使用using指令来完成这个工作。IDisposable被集成在了using块当中。在using()方法中声明的对象在using块的结尾处将调用Dispose()方法，using块之外该对象将不再被引用，因为它已经被认为是需要进行垃圾回收的对象了。
    using(MyClass theInstance = new MyClass())
    {
       // do something
    }
那么，在using语句中实例化或者声明的变量，在变量超出作用域的时候，即使出现了异常的，也会自动调用其Dispose()方法。 
另外，有时候也使用Close()来代替Dispose()的功能，如处理文件或数据库连接时。这些情况下，常常实现IDisposable接口，然后执行一个独立的Close()方法，来调用Dispose()。


2、声明一个析构函数，作为类的成员
    在.NET种由于当对象变为不可访问后将自动调用Finalize方法，所以我们手动调用IDisposable接口的Dispose方法和对象终结器调用的方法极其类似，我们最好将他们放到一起来处理。我们首先想到的是重写Finalize方法，如下：
protected override void Finalize()
{
     Console.WritleLine("析构函数执行...");
}
当我们编译这段代码的时候，我们发现编译器会报如下的错请不要重写，而是提供一个析构函数。
这是因为编译器彻底屏蔽了父类的Finalize方法，编译器提示我们如果要重写Finalize方法我们要提供一个析构函数来代替，下面我们就提供一个析构函数：
class Program
{
    ~Program()
    {
        // Orders.
        Console.WriteLine("析构函数执行...");
    } 
}
实际上这个析构函数编译器会将其转变为如下代码：
protected override void Finalize()
{
   try
   {
     Console.WritleLine("析构函数执行...");
   }
   finally
   {
     base.Finalize();
   }
}



3、实现IDisposable接口和析构函数
虽然说C#提供了两种未托管资源的释放方式，使用析构函数造成系统的开销大，而使用IDisposable接口就要求用户必须确保执行了Dispose()。一般情况下，最好的办法的是执行这两种机制，实现优缺点的互补。我们就可以将Dispose方法的调用和对象的终结器放在一起来处理，如下：
class Program: IDisposable
{
    ~Program()
    {
        Dispose();
    }
    public void Dispose()
    {
        // 清理资源    }
    }
}

上面实现方式实际上调用了Dispose方法和Finalize方法，这样就有可能导致做重复的清理工作，所以就有了下面经典
class Program
{
    private bool IsDisposed = false;
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);  
    }
    protected void Dispose(bool Disposing)
    {
        if (!IsDisposed)
        {
            if (Disposing)
            {
                //清理托管资源         }  
                //清理非托管资源
            }
            IsDisposed = true;
        }
    }
    ~Program()
    {
        Dispose(false);
    }
}





B、GC回收
1、什么是GC？
    首先，Garbage垃圾就是一个内存区域，没有被任何引用指向，或者不再会被用到。GC如其名，就是垃圾收集，当然这里仅就内存而言。Garbage Collector（垃圾收集器，在不至于混淆的情况下也成为GC）以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象[2]，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。这就是GC工作的原理。为了实现这个原理，GC有多种算法。比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.NET CLR，Java VM和Rotor都是采用的Mark Sweep算法。
2、为什么要使用GC？
    也可以说是为什么要使用内存自动管理？有下面的几个原因：
（1）提高了软件开发的抽象度；
（2）程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；
（3）可以使模块的接口更加的清晰，减小模块间的偶合；
（4）大大减少了内存人为管理不当所带来的Bug；
（5）使内存管理更加高效。
    总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。
3、GC的原理
一、Mark-Compact 标记压缩算法
    简单地把.NET的GC算法看作Mark-Compact算法。阶段1: Mark-Sweep 标记清除阶段，先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；阶段2: Compact 压缩阶段，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。
    Heap内存经过回收、压缩之后，可以继续采用前面的heap内存分配方法，即仅用一个指针记录heap分配的起始地址就可以。主要处理步骤：将线程挂起→确定roots→创建reachable objects graph→对象回收→heap压缩→指针修复。可以这样理解roots：heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。
    GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalization queue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register） 。 Reachable objects：指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个root object，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objects graph，剩余对象即为unreachable，可以被回收 。
    指针修复是因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPU register中的指针以及heap中其他对象的引用指针。Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容。传给了COM+的托管对象也会成为root，并且具有一个引用计数器以兼容COM+的内存管理机制，引用计数器为0时，这些对象才可能成为被回收对象。Pinned objects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinned objects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉。 
二、 Generational 分代算法
    程序可能使用几百M、几G的内存，对这样的内存区域进行GC操作成本很高，分代算法具备一定统计学基础，对GC的性能改善效果比较明显。将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉。分代算法的假设前提条件：
    1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长；
    2、对部分内存进行回收比基于全部内存的回收操作要快；
    3、新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率，.NET将heap分成3个代龄区域: Gen 0、Gen 1、Gen 2；
    Heap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections， # Gen 1 collections， #Gen 2 collections。如果Gen 0 heap内存达到阀值，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。
    2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收，Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为full GC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时，full GC可能需要花费几秒时间。大致上来讲.NET应用运行期间，2代、1代和0代GC的频率应当大致为1:10:100。
三、Finalization Queue和Freachable Queue 
    这两个队列和.NET对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。
    在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的Finalize方法还没有被执行，所以不能让它死去。Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。
    .NET Framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。
    托管资源：
    什么叫托管，我的理解就是托付C# 运行环境帮我们去管理，在这个运行环境中可以帮助我们开辟内存和释放内存，开辟内存一般用new ，内存是随机分配的，释放主要靠的是GC 也就是垃圾回收机制。
    .NET中的所有类型都是（直接或间接）从System.Object类型派生的。
    CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上；值类型（value type），分配在堆栈上。
    值类型在栈里，先进后出，值类型变量的生命有先后顺序，这个确保了值类型变量在退出作用域以前会释放资源。比引用类型更简单和高效。堆栈是从高地址往低地址分配内存。
    引用类型分配在托管堆(Managed Heap)上，声明一个变量在栈上保存，当使用new创建对象时，会把对象的地址存储在这个变量里。托管堆相反，从低地址往高地址分配内存。
    .NET中超过80%的资源都是托管资源。
    非托管资源：
    ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。可能在使用的时候很多都没有注意到！
    .NET的GC机制有这样两个问题：
    首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。
    第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。
    GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using语句可以简化资源管理。

4、使用方法
    GC.Collect() 方法 
    作用：强制进行垃圾回收，实际上是调用析构函数。
    GC的方法：
名称                                                             说明
Collect()                           强制对所有代进行即时垃圾回收。
Collect(Int32)                      强制对零代到指定代进行即时垃圾回收。
Collect(Int32, GCCollectionMode)    强制在 GCCollectionMode 值所指定的时间对零代到指定代进行垃圾回收
SuppressFinalize(this)              来告诉GC ，让它不用再调用对象的析构函数中。
GC注意事项：
（1）只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理。
（2）循环引用，网状结构等的实现会变得简单。GC的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。
（3）GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。
（4）GC在一个独立的线程中运行来删除不再被引用的内存。
（5）GC每次运行时会压缩托管堆。
（6）你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。
（7）对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数
（8）Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。
（9）.NET GC使用"代"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。
（10）GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。








C、执行效率
1、字符串比较
不要用ToUpper()或ToLower()转换字符串进行比较，用String.Compare代替，它可以忽略大小写进行比较.
例：
const string C_VALUE = "COMPARE";
if (String.Compare(sVariable, C_VALUE, true) == 0)  
{  
    Console.Write( "相同");
}  

2、空字符串判定
可以用str == String.Empty或者str.Length == 0判断是否为空。(注意判断输入数据的长度，可防止sql注入式攻击)
将String对象的Length属性与0比较是最快的方法，避免不必要的调用 ToUpper 或 ToLower 方法。

3、类型转化
类型转化Int32.TryParse()优于Int32.Parse()优于Convert.ToInt32()。
建议.NET1.1下用Int32.Parse()；.NET2.0用Int32.TryParse()。
因为：
Convert.ToInt32 会把最终的解析工作代理给 Int32.Parse；
Int32.Parse 会把最终的解析工作代理给Number.ParseInt32；
Int32.TryParse 会把最终的解析工作代理给Number.TryParseInt32。

4、遍历
foreach不同于for、while，每次循环不会执行数组方法

    for (var no = 0; no < rooms.length; no++) {
        currow = parseInt(no / 4) + 1;
        curcell = no % 4 + 1;
        if (currow != currowlast) row = ta.insertRow(ta.rows.length);
        cell = row.insertCell(curcell - 1);
        cell.width = "230px";
        cell.innerHTML = "<input id='check_" + no + "' type='checkbox' name='check_box'/><label name='searchTxt' id='lal_" + no + "'>" + rooms[no] + "</label>";
        currowlast = parseInt(no / 4) + 1;
    }


5、Thread.Sleep和Timer性能比较

6、代码优化
前端开发的优化问题
（1） 减少http请求次数：css spirit, data uri
（2） JS，CSS源码压缩
（3） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
（4） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能
（5） 用setTimeout来避免页面失去响应
（6） 用hash-table来优化查找
（7） 当需要设置的样式很多时设置className而不是直接操作style
（8） 少用全局变量
（9） 缓存DOM节点查找的结果
（10） 避免使用CSS Expression
（11） 图片预载
（12） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢








十九、资源
A、资源
1、定义资源
asp.net中的App_GlobalResources可以用来解决本地化的问题，程序会根据浏览器的语言首选项自动判断显示出本地化的界面。
首先在App_GlobalResources新建一个.resx资源文件，并在.resx资源文件中增加内容，可以是字符串、超文本、图片等。
2、访问资源
    //假设在ResourceTest.resx资源文件中添加了LabelText名称的字符串
    //方式一
    string str1 = Resources.ResourceTest.LabelText;
    //方式二：这个方法第一个参数是资源文件名，第二个参数是要检索的键值。
    string str2 = HttpContext.GetGlobalResourceObject(ResourceTest.resx, LabelText, CurrentCulture);
    //方式三：在VS中，可以绑定.resx资源文件
    <asp:Literal ID="Literal1" runat="server" Text="<%$ Resources:lang, userinfo%>" />  或者
    <%=Resources.lang.userinfo%>
B、全局本地化资源GlobalResources
1、根据浏览器设置选择语言
要支持国际化，要将资源文件以*.en-us.resx，在页面的使用方式不变。当你用浏览器访问时，系统会自动侦测出你的浏览器设置的默认语言，然后自动调用不同的资源包来呈现出来，至此你可以更换浏览器的语言首选项来看看效果了。
2、默认语言
可以往web.config中增加<globalization culture="en-US" uiCulture="en-US"/>来改变程序默认使用的语言项。 
3、通过cookie即时选择语言
可以往global.ASAX全局应用程序中增加如下代码
void Application_BeginRequest(Object sender, EventArgs e) 
{ 
    try 
    { 
        if (Request.Cookies["lang"] != null) 
        { 
            System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.CreateSpecificCulture(Request.Cookies["lang"].Value.ToString()); 
            System.Threading.Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo(Request.Cookies["lang"].Value.ToString()); 
        } 
    } 
    catch (Exception) 
    { } 
}
即可通过设置变换cookie值来达到即时切换语言的目的，轻松实现程序的多语言。

C、局部本地化资源LocalResources
1、定义资源
App_LocalResources文件夹，这个文件夹中放的是页面的资源文件，这些资源文件和每个Aspx页面对应。比如我在网站项目下添加了一个Default.aspx文件，在设计VS的模式下，选择工具“生成本地资源” 就会自动在App_LocalResources中生成一个名字为Default.aspx.resx的资源文件。
2、访问资源
    //方式一
    HttpContext.GetLocalResourceObject("resxFile", "resxKey")
    //方式二
    <asp:Label ID="Label1" runat="server" meta.:resourcekey="LabelText"></asp:Label>
    //方式三：遍历App_LocalResources里某一资源文件的所有key, value值
    public void ShowCurrentPageLocalResources()
    {
        // Create a ResourceReader for the file items.resources.
        ResourceReader rr = new ResourceReader("items.resources");
        // Create an IDictionaryEnumerator to iterate through the resources.
        IDictionaryEnumerator id = rr.GetEnumerator();
        // Iterate through the resources and display the contents to the console.
        while(id.MoveNext())
            Console.WriteLine("\n[{0}] \t{1}", id.Key, id.Value);
        rr.Close();
    }

D、手动嵌入的资源
可将一个图片、xml等文件的生成操作设为“嵌入的资源”
Assembly _assembly = System.Reflection.Assembly.GetExecutingAssembly();
string resourceName = "<namespace>.<subfolders>.<image name>.<extension>(<命名空间>.<文件夹>.<图片名>.<后缀>)";
Stream stream = _assembly.GetManifestResourceStream(resourceName);

※通过_assembly.GetManifestResourceNames()可获取资源清单


E、编译时的生成方式
生成操作(BuildAction) 属性:BuildAction 属性指示 Visual Studio .NET 在执行生成时对文件执行的操作。BuildAction 可以具有以下几个值之一： 
无(None) - 不在项目输出组中包含该文件，并且在生成进程中不会对其进行编译。例如包含文档的文本文件，如自述文件。 
编译(Compile) - 将该文件编译到生成输出中。此设置用于代码文件。 
内容(Content) - 不编译该文件，但将其包含在“内容”(Content) 输出组中。例如，此设置是 .htm 或其他类型 Web 文件的默认值。 
嵌入资源(Embedded Resource) - 将该文件作为 DLL 或可执行文件嵌入主项目生成输出中。此设置通常用于资源文件。
生成操作的默认值取决于添加到解决方案中的文件的扩展名。例如，如果将 Visual C# 项目添加到解决方案资源管理器中，则安装操作的默认值是”编译”，因为扩展名 .CS 指示可编译的代码文件。文件名和扩展名出现在解决方案资源管理器中。


十九、安装与部署


1.打开要打包的“.sln”文件，在“解决方案资源管理器”中随便打开一个窗口 
2.菜单栏“文件”--->“添加”--->“新建项目” 
3. 点击“项目类型”--->“其他项目类型”--->“安装和部署”，再在“模板”点击“安装项目”，点击“确定” 
4.在“文件系统”中点击“应用程序文件夹”，右边框变空白，在空白处右击鼠标，“添加”--->点击“项目输出”，出现一个对话框，点击“确定” 
5.再右击鼠标，“添加”--->点击“文件”，选择文件夹中的“bin”文件中的“Debug”文件中的“.exe”，把“.exe”打开。 
6.单击“文件系统”中的“用户的"程序"菜单”，在右边空白处右击鼠标，点击“创建新的快捷方式”，把应用程序文件夹中的
“.exe”文件选上，点击确定。 
7.单击“文件系统”中的“用户桌面”，操作如上一步骤。 
8.点击菜单栏中"生成"中的“生成
Setup1(包名)”，等页面左下角显示"生成成功"即可






1.在 Visual Studio 中，打开 Windows 应用程序。
2.在“文件”菜单上指向“添加”，然后单击“新建项目”。
3.导航到“添加”“新建项目”对话框的“项目类型”面板。 
4.如果使用 Visual Studio 2005 或 2008，请展开“其他项目类型”，然后选择“安装和部署项目”。
5.如果使用 Visual Studio .NET 2003，请选择“安装和部署项目”。
6.在“模板”面板中，选择“安装项目”。
7.选择适当的项目名称，并指定其位置，然后单击“确定”。
8.右击Setup1>视图>启动条件>找到 .NET Framework 
修改属性Version 的 3.5.21022 为 2.0.50727 
9.OK






1 新建安装部署项目 
打开VS，点击新建项目，选择：其他项目类型->安装与部署->安装向导(安装项目也一样)，然后点击确定。 
2 安装向导 
关闭后打开安装向导，点击下一步，或者直接点击完成。 
3 开始制作 
安装向导完成后即可进入项目文件夹： 
双击"应用程序文件夹"在右边的空白处右击，选择添加->文件，将你的做的应用程序的可执行文件和相应的类库和组件添加进来。然后右击你的文件，创建快捷方式，然后把快捷方式分别复制或剪切到左边的"用户的'程序'菜单"和"用户桌面"中。这样安装程序安装完成后会在 "开始->所有程序"和"桌面"上生成程序的快捷方式。也可以直接在"用户的'程序'菜单"和"用户桌面"相应目录下新建快捷方式，然后定位到你的文件。然后右击左边的"应用程序文件夹"打开属性对话框：将属性中的"DefaultLocation"的路径中的"[Manufacturer]"去掉，不然的话做好的安装程序默认安装目录会是"C:\Program Files\你的用户名\安装解决方案名称"； 
然后打开解决方案管理器，右击你的解决方案名称，选择属性：打开的属性页中，选择"系统必备"， 在打开的系统必备页中，在"指定系统必备安装组件的位置"中选中如下选择项：从与我的应用程序相同的位置下载系统必备组件。选上以后，在生成的安装文件包中包含.NetFramework组件 。好了，这样就完成99%了，然后点击"生成->生成解决方案"，哈，生成成功! 
4 制作完成 
现在打开解决方案文件夹下的Debug文件夹，就可以看到生成的安装文件了。
5 关于"卸载"功能的添加 
上面只介绍了简单的生成安装的方法，但是在VS2005下并没有直接生成卸载程序的功能，所以我们只好用msi来实现了，操作方法如下： 
在添加你的应用程序项目的时候，多添加一个msiexec.exe进去，这个文件在c:\windows\system32文件夹下，添加进去以后，为了让他更像个卸载程序，把他的名字改成"Uninstall.exe"，当然这个关系不大，改不改都行。 
然后创建一个快捷方式，放到"开始-程序"中，接下来我们要做的就是查找这个部署项目的ProductCode了，鼠标左键单击项目名称，记住是左键单击，然后点击属性标签，注意：不是右击的属性，这个区别很大，这时你就可以看到ProductCode了。 
然后打开你创建的那个快捷方式的属性对话框，在Aguements属性中输入"/x {ProductCode}"，好了，然后点击"生成解决方案"即可生成带有卸载功能的安装程序了。












二十、Windows Service
A、什么是 Windows 服务？
    Microsoft Windows 服务（即，以前的 NT 服务）使您能够创建在它们自己的 Windows 会话中可长时间运行的可执行应用程序。这些服务可以在计算机启动时自动启动，可以暂停和重新启动而且不显示任何用户界面。这使服务非常适合在服务器上使用，或任何时候，为了不影响在同一台计算机上工作的其他用户，需要长时间运行功能时使用。还可以在不同于登录用户的特定用户帐户或默认计算机帐户的安全上下文中运行服务。

B、创建步骤
1.添加安装程序
在Service1.cs设计界面中右击，选择“添加安装程序”
（1） => 设置服务安装的信息（serviceProcessInstaller1）
Account设为LocalSystem（服务的“登陆为”）：LocalSystem、LocalService、NetworkService、User
●LocalSystem 账户 
LocalSystem是预设的拥有本机所有权限的本地账户，这个账户跟通常的用户账户没有任何关联，也没有用户名和密码之类的凭证。这个服务账户可以打开注册表的HKEY_LOCAL_MACHINE\Security键，当LocalSystem访问网络资源时，它是作为计算机的域账户使用的。 
举例来说，以LocalSystem账户运行的服务主要有：WindowsUpdate Client、Clipbook、Com+、DHCP Client、Messenger Service、Task Scheduler、Server Service、Workstation Service，还有Windows Installer。 
●Network Service 账户 
Network Service账户是预设的拥有本机部分权限的本地账户，它能够以计算机的名义访问网络资源。但是他没有Local   System   那么多的权限，以这个账户运行的服务会根据实际环境把访问凭据提交给远程的计算机。Network   Service账户通常可以访问Network Service、Everyone组，还有认证用户有权限访问的资源。
举例来说，以Network Service账户运行的服务主要有：Distributed Transaction Coordinator、DNS Client、Performance Logs and Alerts，还有RPC Locator。
●Local Service 账户 
Local Service账户是预设的拥有最小权限的本地账户，并在网络凭证中具有匿名的身份。Local Service账户通常可以访问Local Service、Everyone组还有认证用户有权限访问的资源。
举例来说，以Local Service账户运行的服务主要有：Alerter、Remote Registry、Smart Card、SSDP，还有WebClient。
简单说明：
Local System：本地系统用户，个人电脑通常选择这个用户
Network Service：网络服务用户，通常需要远程连接的都使用这个
Local Service：本地服务
（2） => 设置服务本身的信息（serviceInstaller1）
Description（功能描述）
ServiceName（服务名称）
ServicesDependedOn（服务依赖项）
StartType（启动方式）：Automatic、Manual、Disabled
例：
    public ProjectInstaller()
    {
        InitializeComponent();
        ServiceInstaller installer = new ServiceInstaller();
        installer.ServiceName = "SimpleLogService";//服务的名称要和LogService构造方法里的服务名称一致
        installer.DisplayName = "测试日志记录Windows服务";//windows服务显示的名称
        installer.Description = "这是一个简单的测试日志记录Windows服务,在log文件夹下可以看到详细文本日志";
        installer.StartType = ServiceStartMode.Manual; // 自动 手动 或禁用 这里设为手动
    
        ServiceProcessInstaller serviceProcessInstaller = new ServiceProcessInstaller();
        // 采用本地系统帐户运行服务
        serviceProcessInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
        serviceProcessInstaller.Username = null;
        serviceProcessInstaller.Password = null;
        this.Installers.AddRange(new System.Configuration.Install.Installer[] { installer, serviceProcessInstaller });
    }

2.编写代码
至此，安装程序与框架已经搭建完毕，然后就在Service1.cs的OnStart代码视图中编写自己的业务代码

3.服务安装/卸载方式
I.命令行
（1）安装服务的批处理代码：
"%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe"  F:\xxx\xxx.exe 
net start "服务名称"
（2）卸载服务的批处理代码：
net stop "服务名称"
"%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe" /u  F:\xxx\xxx.exe 
II.编译属性
该项目的属性/生成事件/后期生成事件命令行，加上下面的脚本
    先删除：
    %systemroot%\Microsoft.NET\Framework\v4.0.30319\installutil.exe /u $(TargetPath)
    再添加
    %systemroot%\Microsoft.NET\Framework\v4.0.30319\installutil.exe $(TargetPath)
$(TargetPath) 是 Project 编译宏表示输出的绝对路径
III.代码
其中参数 args 就是你用 InstallUtil.exe 工具安装时的参数。一般就是一个exe的文件名

        /// <summary>
        /// 安装服务
        /// </summary>
        /// <param name="arg">就是用 InstallUtil.exe 工具安装时的参数。一般就是一个exe的文件名</param>
        private void InstallHelper(string svcName, string[] args)
        {
            if (!ServiceIsExisted(svcName))
            {
                try
                {
                    if (args == null || args[0] == "") args = {"/u", "WcfHost_WindowsService.exe"};
                    System.Configuration.Install.ManagedInstallerClass.InstallHelper(args);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                    return;
                }
            }
            else
            {
                MessageBox.Show("该服务已经存在，不用重复安装。");
            }
        }
        /// <summary>
        /// 检查指定的服务是否存在。
        /// </summary>
        /// <param name="svcName">要查找的服务名字</param>
        /// <returns></returns>
        private bool ServiceIsExisted(string svcName)
        {
            ServiceController[] services = ServiceController.GetServices();
            foreach (ServiceController s in services)
            {
                if (s.ServiceName == svcName)
                {
                    return true;
                }
            }
            return false;
        }

4.启动/停止服务
在“服务”列表中启动服务，或net start "MyServiceName"

C、调试
I.附加到进程
打开的Visual Studio 2010工具栏中的工具 => 附加到进程 => 点击确定，选择列表中的要调试服务名称 => 点击附加就可以调试了。程序中只需F9打点就可以调试，注意要windows服务保持版本一致。
II.断点
protected override void OnStart(string[] args)
{
    Debugger.Launch();
}
※OnStart方法中如有阻塞的方法，请通过异步或线程调用，使OnStart方法不被阻塞，服务方能成功启动。

在js中也可以使用debugger关键字进行调试。

D、sc的用法
描述：SC 是用于与服务控制管理器通信的命令行程序。
用法：
sc <server> [command] [service name] <option1> <option2>…
选项 <server> 的格式为（可以键入 “sc [command]”以获得命令的进一步帮助）
命令:
query—————查询服务的状态，或枚举服务类型的状态。
queryex————查询服务的扩展状态， 或枚举服务类型的状态。
start—————-启动服务。
pause————–发送 PAUSE 控制请求到服务。
interrogate——–发送 INTERROGATE 控制请求到服务。
continue———–发送 CONTINUE 控制请求到服务。
stop—————-发送 STOP 请求到服务。
config————–(永久地)更改服务的配置。
description——–更改服务的描述。
failure————–更改服务失败时所进行的操作。
qc——————-查询服务的配置信息。
qdescription——-查询服务的描述。
qfailure————-查询失败服务所进行的操作。
delete—————(从注册表)删除服务。
create—————创建服务(将其添加到注册表)。
control————–发送控制到服务。
sdshow————–显示服务的安全描述符。
sdset—————-设置服务的安全描述符。
GetDisplayName—获取服务的 DisplayName。
GetKeyName——–获取服务的 ServiceKeyName。
EnumDepend——-枚举服务的依存关系。

其中，create的格式：
sc [ServerName] create [ServiceName] [type= {own|share|kernel|filesys|rec|adapt|interact type= {own|share}}] [start= {boot|system|auto|demand|disabled}] [error= {normal|severe|critical|ignore}] [binpath= BinaryPathName] [group= LoadOrderGroup] [tag= {yes|no}] [depend= dependencies] [obj= {AccountName|ObjectName}] [displayname= DisplayName] [password= Password]
※注意每个属性名后面都有一个空格

例：
sc create ServerManagerMQ binpath= "c:\xinnet\servermanager\servermanager.exe 1" start=auto
sc create ServerManagerSocket binpath= "c:\xinnet\servermanager\servermanager.exe 2" start=auto

net start ServerManagerMQ
net start ServerManagerSocket

sc delete ServerManagerMQ
sc delete ServerManagerSocket

sc config ServerManagerMQ start= demand(设置服务为手动启动) 　　
sc config ServerManagerMQ start= disabled(设置服务为禁用) 　
sc config ServerManagerMQ start= AUTO(设置服务为自动启动) 　　


二十一、SOA
A、基础知识
1.什么是WSDL？什么是SOAP？什么是REST？
（1）WSDL（WebServices Description Language）：是对WebService的描述，使用XML的格式描述了一个WebService有哪些方法、参数类型、访问路径等。
（2）SOAP：是以HTTP协议的方式，把WebService中的远程调用和返回封装成机器可读的XML格式化数据。
SOAP(Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。 
可以说WSDL是对“类”的特殊序列化，SOAP是对“对象”的特殊序列化。
（3）REST：Client的通过URI来获取资源的具体象征(Representational State Transfer)。Client取得这些具体象征使这些应用程序转变其状态(以浏览器而言，取得 HTML、CSS、JavaScript … 来生成界面)，随着不断取得资源的具体象征，Client 端不断地改变其状态，这样不断的反复(iterations) 过程就是所谓的Representational State Transfer。
REST依赖一套简单的“动词”，把所有的复杂性都转移到了指定资源的“名词”中。与此不同，SOAP却有一套相当复杂的XML格式化命令和数据传输选项。

REST的思想归结以下有如下几个关键点：
1．面向资源的接口设计
    所有的接口设计都是针对资源来设计的，也就很类似于我们的面向对象和面向过程的设计区别，只不过现在将网络上的操作实体都作为资源来看待，同时URI的设计也是体现了对于资源的定位设计。后面会提到有一些网站的API设计说是REST设计，其实是RPC-REST的混合体，并非是REST的思想。
2．抽象操作为基础的 CRUD
    这点很简单，Http中的 get, put, post, delete分别对应了 read, update, create, delete四种操作，如果仅仅是作为对于资源的操作，抽象成为这四种已经足够了，但是对于现在的一些复杂的业务服务接口设计，可能这样的抽象未必能够满足。其实这也在后面的几个网站的 API设计中暴露了这样的问题，如果要完全按照REST的思想来设计，那么适用的环境将会有限制，而非放之四海皆准的。
3．Http是应用协议而非传输协议
    这点在后面各大网站的 API分析中有很明显的体现，其实有些网站已经走到了SOAP的老路上，说是REST的理念设计，其实是作了一套私有的SOAP协议，因此称之为REST风格的自定义SOAP协议。
4．无状态，自包含
    这点其实不仅仅是对于REST来说的，作为接口设计都需要能够做到这点，也是作为可扩展和高效性的最基本的保证，就算是使用SOAP的WebService也是一样。

B、概述
    Windows Communication Foundation(WCF)是由微软发展的一组数据通信的应用程序开发接口，可以翻译为Windows通讯接口，它是.NET框架的一部分。由.NET Framework 3.0 开始引入。
    WCF的最终目标是通过进程或不同的系统、通过本地网络或是通过Internet收发客户和服务之间的消息。
    WCF合并了Web服务、.net Remoting、消息队列和Enterprise Services的功能并集成在Visual Studio中。
    WCF专门用于面向服务开发。

C、机制
ClientA--                      ------Service1
         |                    |
          ---ServiceHost------|------Service2
         |                    |
ClientB--                      ------Service3

D、WCF的三大核心ABC
绑定、契约和服务行为的关系：
•绑定指的是绑定信道：BasicHttpBinding、NetTcpBinding、NetNamedPipeBinding和WSHttpBinding等
•契约指的是ServiceContract的SessionMode属性：SessionMode.Allowed、SessionMode.Required、SessionMode.NotAllowed
•服务行为指的是ServiceBehavior的InstanceContextMode属性:InstanceContextMode.PerCall、InstanceContextMode.PerSession、InstanceContextMode.Singleton

I.A代表Address-where（对象在哪里）

II.B代表Binding-how（通过什么协议取得对象）
1.配制属性
（1）TransferMode 属性
TransferMode其实是一个举枚，它支持四种模式（Buffered、Streamed、StreamedRequest、StreamedResponse）：
Buffered：缓冲模式，说白了就是在内存中缓冲，一次调用就把整个消息读/写完，也就是我们最常用的方式，就是普通的操作协定的调用方式；
Streamed：请求和响应流；
StreamedRequest：只是在请求的时候使用流，说简单一点就是在传入方法的参数使用流，如 int MyMethod(System.IO.Stream stream);
StreamedResponse：就是操作协定方法返回一个流，如 Stream MyMethod(string file_name);
一般而言，如果使用流作为传入参数，最好不要使用多个参数，如这样：
bool TransferFile(Stream stream, string name);
（2）MaxBufferSize
（3）MaxReceivedMessageSize属性
该值默认大小为64k，因此，当传输数据大于64k时，则抛出CommunicationException异常。（可以直接设置为int.max） 
MaxReceivedMessageSize = 500 * 1024 * 1024;  
（4）Timeout属性
receiveTimeout 和sendTimeout。大数据传送时间较长，需要修改这两个值，以免传输超时。 

·OpenTimeout
客户端与服务端建立连接时，如果超过指定时间都还没完成，就引发TimeoutException。
在TCP通讯中，服务器必须首先准备好侦听端口并在该端口上侦听(Listen)，而客户端则必须首先向服务器发出连接(Connect)指令，服务器端收到后作出接受响应(Accept)后连接成功，此后两者就可以互发消息了。
在WCF领域中，类似地，Open()表示建立一个Binding。
测试：拨网线。
·CloseTimeout
与OpenTimeout类似，CloseTimeout用于关闭一个连接时。
一般情况下，客户端比较随意，不会在意这个超时异常。“Close()是我发出的，我自己决定何时清理资源。”
在服务器就不同了，她必须对客户端负责，不能乱来，在收到Close()成功的响应之前，或收到超时异常之前，不能随意清理与客户端相关的资源。
·SendTimeout
客户端调用的超时，默认1分钟。每次调用都必须在指定时间内完成，否则将引发TimeoutException。
在TCP通讯中，双方建立连接后，客户端如果需要发送消息给服务端，就发送一个数据包给服务器，服务器收到后必须给出一个响应，客户端收到这个响应后才能宣告发送成功。类似地，服务器也可能主动发送消息给客户端。这两个动作，分别对于客户端和服务器来说，都是发送(Send)，而对于另一方来说都是接收(Receive)。
但是，在WCF领域中的SendTimeout中的Send与TCP的Send理念上类似，但是实质上完全不是一回事。SendTimeout中的Send是指客户端发起调用。
在WCF客户端，用proxy.InnerChannel.OperationTimeout可以取到SendTimeout的值。（此处，proxy 是自动生成的服务代理类XxxClient的一个实例）
测试：在服务器的调用处理代码中插入MessageBox.Show(...)或Thread.Sleep(...)。
·ReceiveTimeout
与SendTimeout同理，ReceiveTimeout中的Receive是指服务器端发起回调(Callback)。只有在双向通讯绑定时适用，如WSDualHttpBinding, NetTcpBinding, NetNamedPipeBinding, ...
ReceiveTimeout是服务器回调(Callback)的超时，默认10分钟。每次回调都必须在指定时间内完成，否则将在服务器端引发TimeoutException。
测试：在客户端的回调处理代码中插入MessageBox.Show(...)或Thread.Sleep(...)。 

个人理解：SendTimeout是指客户端发送数据(请求)wcf服务，wcf服务响应（wcf发送回来数据），这两个加起来的总时间。
ReceiveTimeout跟回调有关，并不是指wcf服务响应（wcf发送回来数据）的时间。

例：

                <binding name="BasicHttpBinding_IService" closeTimeout="00:01:00"
                    openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00"
                    allowCookies="false" bypassProxyOnLocal="false" hostNameComparisonMode="StrongWildcard"
                    maxBufferSize="65536" maxBufferPoolSize="524288" maxReceivedMessageSize="65536"
                    messageEncoding="Text" textEncoding="utf-8" transferMode="Buffered"
                    useDefaultWebProxy="true">
                    <readerQuotas maxDepth="32" maxStringContentLength="8192" maxArrayLength="16384"
                        maxBytesPerRead="4096" maxNameTableCharCount="16384" />
                    <security mode="None">
                        <transport clientCredentialType="None" proxyCredentialType="None"
                            realm="" />
                        <message clientCredentialType="UserName" algorithmSuite="Default" />
                    </security>
                </binding>


2.WCF使用的传输协议
（1）HTTP/HTTPS
HTTP全称为 HyperText Transfer Protocol(超文本传输协议)，是建立在TCP/IP簇上的应用层协议。
HTTP特点
HTTP提供简单的请求-回复（Request-Reply）消息传输方式；
HTTP是无状态的，每次HTTP请求都是相互独立的；
HTTP是无连接的，基于HTTP的数据传输无须事先打开链接。
HTTP的默认端口为：80；HTTPS的默认端口为：443。
HTTPS
HTTPS全称为HyperText Transfer Protocol over Secur  e Layer(安全超文本传输协议)，它是采用SSL（Secure Socket Layer）的HTTP。而SLL是一个进行数据加密的协议，
很多安全性要求较高的网站都采用HTTPS。

（2）Net.TCP
TCP全称为Transport Control Protocol(传输控制协议)，在整个TCP/IP簇中处于核心地位。从整个协议分层结构来看，位于应用层之下，网络层（IP协议）之上。较之HTTP,TCP具有
如下特点：
•TCP是基于连接的传输协议，在开始进行数据传输之前，通过客户端和服务端之间的3次“握手”创建连接；在结束传输之后，通过4次“握手”终止连接。 
•TCP是有状态的，由于数据传输在一个确定的连接中进行，因此可以保持每次数据传输的状态。 
•TCP支持全双工（Duplex）通信，一旦连接成功创建，数据就可以在两个方向上同时传输。 
•TCP支持可靠通信（Reliable Messaging），IP协议本身提供的数据传输是不可靠的，数据的可靠传输只能通过TCP来保证。 
•Net.TCP默认端口为：808 

（3）Net.Pipe
命名管道（Named Pipes）是Windows 平台及UNIX系统下实现跨进程通信（Inter Process Communication, IPC）的标准实现方式。虽然命名管道本身可以实现跨机器的通信，但是
WCF只将命名管道专门用于同一台机器的跨进程通信，所以基于命名管道的URI的主机名称|IP地址部分只能是本机的机器名、localhost或127.0.0.1。

（4）Net.MSMQ
消息队列（Message Queuing，也称MSMQ），是微软对消息服务领域的开创新尝试。由于消息队列采用了特殊的通信机制，因此对于改善和提高系统的可扩展性（Scalability）和高可用性（High Availability）具有重要的意义。消息队列分为如下两种类型：
•公共消息队列：共有队列的名称被注册到AD域中，所以我们无需指定队列所在的机器名称就可以访问队列。 
•私有消息队列：似有队列使用在工作组（Work Group）模式下，而访问似有队列需要制定包含对列所在机器名称的路径。 


III.C代表Contact（契约）-what（定义的对象是什么，如何操纵）
在WCF中包括了四种契约：服务契约，数据契约，错误契约和消息契约。所有WCF方法都通过interface被访问，各种契约都定义也在interface上，因此，※※这是一种典型的“面向接口编程”。※※
1.服务契约
    服务契约描述了暴露给外部的类型（接口或类）、服务所支持的操作、使用的消息交换模式和消息的格式。每个WCF服务必须实现至少一个服务契约。使用服务契约必须要引用命名空间System.ServiceModel 。服务契约中常用到的三个特性：
（1）ServiceContractAttribute（声明在契约上，即接口上）
    ServiceContract声明用来把.NET中的接口声明（CLR格式）映射为与平台无关的契约声明（XML格式），以向外界暴露服务访问入口。ServiceContract声明与类的访问修饰符无关，即不管接口（类）的访问修饰符是public/private/protected/internal，只要把该接口（类）声明为ServiceContract，该接口（类）总会变成服务契约暴露给客户端。因为访问修饰符（public/private/protected/internal）定义的是在CLR中的访问边界，而ServiceContract定义的是在WCF中的访问边界。
    在WCF中服务契约接口都需要显示声明为ServiceContract，否则，接口不会被当成WCF契约向外界暴露。
    即使我们把接口声明为ServiceContract了，但该服务契约现在并不包含任何成员，我们还要在需要作为契约成员的方法上面加上OperationContractAttribute声明。
该特性定义在类或接口上，用来描述一个相关操作的集合。ServiceContractAttribute特性还有如下的一些属性值可以设置：
Name：给服务契约定义一个名称，而不是使用接口或是类的类型名，在客户端添加服务引用时会用到。
Namespace：命名空间，默认值为http://tempuri.org。
CallbackContract：将另一个服务契约定义为回调契约，使得客户端可以接收服务端的异步消息。
ProtectionLevel：控制契约中发送给消息的保护方式是否需要被签名和加密。该属性为System.Net.Security.ProtectionLevel枚举类型。
SessionMode：确定会话是否为公开服务契约的端点所支持。
ConfigurationName：服务的配置名称。
[ServiceContract(Name="HelloWorld", Namespace="http://oec2003.cnblogs.com"]
public interface IHelloWorldService
{ 

} 

★会话
每个客户端在服务器上都有其的独立数据存储区，互不相干，就好像A和服务器在单独谈话一样，所以叫会话。
不开启会话的情况：先后调用的两个方法属于“不同”实例。
开启会话的情况：先后调用的两个方法属于“同一个”实例。
[ServiceContract(SessionMode = SessionMode.Required)]  
public interface IService  
{  
    [OperationContract(IsOneWay = true, IsInitiating = true, IsTerminating = false)]  //启用会话
    void SetValue(int n);  
    [OperationContract]  
    int GetValue();  
    [OperationContract(IsInitiating = false, IsTerminating = true)]    //结束会话
    void EndSession();  //在选择作为结束会话的方法时，最好使用返回值为void或者单向通讯（One Way）的方法，这样，不用等待客户结束才结束会话，因为单向通讯，不需要向客户端回复消息，因为它被调用后就可以马上终止会话了。
}  

这里就用到了ServiceContract契约的SessionMode属性：
public enum SessionMode
{
    Allowed,
    Required,
    NotAllowed
}
·SessionMode.Allowed：这是SessionMode属性的默认值。启用传输会话，但应用程序不必须使用会话。如果该服务行为声明为PerCall，那它仍不会保留实例状态。如果服务声明为PerSession，那它会根据信道情况确定是否保留实例状态。
    BasicHttpBinding和WSHttpBinding两种绑定并不支持传输会话，所以即使服务行为被配置为PerSession，那它依然采用PerCall的调用方式。
    NetTcpBinding、NetNamedPipeBinding和WSHttpBinding安全可信赖绑定支持传输会话，如果服务行为被配置为PerSession，那它采用PerSession调用方式。
·SessionMode.Required：指定绑定信道必须支持传输会话，如果绑定信道不支持传输会话，在加载服务的时候会产生异常。
    当服务行为指定为PerSession时，那此时服务端实例与客户端代理可以实现一对一的调用，并能保存服务端实例的状态。
    当服务行为指定为PerCall时，那此时仍不会在服务端保存实例状态。
    如果要设计带有会话状态的服务契约的时候，建议把服务契约的SessionMode设为SessionMode.Required。
·SessionMode.NotAllowed：不启用传输会话，禁止服务保存服实例的状态。服务永远是PerCall模式

InstanceContextMode.PerCall不支持会话，会使IsInitiating = true失效，即会话不会生效。
InstanceContextMode.Single会使IsTerminating = true失效。


★保持会话时长
服务端会话保持的时长设置方法是在服务端的config配置文件中设置：
<bindings>
    <netTcpBinding>
        <binding name="TCPSession">
            <reliableSession inactivityTimeout="00:25:00" enabled="true" />
        </binding>
    </netTcpBinding>
</bindings>
编程方式为：
NetTcpBinding netTcpBinding = new NetTcpBinding();
netTcpBinding.ReliableSession.InactivityTimeout = TimeSpan.FromMinutes(25);

※支持会话的Binding方式
·默认的BasicHttpBinding不支持会话，HTTP属于一次性连接，没有会话，或者说一次连接通信后，会话即结束。TCP、IPC绑定可以支持会话，
·NetTcpBinding和NetNamedPipeBinding两种绑定能够在客户端和服务端保持一个持续的连接，所以它们可以很好地把客户端与服务实例关联起来。可以使用PerSession实例模式。
·BasicHttpBinding绑定是通过Http协议进行数据传输的一种简单的绑这下，而Http协议本身又是一种无状态协议，所以服务端无法区分每次请求的客户端。因此在这种绑定信道上是无法使用PerSession模式的。
·WSHttpBinding绑定也是通过Http协议进行数据传输的，当然Http协议本身也是无状态的，但它可以在消息头中包含ID来识别不同的客户端。因此，当WSHttpBinding在安全模式和可信赖消息模式下是可以使用PerSession模式的。



（2）ServiceBehaviorAttribute（声明在实现上，即实现接口的类上）
※与契约不同，服务行为特性要设置在“实现”上，即在“类”上。
1）实例管理模式（影响到是否new一个新实例）
指明了服务端会话保持的时长，但客户端要知道该契约是否需要保持状态，因此在定义服务契约的时候需要指明该契约的会话模式。
WCF服务行为支持三种实例管理模式
·PerCall：针对客户端的每个请求创建一个新的服务实例（“一次xxxClient.ServerMethod()请求”使用同一个服务实例）。（不影响服务实例的静态成员）
    在服务被配置成PerCall实例模式的状态时，客户端代理每次对服务契约调用，WCF都会产生一个新服务实例来处理客户请求，当处理完请求后，WCF就会把服务实例作为一个垃圾，等待垃圾回收器来清理。
方法：
[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerCall)]     //特性只能应用到类上
public class MyService : IService
{
    ...
}
特点：
1>服务实例在方法被调用时创建，调用完立即释放。
2>吞吐量大，内存开销少。能有效节约服务器内存，也不会过长时间占用昂贵的服务器资源（数据库连接，文件指针等）。
3>不会产生并发问题
4>两次调用之间不会保存状态
·PerSession：针对每个连接的客户端创建一个服务实例（“同一个xxxClient的请求”使用同一个服务实例）。（不影响服务实例的静态成员）
    当服务的实例模式指定为PerSession时，每个客户端代理会取得一个独享的服务实例，并进行一对一的调用，这个服务实例不会在一次调用后立即释放，而会一直存在，直到客户端代理关闭（当客户端代理关闭时会通知服务会话结束）。
特点：
1>需要在服务器端管理实例状态
2>吞吐量下降
3>服务器资源开销过多
4>事务控制麻烦等问题。
5>一般来说，它只能为几十个客户端进行服务。
注：如果客户端启用另一个代理请求服务，那会在服务端产生一个新的独享服务实例来与之交互。
方法：
[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]     //特性只能应用到类上，默认为此值
public class MyService : IService
{
    ...
}
·Singleton：所有的客户端共享一个服务实例（“通通”使用同一个服务实例）。（服务实例的静态成员也受影响）
    Singleton模式是终极服务共享模式，所以客户端共享一个服务实例，不管你是采用什么样的绑定信道。服务实例在宿主程序运行的时候创建，在宿主程序结束的时候释放，中间全程占用服务器资源。
特点：
1>所有客户端调用同一实例
2>吞吐量受影响
3>对象在内存中占用时间较长
4>容易产生并发性问题
方法：
[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]       //特性只能应用到类上
public class MyService : IService
{
    ...
}

OperationContext.Current.SessionId;     //当前会话Id
proxy.InnerChannel.SessionId;           //实例的会话Id



2）并发模式（影响到同一个服务实例能否同时处理多个请求，如果是Single或Reentrant就加锁并排队）
在WCF中使用 ServiceBehaviorAttribute中的ConcurrencyMode属性来控制这个设置。ConcurrencyMode属性是个枚举类型，有三个值：ConcurrencyMode.Single、ConcurrencyMode.Reentrant和ConcurrencyMode.Multiple
public enum ConcurrencyMode
{
   Single,      //默认，单线程模型
   Reentrant,   //单线程，可重入模型，通常用在CallBack调用模型中
   Multiple     //多线程模型
}

·ConcurrencyMode.Single（同一个服务实例只处理一条请求）（服务端执行完客户端的回调方法后，由于当前服务已被加锁，已不能再次进入，会超时退出）
单线程处理模式，“同一个服务实例”不会同时处理多个请求。当服务在处理请求时“会对当前服务加锁”，如果再有其它请求需要该服务处理的时候，需要排队等候。当服务处理完请求后会自动解锁，队列中的下个请求获取服务资源，继续处理。
例如：我们去银行去办理业务，如果营业厅中只有一个窗口对外服务的话，那当前窗口每次只能处理一个用户请求，如果再有其它用户需要办理业务的话，只能排队等待。直到我办理完业务后，营业窗口才能为队列中下个用户提供服务。

·ConcurrencyMode.Reentrant（服务端执行完客户端的回调方法后，可以继续执行下去）
对于PerCall实例模型，如果采用Single的并发模式时，在实现回调的时候会出现问题：当服务在处理客户请求的时候是处于锁定状态的，当回调的时候，在未解除锁定的状态下又去调用客户端，在客户端回调执行完成后，想再回到服务端的时候发现服务端被自己锁定无法进入，产生等待超时的异常。要解决这个问题，我们可以采用Reentrant并发模式，Reentrant模式依然是单线程模式，只是它允许客户端加调用能再回到服务端继续执行。
可重入的单线程处理模式，它仍然是单线程处理。服务端一次仍然只能处理一个请求，如果有多个请求同时到达仍然需要排队。与单线程不同的是，请求在处理过程中可以去调用其它服务，等到其它服务处理完成后，再回到原服务等待队列尾排队。在调用其它服务的过程中，会暂时释放锁，其它等待线程会趁机进行服务的调用。这种模式常见于服务端回调客户端的场境中。
例如：我们去银行办理业务，营业厅中还是只有一个窗口对外服务，一次只能处理一个用户请求。我向银行服务员请求办理开户业务，从此刻开始该服务被我锁定，其它人员只能排队等待。在服务员办理业务的过程中，会让我填写开户申请表，这个签字的过程就是服务端对客户端的回调过程。由于填写开户申请表的时间会很长，为了不耽搁后面排队顾客的时间，我暂时释放对服务员的锁定，到旁边填写申请表，让后面的人员办理业务。在我签完字后再回到队列中等待服务，当再轮到我的时候我再次锁定服务，把凭据交给服务员，让他继续处理我的业务，这相当于服务的“重入”过程。 等到业务办完后，我会离开银行柜台，释放对该服务的锁定，等待队列中的下个人员又开始锁定服务办理业务了。

·ConcurrencyMode.Multiple
多线程模式，多线程模式可以很好地增加系统的吞吐量。当多个用户请求服务实例时，服务并不会加锁，而是同时为多个请求服务。这样一来对所有用户共享的资源就会产生影响，所以这种多线程的访问模式需要对共享资源做好保护，大部份的情况下需我们的手动编写代码来实现多线程之间的访问保护。
例如：我们去吃烤肉串，烤肉串的师傅可以同时为多个顾客烤制，而不用一个一个地排队等待，这就是典型的多线程处理模式。但这种模式如果不对肉串很好保护得的话那可麻烦了，比仿，我要的是3串麻辣味的，你要的是3串香辣味的，他要的是3串原味的，烤肉的时傅在烤制的时候需要对这三份肉串做好保护，防止做出一些“五味俱全”的肉串来。





（3）OperationContractAttribute（声明在契约的方法上，即接口中定义的方法上）
    用OperationContractAttribute标记的方法即为一个服务操作，简单的使用该特性就可以让一个方法加入到服务契约的操作队列中，可以被客户端所调用。该特性也有一些设置消息交换方式的属性。如下
Name：定义一个操作名称，而不是使用方法名称。
Action：该操作消息的动作标题。
ReplyAction：响应该操作消息的动作标题。
IsOneWay：设置该操作是否单向和没有回复，如果操作是单向的，将不支持ReplyAction。
ProtectionLevel：允许你控制特定的操作消息是否被保护，操作中的ProtectionLevel属性将覆盖服务契约中的ProtectionLevel。该属性为System.Net.Security.ProtectionLevel枚举类型。
IsInitiating：操作是否可以用来初始化会话。即启用一个会话。
IsTerminating：操作是否中止一个会话。即终止一个会话。
AsyncPattern：将服务操作定义为异步实现模式。
[ServiceContract(Namespace="http://oec2003.cnblogs.com", Name="oec2003", ConfigurationName="IHelloWorldService")]
public interface IHelloWorldService
{
    [OperationContract(Name="oec2003SayHello", Action = "http://oec2003.cnblogs.com/IHelloWorldService/Hello", ReplyAction = "http://oec2003.cnblogs.com/IHelloWorldService/HelloReply")]
    string SayHello();
} 
MessageParameterAttribute
使用 MessageParameterAttribute 可以控制参数或返回值的名称。此属性对于已用 MessageContractAttribute 特性标记的参数无效。该特性只有一个Name属性，看如下代码：
[ServiceContract(Namespace="http://oec2003.cnblogs.com", Name="oec2003", ConfigurationName="IHelloWorldService")]
public interface IHelloWorldService
{
    [OperationContract]
    [return: MessageParameter(Name = "responseString")]
    string SayHello([MessageParameter(Name = "string")]string meg);
}


其它例：
1）NameSpace属性
在编写WCF服务的时候，我们应当为每个服务契约设置NameSpace属性，如果为服务契约指定NameSpace属性的话，那该服务契约会默认NameSpace="http://tempuri.org/"。这里NameSpace的作用与原来CLR中NameSpace的作用一样，都是为了定义一个命名空间，防止命名的冲突。
如：
[ServiceContract(Namespace = "http://hi.baidu.com/grayworm")]
interface IMyContract
{...}
对Internet发布的服务契约，命名空间一般使用公司的网址进行命名，对于局域网内发布的服务契约则没有必要按照这种方式进行命名，我们可以使用更有意义单词作为NameSpace。
[ServiceContract(Namespace = "MyNamespace")]
interface IMyContract
{...}


2）Name属性
我们还可以为服务契约指定别名。在默认的情况下，服务契约的名称与接口的名称一样，我们可以在ServiceContract声明中使用Name属性为服务契约指定别名。
[ServiceContract(Namespace="")]
public interface ICaculator
{
    [OperationContract(Name="AddInt")]
    int Add(int arg1, int arg2);
    [OperationContract(Name="AddDouble")]
    double Add(double arg1, double arg2);
}

※重载
在面向对象的思想中，我们有方法重载的概念，所谓的方法重载就是指一个类中如果两个方法的方法名相同而方法参数不同，那这两个参数就形成了重载。CLR可以根据方法的能数来区分这两个方法。而在WCF世界中这种方法名相同而参数不同的形式则会引发InvalidOperationException异常，即在WCF中不支持面向对象中的方法重载。

在OperationContract声明上通过Name属性为方法起别名，将来客户端就会通过这个别名来区分不同方法的，以达到重载的目的。如：
[ServiceContract]
public interface ICaculator
{
    [OperationContract(Name="AddInt")]
    int Add(int arg1, int arg2);
    [OperationContract(Name="AddDouble")]
    double Add(double arg1, double arg2);
}
这样在客户端会把两个Add方法区分为AddInt和AddDouble两个方法。

3）通信模式
    WCF在通信过程中有三种模式：请求与响应、单向、双工通信。
<1>请求与响应模式（Request-Response）：客户端发送请求，然后一直等待服务端的响应(异步调用除外)，期间处于假死状态，直到服务端有了答复后才能继续执行其他程序。（即使返回值是void 也属于请求与响应模式。）
方法：[OperationContract]（阻塞线程）
缺点：如果用WCF在程序A中上传一个2G的文件，那么要想执行程序B也许就是几个小时后的事情了。如果操作需要很长的时间，那么客户端程序的响应能力将会大大的下降。
优点：有返回值我们就可以向客户端返回错误信息，如：只接收".rar"文件等信息。

<2>单向模式（OneWay）：客户端向服务端发送求，但是不管服务端是否执行完成就接着执行下面的程序。
方法：[OperationContract(IsOneWay = true)]（不阻塞线程）
缺点：与“请求与响应模式”相反。
优点：与“请求与响应模式”相反。
特点：使用 IsOneWay=true 标记的操作不得声明输出参数、引用参数或返回值。

<3>双工模式（Duplex）：双工模式建立在上面两种模式的基础之上，实现客户端与服务端相互的调用。相互调用：以往我们只是在客户端调用服务端，然后服务端有返回值返回客户端，而相互调用不光是客户端调用服务端，而且服务端也可以调用客户端的方法。
方法：[ServiceContract(CallbackContract = typeof(IUserCallback))]
      public class IUser
      {...}
缺点：
优点：
特点：

由于回调契约本质也是一个服务契约，所以定义方式和一般意义上的服务契约基本一样。有一点不同的是，由于定义IUser的时候已经通过[ServiceContract(CallbackContract=typeof(IUserCallback))]指明ICallback是一个服务契约了，所以ICallback不再需要添加ServiceContractAttribute特性。






（4）回调模式
大概步骤：
    1声明回调接口
    2调用接口处加回调接口的回调契约
    3调用接口实现时，声明回调实例，并通过会话给实例赋值。在所需的地方使用回调函数。
    4在客户端实现架设接口
具体如下：
第一步，定义一个回调接口。
public interface ICallback                                                                    /* ※1.必需，定义回调接口 */  
{  
    // 回调操作也必须One Way  
    [OperationContract(IsOneWay = true)]  
    void CallClient(int v);  
}  

第二步，定义服务协定。
[ServiceContract(Namespace = "MyNamespace",   
    CallbackContract = typeof(ICallback),       /* 标注回调协定 */                            /* ※2.必需，在需要回调的接口上声明回调接口 */
    SessionMode = SessionMode.Required          /* 要求会话 */  
    )]  
public interface IService  
{  
    // 会话从调用该操作启动  
    [OperationContract(IsOneWay = true,         /* 必须 */  
        IsInitiating = true,                    /* 启动会话 */  
        IsTerminating = false)]  
    void CallServerOp();  
  
    // 调用该操作后，会话结束  
    [OperationContract(IsOneWay = true,         /* 使用回调，必须为OneWay */  
        IsTerminating = true,                   /* 该操作标识会话终止 */  
        IsInitiating = false)]  
    void End();  
}  

第三步，实现服务协定。
public class MyService : IService, IDisposable  
{  
    private Timer timer = null;                 //计时器，定时干活  
    Random rand = null;                         //生成随机整数  
  
    public void CallServerOp()  
    {  
        ICallback m_cb = OperationContext.Current.GetCallbackChannel<ICallback>();            /* ※3.必需，取得并调用回调方法，方法的引用暂由回调接口代替 */  
        rand = new Random();  
        // 生成随整数，并回调到客户端  
        // 每隔3秒生成一次  
        timer = new Timer((obj) => m_cb.CallClient(rand.Next()), null, 10, 3000);  
    }  
  
    public void Dispose()  
    {  
        timer.Dispose();  
        Console.WriteLine("{0} - 服务实例已释放。", DateTime.Now.ToLongTimeString());  
    }  
  
  
    public void End()                           //结束  
    {  
        Console.WriteLine("会话即将结束。");  
    }  
}  
第四步，完成服务器端的配置。
static void Main(string[] args)  
{  
    Console.Title = "WCF服务端";  
    // 服务器基址  
    Uri baseAddress = new Uri("http://localhost:1378/services");  
    // 声明服务器主机  
    using (ServiceHost host = new ServiceHost(typeof(MyService), baseAddress))  
    {  
        // 添加绑定和终结点  
        // tcp绑定支持会话  
        WSDualHttpBinding binding = new WSDualHttpBinding();                                  /* ※4.必需，必须是支持回调的Binding，如此处的WSDualHttpBinding */  
        binding.Security.Mode = SecurityMode.None;  
        host.AddServiceEndpoint(typeof(IService), binding, "net.tcp://localhost:1211/rr");  
        // 添加服务描述  
        host.Description.Behaviors.Add(new ServiceMetadataBehavior { HttpGetEnabled = true });  
        try  
        {  
            // 打开服务  
            host.Open();  
            Console.WriteLine("服务已启动。");  
        }  
        catch (Exception ex)  
        {  
            Console.WriteLine(ex.Message);  
        }  
        Console.ReadKey();  
    }  
}  




服务器端完工后，下面就是客户端。
第一步，新建一个Windows窗体应用项目（Windows Forms）。
第二步，到对应目录以管理员身份运行服务器端，然后在客户端添加服务引用。
第三步，在客户端实现回调接口。
/// <summary>  
/// 实现回调接口  
/// </summary>  
public class MyCallback : WS.IServiceCallback       /* ※5.必需，客户端实现一个回调方法，该回调方法应遵循（实现）服务端的回调接口，注意名称，WS是服务引用，
                                                       IServiceCallback的命名规则是“IService”+“Callback”，是客户端引用WCF服务后，自动生成的回调接口 */
{  
    // 因为该方法是由服务器调用的  
    // 如果希望在客户端能即时作出响应  
    // 应当使用事件  
    public void CallClient(int v)  
    {  
        if (this.ValueCallbacked != null)  
        {  
            this.ValueCallbacked(this, v);  
        }  
    }  
    /// <summary>  
    /// 回调引发该事件  
    /// </summary>  
    public event EventHandler<int> ValueCallbacked;  
}  
※注意，回调的接口是在客户端实现的，不是服务器端。



using System;  
using System.Collections.Generic;  
using System.ComponentModel;  
using System.Data;  
using System.Drawing;  
using System.Linq;  
using System.Text;  
using System.Threading.Tasks;  
using System.Windows.Forms;  
  
namespace Client  
{  
    public partial class Form1 : Form  
    {  
        WS.ServiceClient cl = null;  
        MyCallback cb = null;  
        public Form1()  
        {  
            InitializeComponent();  
            cb = new MyCallback();  
            cb.ValueCallbacked += cb_ValueCallbacked;  
              
        }  
  
        void cb_ValueCallbacked(object sender, int e)  
        {  
            this.lbResult.Text = e.ToString();  
        }  
  
        private void button1_Click(object sender, EventArgs e)  
        {  
            cl = new WS.ServiceClient(new System.ServiceModel.InstanceContext(cb));  
            cl.CallServerOp();  
            button1.Enabled = false;  
            button2.Enabled = true;  
        }  
  
        private void button2_Click(object sender, EventArgs e)  
        {  
            cl.End();  
            button1.Enabled = true;  
            button2.Enabled = false;  
        }  
    }  
}  


总结：
IsOneway：影响的是声名了OperationContract的方法是否阻塞；
InstanceContextMode：影响的是每次访问服务是否开启新的实例；
ConcurrencyMode：影响的是服务端开启的多个实例是队列还是并行。


（5）事务
A.Client/Service事务模型
如果客户端启用了事务，则服务端就参与事务；如果客户端没有启用事务，则服务端独立启用事务。即不管客户端是否启用事务，服务端总是运行在事务中。
  服务端代码：
    [ServiceContract]
    public interface IClientServiceTransaction
    {
        [OperationContract]
        //如果客户端启用了事务，则服务端参与事务
        [TransactionFlow(TransactionFlowOption.Allowed)]                        //1.必需
        void CSMethod();
    }

    public class ClientServiceTransaction:IClientServiceTransaction
    {
        //服务端代码必须置于服务中执行
       [OperationBehavior(TransactionScopeRequired=true)]                       //2.必需
        public void CSMethod()
        {
            //获取当前事务对象
            Transaction transaction = Transaction.Current;
            //注册事务流执行结束的事件方法
            transaction.TransactionCompleted += new TransactionCompletedEventHandler(transaction_TransactionCompleted);
            //显示事务的本地ID
            Debug.WriteLineIf(transaction != null, "<服务端>事务本地ID："+transaction.TransactionInformation.LocalIdentifier);
        }

        //事务流执行结束时会触发此方法
        void transaction_TransactionCompleted(object sender, TransactionEventArgs e)
        {
            //显示事务全局的ID
            Debug.WriteLine("<服务端>事务全局ID："+e.Transaction.TransactionInformation.DistributedIdentifier);
            //显示事务的执行结果
            Debug.WriteLine("<服务端>事务执行结果"+e.Transaction.TransactionInformation.Status);
        }
    }

  服务配置代码：
    在配置中我建立了两个终结点，分别采用netTcpBinding和wsHttpBinding。
    <system.serviceModel>
        <!--配置绑定，启用事务流-->
        <bindings>
            <netTcpBinding>
                <binding name="TCPTransactionBinding" transactionFlow="true" transactionProtocol="WSAtomicTransactionOctober2004" />                       //3.必需   transactionFlow="true"
            </netTcpBinding>
            <wsHttpBinding>
                <binding name="WSTransactionBinding" transactionFlow="true" />
            </wsHttpBinding>
        </bindings>
        <service>
            <!--wsHttpBinding终结点配置-->
            <endpoint address="ws" binding="wsHttpBinding" bindingConfiguration="WSTransactionBinding" contract="Services.TransactionFlow.IClientServiceTransaction" listenUriMode="Explicit">
            </endpoint>
           <!--元数据终结点配置（略）-->
            <!--netTcpBinding终结点配置-->
            <endpoint address="net.tcp://localhost:8300/tcp" binding="netTcpBinding" bindingConfiguration="TCPTransactionBinding" contract="Services.TransactionFlow.IClientServiceTransaction" />
        </service>
    </system.serviceModel>

  客户端代码：
    public static void Main(string[] args)
    {
        SRClientService.ClientServiceTransactionClient prox = new Client.SRClientService.ClientServiceTransactionClient("WSHttpBinding_IClientServiceTransaction");
        //第一次调用，客户端没有启用事务
        prox.CSMethod();
        using (TransactionScope ts = new TransactionScope())                                                                   //4.必需
        {
            Transaction.Current.TransactionCompleted += new TransactionCompletedEventHandler(Current_TransactionCompleted);
            Console.WriteLine("<客户端>事务本地ID：" + Transaction.Current.TransactionInformation.LocalIdentifier);
            //第二次调用事务，客户端启用了分布式事务
            prox.CSMethod();
            
            //事务提交。如果提交，事务流会执行成功；如果不提交的话，事务流会回滚。
            //ts.Complete();
        }
        Console.ReadLine();
    }
    //事务流执行结束时会触发此方法
    static void Current_TransactionCompleted(object sender, TransactionEventArgs e)
    {
        Console.WriteLine("<客户端>事务全局ID："+e.Transaction.TransactionInformation.DistributedIdentifier);
        Console.WriteLine("<客户端>事务执行结果："+e.Transaction.TransactionInformation.Status);
    }


2.数据契约（DataContract声明在契约的实现上，即类上；DataMember声明在实现的方法上，即类的方法上）
    在进行WCF编程的时候，服务端程序难免会与客户端程序之间发生数据交换，由于服务端与客户端可能是两种异质运行环境，这就需要实现服务端的数据类型与客户端代理类数据类型的统一。在服务器端与客户端交换数据是通过流来实现的，因此在传递对象的时候需要我们把对象转换到流中去，在目的地我们再从流中把数据读取出来重新生成能相应对象，这个思想就是我们序列化的思想。在DotNET序列化中是通过Serialization声明来标识类允许被实例化的，这种序列化只是把数据序列化到流中去，而在WCF中不仅仅要把数据序列化到流中去还应包含数据类型的描述。因为客户端的程序可能与服务器端的程序不一样而无法实现数据准确的序列化和反序列化，比如服务器端我是用WCF开发的，而客户端是用JavaEE开发的，现在需要从服务器端返回一个Dog对象给客户端。如果只使用简单的序列化和反序列化的话，可能会产生问题：服务器端DotNET序列化的数据在客户端JavaEE不能识别流的格式，无法实现反序列化。
数据契约的作用就是实现一种与平台无关的序列化，即在序列化过程中实现在schema与CLR类型之间转换。
许多内置类型都默认可以被序列化，但自定义类型我们就需要使用数据契约来显式指明其可被序列化。
    使用数据契约必须引用System.Runtime.Serialization命名空间，在类型上使用DataContractAttribute可以创建数据契约，类型中的成员使用DataMember标记。代码如下：
[DataContract]
public class User
{
    [DataMember]
    public int Age { get; set; }
    [DataMember]
    public string Name { get; set; }
    [DataMember]
    public string Email { get; set; }
} 
（1）DataContractAttribute
    DataContractAttribute特性定义在类型之上，类型包括类、结构、枚举但不包括接口。DataContractAttribute特性不能被继承，即继承自有DataContractAttribute特性标记的类并不是数据契约，必须显示使用DataContractAttribute标记才能成为数据契约。DataContractAttribute特性有IsReference、Name和Namespace三个属性：
IsReference：bool类型，表示在进行序列化的时候是否保持对象现有的引用结构。
Name：名称。
Namespace：命名空间。

（2）DataMemberAttribute
使用DataMemberAttribute标记的类型成员才能成为数据契约的数据成员。这个和服务契约中的OperationContractAttribute类似。DataMemberAttribute特性有如下四个属性:
EmitDefaultValue：表明在数据成员的值等于默认值的情况下，是否还须要将其序列化到最终的XML中，默认值为true，表示默认值会参与序列化。
IsRequired：bool类型，表明属性成员是否是必须的成员，默认值为false。
Name：数据成员的别名。
Order：相应的数据成员在最终序列化的XML中出现的位置，默认是按字母顺序排列的。
[DataContract(IsReference=true, Name="MyUser", Namespace="http://oec2003.cnblogs.com")]
public class User
{
    [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Oec2003_Age", Order = 1)]
    public int Age { get; set; }
    [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Oec2003_Name", Order = 2)]
    public string Name { get; set; }
    [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "Oec2003_Email", Order = 3)]
    public string Email { get; set; }
}

※与服务契约一样，使用DataContract和DataMember声明的数据契约也与访问修饰符（public, private, protected...）无关。
1）带数据协定的类，其中带数据协定的字段都会转成公共的，不带数据类型的字段不会被暴露。
2）不带数据协定的类，其中的字段也会被暴露，但不是原类型。

推断数据契约
WCF引入了对数据契约进行推断的支持。如果编组类型是public类型，且未曾标记DataContract特性，WCF就会自动推断，认为DataContract特性被应用到该类型上，且它的所有公共成员（包括字段、属性）均被应用了DataMember特性。

[DataContract]
class MyDataContract
{
    [OnSerializing]
    void OnSerializing(StreamingContext context)
    [OnSerialized]
    void OnSerialized(StreamingContext context)
    [OnDeserializing]
    void OnDeserializing(StreamingContext context)
    [OnDeserialized]
    void OnDeserialized(StreamingContext context)
}
每个序列化事件的处理方法都必须遵守如下的方法签名：
void <Method Name> (StreamingContext context);

DataContract与Serializable的区别：
[DataContract]有[NonSerialized]特性
[Serializable]

总结一下吧，WCF中应用各个标记时所作的序列化处理：
1.不给任何标记将会做XML映射，所有公有属性/字段都会被序列化
2.[Serializable]标记会将所有可读写字段序列化
3.[DataContract]和[DataMember]联合使用来标记被序列化的字段

（3）ServiceKnownTypeAttribute（声明在契约或契约中的方法上，即接口或接口中的定义上）
    服务端中的对象是如何传给客户端的：服务端中的对象序列化后，通过信道传给客户端，在客户端反序列化。那么，在服务端的方法定义时，如果返回的是父类，而return的是子类，就会报错。因为反序列化后，该契约不知道这两个类是继承关系，如何将子类转换成父类，为避免此问题，需要在契约或契约中的方法上声名ServiceKnownType，以便通知契约将这些已知类型“相关到”那些父类上。
1）使用代码方式指定“已知数据类型”
    当[ServiceKnownType(Type t)]被声明在服务契约的级别上时，当前服务契约中的任何方法都可以识别它所指定的子类。代码如下：
[ServiceContract]
[ServiceKnownType(typeof(Dog))]
public interface IPetShop
{
    [OperationContract]
    Pet Sell(string owner, string race);
}
public class PetShop : IPetShop
{
    public Pet Sell(string owner, string race)
    {
        Dog dog = new Dog();
        dog.Name = Guid.NewGuid().ToString();
        dog.Owner = owner;
        dog.Race = race;
        return dog;
    }
}

注：
<1>不要把ServiceKnowntypeAttribute声明加在服务类本身上，但可以把ServiceKnowntypeAttribute声明加在接口服务契约中。
<2>KnownTypeAttribute(Type t)是用在数据契约中的，而ServiceKnowntypeAttribute(Type t)是用在服务契约中的。
<3>我们可以使用多个KnownTypeAttribute或ServiceKnowntypeAttribute来告诉WCF识别多个子类
[ServiceContract]
[ServiceKnownType(typeof(Customer))]
[ServiceKnownType(typeof(Person))]
interface IContactManager

2）使用配置文件指定“已知数据类型”
上面我们可以为WCF服务设置“已知数据类型”，但是当需要把一个新的子类添加为“已知数据类型”时，就需要我们对现有WCF服务进行修改源代码、重新编译、重新布署等操作，为我们服务的可扩展性大打折扣。为了避免这种问题的出现，WCF允许我们把“已知数据类型”配置在宿主程序的配置文件中。
配置代码如下：
<configuration>
    <system.runtime.serialization>
        <dataContractSerializer>
            <declaredTypes>
                <add type = "Services.Pet, Services">
                    <knownType type = "Services.Dog, Services"/>
                </add>
            </declaredTypes>
        </dataContractSerializer>
    </system.runtime.serialization>
这样在客户端生成代理类的时候会根据宿主程序上面的配置文件，在客户端代理类中生成对应的Pet数据契约复本和Dog数据契约复本，并在Pet数据契约复本上加上了KnownTypeAttribute声明




3.消息契约
使用消息契约必须引用System.ServiceModel命名空间，消息契约和数据契约一样都是定义在数据类型上。和数据契约不同的是消息契约更多的是关注数据成员在SOAP消息中的表示。定义一个消息契约需要用到MessageContractAttribute特性，另外还涉及到MessageHeaderAttribute和MessageBodyMemberAttribute这两个特性，MessageContractAttribute特性标记在类型上，MessageHeaderAttribute和MessageBodyMemberAttribute特性标记在数据成员上。

※注意：
i.作为操作协定的输入消息协定（作为参数）封装了操作方法的所有in参数；作为操作协定的返回值的消息协定（return）封装了out参数和返回值。
ii.对于消息头还是消息正文，这个没有什么严格的规定的。一般的原则可以是，类似附加信息之类的可以用作头部，比较重要的信息作为正文。你不妨试试，无论你的成员定义为头部还是正文，在代码调用是看不什么根本区别。
iii.消息协定作为传入参数，则只能有一个参数，以下定义是错误的：void Reconcile(BankingTransaction bt1, BankingTransaction bt2);
iv.除非你返回值为void，如不是，那你必须返回一个消息协定，bool UpLoadFile(TransferFileMessage tMsg);我们这个定义明显不符合要求。
v.一般而言，如果使用流作为传入参数，最好不要使用多个参数，如这样：bool TransferFile(Stream stream, string name);  如果有多个参数，可以使用消息契约

（1）MessageContractAttribute
通过在一个类型上使用MessageContractAttribute标记可以使之成为一个消息契约。MessageContractAttribute特性含有如下几个属性：
IsWrapped：是否为定义的主体成员（一个或者多个）添加一个额外的根节点。
WrapperName：根节点的名称。
WrapperNamespace：根节点的命名空间。
ProtectionLevel：表示保护级别，WCF中通过System.Net.Security.ProtectionLevel枚举定义消息的保护级别。一般有3种可选的保护级别：None、Sign和EncryptAndSign。

（2）MessageHeaderAttribute
使用MessageHeaderAttribute标记的数据成员将会出现在SOAP消息的头部，该特性包含下面几个属性：
Actor：为一个URI值，表示处理该报头的目标节点。
MustUnderstand：bool类型，表明Actor定义的节点是否必须理解并处理该节点。
Name：名称。
Namespace：命名空间。
ProtectionLevel：表示保护级别。
Relay：表明该报头是否需要传递到下一个SOAP节点。

（3）MessageBodyMemberAttribute
使用MessageHeaderAttribute标记的数据成员将会出现在SOAP消息的主体部分，该特性包含下面的属性：
Order：Order属性用来控制成员在SOAP主体部分中出现的位置，默认按字母顺序排列。
Name：名称。
Namespace：命名空间。
ProtectionLevel：表示保护级别。
[MessageContract(IsWrapped=false, WrapperName="MyMessage", WrapperNamespace="http://oec2003.com")]
public class MessageTest
{
    [MessageHeader]
    public string Name { get; set; }
    [MessageHeader(Actor="http://oec2003.com/Age", MustUnderstand=true, Name="MyAge",
        Namespace="http://oec2003.com", Relay=true)]
    public int Age { get; set; }
    [MessageBodyMember(Order = 1)]
    public string Email { get; set; }
} 



例：
//定义消息契约
[MessageContract]  
public class RequrestMessage  
{  
    [MessageHeader]  
    public int maxNum;  
    [MessageBodyMember]  
    public string CheckName;  
}  
  
[MessageContract]  
public class ResponseMessage  
{  
    [MessageBodyMember]  
    public string Name;  
    [MessageBodyMember]  
    public int CheckResult;  
}  

//随意定义一个带服务契约的方法的接口
public interface IService  
{  
    [OperationContract]  
    ResponseMessage CheckRenpin(RequrestMessage rqmsg);  
}  

//实现该接口时，方法中可以用到带有消息契约的类
public class MyService : IService  
{  
    public ResponseMessage CheckRenpin(RequrestMessage rqmsg)  
    {  
        ResponseMessage respMsg = new ResponseMessage();  
        Random rand = new Random();  
        respMsg.CheckResult = rand.Next(rqmsg.maxNum);  
        respMsg.Name = rqmsg.CheckName;  
        return respMsg;  
    }  
}

public int CheckRenpin(int maxNum, string CheckName, out string Name)
        |                    |               |                  |
        |                    -------------------------          |
        -------                                      |          |
              |                                      |          |
public ResponseMessage CheckRenpin(RequrestMessage rqmsg)       |
              |                                                 |
              ---------------------------------------------------


D、报头
在宿主实现时
        public void TestMethod()  
        {  
            int index = OperationContext.Current.IncomingMessageHeaders.FindHeader("header", "http://tempuri.org");  
            if (index != -1)  
            {  
                string hd = OperationContext.Current.IncomingMessageHeaders.GetHeader<string>(index);  
                Console.WriteLine("收到的标头：{0}", hd);  
                Console.WriteLine(OperationContext.Current.RequestContext.RequestMessage); 
            }  
        }  

在客户端调用时
        static void Main(string[] args)  
        {  
            WS.ServiceClient myclient = new WS.ServiceClient();  
            using (OperationContextScope scope=new OperationContextScope(myclient.InnerChannel))  
            {  
                MessageHeader myHeader = MessageHeader.CreateHeader("header", "http://tempuri.org", "你好，这是消息头。");  
                OperationContext.Current.OutgoingMessageHeaders.Add(myHeader);  
  
                // 调用方法  
                myclient.TestMethod();  
                Console.WriteLine("服务方法已调用。");  
            }  
            Console.ReadKey();  
        }  


ServiceContract(Namespace = "MyNamespace")/////////////////////

E、宿主服务器的配置
1.作用
宿主服务器的配置也是WCF编程中的主要组成部分。在以往的.net应用程序中，我们会把DBConn和一些动态加载类及变量写在配置文件里。但WCF有所不同。他指定向客户端公开的服务，包括服务的地址、服务用于发送和接收消息的传输和消息编码，以及服务需要的安全类型等。使用配置文件后，我们无需编译即可修改WCF的变化的信息，提高了程序的灵活性。
2.注意事项
（1）如果在代码里写了配置，那么配置文件将不起作用。
（2）Web程序在Web.config中配置，应用程序中在App.config中配置。更新“服务引用”的时候，app.config、web.config会被更新.
（3）服务项目引用与普通引用没有本质上的区别，只不过项目通过服务引用时，必须开启服务
3.结构
    在Config中配置服务的结点为：<system.serviceModel></system.serviceModel>，在这个节点中主要有三个平级的部：
    Service配置节[必须有]：配置服务、接口和终结点。每个Service都会有以下两个属性。name：名称空间.类名[服务的具体实现类]。behaviorConfiguration：一个在behaviors节点中找到的名称。
　　Binding配置节[可有可无]：配置绑定，如http，tcp等。 
　　Behavior配置节[可有可无]：配置行为，如认证等。
    如下代码所示：
<?xml version="1.0" encoding="utf-8"?>
 <configuration>
   <system.serviceModel>
 
     <!--配置“服务端”服务，添加终结点-->
     <services>
       <service>
         <endpoint></endpoint>
       </service>
     </services>
 
     <!--配置“客户端”服务，添加终结点-->
     <client>
       <endpoint>
         <identity>
           <userPrincipalName value="WORKGROUP\yuzhao" />
         </identity>
       </endpoint>
     </client>
 
     <!--配置绑定-->
     <bindings>
       <netTcpBinding>
         <binding>
           <security mode="None|Transport|Message|TransportWithMessageCredential|TransportCredentialOnly">
            <transport clientCredentialType="None|Basic|Digest|Ntlm|Windows" proxyCredentialType="None|Basic|Digest|Ntlm|Windows" realm="string" >
                <extendedProtectionPolicy policyEnforcement="Never|WhenSupported|Always" protectionScenario="TransportSelected|TrustedProxy">
                    <customServiceNames></customServiceNames>
                </extendedProtectionPolicy>
            </transport>
        </security>
         </binding>
       </netTcpBinding>
     </bindings>
 
     <!--配置行为-->
     <behaviors>
       <serviceBehaviors>
         <behavior>
         </behavior>
       </serviceBehaviors>
     </behaviors>
 
   </system.serviceModel>
 </configuration>

4.WCF服务的配置
（1）代码方式（ServiceHost）
1）定义一个基地址，定义n个终结点地址
using(ServiceHost host = new ServiceHost(typeof(HelloWordService)))
{
    host.AddServiceEndpoint(typeof(IHelloWordService),
        new BasicHttpBinding(), new Uri("http://localhost:10000/HelloWorldService"));
    host.AddServiceEndpoint(typeof(IHelloWordService),
        new NetTcpBinding(), new Uri("net.tcp://localhost:10001/HelloWorldService"));

    if (host.State != CommunicationState.Opening)
        host.Open();
}

（2）定义xml配置文件方式
1）终结点
<services>
  <service behaviorConfiguration="serverBehavior" name="HelloWordService">
    <endpoint address="http://localhost:10000/HelloWorldService" 
              binding="basicHttpBinding" contract="IHelloWordService"></endpoint>
    <endpoint address="net.tcp://localhost:10001/HelloWorldService" 
              binding="netTcpBinding" contract="IHelloWorldService"></endpoint>
  </service>
</services>
2）基地址+终结点
<services>
  <service behaviorConfiguration="serverBehavior" name="HelloWordService">
    <host>
      <baseAddresses>
        <add baseAddress="http://localhost:10000/"/>
        <add baseAddress="net.tcp://localhost:10001/"/>
      </baseAddresses>
    </host>
    <endpoint address="HelloWorldService" 
              binding="basicHttpBinding" contract="IHelloWordService"></endpoint>
    <endpoint address="HelloWorldService" 
              binding="netTcpBinding" contract="IHelloWorldService"></endpoint>
  </service>
</services>


3）完整结构
<configuration>
  <!-- 部署服务库项目时，必须将配置文件的内容添加到
 主机的 app.config 文件中。System.Configuration 不支持库的配置文件。 -->
  <system.serviceModel>
    <!--服务端-->
    <!--非必须，如不想通过配置的方式建立Host服务器，可省略-->
    <services>
      <!--name:名称空间.类型名-->
      <!--behaviorConfiguration：behavior的名称，请看behavior配置节的名称-->
      <service name="MyWCF.Service" behaviorConfiguration="MyBehavior">
        <host>
          <baseAddresses>
            <!-- 每种传输协议的baseAddress，用于跟使用同样传输协议Endpoint定义的相对地址组成完整的地址，
                 每种传输协议只能定义一个baseAddress。HTTP的baseAddress同时是service对外发布服务说明页面的URL -->
            <add baseAddress="http://127.0.0.1:12223/" />
          </baseAddresses>
        </host>
        <!-- Service Endpoints -->
        <!-- 除非完全限定，否则地址将与上面提供的基址相关，每个服务可以有多个Endpoint -->
        <!-- Address：指定这个Endpoint对外的URI，这个URI可以是个绝对地址，也可以是个相对于baseAddress的
                      相对地址。如果此属性为空，则这个Endpoint的地址就是baseAddress-->
        <!-- bindingConfiguration：binding的名称，请看binding配置节的名称-->
        <endpoint address="" binding="basicHttpBinding" bindingConfiguration="BasicHttpBinding_IService" contract="MyWCF.IService">
          <!-- 部署时，应删除或替换下列标识元素，以反映
             用来运行所部署服务的标识。删除之后，WCF 将
              自动推断相应标识。 -->
          <identity>
            <dns value="localhost" />
          </identity>
        </endpoint>
        <!-- Metadata Endpoints -->
        <!-- 元数据交换终结点供相应的服务用于向客户端做自我介绍。 -->
        <!-- 此终结点不使用安全绑定，应在部署前确保其安全或将其删除 -->
        <endpoint address="mex" binding="mexHttpBinding" contract="IMetadataExchange" />
      </service>
    </services>
    <!--客户端-->
    <!--非必须，如不想通过配置的方式以客户端的身份调用服务，可省略-->
    <client>
      <endpoint address=""  binding="basicHttpBinding" contract="MyWCF.IService" bindingConfiguration="BasicHttpBinding_IService" />
    </client>
    
    <!--绑定-->
    <bindings>
      <!--basicHttp绑定-->
      <basicHttpBinding>
        <binding maxReceivedMessageSize="16777215" name="BasicHttpBinding_IService" maxBufferSize="16777215" />
      </basicHttpBinding>
      <!--wsHttp绑定-->
      <wsHttpBinding>
        <binding name="HttpBinding_Iservice">
          <security mode="None">
            <message clientCredentialType="Windows" />
          </security>
        </binding>
      </wsHttpBinding>
      <!--自定义绑定-->
      <customBinding>
        <binding name="xxxbinding">
          <!--可靠绑定、有序交付-->
          <reliableSession ordered="false"/>
          <binaryMessageEncoding>
            <readerQuotas maxArrayLength="2147483647 "/>
          </binaryMessageEncoding>
        </binding>
      </customBinding>
    </bindings>
    
    <!--行为-->
    <behaviors name="MyBehavior">
      <serviceBehaviors>
        <behavior>
          <!-- 为避免泄漏元数据信息，请在部署前将以下值设置为 false 并删除上面的元数据终结点 -->
          <serviceMetadata httpGetEnabled="true" />        <!-- httpGetEnabled - bool类型的值，表示是否允许通过HTTP的get方法获取sevice的WSDL元数据 -->
          <!-- 要接收故障异常详细信息以进行调试，请将以下值设置为 true。在部署前设置为 false 以避免泄漏异常信息 -->
          <serviceDebug includeExceptionDetailInFaults="false" />
        <!-- Specify throttling behavior -->
        <!--    MaxConcurrentCalls：在同一时刻允许处理的最大服务操作数。如果超过此数，则需要把其他方法调用插入队列，以等待处理，默认值16。
                MaxConcurrentSessions：同时传输或应用程序会话的最大个数，默认值10。
                MaxConcurrentInstances：实例的最大个数，默认值26。
        -->
        <serviceThrottling
            MaxConcurrentCalls="5"
            MaxConcurrentSessions="2"
            MaxConcurrentInstances="3" />
        </behavior>
      </serviceBehaviors>
    </behaviors>
  </system.serviceModel>
</configuration>


其中serviceThrottling的代码配置形式为：
    ServiceThrottlingBehavior stbehavior = new ServiceThrottlingBehavior();
    stbehavior.MaxConcurrentCalls = 5;
    stbehavior.MaxConcurrentSessions = 2;
    stbehavior.MaxConcurrentInstances = 3;



F、步骤
1.封装一个WCF服务
新建项目->WCF服务库->名称“WcfService”
1）新建一个服务接口
IService.cs
using System.ServiceModel;

namespace WcfService
{
    [ServiceContract]
    public interface IService
    {
        [OperationContract]
        int Add(int i, int j);
    }
}
2）实现服务接口（也可以在宿主中实现）
WCFService.cs
namespace WCFService
{
    public class Service : IService
    {
        public int Add(int i, int j)
        {
            return i+j;
        }
    }
}

2.托管WCF服务
2.1.Web类型宿主
新建网站->WCF服务->名称“WcfHost_Web”
（1）“添加引用”，引用WcfService项目
（2）web.config
1）新建Service
<service name="WcfService.Service">
2）添加endpoint
<endpoint address="basic" binding="basicHttpBinding" contract="WcfService.IService" />
3）添加serviceMetadata
<serviceMetadata httpGetEnabled="true"/>
全文：
****************************************************************************************************************************************
<?xml version="1.0" encoding="utf-8"?>
<configuration>

  <system.web>
    <compilation debug="false" targetFramework="4.0" />
  </system.web>
  <system.serviceModel>
    <services><!-- 服务端 -->
      <service name="WcfService.Service">
        <endpoint address="basic" binding="basicHttpBinding" bindingConfiguration="" contract="WcfService.IService" />
      </service>
    </services>
    <behaviors>
      <serviceBehaviors>
        <behavior>
          <!-- 为避免泄漏元数据信息，请在部署前将以下值设置为 false 并删除上面的元数据终结点 -->
          <serviceMetadata httpGetEnabled="true"/>
          <!-- 要接收故障异常详细信息以进行调试，请将以下值设置为 true。在部署前设置为 false 以避免泄漏异常信息-->
          <serviceDebug includeExceptionDetailInFaults="false"/>
        </behavior>
      </serviceBehaviors>
    </behaviors>
    <serviceHostingEnvironment multipleSiteBindingsEnabled="true" />
  </system.serviceModel>
  <system.webServer>
    <modules runAllManagedModulesForAllRequests="true"/>
  </system.webServer>
  
</configuration>

****************************************************************************************************************************************

（3）Service.svc
项目新建时，其默认为：
<%@ ServiceHost Language="C#" Debug="true" Service="Service" CodeBehind="~/App_Code/Service.cs" %>
即使用App_Code下的IService.cs、Service.cs本项目内WCF服务，其中“CodeBehind”表示该服务启动后执行的后台代码，非必选项。
将其改为：
<%@ ServiceHost Language="C#" Debug="true" Service="WcfService.Service" %>      Service="WcfService.Service"表明使用WcfService命名空间下的Service类来开启WCF服务
即引用步骤1中的WCF服务

（4）配置IIS
将此项目根目录配置成网站http://192.168.0.1:8881/
访问http://192.168.0.1:8881/Service.svc后得到提示：
****************************************************************************************************************************************
Service 服务
已创建服务。
若要测试此服务，需要创建一个客户端，并将其用于调用该服务。可以使用下列语法，从命令行中使用 svcutil.exe 工具来进行此操作:
svcutil.exe http://localhost:8881/WcfHost_Web/Service.svc?wsdl
这将生成一个配置文件和一个包含客户端类的代码文件。请将这两个文件添加到客户端应用程序，并使用生成的客户端类来调用服务
****************************************************************************************************************************************
架设好后，即开启了该WCF服务，地址是：http://localhost:8881/WcfHost_Web/Service.svc

2.2.控制台类型宿主（WinForm、WPF类型方法相同）
新建项目->控制台应用->名称“WcfHost_Console”
（1）“添加引用”，引用WcfService项目
（2）开启WCF服务的方法
1）简洁版
using System.ServiceModel;
using System.ServiceModel.Description;       //ServiceMetadataBehavior会用到

    class Program
    {
        void StartService()
        {
            ServiceHost sh = new ServiceHost(typeof(WcfService.Service), new Uri("http://localhost:8882/WcfHost_Console/"));
            sh.AddServiceEndpoint(typeof(IService), new BasicHttpBinding(), "_point");                     //添加终结点/_point，此处也可不写，默认为/。一个终结点对应一个服务接口
            //sh.AddServiceEndpoint(typeof(IService_Other), new BasicHttpBinding(), "_point_Other");       //如果WcfService.Service还实现了IService_Other接口，又一个终结点对应另一个服务接口

            ServiceMetadataBehavior behavior = new ServiceMetadataBehavior();
            behavior.HttpGetEnabled = true;
            sh.Description.Behaviors.Add(behavior);

            sh.Open();
            Console.WriteLine("Service start.");
            Console.WriteLine("Press <ENTER> to terminate service....");
            Console.Read();
            sh.Close();
        }
    }

2）彻底释放版
using System.ServiceModel;
using System.ServiceModel.Description;       //ServiceMetadataBehavior会用到

    class Program
    {
        static void Main(string[] args)
        {
            MyServiceHost host = new MyServiceHost();
            host.Open();       //开启一个服务
            host.Dispose();    //释放该服务
        }
    }

    class MyServiceHost : IDisposable
    {
        ServiceHost host;
        public void Open()
        {
            host = new ServiceHost(typeof(WcfService.Service), new Uri("http://localhost:8882/WcfHost_Console") );       //此处引用了WCFService项目的MyService类
            host.AddServiceEndpoint(typeof(IService), new BasicHttpBinding(), "_point");                                 //添加终结点/_point，此处也可不写，默认为/
            
            ServiceMetadataBehavior behavior = new ServiceMetadataBehavior();  
            behavior.HttpGetEnabled = true;  
            host.Description.Behaviors.Add(behavior);  

            if(host.State != CommunicationState.Opening)
            {
                host.Open();         //开启服务
                Console.WriteLine("Service start.");  
                Console.WriteLine("Press <ENTER> to terminate service....");
                Console.ReadLine();
                host.Close();        //关闭服务
            }
        }

        public void Dispose()
        {
            if (host != null)
                (host as IDisposable).Dispose();
        }
    }

运行该程序，显示“Service start.”，即开启了该WCF服务，地址是：http://localhost:8882/WcfHost_Console


2.3.服务类型宿主
新建项目->建立Windows服务->名称“WcfHost_WindowsService”
（1）“添加引用”，引用WcfService项目；“添加引用”，引用System.ServiceModel
（2）开启WCF服务的方法
（3）Service1.cs改为WcfHost_WindowsService.cs
在WcfHost_WindowsService的设计界面中右击，选择“属性”，把其中的(Name)和ServiceName都改为WcfHost_WindowsService
namespace WcfHost_WindowsService
{
    public partial class WcfHost_WindowsService : ServiceBase
    {
        ServiceHost sh;
        
        public void WcfHost_WindowsService()
        {
            InitializeComponent();
        }
        protected override void OnStart(string[] args)
        {
            sh = new ServiceHost(typeof(WcfService.Service), new Uri("http://localhost:8882/WcfHost_WindowsService/"));
            sh.AddServiceEndpoint(typeof(IService), new BasicHttpBinding(), "_point");                                      //添加终结点/_point，此处也可不写，默认为/
            ServiceMetadataBehavior behavior = new ServiceMetadataBehavior();
            behavior.HttpGetEnabled = true;
            sh.Description.Behaviors.Add(behavior);
            sh.Open();
        }
        protected override void OnStop()
        {
            sh.Close
        }
    }
}
（4）服务添加安装程序
其余步骤参见Windows Service部分。

3.调用远程宿主的WCF服务
新建项目->控制台应用->名称“InvokeWcf”（WinForm、WPF类型方法相同）
（1）“添加服务引用”
http://localhost:8881/WcfHost_Web/                  将服务引用的命名空间命名为MyWcfHost_Console_Reference
http://localhost:8732/WcfHost_Console/_point        将服务引用的命名空间命名为MyWcfHost_Web_Reference，如果没添加额外的终结点就是http://localhost:8882/WcfHost_Console/
此时app.config文件的内容变为
****************************************************************************************************************************************
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <system.serviceModel>
        <bindings>
            <basicHttpBinding>
                <binding name="BasicHttpBinding_IService" closeTimeout="00:01:00"
                    openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00"
                    allowCookies="false" bypassProxyOnLocal="false" hostNameComparisonMode="StrongWildcard"
                    maxBufferSize="65536" maxBufferPoolSize="524288" maxReceivedMessageSize="65536"
                    messageEncoding="Text" textEncoding="utf-8" transferMode="Buffered"
                    useDefaultWebProxy="true">
                    <readerQuotas maxDepth="32" maxStringContentLength="8192" maxArrayLength="16384"
                        maxBytesPerRead="4096" maxNameTableCharCount="16384" />
                    <security mode="None">
                        <transport clientCredentialType="None" proxyCredentialType="None"
                            realm="" />
                        <message clientCredentialType="UserName" algorithmSuite="Default" />
                    </security>
                </binding>
                <binding name="BasicHttpBinding_IService1" closeTimeout="00:01:00"
                    openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00"
                    allowCookies="false" bypassProxyOnLocal="false" hostNameComparisonMode="StrongWildcard"
                    maxBufferSize="65536" maxBufferPoolSize="524288" maxReceivedMessageSize="65536"
                    messageEncoding="Text" textEncoding="utf-8" transferMode="Buffered"
                    useDefaultWebProxy="true">
                    <readerQuotas maxDepth="32" maxStringContentLength="8192" maxArrayLength="16384"
                        maxBytesPerRead="4096" maxNameTableCharCount="16384" />
                    <security mode="None">
                        <transport clientCredentialType="None" proxyCredentialType="None"
                            realm="" />
                        <message clientCredentialType="UserName" algorithmSuite="Default" />
                    </security>
                </binding>
            </basicHttpBinding>
            <netTcpBinding>
                <binding name="TCPSession">
                    <reliableSession inactivityTimeout="00:25:00" />
                </binding>
            </netTcpBinding>
        </bindings>
        <client><!-- 客户端 -->
            <endpoint address="http://localhost:8882/WcfHost_Console/_point"
                binding="basicHttpBinding" bindingConfiguration="BasicHttpBinding_IService"
                contract="MyWcfHost_Console_Reference.IService" name="BasicHttpBinding_IService" />
            <endpoint address="http://localhost:8881/WcfHost_Web/Service.svc/basic"
                binding="basicHttpBinding" bindingConfiguration="BasicHttpBinding_IService1"
                contract="MyWcfHost_Web_Reference.IService" name="BasicHttpBinding_IService1" />
        </client>
    </system.serviceModel>
</configuration>
****************************************************************************************************************************************
·OpenTimeout
客户端与服务端建立连接时，如果超过指定时间都还没完成，就引发TimeoutException。
在TCP通讯中，服务器必须首先准备好侦听端口并在该端口上侦听(Listen)，而客户端则必须首先向服务器发出连接(Connect)指令，服务器端收到后作出接受响应(Accept)后连接成功，此后两者就可以互发消息了。
在WCF领域中，类似地，Open()表示建立一个Binding。
测试：拨网线。
·CloseTimeout
与OpenTimeout类似, CloseTimeout用于关闭一个连接时。
一般情况下，客户端比较随意，不会在意这个超时异常。“Close()是我发出的，我自己决定何时清理资源。”
在服务器就不同了，她必须对客户端负责，不能乱来，在收到Close()成功的响应之前，或收到超时异常之前，不能随意清理与客户端相关的资源。
·SendTimeout
客户端调用的超时，默认1分钟。每次调用都必须在指定时间内完成，否则将引发TimeoutException。
在TCP通讯中，双方建立连接后，客户端如果需要发送消息给服务端，就发送一个数据包给服务器，服务器收到后必须给出一个响应，客户端收到这个响应后才能宣告发送成功。类似地，服务器也可能主动发送消息给客户端。这两个动作，分别对于客户端和服务器来说，都是发送(Send)，而对于另一方来说都是接收(Receive)。
但是，在WCF领域中的SendTimeout中的Send与TCP的Send理念上类似，但是实质上完全不是一回事。SendTimeout中的Send是指客户端发起调用。
在WCF客户端，用proxy.InnerChannel.OperationTimeout可以取到SendTimeout的值。（此处，proxy 是自动生成的服务代理类XxxClient的一个实例）
测试：在服务器的调用处理代码中插入MessageBox.Show(...)或Thread.Sleep(...)。
·ReceiveTimeout
与SendTimeout同理, ReceiveTimeout中的Receive是指服务器端发起回调(Callback)。只有在双向通讯绑定时适用，如WSDualHttpBinding, NetTcpBinding, NetNamedPipeBinding, ...
ReceiveTimeout是服务器回调(Callback)的超时，默认10分钟。每次回调都必须在指定时间内完成，否则将在服务器端引发TimeoutException。
测试：在客户端的回调处理代码中插入MessageBox.Show(...)或Thread.Sleep(...)。 

个人理解：SendTimeout是指客户端发送数据(请求)wcf服务，wcf服务响应（wcf发送回来数据），这两个加起来的总时间。
ReceiveTimeout跟回调有关，并不是指wcf服务响应（wcf发送回来数据）的时间。

（2）“添加引用”，System.ServiceModel
（3）调用运程宿主上的WCF服务
★简单方式
    class Program
    {
        static void Main(string[] args)
        {
            //1、调用网站Wcf宿主
            try
            {
                using (MyWcfHost_Web_Reference.ServiceClient client_web = new MyWcfHost_Web_Reference.ServiceClient())
                {
                    Console.WriteLine("调用网站Wcf宿主成功，“11+22=" + client_web.Add(11, 22) + "”");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("调用网站Wcf宿主失败");
            }
            //2、调用控制台Wcf宿主
            try
            {
                using (MyWcfHost_Console_Reference.ServiceClient client_console = new MyWcfHost_Console_Reference.ServiceClient())
                {
                    Console.WriteLine("调用控制台Wcf宿主成功，“11+22=" + client_console.Add(11, 22) + "”");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("调用控制台Wcf宿主失败");
            }
            //3、调用Windows服务Wcf宿主
            try
            {
                using (MyWcfHost_WindowsService_Reference.ServiceClient client_web = new MyWcfHost_WindowsService_Reference.ServiceClient())
                {
                    Console.WriteLine("调用Windows服务Wcf宿主成功，“11+22=" + client_web.add(11, 22) + "”");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("调用Windows服务Wcf宿主失败");
            }
            Console.Read();
        }
    }

★通道方式
    EndpointAddress address = new EndpointAddress("http://localhost:8732/WcfHost_Console/_point");
    BasicHttpBinding binding = new BasicHttpBinding();
    using (ChannelFactory<MyWcfHost_Console_Reference.IService> factory = new ChannelFactory<MyWcfHost_Console_Reference.IService>(binding, address))
    {
        MyWcfHost_Console_Reference.IService channel = factory.CreateChannel();
        Console.WriteLine( channel.add(33, 44) );
    }
IClientChannel clientChannel = channel as IClientChannel;
IServiceChannel serviceChannel = channel as IServiceChannel;
IContextChannel contextchanel = channel as IContextChannel;

clientChannel.OperationTimeout = new TimeSpan(0, 10, 0);        //延时设为10分钟

★继承方式
    class Program
    {
        static void Main(string[] args)
        {
            using (Client client = new Client())
            {
                Console.WriteLine( client.add(33, 44) );
            }
        }
    }
    
    class Client : ClientBase<MyWcfHost_Console_Reference.IService>, MyWcfHost_Console_Reference.IService
    {
        Client() : base(new WSHttpBinding(), new EndpointAddress(new Uri("http://localhost:8882/WcfHost_Console/"))) 
        {
        }
        
        public int add(int i, int j)
        {
            return base.Channel.add(i+j);
        }

    }



G、wcf service生成asp.net webservice
****************************************************************************************************************************************
使用wsdl工具将wcf service生成asp.net webservice方式。
start --->运行--->cmd --->cd C:/Program Files (x86)/Microsoft SDKs/Windows/v6.0A/bin  回车。
输入wsdl 服务地址。例（wsdl http://localhost:8571/Service1.svc ）便生成相应的类似asp.net webservice代理类的文件。文件地址亦在上面bin中。
新建Console application (net Framework 2.0)，添加刚刚生成的代理类，调用。
****************************************************************************************************************************************
Service 服务
已创建服务。
若要测试此服务，需要创建一个客户端，并将其用于调用该服务。可以使用下列语法，从命令行中使用 svcutil.exe 工具来进行此操作:
svcutil.exe http://localhost:8881/WcfHost_Web/Service.svc?wsdl
这将生成一个配置文件和一个包含客户端类的代码文件。请将这两个文件添加到客户端应用程序，并使用生成的客户端类来调用服务
****************************************************************************************************************************************



H、REST（Representational State Transfer）风格
之前说明的都是SOAP架构风格的WCF，下面说一下REST风格的WCF。
1.绑定协议与行为（webHttpBinding 与webHttpBehavior）
众所周知，WCF中支持的协议有很多，如wsHttpBinding等ws-*系列的、netTcpBinding、支持MSMQ的系列协议等。在构建REST架构风格的WCF中
我们使用的协议为webHttpBinding 。与之相对应的行为则是webHttpBehavior。

2.Action中的各个动词决定了对资源进行何种操作。
POST：对客户端知晓的资源进行添加。它是WebInvokeAttribute默认的操作动作
GET：对资源进行获取。它是WebGetAttribute默认的操作动作
DELETE：对资源进行删除。一般由WebInvokeAttribute指定
PUT：对资源进行修改，也可用于添加。一般由WebInvokeAttribute指定

3.
（1）服务端
●Model（Product.cs）
namespace RESTService
{
    [DataContract]
    public class Product
    {
        [DataMember]
        public Guid Id { get; set; }

        [DataMember]
        public String Name { get; set; }
    }
}

●REST Service接口（IProductService.cs）
namespace RESTService
{
[ServiceContract]
        
    /// <summary>
    /// 演示REST(Representational State Transfer)的接口
    /// </summary>
    /// <remarks>
    /// HTTP方法中：
    /// POST相当于Create，非幂等
    /// GET相当于Read
    /// PUT相当于Update
    /// DELETE相当于Delete
    
    public interface IProductService
    {
        /// WebInvoke - 指示服务操作在逻辑上就是调用操作，而且可由 Web 编程模型调用
        /// UriTemplate - 用于服务操作的统一资源标识符 (URI) 模板。URI模板可以将一个 URI 或一组 URI 映射到服务操作。有关 URI 模板的更多信息，请参见 UriTemplate 和 UriTemplateTable
        /// Method - 与操作关联的协议方法，默认为 POST
        /// ResponseFormat - 指定从服务操作发出的响应的格式。Xml 或 Json
        [OperationContract]
        [WebGet(UriTemplate="Product")]
        List<Product> GetProducts();

        [OperationContract]
        [WebInvoke(UriTemplate="Product", Method="POST", WebMessageFormat.Json)]                //如果UriTemplate = "User/{name}/{dayOfbirth}",
        bool CreateProduct(Product product);                                                    //那么User CreateUser(string name, string dayOfbirth);

        [OperationContract]
        [WebInvoke(UriTemplate = "Product", Method = "PUT")]
        bool UpdateProduct(Product product);

        [OperationContract]
        [WebInvoke(UriTemplate = "Product", Method = "DELETE")]
        bool DeleteProduct(Product product);
    }
}
上面的契约大致表示
POST-----CreateProduct
GET------GetProducts
PUT------UpdateProduct
DELETE---DeleteProduct。

UriTemplate就是Uri模版的意思，如果web地址为http://www.rest.com，那么rest服务的地址就是http://www.rest.com/Product。

●REST Service的svc（ProductService.svc）
<%@ ServiceHost Language="C#" Debug="true" Service="RESTService.ProductService" CodeBehind="ProductService.svc.cs" %>

●接口实现（ProductService.svc.cs，也可以不使用ProductService.svc.cs，去单独写一个ProductService.cs）
namespace RESTService
{
    // 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码、svc 和配置文件中的类名“Service1”。
    // 注意: 为了启动 WCF 测试客户端以测试此服务，请在解决方案资源管理器中选择 Service1.svc 或 Service1.svc.cs，然后开始调试。
    public class ProductService : IProductService
    {
        public List<Product> GetProducts()
        {
            return new List<Product>()
                {
                    new Product(){ Id = Guid.NewGuid(), Name = "TEST_GET_1" },
                    new Product(){ Id = Guid.NewGuid(), Name = "TEST_GET_2" },
                    new Product(){ Id = Guid.NewGuid(), Name = "TEST_GET_3" },
                };
        }

        public string CreateProduct(Product product)
        {
            string str = "Operation is PUT (Create):";
            string strA = "Id is " + product.Id + ",";
            string strB = "Name is " + product.Name;
            return str + strA + strB;
        }

        public string UpdateProduct(Product product)
        {
            string str = "Operation is POST (Update):";
            string strA = "Id is " + product.Id + ",";
            string strB = "Name is " + product.Name;
            return str + strA + strB;
        }

        public string DeleteProduct(Product product)
        {
            string str = "Operation is DELETE (Delete):";
            string strA = "Id is " + product.Id + ",";
            string strB = "Name is " + product.Name;
            return str + strA + strB;
        }
    }
}

●配置文件
<system.serviceModel>
    <services>
      <service name="RestWCF.ProductService">
        <endpoint address="" behaviorConfiguration="RestBehavior" binding="webHttpBinding"
          bindingConfiguration="" contract="RestWCF.IProductService" />
      </service>
    </services>
    <behaviors>
      <endpointBehaviors>
        <behavior name="RestBehavior">
          <webHttp helpEnabled="true" defaultBodyStyle="Bare" defaultOutgoingResponseFormat="Json" automaticFormatSelectionEnabled="true" />
        </behavior>
      </endpointBehaviors>
      <serviceBehaviors>
        <behavior name="">
          <serviceMetadata httpGetEnabled="true" />
          <serviceDebug includeExceptionDetailInFaults="false" />
        </behavior>
      </serviceBehaviors>
    </behaviors>
    <serviceHostingEnvironment multipleSiteBindingsEnabled="true" />
  </system.serviceModel>
在这里因为要配置Rest服务，所以我们添加webHttp Behavior，并且启用helpEnabled，在这里我们设置defaultBodyStyle="Bare"代表不包装。
defaultOutgoingResonseFormat="Json"，则代表默认输出的格式是json，如果不设置的话，默认是xml。
automaticFormatSelectionEnabled="true"，利用传入消息的AcceptHeader，自动从JSON和XML中选择一种格式。

●可以在浏览器中浏览http://localhost:58516/ProductService.svc/Product/help，因为我们启用了HelpEnabled

（2）客户端
•GET调用
private void Get_Click(object sender, RoutedEventArgs e)
{
    WebClient webClient = new WebClient();
    webClient.DownloadStringCompleted += (o, ea) =>
        {
            MessageBox.Show(ea.Result);
        };
    webClient.DownloadStringAsync(new Uri("http://localhost:58516/ProductService.svc/Product "));
}

•PUT调用
private void Post_Click(object sender, RoutedEventArgs e)
{
    WebRequest webRequest = WebRequestCreator.ClientHttp.Create(new Uri("http://localhost:58516/ProductService.svc/Product"));
    //webRequest.Headers[HttpRequestHeader.ContentType] = "application/json";
    webRequest.ContentType = "application/json";
    webRequest.Method = "PUT";
    webRequest.BeginGetRequestStream(requestAsyncCallback =>
    {
        JsonObject jo = new JsonObject();
        jo["Id"] = Guid.NewGuid().ToString();
        jo["Name"] = "TEST_PUT";
        string jsonString = jo.ToString();
        byte[] buffer = System.Text.Encoding.Unicode.GetBytes(jsonString);
        
        Stream requestStream = webRequest.EndGetRequestStream(requestAsyncCallback);
        requestStream.Write(buffer, 0, buffer.Length);
        requestStream.Close();

        webRequest.BeginGetResponse(responseAsyncCallback =>
        {
            WebResponse webResponse = webRequest.EndGetResponse(responseAsyncCallback);
            using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
            {
                string result = reader.ReadToEnd();
                //MessageBox.Show(result);
                this.Dispatcher.BeginInvoke(() =>
                {
                    MessageBox.Show(result);
                });
            }
        }, null);
    }, null);
}

•POST调用
private void POST_Click(object sender, RoutedEventArgs e)
{
    WebRequest webRequest = WebRequestCreator.ClientHttp.Create(new Uri("http://localhost:58516/ProductService.svc/Product"));
    //webRequest.Headers[HttpRequestHeader.ContentType] = "application/json";
    webRequest.ContentType = "application/json";
    webRequest.Method = "POST";
    webRequest.BeginGetRequestStream(requestAsyncCallback =>
    {
        JsonObject jo = new JsonObject();
        jo["Id"] = Guid.NewGuid().ToString();
        jo["Name"] = "TEST_POST";
        string jsonString = jo.ToString();
        byte[] buffer = System.Text.Encoding.Unicode.GetBytes(jsonString);

        Stream requestStream = webRequest.EndGetRequestStream(requestAsyncCallback);
        requestStream.Write(buffer, 0, buffer.Length);
        requestStream.Close();

        webRequest.BeginGetResponse(responseAsyncCallback =>
        {
            WebResponse webResponse = webRequest.EndGetResponse(responseAsyncCallback);
            using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
            {
                string result = reader.ReadToEnd();
                //MessageBox.Show(result);
                this.Dispatcher.BeginInvoke(() =>
                {
                    MessageBox.Show(result);
                });
            }
        }, null);
    }, null);
}

•DELETE调用
private void DELETE_Click(object sender, RoutedEventArgs e)
{
    WebRequest webRequest = WebRequestCreator.ClientHttp.Create(new Uri("http://localhost:58516/ProductService.svc/Product"));
    //webRequest.Headers[HttpRequestHeader.ContentType] = "application/json";
    webRequest.ContentType = "application/json";
    webRequest.Method = "DELETE";
    webRequest.BeginGetRequestStream(requestAsyncCallback =>
    {
        JsonObject jo = new JsonObject();
        jo["Id"] = Guid.NewGuid().ToString();
        jo["Name"] = "TEST_DELETE";
        string jsonString = jo.ToString();
        byte[] buffer = System.Text.Encoding.Unicode.GetBytes(jsonString);

        Stream requestStream = webRequest.EndGetRequestStream(requestAsyncCallback);
        requestStream.Write(buffer, 0, buffer.Length);
        requestStream.Close();

        webRequest.BeginGetResponse(responseAsyncCallback =>
        {
            WebResponse webResponse = webRequest.EndGetResponse(responseAsyncCallback);
            using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
            {
                string result = reader.ReadToEnd();
                //MessageBox.Show(result);
                this.Dispatcher.BeginInvoke(() =>
                {
                    MessageBox.Show(result);
                });
            }
        }, null);
    }, null);
}

在客户端，
    System.ServiceModel.Web.WebOperationContext.Current.OutgoingResponse.SetStatusAsNotFound();
    System.ServiceModel.Web.WebOperationContext.Current.OutgoingResponse.StatusCode = System.Net.HttpStatusCode.NotFound;



I、以JSON格式进行序列化
1.定义序列化方式
using System.ServiceModel.Channels;

namespace Microsoft.Ajax.Samples
{
    /// <summary>
    /// JsonContentTypeMapper
    /// 用在配置中<webMessageEncoding webContentTypeMapperType="Microsoft.Ajax.Samples.JsonContentTypeMapper, JsonContentTypeMapper, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
    /// </summary>
    public class JsonContentTypeMapper : WebContentTypeMapper
    {
        public override WebContentFormat GetMessageFormatForContentType(string contentType)
        {
            if (contentType == "text/javascript")
            {
                return WebContentFormat.Json;
            }
            else
            {
                return WebContentFormat.Default;
            }
        }
    }
}

2.在配置中调取该方式
    <binding name="JsonMapper">
      <!--此处配置相当重要，使用了我们编写的JsonContentTypeMapper类，约定返回值类型是Json-->
      <webMessageEncoding webContentTypeMapperType="Microsoft.Ajax.Samples.JsonContentTypeMapper, JsonContentTypeMapper, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
      </webMessageEncoding>
      <httpTransport manualAddressing="true"/>
    </binding>

3.在需要使用序列化的位置添加标注
    [OperationContract]
    [WebInvoke(ResponseFormat=WebMessageFormat.Json)]
    public Person GetPerson(string name)
    {}

    [OperationContract]
    [WebInvoke(RequestFormat = WebMessageFormat.Json)]
    public bool CreatePerson(Person p)
    {}



J、Silverlight中的WCF
1.取得返回值
在Silverlight中，调用WCF的方法是异步的，没有直接返回值，无法通过传统形式取得返回值，其只能通过回调的形式来取得返回值：

public MainPage()
{
    InitializeComponent();
    ServiceClient client = new ServiceClient();
    client.addAsync(11, 22);
    client.addCompleted += new EventHandler<addCompletedEventArgs>(client_addCompleted);
    //或client.addCompleted += client_addCompleted;

}

void client_addCompleted(object sender, addCompletedEventArgs e)
{
    MessageBox.Show(e.Result.ToString());
}

2.跨域访问
一句话：同一个IP、同一个网络协议、同一个端口，三者都满足就是同一个域。
否则就是跨域访问了。
Silverlight默认不允许跨域访问wcf，若需要跨域，则必须配置跨域策略，Silverlight跨域策略文件名clientaccesspolicy.xml，不论是控制台、svc、还是服务的形式，策略文件必须放在WCF宿主的根目录下。
clientaccesspolicy.xml
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
<?xml version="1.0" encoding="utf-8" ?>
<access-policy>
<cross-domain-access>
<policy>
<allow-from http-request-headers="*">
<domain uri="*"/>
<!--<domain uri="http://www.baidu.com"/>-->
</allow-from>
<grant-to>
<resource path="/" include-subpaths="true"/>
</grant-to>
</policy>
</cross-domain-access>
</access-policy>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

crossdomain.xml
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
<?xml version="1.0" ?>
<cross-domain-policy>
  <allow-access-from domain="*" />
</cross-domain-policy>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

K、异常
在服务端直接抛出Exception，客户端不能正常解析出Exception的Message内容。所以要在服务端使用SoapException
throw new System.Web.Services.Protocols.SoapException(string.Format("请求驳回：重复提交'服务费请求'{0}", flagValue), System.Web.Services.Protocols.SoapException.ServerFaultCode);


L、HttpListener
1.概述
HttpListener:使用HttpListener可创建响应 HTTP 请求的简单 HTTP 协议侦听器。实际上HttpListener只是实现了服务器端Socket上面的一个简单封装类。通过设置Prefixes属性来进行侦听，如侦听器绑定到http或https端点的URL(如下代码).侦听器默认是绑定到运行在http的80端口和https的443的端口，并允许匿名和无身份验证的客户端访问。可以使用HttpListener类的属性Prefixes来制定自定义url和端口，并通过设置属性AuthenticationSchemes属性来配置身份验证。

2.步骤（同步）
using (HttpListener listerner = new HttpListener())
{
    listerner.AuthenticationSchemes = AuthenticationSchemes.Anonymous;          //指定身份验证 Anonymous匿名访问
    listerner.Prefixes.Add("http://localhost:8080/web/");                       //添加监听地址，可以是http或https，可以添加端口
    listerner.Start();
    while(true)
    {
        //等待请求连接，没有请求则GetContext处于阻塞状态
        HttpListenerContext context = listerner.GetContext();
        context.Response.StatusCode = 200;                                      //设置返回给客服端http状态代码
        string name = context.Request.QueryString["name"];
        
        using (StreamWriter writer = new StreamWriter(context.Response.OutputStream))
        {
            writer.Write(name);
        }
    }
}


AuthenticationSchemes枚举类有以下值
Anonymous：默认值，允许任意的客户机进行连接，不需要身份验证。
Basic：要求提供纯文本（64位编码）用户名和密码来进行验证。
Digest：类似与基本身份验证，但是用户名和密码使用一个简单密码散列进行传输。
Ntlm：指定 NTLM 身份验证(只有IE支持)。
IntegratedWindowsAuthentication：指定Windows身份验证。
Negotiate：和客户端协商以确定身份验证方案。如果客户端和服务器均支持 Kerberos，则使用 Kerberos；否则使用 Ntlm
None：不进行身份验证。

M、拦截器
[ServiceContract]
public interface IIntercept
{
    [OperationContract(Action = "*", ReplyAction = "*")]
    Message Intercept(Message request);
}




二十一、Log4Net
A.Log4net核心组成 
Log4net主要由四个部分组成，分别是Logger（记录器）, Repository（库）, Appender（附着器）以及 Layout（布局）。 
  Appender决定日志输出的方式appender标签有两个重要的子节点fillter和layout。 
  Fiter负责过滤你想要得到的日志界别或包含特出的字符串。 
  Layout负责日志输出的样式。 

B.配置过程
配置文件->调用配置文件->生成对象->生成日志
1.配置文件
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <configSections>         <!--  必须放在第一位  -->
    <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
  </configSections>
  <!--站点日志配置部分-->
  <log4net>
    <appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender">
      <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%date [%thread] %-5level %logger %ndc - %message%newline" />
      </layout>
    </appender>
    
    <!-- 节点配置有两种形式，节点大小写不敏感  -->
    <!-- 形式一 <param name="File" value="logs/" />  -->
    <!-- 形式二 <File value="logs/" />  -->
    <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender, log4net">
      <!--日志文件名开头-->
      <file value="logs/prefix_" />
      <!--输出日志文件的编码格式-->
      <encoding value="Shift_JIS" />
      <!--多线程时采用最小锁定-->
      <lockingModel type="log4net.Appender.FileAppender+MinimalLock" />
      <!--日期的格式，每天换一个文件记录，如不设置则永远只记录一天的日志，需设置-->
      <datePattern value="yyyyMMdd_HHmmss.'log'" />
      <!--是否追加到文件,默认为true，通常无需设置-->
      <appendToFile value="true"/>
      <!--变换的形式为日期，这种情况下每天只有一个日志-->
      <!--此时MaxSizeRollBackups和maximumFileSize的节点设置没有意义-->
      <!--<rollingStyle value="Date"/>-->
      <!--变换的形式为日志大小-->
      <!--这种情况下MaxSizeRollBackups和maximumFileSize的节点设置才有意义-->
      <RollingStyle value="Size"/>
      <!--每天记录的日志文件个数，与maximumFileSize配合使用-->
      <MaxSizeRollBackups value="10"/>
      <!--每个日志文件的最大大小-->
      <!--可用的单位:KB|MB|GB-->
      <!--不要使用小数,否则会一直写入当前日志-->
      <maximumFileSize value="2MB"/>
      <!--置为true，当前最新日志文件名永远为file节中的名字-->  
      <param name="StaticLogFileName" value="false" />
      <!--日志格式-->
      <layout type="log4net.Layout.PatternLayout">
      <!--
          其中layout节点的配置说明：
          %m(message):输出的日志消息；
          %M(Method):输出方法名；（尽量避免使用，除非执行速度不造成任何问题。）
          %n(newline):换行；
          %d(datetime):输出当前语句运行的时刻；
          %r(runtime):输出程序从运行到执行到当前语句时消耗的毫秒数；
          %t(threadid):当前语句所在的线程ID；
          %p(priority): 日志的当前日志级别；
          %c(class):当前日志对象的名称；
          %L(Line)：输出语句所在的行号；
          %F(File)：输出语句所在的文件名；
          %-10：表示最小长度为10，如果不够，则用空格填充；
          %replace(p ){r, t}:p 为日志内容，r 是正则表达式，将p 中符合r 的内容替换为t。例如， "%replace(%msg){'\s', ''}"；
      -->
        <conversionPattern value="%d [%t] %-5p %c - %m%n" />
      </layout>
    </appender>
    <root>
      <!--控制级别，由低到高: ALL < DEBUG < INFO < WARN < ERROR < FATAL < OFF-->
      <!--比如定义级别为INFO，则INFO级别向下的级别，比如DEBUG日志将不会被记录-->
      <!--如果没有定义LEVEL的值，则缺省为DEBUG-->
      <level value="ERROR" />
      <appender-ref ref="ConsoleAppender" />
      <appender-ref ref="RollingFileAppender" />
    </root>
    <logger name="Spring">
      <level value="Error" />
      <appender-ref ref="RollingFileAppender" />
    </logger>

  </log4net>
</configuration>


2.
在项目中的AssemblyInfo.cs文件的最后一行中添加：
[assembly: log4net.Config.DOMConfigurator(ConfigFile = "xxx.config", Watch = true)]
如：[assembly: log4net.Config.DOMConfigurator(ConfigFile = "Web.config", Watch = true)]
如：[assembly: log4net.Config.DOMConfigurator(ConfigFile = "log4net.config", Watch = true)]
如：[assembly: log4net.Config.XmlConfigurator(ConfigFile = "configs\\FrameworkConfig\\Log4Net.config", Watch = true)]
要注意的是：Config.DOMConfigurator.Configure已经被标注为“废弃的(obsolete)"。log4net官网文档推荐用Config.XmlConfigurator代替Config.DOMConfigurator

class Program
{
    public static ILog log = LogManager.GetLogger(typeof(Program));
    public static ILog logSpringStr = LogManager.GetLogger("Spring");
    public static ILog logSpringType = LogManager.GetLogger(typeof(Program));
    static void Main(string[] args)
    {
        log.Error("root node");                 //root生效，name="Spring"的logger不生效
        logSpringStr.Error("spring node");      //root生效，name="Spring"的logger生效
        logSpringType.Error("spring node");     //root生效，name="Spring"的logger不生效
        log.Info("info info");
        log.Warn("Warn info");
        log.ErrorFormat("Error {0}","info");
        log.Fatal("fatal info");
    }
}


3.注意事项
·项目的目标框架为.NET Framework 3.5(或者4) Client Profile时会报出下图错误，改成.NET Framework 3.5(或者4) 即可；
·当configSections节点要放在configuration节点下的第一位，这是app.config文件的语法规定；
·对于大量记日志的程序，需注意配置RollingStyle值为Composite，且设置MaxSizeRollBackups（每天记录的日志文件个数）和maximumFileSize（每个日志文件的最大大小）。我以前遇过一次日志过大的问题，有一次版本临时发布就改了一个方法而没有经过测试，造成每天记几十G日志的，几天就把服务器磁盘弄满了。
·当发现不记日志时，可从两方面调查问题，一是log4net有没有初始化，也就是XmlConfigurator.Configure()；二是看level节点的配置是不是正确；
·当发现一些设置参数没有起作用时，请检查是不是同一个节点被设置过多次，当被重复设置时，log4net会选择最后一个作为实际的设置。例如设置记录日志的级别设置两次如<level value="ERROR"/><level value="All"/>，则最终会以ALL作为记录日志的级别。
·使用Common Logging时，不需要加[assembly: log4net.Config.DOMConfigurator(ConfigFile = "xxx.config", Watch = true)]，且不需要配configSections。



二十、HTML页面操作与配置
A、HTML基本知识
（1）innerHtml、innerText、outerHtml、outerText的区别
string aa = Ele.innerHtml;
"<OPTION value=\"\">请选择</OPTION><OPTION value=0, 河西>河西</OPTION><OPTION value=1, 河东>河东</OPTION>"
string bb = Ele.innerText;
"请选择河西河东"
string cc = Ele.outerHtml;
"<SELECT id=id><OPTION value=\"\">请选择</OPTION><OPTION value=0, 河西>河西</OPTION><OPTION value=1, 河东>河东</OPTION></SELECT>"
string dd = Ele.outerText;
"请选择河西河东海棠湾田独凤凰崖城天涯育才"

（2）转义符
要在"<>"内显示"<"、">"，要用"&lt;"和、"&gt;"：
&lt; (即less than, 小于), 为"<"
&gt; (即greater than, 大于), 为">"
&nbsp;空格
<br/> 回车
<hr/> 直线

（3）tabindex
tabindex 属性 -- 代表使用"Tab"键的遍历顺序 
可以使用Tab键遍历页面中的所有链接与表单元素，当遍历到某个链接时，按Enter即可。遍历时会按照tabindex的大小决定顺序 
遍历到某个链接的时候，会有虚线框包围链接，这时按回车键即可进入链接的页面。 
取值: 
数字，范围为[1~32767] 
<a href="http://www.dreamdu.com/xhtml/" tabindex="1">1</a>
<a href="http://www.dreamdu.com/css/" tabindex="3">3</a>
<a href="http://www.dreamdu.com/xhtml/tag_a/ " tabindex="2">2</a>
<!--连续按 "Tab"，可以改变焦点的位置.遍历的顺序是1-2-3.-->

（4）链接
<a href=url target=_blank> 新窗口
<a href=url target=_self> 本窗口
<a href=url target=_parent> 父窗口
<a href=url target=_top> 整个浏览器窗口
<a href="#foot">   <a name="foot">这里是FOOT部分</a>  <!-- 锚点 -->

（5）直线
<hr></hr>

B、各类控件
0、服务器端控件
客户端控件<input id="myid" name="myname">转为
服务器端控件<input runat="server" id="myid" name="myname">后
name的值会自动修改为id的值，即以上内容解析到客户端会变为
<input runat="server" id="myid" name="myid">

1、checkbox
<html>
<head><title>选择</title></head>
<body>
请选择你喜欢的水果：<br>
<form action = "http://www.admin5.com/html/asdocs/html_tutorials/choose.asp" method = "post">
<input type="checkbox" name="fruit" value ="apple" >苹果<br>
<input type="checkbox" name="fruit" value ="orange" checked>桔子<br>
<input type="checkbox" name="fruit" value ="mango">芒果<br>
<input type="submit" value="提交">
</form>
</body>
</html>



TEXTAREA自适应文字行数的多少
<textarea rows=1 name=s1 cols=27 onpropertychange="this.style.posHeight=this.scrollHeight">
</textarea>


    <div style="background-image: url(Image/newpic/bg_CCHP2-2.png); width: 100%; height: 100%;
        background-repeat: no-repeat; position: absolute; left: 0px; top: 0px;">



2、input文本框
只读
<input type="text" readonly="readonly" id="logofilename" runat="server" style=" margin-left:-6px; width:200px;" onkeydown="return false;" />




3、FileUpload及Label
（1）前台aspx：
<asp:FileUpload runat="server" ID="logoUP" class="file" onchange="jQuery('#logofilename').val(this.value);" />
    <span>
        <input type="text" readonly="readonly" id="logofilename" runat="server" />
        <label id="logoLab3" for="logoUP"  class="whiteBtn1" runat="server"></label>
    </span>
（2）样式css：
input.file
{
    vertical-align:middle;
    position:relative;
    left: 0px;
    filter: alpha(opacity=0);    //透明度IE
    opacity: 0;                  //透明度W3C
    z-index: 1; 
    width:0px; 
    height:20px;
    outline:none;
 }


4、<%%>的解析
（1）<%= %>
里面放变量名（有返回值的函数也可以），如：
<div>
    <h1>Hello World</h1>
    <p>Welcome to Beginning ASP.NET 3.5 on <%= DateTime.Now.ToString() %></p>
</div>
输出结果为：
Hello World
Welcome to Beginning ASP.NET 3.5 on 2009-11-10 15:53:08
※后台方法声明须为public或者protected，然后前台才能使用js脚本进行调用。
（2）<%# %> 数据的绑定
一般在asp:repeater、datalist等asp容器内使用，通过如repeater.datasource=DataSet;repeater.DataBind();绑定容器和数据源。
只有执行了相应控件的DataBind方法，前台代码中这些控件中使用<%# %>的绑定才会发生（并且控件内部的所有绑定也会发生，比如又嵌套了一个绑定后台数据的控件），否则得话将不会被赋值，而是默认空值。可以用Page的DataBind方法，那么整个页面所有绑定都会执行。当然，如果我们只执行DataList1或者DropDownList1的DataBind方法，那么只有相应控件的绑定才会发生。需要注意的是，这里说的需要执行DataBind包括了显示和隐式执行，有些数据绑定类控件，当它们通过 DataSourceID 属性绑定到数据源控件时，会通过隐式调用 DataBind 方法来执行绑定。这时就不必显示的再次调用了，如：
后台
Page.DataBind();//全部绑定
repeat1.DataBind();//只绑定要使用该数据的控件
lable1.DataBind();//只绑定要使用该数据的控件
前台：
<%# DataBinder.Eval(Container.DataItem, "room_type", {0:c})%>;
<%# Eval("alarm_list")%>
<%# DataBinder.Eval(Container.DataItem, "ClassName") %> 
完整代码：
      <asp:DataList ID="ClassList" runat="server">
          <ItemTemplate>
              <%# DataBinder.Eval(Container.DataItem, "ClassName") %>
          </ItemTemplate>
      </asp:DataList></td>
（3）<%@ %>
里面放要引用的内容，如：
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="Default.aspx.cs" Inherits="_Default" %>
<%@ page import="mytrain.formbean.userBean" %>
（4）<%: %>
这种方式是ASP.NET4.0中新加入的绑定方式，常用于MVC中，但普通webform中也可使用。他的功能其实就是对绑定的值进行一下编码，因此，一下两者是等同的：
 <%= Server.HtmlEncode("<b>test</b>") %>
 <%: "<b>test</b>" %>;
（5）<% %>
里面放函数，如：
<tr bgcolor="#ffffff">
   <td height="20">
      <div align="center">类别：</div>
   </td>
   <td height="9">&nbsp;
      <%ST_getList();%> 
   </td>
</tr>
（6）<%= %>和<%# %>的区别
两者区别：
    两种绑定方式上，他们的约束基本相同，都要求与属性匹配，出现在他们可以出现的位置。后者的使用位置更广泛，尤其是支持服务器端控件和绑定数据集合。后台代码方面，后者需要调用DataBind才能完成绑定，前者则没有这方面要求。这里主要区别一下两者在执行机制上的区别：<%=...%>是在程序执行时调用（应该是在页面的RenderControl事件过程中完成的，也就是通常情况下我们可以看到的后台代码都执行完毕后再去到前台代码中进行赋值绑定），而<%#... %>是在DataBind()方法之后被调用，一旦调用了DataBind()，则它对应的控件将绑定变量，因此，请注意：如果在DataBind()后再修改变量，那么绑定的就不是最新值了，这就需要在完成变量的赋值后，再去DataBind()。其实这两种方式，它的运行过程可以在VS中通过设置断点来看看，看两者的绑定赋值分别是在什么时候发生的。




C、html页面配置

enctype="multipart/form-data"
enctype="application/x-www-form-urlencoded

asp.net取消页面缓存几种方法
1. 客户端取消

<html>
<head>
<meta http-equiv=”Expires” CONTENT=”0″>
<meta http-equiv=”Cache-Control” CONTENT=”no-cache”>
<meta http-equiv=”Pragma” CONTENT=”no-cache”>
</head>

2. 服务器端取消：

服务器端：
Response.Buffer = true;
Response.ExpiresAbsolute = DateTime.Now.AddDays(-1);
Response.Cache.SetExpires(DateTime.Now.AddDays(-1));
Response.Expires = 0;
Response.CacheControl = "no-cache";
Response.Cache.SetNoStore();

3. Global里面：
protected   void   Application_BeginRequest(Object sender, EventArgs e)
{
HttpContext.Current.Response.Cache.SetNoStore();
}
<%@ OutPutCache Location=”None”%>

4. 页面基类：
public class PageBase: Page
{
  public PageBase() {}
  protected override OnLoad(EventArgs e) {
    Response.Cache.SetNoStore();
    base.OnLoad();
  }
}

5. 有效的办法，通过在URL上添加随机数方式，
例如：
http://www.uoian.cn/default.asp?t=xxx
因为IE是用过URL来控制缓存的
 







微软提供了几种解决方法，一个是设置服务器返回页面的头强制客户端基于IE7标准，而另外一个方法是基于页面的，只要在<head>标签内使用meta标记：<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7" />即可以，测试通过，一切正常。
















二十一、Html元素与CSS样式

<html>
<head>
<script type="text/javascript">
....
</script>
</head>


A、样式导入
（1）导入
@import url(1.css);
（2）链接
<link href="1.css" type="text/css" rel="stylesheet">

a:link {color: #FF0000}     /* 未访问的链接 */
a:visited {color: #00FF00}  /* 已访问的链接 */
a:hover {color: #FF00FF}    /* 当有鼠标悬停在链接上 */
a:active {color: #0000FF}   /* 被选择的链接 */
（2.5）
    采用@import导入样式文件，网上通俗的说法就是造成无法同时下载不同的样式文件（如果这个主题有多个样式文件），会增加页面总体加载时间，网络状况不好的情况下，刚开始的几秒中会很混乱，所以建议将采用这种模式导入的样式文件的主题，如果不是很复杂的，可以将样式文件合并到style.css中，可能会对博客的打开的速度有所帮助。
（3）预定义
1）标签选择器
body 
{
    width:1280px;
    height:728px;
    background-image:url(../Image/newpic/bg_CCHP1.png);
    background-repeat:no-repeat;
}
 <body>标签选择器</body>
2）类别选择器
.first{}
 <p class="first">类别选择器</p>
3）ID选择器
one{}
 <p ID="one">ID选择器</p>
4）属性选择器
a[little]{}
 <a title="css1">属性选择器</p>




B、概念
（1）标签
标签是分成 区块（block） 和 内联块（inline）2种
一个标签显示一行的称为 区块，如（段落P，标题H系列，DIV等）
（你没见过在2个P标签放在一行能显示的情况吧）？
若标签能在一行显示N个，表明此标签为 内联块，如（<a>, <img>, <input>）

区块和内联块最大的区别就是，区块可以设置宽、高、居中对齐等操作，而内联块不行
也就是说，当你需要将一张图片居中，或者要设置区域大小，或单独一行显示，就用到你说的这个样式
反之，你若想把区块变为内联块，则将display:none就可以了
PS：区分区块还是内联块其实很简单，你可以把这个标签加一个背景颜色，若能占一行，则为区块，反之则是内联块








C、style
1、布局
margin（间隔、元素框外部）：margin-top、margin-bottom、margin-left、margin-right
padding（间隙、元素框内部）：padding-top、padding-bottom、padding-left、padding-right
border-style：none、dotted、dashed、solid、double、groove、ridge、inset、outset
border-width：medium、thick、thin、width
border-color：
border（元素框）：all-up
position：absolute、relative、fixed
overflow（溢出设置）：visible、hidden、scroll、auto 
text-overflow：ellipsis
word-wrap：break-word、normal
visibility：visible、hidden、collapse
display：block、inline（内联）、inline-block、none、list-item
textDecorationUnderline（下划线）：ture、false
color：red、black、blue...

例：
让浏览器窗口永远都不出现滚动条：
<body style="overflow-x:hidden;overflow-y:hidden">或<body style="overflow:hidden"> 或<body scroll=no> 

2、position
相对位置relative：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。
绝对位置absolute：绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。
绝对定位其实也是相对定位，“什么？你不是在搞笑吧？”
没错，绝对定位会按照我们给定的坐标x，y来准确地定位你一个元素。但是问题在于，坐标系的原点在哪里呢？答案就是父元素。

3、float
浮动，与div搭配较多
语法：<img style="float : none | left |right " />
参数值： 
none：对象不浮动
left：对象浮在左边
right：对象浮在右边
inherit：继承父对象

4、display
语法：<input style="DISPLAY: none">
值 描述 
none 此元素不会被显示（不占位）。 
block 此元素将显示为块级元素，此元素前后会带有换行符。 
inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 
inline-block 行内块元素。（CSS2.1 新增的值） 
list-item 此元素会作为列表显示。 
run-in 此元素会根据上下文作为块级元素或内联元素显示。 
compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 
marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 
table 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 
inline-table 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 
table-row-group 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。 
table-header-group 此元素会作为一个或多个行的分组来显示（类似 <thead>）。 
table-footer-group 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。 
table-row 此元素会作为一个表格行显示（类似 <tr>）。 
table-column-group 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。 
table-column  此元素会作为一个单元格列显示（类似 <col>） 
table-cell 此元素会作为一个表格单元格显示（类似 <td> 和 <th>） 
table-caption 此元素会作为一个表格标题显示（类似 <caption>） 
inherit 规定应该从父元素继承 display 属性的值。 

默认值： inline 
JavaScript 语法： object.style.display="none" 
JQuery 语法：$(this).find("a").attr("style", "display:none");  而不是  $(this).find("a").attr("display", "none"); 
$(this).find("a").css('display', 'none')




block元素的特点是：
 
总是在新行上开始；
高度，行高以及顶和底边距都可控制；
宽度缺省是它的容器的100%，除非设定一个宽度
<div>, <p>, <h1>, <form>, <ul> 和 <li>是块元素的例子。
 
display:inline就是将元素显示为行内元素.








inline元素的特点是： 

和其他元素都在一行上；
高，行高及顶和底边距不可改变；
宽度就是它的文字或图片的宽度，不可改变。
<span>, <a>, <label>, <input>, <img>, <strong> 和<em>是inline元素的例子。
 
inline和block可以控制一个元素的行宽高等特性，需要切换的情况如下：
 
让一个inline元素从新行开始；
让块元素和其他元素保持在一行上；
控制inline元素的宽度（对导航条非凡有用）；
控制inline元素的高度；
无须设定宽度即可为一个块元素设定与文字同宽的背景色。
 
display:inline-block将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，答应空格。






inline-block的元素特点：
 
将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，答应空格。(准确地说，应用此特性的元素呈现为内联对象，四周元素保持在同一行，但可以设置宽度和高度地块元素的属性)
 
并不是所有浏览器都支持此属性，目前支持的浏览器有：Opera、Safari在IE中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表症。从上面的这个分析，也不难理解为什么IE下，对块元素设置display:inline-block属性无法实现inline-block的效果。这时块元素仅仅是被display:inline-block触发了layout，而它本就是行布局，所以触发后，块元素依然还是行布局，而不会如Opera中块元素呈递为内联对象。查看更多的CSS教程。






5、visibility
<input style="visibility: visible"> 此元素不会被显示（但占位）。

6、background
（1）background
（2）background-image
    <div style="background-image: url(Image/newpic/bg_CCHP2-2.png); width: 100%; height: 100%; background-repeat: no-repeat; position: absolute; left: 0px; top: 0px;">
（3）background-color
background-color: transparent;背景透明

（4）background-repeat

（5）background-attachment

（6）background-position

7、font
font-family
font-weight:bold、bolder、lighter、normal、100-900（100的整数）
font-size：<absolute-size>、<relative-size>、<length>、<percentage>
font-style：italic、oblique、normal
font-variant：normal、small-caps
font：all-up

8、text
text-indent：<value>
text-aligh：left、center、right、justfy
white-space：pre、nowrap、normal
line-height：
vertical-aligh：baseline、sub、super、top、text-top、middle、bottom、text-bottom
参数： 
baseline : 将支持valign特性的对象的内容与基线对齐
sub : 垂直对齐文本的下标
super : 垂直对齐文本的上标
top : 将支持valign特性的对象的内容与对象顶端对齐
text-top : 将支持valign特性的对象的文本与对象顶端对齐
middle : 将支持valign特性的对象的内容与对象中部对齐
bottom : 将支持valign特性的对象的文本与对象底端对齐
text-bottom : 将支持valign特性的对象的文本与对象顶端对齐
length : CSS2由浮点数字和单位标识符组成的长度值 | 或者百分数。可为负数。定义由基线算起的偏移量。基线对于数值来说为0，对于百分数来说就是0%。目前IE5尚不支持。
示例：
td { vertical-align : center; } 

text-transform：none、uppercase、lowercase、capitalize
text-decoration：none、line-through、underline、blink、overline
word-spacing：normal、<value>
letter-spacing：normal、<value>
word-wrap:normal：控制连续文本换行、break-word：内容将在边界内换行。如果需要，词内换行（word-break）也会发生。在 div 中，英文字母之间没有空格的话，默认为一个英文单词，所以单词就一次输出不换行。 
text-overflow：ellipsis：超出部分自动用...来表示、clip：不显示省略标记（...），而是简单的裁切。


9、overflow
overflow（溢出设置）：visible、hidden、scroll、auto 

10、ime-mode
有时候要限制用户可输入的内容限制为英文字母和数字，即希望关闭输入法
这时候只要简单的对要限制的控件加上一个ime-mode的css属性即可，如<input style="ime-mode:disabled">
语法：
ime-mode CSS提议属性
ime-mode : auto | active | inactive | disabled 
参数：
auto : 不影响IME的状态。与不指定ime-mode属性时相同
active : 指定所有使用IME输入的字符。即激活本地语言输入法。用户仍可以撤销激活IME
inactive : 指定所有不使用IME输入的字符。即激活非本地语言。用户仍可以撤销激活IME
disabled : 完全禁用IME。对于有焦点的控件（如输入框），用户不可以激活IME
补充说明：
设置或检索是否允许用户激活输入中文，韩文，日文等的输入法（IME）状态。
对应的脚本特性为imeMode。

11、cursor
style="cursor:*"
例子：<a href="#" style="cursor:pointer">CSS鼠标手型效果</a>
default                       默认
text                          文字/编辑
auto                          自动
pointer, hand(hand是IE专有)   手形
move                          可移动对象
not-allowed                   不允许
no-drop                       无法释放
wait                          等待/沙漏
progress                      半沙漏
help                          帮助
crosshair                     十字准星
(North)n-resize               向上改变大小
(South)s_resize               向下改变大小，与n-resize效果相同
(West)w-resize                向左改变大小
(East)e-resize                向右改变大小，与w-resize效果相同
（NorthWest）nw-resize        向左上改变大小
（SouthWest）sw-resize        向左下改变大小
（NorthEast）ne-resize        向右上改变大小，与sw-resize效果相同
（SouthEast）se-resize        向右下改变大小，与nw-resize效果相同
col-resize                    左右改变大小
row-resize                    上下改变大小
inherit
url('光标地址')               自定义光标，如：<BODY style="CURSOR: url(http://203.73.125.205/~liangmi2/farmfrog01.cur`)">
另：document.body.style.cursor= " "（js方法）













D、页面元素
1、table
<table>标示一个表格；
<tr>标示这个表格中间的一个行，必须在一个<table></table>里面，它不能单独使用，相当于<table>的属性标签. ；
<th>...</th> 定义表头单元格；
<td>标示行中的一个列，需要嵌套在<tr></tr>中间；



<tr>...</tr> 定义一行标签，一组行标签内可以建立多组由<td>或<th>标签所定义的单元格。



2、align
排列
<img align="right" />


3、img
<img> 标签的 usemap 属性
语法：
usemap 属性将图像定义为客户端图像映射。（注：图像映射指的是带有可点击区域的图像）
usemap 属性与 <map> 元素的 name 或 id 属性相关联，以建立 <img> 与 <map> 之间的关系。
usemap = eleName | eleid
参数：
eleName : <map> 元素的 name 
eleid : <map> 元素的 id 


<area> 标签定义图像映射中的区域，area 元素总是嵌套在 <map> 标签中。
参数：
alt : 定义此区域的替换文本。
coords : 定义可点击区域（对鼠标敏感的区域）的坐标。
href : 定义此区域的目标 URL。
nohref : nohref 从图像映射排除某个区域。
shape = default | rect | circ | poly 定义区域的形状（默认|矩形|圆形|多边形）。
target = _blank | _parent | _self | _top 规定在何处打开 href 属性指定的目标 URL。

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
<img src="planets.jpg" border="0" usemap="#planetmap" alt="Planets" />

<map name="planetmap" id="planetmap">
  <area shape="circle" coords="180, 139, 14" href ="venus.html" alt="Venus" />
  <area shape="circle" coords="129, 161, 10" href ="mercur.html" alt="Mercury" />
  <area shape="rect" coords="0, 0, 110, 260" href ="sun.html" alt="Sun" />
</map>
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

IE 可以直接判断本地图片的大小，其他文件不知道
（1）HTML
<IMG id="PhotoImg" style="POSITION:absolute;TOP:100px;LEFT:100px;" 
onerror="
document.all.PhotoImg.fileSize.value='-1';
alert('请选择一个图像文件');" 

onload="
if(document.getElementById('PhotoImg').fileSize<=1024*FileMaxSize){
ads;
    document.all.PhotoImg.fileSize.value=document.getElementById('PhotoImg').fileSize;
}
else {
    alert('图片不能大于'+FileMaxSize+'K，请重新选择');
    document.all.PhotoImg.fileSize.value='-1';
}" />

（2）JS
<script>
var ImgFile = new Image();
ImgFile.src = document.getElementById('LocalFile').value;
ImgFile.onload = function(){
   alert(this.filesize);
}

ImgFile.onerror=function(){
document.all.PhotoImg.fileSize.value='-1';
alert('请选择一个图像文件');
}
</script>


4、fieldset和legend
<fieldset>
<legend>外框标题</legend>
</fieldset>

二十二、JavaScript
Atwood定律：即”任何能够用JavaScript实现的应用系统,最终都必将用JavaScript实现。
A、基本概念
C#是编译型语言
javascript是解释型语言：
  编译型语言可以看做出书，写完了，出版，一起给用户看；
  解释型语言可以看做面谈，对方说一句你听一句，代码执行不用编译，就是说，Javascript是读一句执行一句的，所以不会先将所有的都编译
java比较特殊，过程是：
.java->编译->.class
.class需要jvm解释（+JIT技术编译），执行。
Java程序需要编译但是没有直接编译成机器语言，而是编译成字节码再用解释方式执行。

结论：
一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。
二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。
三、但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。。。
先编译后解释的混合型语言。

特点：对象、方法、作用域、回调、链式调用、闭包、原型链

1、定量
定义常量的关键字:const
如：const result=1;

2、变量
定义变量的关键字:var
如：var a; 
声明之后使用（局部变量）
不声明直接使用（全局变量）
为了获得最佳的性能，当声明 JScript .NET 变量时，可为其分配一个类型。例如，var A : String

javascript中包含6种数据类型：undefined、null、string、number、boolean和object。其中，前5种是原始数据类型，object是对象类型。object类型中包括Object、Function、String、Number、Boolean、Array、Regexp、Date、Globel、Math、Error，以及宿主环境提供的object类型。

3、指定声明为数组的方法
var Arr = new Array();
var Arr = [];

4、预编译
页面显示时，先执行<% %>里的语句，将它编译成html代码后，整个页面才会显示出来。显示完后，开始执行js代码和css。执行完js代码和css，整个页面就算是真正意义上的加载完成了。
/// <reference path="jquery-1.4.4.js"/>

5、完全连接符的补充说明
几乎所有语言中||和&&都遵循“短路”原理，如&&中第一个表达式为假就不会去处理第二个表达式，而||正好相反。
js也遵循上述原则。但是比较有意思的是它们返回的值。
代码：var attr = true && 4 && "aaa";
那么运行的结果attr就不是简单的true或这false，而是"aaa"
再来看看||：
代码：var attr = attr || "";
这个运算经常用来判断一个变量是否已定义，如果没有定义就给他一个初始值，这在给函数的参数定义一个默认值的时候比较有用。因为js不像php可以直接在型参数上定义func($attr=5)。再次提醒你记住上面的原则：如果实参需要是0、""、null、false、undefined、NaN的时候也会当false来处理。
 
 if(a >=5){
     alert("你好");
 }
 可以写成：
 a >= 5 && alert("你好");

6、!!
!!的作用是把一个其他类型的变量转成的bool类型。
很多代码if(!!attr)，为什么不直接写if(attr)；其实这是一种更严谨的写法。 

7、js中的true、false判断
在js逻辑运算中，0、""、null、false、undefined、NaN都会判为false，其他都为true（好像没有遗漏了吧，请各位确认下）。

B、字符
1、URI转义符
（1）常用转义符
代码 输出 
\' 单引号 
\" 双引号 
\& 和号 
\\ 反斜杠 
\n 换行符 
\r 回车符 
\t 制表符 
\b 退格符 
\f 换页符 
（2）网址进行转义
1）释义
    encodeURI 和 encodeURIComponent都是ECMA-262标准中定义的函数，所有兼容这个标准的语言（如JavaScript, ActionScript）都会实现这两个函数。它们都是用来对URI （RFC-2396）字符串进行编码的全局函数，但是它们的处理方式和使用场景有所不同。为了解释它们的不同，我们首先需要理解RFC-2396中对于URI中的字符分类：
·保留字符（reserved characters）：这类字符是URI中的保留关键字符，它们用于分割URI中的各个部分。这些字符是：";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," 
·Mark字符（mark characters）：这类字符在RFC-2396中特别定义，但是没有特别说明用途，可能是和别的RFC标准相关。 这些字符是："-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")" 
·基本字符（alphanum characters）：这类字符是URI中的主体部分，它包括所有的大写字母、小写字母和数字 

2）区别
    在介绍完上面三类字符串后，我们就非常容易来解释encodeURI和encodeURIComponent函数的不同之处了： 
·encodeURI: 该函数对传入字符串中的所有非（基本字符、Mark字符和保留字符）进行转义编码（escaping）。所有的需要转义的字符都按照UTF-8编码转化成为一个、两个或者三个字节的十六进制转义字符（%xx）。例如，字符空格" "转换成为"%20"。在这种编码模式下面，需要编码的ASCII字符用一个字节转义字符代替，在\u0080和\u007ff之间的字符用两个字节转义字符代替，其他16为Unicode字符用三个字节转义字符代替。
·encodeURIComponent: 该函数处理方式和encodeURI只有一个不同点，那就是对于保留字符同样做转义编码。例如，字符":"被转义字符"%3A"代替。
    之所以有上面两个不同的函数，是因为我们在写JS代码的时候对URI进行两种不同的编码处理需求。encodeURI可以用来对完整的URI字符串进行编码处理。而encodeURIComponent可以对URI中一个部分进行编码，从而让这一部分可以包含一些URI保留字符。这在我们日常编程中是十分有用的。比如下面的URI字符串： 
http://www.mysite.com/send-to-friend.aspx?url=http://www.mysite.com/product.html 
    在这个URI字符串中。send-to-friend.aspx页面会创建HTML格式的邮件内容，里面会包含一个链接，这个链接的地址就是上面URI字符串中的url值。显然上面的url值是URI中的一个部分，里面包含了URI保留关键字符。我们必须调用encodeURIComponent对它进行编码后使用，否则上面的URI字符串会被浏览器认为是一个无效的URI。

3）举例说明
<1>encodeURI
var uri="my test.asp?name=ståle&car=saab"; 
document.write(encodeURI(uri)); 
输出如下： 
my%20test.asp?name=st%C3%A5le&car=saab 
<2>encodeURIComponent
var uri="http://jb51.net/my test.asp?name=ståle&car=saab"; 
document.write(encodeURIComponent(uri)); 
输出如下： 
http%3A%2F%2Fjb51.net%2Fmy%20test.asp%3Fname%3Dst%C3%A5le%26car%3Dsaab 

4）使用
JS中对网址进行转义有三个方法，分别是escape(), encodeURI(), encodeURIComponent()
这三个方法都是把网址中的非ASCII字符转为%XX的形式
三个方法的区别是分别有些字符是不做转义的：
escape()              -@*/+
encodeURI()           -!@#$&*()=:/;?+',.~
encodeURIComponent()  -_.!~*'() 
前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）.

URI编码函数：encodeURIComponent() 
URI解码函数：decodeURIComponent() 



在老的浏览器中不执行此JS:<!--      //-->
注释 <%--      --%>
引用一个文件式的JS:<script type="text/javascript" src="aaa.js"></script>
窗口全屏大小:<script>function fullScreen(){ this.moveTo(0, 0);this.outerWidth=screen.availWidth;this.outerHeight=screen.availHeight;}window.maximize=fullScreen;</script>
JS中的焦点顺序:document.getElementByid("表单元素").tabIndex = 1
contentEditable可设置元素是否可被修改, isContentEditable返回是否可修改的状态.
isDisabled判断是否为禁止状态.disabled设置禁止状态




编码Base62 function(p,a,c,k,e,r)


2、string操作
bold() 粗体 
italtics() 斜体 
strike() 删除线 
fontsize(字级大小) 文字大小 
fontcolor(#rrggbb) 
sup() 上标 
sub() 下标 
string.toUpperCase(); 字符串转成大写
string.toLowerCase();字符串转成小写
var today = new Date();定义日期型变量
数学函数:
Math.PI(返回圆周率),
Math.SQRT2(返回开方),
Math.max(value1, value2)返回两个数中的最在值,
Math.pow(value1, 10)返回value1的十次方,
Math.round(value1)四舍五入函数,
Math.floor(Math.random()*(n+1))返回随机数
charAt(索引) 返回索引位置的字符 
charCodeAt(索引) 返回索引位置的ASCII字符码，十进制表示 
string.indexOf("字符"[,索引]),返回第一个出现的位置(从0开始计算)
string.lastIndexOf(searchString[,startIndex])最后一次出现的位置.（反向搜索） 
search("字串") 返回字串在对象中的索引位置 
string.match(regExpression),判断字符是否匹配.
slice(索引i[,索引j]) 返回索引i到索引j-1的子串 
string.split(分隔符)返回一个数组存储值
split(["字串"][,限制]) 将字串从对象中删除 
join(["间隔字符"] 将数组合并为字符串
string.substr(start[,length])取从第几位到指定长度的字符串.
substring(索引i[,索引j]) 返回索引i到索引j-1的子串 
string.replace("字串1", "字串2") 将字串1替换为字串2
string.replace(regExpression, replaceString)替换现有字符串，例：
    var fileName = "This is a title".replace(" ", "_");
而实际上，结果是"This_is a title". 在JavaScript中，String.replace的可以是正则表达式。所以可以通过正则表达式的g参数替换全部字母，正确的做法是这样：
    var fileName = "This is a title".replace(/ /g, "_");
link("url") 设置链接 
toString() 返回字符串 
valueOf() 返回字符串值 
match(/匹配字符/) 
\d  匹配一个数字字符。  
\D  匹配一个非数字字符。 
\n  匹配一个换行符。  
\r  匹配一个回车符。  
\s  匹配一个空格符。  
\S  匹配任意非空格符。 
\t  匹配一个table符。 
\w  匹配一个单词符。 
\W  匹配任何非单词符。 
\num  匹配正整数num。 
/n/ 匹配八进制，十六进制，十进制的escape值。 



JavaScript 中 =、==、=== 的区别
= 是赋值运算符，比如 var a = 5;，将 5 赋值给变量 a。
== 比较运算符，判断两个表达式是否相等。不相等的比较运算符是 !=。
=== 恒等比较运算符，要判断类型。不相等的恒等比较运算符是 !==。
alert(5 == "5"); // true
alert(5 === "5"); // false



IniFile
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
static string[] vals = IniInitializing.GetPageText(Constant.ViewNamePath, "AlarmSetting", keys);

    public static string[] GetPageText(string filepath, string sectionname, params string[] keys)
    {
        if (baseDir == null)
            baseDir = System.AppDomain.CurrentDomain.BaseDirectory;
        string path = System.IO.Path.Combine(baseDir, filepath);
        string[] txt_page = new string[keys.Length];
        try
        {
            IniFile f_ini = new IniFile(path.Trim());
            for (int ii = 0; ii < keys.Length; ii++)
            {
                txt_page[ii] = f_ini.GetString(sectionname, keys[ii], "").Trim(new char[]{' ','\t','\r'});
            }
        }
        catch (Exception ex)
        {
            // Constant.InfoLogger.Info("when read file:" + filepath + ex.Message);
            Logger.Warn("Failed to retrieve string value from file '" + filepath 
                + "', because: " + ex.Message);
        }
        return txt_page;
    }
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例



3、类型判断
（1）isNaN(变量):测试是否为数值型。（isNaN（is not a num）），例：
alert(isNaN("")); //false
alert(isNaN(null)); //false
alert(isNaN(undefined)); //true
alert(isNaN(NaN)); //true
alert(isNaN("38px")); //true
也就是说零长度字符串和 null 也会被看作数字
（2）typeof，取得类型
运算数为数字 typeof(x) = "number" 
字符串 typeof(x) = "string" 
布尔值 typeof(x) = "boolean" 
对象，数组和null typeof(x) = "object" 
函数 typeof(x) = "function" 
未定义、未声明 typeof(x) = "undefined" 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
if (str == "" ||  typeof str == 'undefined') alert("error!");
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
if(document.mylist.length != "undefined" ) {} 这个用法有误. 
正确的是 if( typeof(document.mylist.length) != "undefined" ) {} 
或 if( !isNaN(document.mylist.length) ) {} 
typeof的运算数未定义，返回的就是 "undefined". 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
Str有两种生成方式：
(1)var str = "hello world";
(2)var str2 = new String("hello world");
function isString(str) {
    if (typeof str == "string" || str.constructor == String) {
    return true;
    }
    Return false;
}
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


（3）.constructor，取得类型
string str = "text";
if(str.constructor == String) return true;


（4）instanceof，用于判断一个变量是否是某个对象的实例
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
array a = new Array();
bool judge = a instanceof Object;
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
返回true，Array是Object的一个子类


（5）类型转换
0）便捷转换方法
var myVar = '23255';  

var myString = "" + myVar;  
typeof myString; //String 

var myInt = ~~myVar;  
typeof myInt  //Integer

var myBoolean = !!myVar;  
typeof myBoolean  //Boolean 

var myfloat = 1*myVar;
typeof myfloat  //float

var myarray = [myVar];
typeof myarray  //  to array

var myvar = "(^\\d$)";

var reg1 = new RegExp(myvar);
typeof reg1;
var reg2 = eval("/" + myvar + "/");   此两种效果相同
typeof reg2;

转换日期(new Date(myVar))


方法主要有三种：转换函数、强制类型转换、利用js变量弱类型转换。
1）转换函数
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。
一些示例如下：
parseInt("1234blue"); //returns 1234
parseInt("0xA"); //returns 10
parseInt("22.5"); //returns 22
parseInt("blue"); //returns NaN
parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：
parseInt(string[,radix(代表进制)])强制转换成整型.
parseInt("AF", 16); //returns 175
parseInt("10", 2); //returns 2
parseInt("10", 8); //returns 8
parseInt("10", 10); //returns 10
如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。例如：
parseInt("010"); //returns 8
parseInt("010", 8); //returns 8
parseInt("010", 10); //returns 10
另：这个是常识，可是很多人给忽略了parseInt还有第二个参数，用以指明进制。比如，parseInt("09")，如果你认为答案是9，那就错了。因为，在此，字符串以0开头，parseInt以八进制来处理它，在八进制中，09是非法，返回false，布尔值false转化成数值就是0. 因此，正确的做法是parseInt("09", 10)。

parseFloat()方法与parseInt()方法的处理方式相似：parseFloat(string[,radix])强制转换成浮点型。
使用parseFloat()方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，parseFloat()没有基模式。
下面是使用parseFloat()方法的示例：
parseFloat("1234blue"); //returns 1234.0
parseFloat("0xA"); //returns NaN
parseFloat("22.5"); //returns 22.5
parseFloat("22.34.5"); //returns 22.34
parseFloat("0908"); //returns 908
parseFloat("blue"); //returns NaN

还有json格式的转换。
var myString = JSON.stringify(myJson)      // json -> 字符串
var myString = jQuery.toJSONString(myJson)
var myString = myJson.toJSONString()

var myJson = JSON.parse(myString)          // 字符串 -> json
var myJson = jQuery.parseJSON(myString)
var myJson = myString.parseJSON()

2）强制类型转换

还可使用强制类型转换（type casting）处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。
ECMAScript中可用的3种强制类型转换如下：
Boolean(value)——把给定的值转换成Boolean型；
Number(value)——把给定的值转换成数字（可以是整数或浮点数）；
String(value)——把给定的值转换成字符串。
用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。
当要转换的值是至少有一个字符的字符串、非0数字或对象（下一节将讨论这一点）时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。

可以用下面的代码段测试Boolean型的强制类型转换。

Boolean(""); //false – empty string
Boolean("hi"); //true – non-empty string
Boolean(100); //true – non-zero number
Boolean(null); //false - null
Boolean(0); //false - zero
Boolean(new Object()); //true – object

Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。示例如下：

用法结果
Number(false) 0
Number(true) 1
Number(undefined) NaN
Number(null) 0
Number( "5.5 ") 5.5
Number( "56 ") 56
Number( "5.6.7 ") NaN
Number(new Object()) NaN
Number(100) 100

最后一种强制类型转换方法String()是最简单的，示例如下：

var s1 = String(null); //"null"
var oNull = null;
var s2 = oNull.toString(); //won’t work, causes an error

3）利用js变量弱类型转换

举个小例子，一看，就会明白了。
<script>
var str= '012.345 ';
var x = str-0;
x = x*1;
</script>

上例利用了js的弱类型的特点，只进行了算术运算，实现了字符串到数字的类型转换，不过这个方法还是不推荐的



C、数组
1、push和pop   对数组从尾部进行压入或弹出，而且是在原数组进行操作，
push(args)可以每次压入多个元素，并返回更新后的数组长度
pop()函数每次只会弹出最后一个结尾的元素，并返回弹出的元素
例：
var oldArr = [1, 2, 3];
alert(oldArr.push(4, [5, 6]))-->5

var oldArr = [1, 2, 3, 4]
oldArr.pop()-->4
oldArr.pop()-->3

2、unshift和shift  对数组从头部进行压入或弹出，而且是在原数组进行操作，
unshift  压入
shift    弹出
例：
var oldArr2=[1, 2];
oldArr2.unshift(3)-->undefined   此时oldArr2为-->[3, 1, 2]
oldArr2.shift()-->3   此时oldArr2为[1, 2]


3、splice 添加/删除
arrayObject.splice(index, howmany, element1, ....., elementX)参数 描述 
index 必需。规定从何处添加/删除元素。
该参数是开始插入和（或）删除的数组元素的下标，必须是数字。
howmany 必需。规定应该删除多少元素。必须是数字，但可以是 "0"。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。
element1-X 可选。规定要添加到数组的新元素。从 index 所指的下标处开始插入。可向数组添加若干元素。 
例：
arrayObject.splice(i, 1);                                   //删除第i个元素


4、concat 合并
例4:var oldArr4=[1, 2];
oldArr4.concat(3, 4)-->[1, 2, 3, 4]
oldArr4.concat(3, 4, [5, 6])-->[1, 2, 3, 4, 5, 6]           （这边添加的是[5, 6]中的元素5和元素6）
oldArr4.concat(3, [4, [5, 6]])-->[1, 2, 3, 4, [5, 6]]       （这边最里层的元素[5, 6]整个用来添加，而不是拆开）


5、slice 截取
用来截取原数组中的部分元素，返回一个新的数组，原数组不会改变，其操作方式跟string的slice类似
var oldArr7=[1, 2, 3, 4];
oldArr7.slice(0)-->[1, 2, 3, 4]
oldArr7.slice(0, 2)-->[1, 2]
oldArr7.slice(0, 0)-->[]
oldArr7.slice(0, -1)-->[1, 2, 3]
oldArr7.slice(-3, -1)-->[2, 3] 
oldArr4.slice(-1, -3)--[] 


6、sort、reverse排序之正序、倒序
oldArr.sort(); //对数组元素排序，返回数组地址
oldArr.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址


7、join字符串转化
oldArr.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。
toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用


8、综合
var arr=[12, 23, 5, 3, 25, 98, 76, 54, 56, 76];
//定义了一个包含10个数字的数组
alert(arr.length); //显示数组的长度10
arr.length=12; //增大数组的长度
alert(arr.length); //显示数组的长度已经变为12
alert(arr[8]); //显示第9个元素的值，为56
arr.length=5; //将数组的长度减少到5，索引等于或超过5的元素被丢弃
alert(arr[8]); //显示第9个元素已经变为"undefined"
arr.length=10; //将数组长度恢复为10
alert(arr[8]); //虽然长度被恢复为10，但第9个元素却无法收回，显示"undefined"






D、方法
1、setTimeout延迟
作用：在指定的延迟时间后，去执行一次表达式，记住，次数是“一次”
格式：
  setTimeout(code, millisec)
  setTimeout(func, millisec, args)
    code （必需）：要调用的函数后要执行的 JavaScript 代码串。
    millisec（必需）：在执行代码前需等待的毫秒数。
    func：要执行的函数。

setTimeout   在执行时，是在载入后延迟指定时间后，去执行一次表达式，仅执行一次
setInterval  在执行时，它从载入后，每隔指定的时间就执行一次表达式
基本用法：
（1）执行一段代码
   var i=0;
   setTimeout("i+=1;alert(i)", 1000);
（2）执行一个函数
   var i=0;
   setTimeout(function(){i+=1;alert(i);}, 1000);
（3）执行一个函数
   var i=0;
   function test(){
       i+=1;
       alert(i);
   }
   setTimeout("test()", 1000);
   也可以这样：
   setTimeout(test, 1000);
总结：
   setTimeout的原型是这样的：
   iTimerID = window.setTimeout(vCode, iMilliSeconds [, sLanguage])
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
使div层定时消失：
jquery：setTimeout("$('#alertmsg').css('display', 'none')", 3000);   #alertmsg为div的id  3000为3秒后消失
直接js：setTimeout("alertmsg.style.display='none'", 3000);
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
2、setInterval间隔
作用：每隔指定的时间就执行一次表达式
格式：setInterval(表达式, 交互时间) 


2.5、setTimeout()与setInterval()区别
（1）setTimeout()
用setTimeout实现的自动变化显示随机数的效果:
<html> 
<head> 
<script> 
window.onload=sett; 
function sett() 
{ 
document.body.innerHTML=Math.random(); 
setTimeout("sett()", 5000); //与setInterval区别
} 
</script> 
</head> 
<body> 
</body> 
</html>
（2）setInterval()
setInterval实现的自动变化显示随机数的效果:
<html> 
<head> 
<script> 
function sett() 
{ 
document.body.innerHTML=Math.random(); 
} 
setInterval("sett();", 5000); 
</script> 
</script> 
</head> 
<body> 
</body> 
</html>

区别：setTimeout方法不会每隔5秒钟就执行一次showTime函数，它是在每次调用setTimeout后过5秒钟再去执行showTime函数。这意味着如果showTime函数的主体部分需要2秒钟执行完，那么整个函数则要每7秒钟才执行一次。而setInterval却没有被自己所调用的函数所束缚，它只是简单地每隔一定时间就重复执行一次那个函数。
如果要求在每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用setInterval，而如果不想由于连续调用产生互相干扰的问题，尤其是每次函数的调用需要繁重的计算以及很长的处理时间，那么最好使用setTimeout。






3、自定义延迟
sleep(5000);//执行休眠操作以便能够处理完新打开窗口执行代码
  function sleep(milisecond) {
      var currentDate, beginDate = new Date();
      var beginHour, beginMinute, beginSecond, beginMs;
      var hourGaps, minuteGaps, secondGaps, msGaps, gaps;
      beginHour = beginDate.getHours();
      beginMinute = beginDate.getMinutes();
      beginSecond = beginDate.getSeconds();
      beginMs = beginDate.getMilliseconds();
      do {
          currentDate = new Date();
          hourGaps = currentDate.getHours() - beginHour;
          minuteGaps = currentDate.getMinutes() - beginMinute;
          secondGaps = currentDate.getSeconds() - beginSecond;
          msGaps = currentDate.getMilliseconds() - beginMs;
          if (hourGaps < 0) hourGaps += 24; //考虑进时进分进秒的特殊情况
          gaps = hourGaps * 3600 + minuteGaps * 60 + secondGaps;
          gaps = gaps * 1000 + msGaps;
      } while (gaps < milisecond);
  }



4、在ie7、ie8中，使用javascript提供的close()方法都可以关闭当前窗口或标签，但都提示讨厌的对话框，找了下代码，终于可以无提示直接关闭了。
javascript代码
function closewin()       
{       
    window.opener=null;
    window.open('','_self');
    window.close();      
}



创建一个文档元素:document.createElement(),document.createTextNode()
复选按钮在JS中判断是否选中:document.forms[0].checkThis.checked (checked属性代表为是否选中返回TRUE或FALSE)



document.write()不换行的输出, document.writeln()换行输出
document.body.noWrap=true;防止链接文字折行.

5、alert
function show_alert()
{
  txt="本页中存在错误。\n\n";
  txt+="错误：" + msg + "\n";
  txt+="URL: " + url + "\n";
  txt+="行：" + l + "\n\n";
  txt+="点击“确定”继续。\n\n";
  alert(txt);
}





6、confirm
if(confirm("Are you sure?")){alert("ok");}else{alert("Not Ok");}


7、日期、时间
（1）创建 Date 对象的语法：
参数形式有以下５种：
   new Date("month dd, yyyy hh:mm:ss");
   new Date("month dd, yyyy");
   new Date(yyyy, mth, dd, hh, mm, ss);
   new Date(yyyy, mth, dd);
   new Date(ms);

var date = new Date(); 
var date = new Date(yy/mm-1/dd);
var date = new Date(yy, mm-1, dd);
var date = new Date(mm-1/dd/yy);
var date = new Date(mm-1, dd, yy);


（2）方法
getMonth() + 1     //返回当前月份
getDate()          //返回当前日期
getDay()           //返回当前星期
getHours()         //返回当前小时
getMinutes()       //返回当前分钟
getSeconds()       //返回当前秒
getMilliseconds()  //返回当前毫秒
getFullYear()      //返回当前年份
getYear()          //返回从1970年至今的年数
getTime()          //返回从1970年1月1日到事件发生时的毫秒数。（功能类似jquery的event.timeStamp、也类似C#的DateTime.Parse("1970-1-1").Ticks）

Date() 返回当日的日期和时间。  
getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。  
getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。  
getMonth() 从 Date 对象返回月份 (0 ~ 11)。  
getFullYear() 从 Date 对象以四位数字返回年份。 
getYear() 请使用 getFullYear() 方法代替。 
getHours() 返回 Date 对象的小时 (0 ~ 23)。  
getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。  
getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。  
getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。  
getTime() 返回 1970 年 1 月 1 日至今的毫秒数。  
getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。  
getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。  
getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。  
getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。  
getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。  
getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。  
getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 
getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。  
getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。  
parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 
setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 
setMonth() 设置 Date 对象中月份 (0 ~ 11)。  
setFullYear() 设置 Date 对象中的年份（四位数字）。  
setYear() 请使用 setFullYear() 方法代替。  
setHours() 设置 Date 对象中的小时 (0 ~ 23)。  
setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。  
setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。  
setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。  
setTime() 以毫秒设置 Date 对象。  
setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。  
setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。  
setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。  
setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。  
setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。  
setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。  
setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。  
toSource() 返回该对象的源代码。  
toString() 把 Date 对象转换为字符串。  
toTimeString() 把 Date 对象的时间部分转换为字符串。  
toDateString() 把 Date 对象的日期部分转换为字符串。 
toGMTString() 请使用 toUTCString() 方法代替。 1 3 
toUTCString() 根据世界时，把 Date 对象转换为字符串。   
toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。  
toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 
toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 
UTC() 根据世界时返回 1997 年 1 月 1 日 到指定日期的毫秒数。 
valueOf() 返回 Date 对象的原始值。  
var objDate=new Date([arguments list]);

（3）实用方法
1）//n天后
        function doit(dtstr, n) {
            var v = dtstr;
            if (v == "") return false;
            var dt = new Date(v.replace(/\-/g, "\/"));
            dt.setDate(dt.getDate() + n);
            var newdt = dt.getFullYear() + "-" + (dt.getMonth() + 1) + "-" + dt.getDate();
            return newdt;
        }
2）//n个月后
        function addmulMonth(dtstr, n) {
            var s = dtstr.split("-");
            var yy = parseInt(s[0]);
            var mm = parseInt(s[1]) - 1; 
            var dd = parseInt(s[2]);
            var dt = new Date(yy, mm, dd); 
            dt.setMonth(dt.getMonth() + n);
            if ((dt.getYear() * 12 + dt.getMonth()) > (yy * 12 + mm + n)) {
                dt = new Date(dt.getYear(), dt.getMonth(), 0); 
            }
 
            return dt.getYear() + "-" + dt.getMonth() + "-" + dt.getDate();
        }     
3）//n年后
        function addmulYear(dtstr, n)
        {
            var s = dtstr.split("-");
            var yy = parseInt(s[0]);
            var mm = parseInt(s[1]); 
            var dd = parseInt(s[2]);
            return yy + n + "-" + mm + "-" + dd;
        }
4）//一段时间
ED="2012/10/25";
SD="2012/10/28";
var inter = Math.floor((ED.getTime() - SD.getTime()) / (24 * 3600 * 1000) + 1);

（5）日期减去天数等于第二个日期
function cc(dd, dadd)
{
    //可以加上错误处理
    var a = new Date(dd);
    a = a.valueOf();
    a = a - dadd * 24 * 60 * 60 * 1000;
    a = new Date(A);
    alert(a.getFullYear() + "年" + (a.getMonth() + 1) + "月" + a.getDate() + "日";
}
cc("12/23/2002", 2);


8、浏览器信息
var browser=navigator.appName;
var b_version=navigator.appVersion;
var version=parseFloat(b_version);

9、跳出多层循环
            outerloop: //命名外圈语句
            for (i = 0; i < 10; i++) {
                innerloop: //命名内圈语句
                for (j = 0; j < 10; j++) {
                    // 跳出内圈循环
                    if (j > 3) { break; }  // 每当大于3时跳出， 直接使用break跳出，即每次打印的j的值绝对小于3
                    if (i == 2) { break innerloop; }   //当i 的值等于2时，指定内循环innerloop跳出  ，beak 后面指定 innerloop ，即内循环不执行了，不打印信息了
                    // 跳出外圈循环
                    if (i == 4) { break outerloop; }   //当i的值等于4时，直接跳出外循环，  break 后面 指定 outerloop，所以i只能循环到3，这时外循环直接跳出了
                    document.write("i = " + i + " , j = " + j + "<br />"); //这里打印I 和j的值
                }
            }

10、使用“arguments”对象来了解一个函数接收到了多少个参数
这个技术可以让你使用“arguments”对象来了解一个函数接收到了多少个参数。例如：
function add_nums(){
      return arguments.length;  
}     
add_nums(23, 11, 32, 56, 89, 89, 89, 44, 6); //this return the number 9 


11、常用常数
JavaScript 提供 8 种可被 Math 对象访问的算数值：
Math.E            常数e
Math.PI           圆周率 
Math.SQRT2        2 的平方根 
Math.SQRT1_2      1/2 的平方根 
Math.LN2          2 的自然对数 
Math.LN10         10 的自然对数 
Math.LOG2E        以 2 为底的 e 的对数 
Math.LOG10E       以 10 为底的 e 的对数 
Math.random()     返回区间为[0, 1)的伪随机数，可能为0，但总是小于1，


12、for（javascript的Foreach语法）
（1）遍历数组
    var mycolors = new Array('blue', 'red', 'yellow');
    function f1(){        
        var content="";
        for(var key in mycolors){
            content += key+": "+mycolors[key]+"<br/>";
        }    
        document.getElementById("content").innerHTML = content;
    }
result
0: blue
1: red
2: yellow
（2）遍历键值对
    function User(){}
    
    function f2(){                
        var u1=new User();
        u1.uname="张三";
        u1.age="18";
        
        var content="";
        for(var key in u1){
            content += key+": "+u1[key]+"<br/>";
        }    
        document.getElementById("content").innerHTML = content;
    }
result
uname: 张三
age: 18






E、页面处理
0、document
对于document对象的referrer属性
1.a.html文件内容如下：
           <a href="b.html">浏览b.html</a>
2.b.html文件中的内容如下：
               <body>
                   <script type="text/javascript">
                        document.write(document.referrer);
                   </script>
                </body>
           则在通过a.html中的超链接访问b.html的时候，显示的结果是：
           http://127.0.0.1:8180/a.html
        （经过测试，需要将两个文件放在服务器中才能得到想要的结果，若直接在本地文件夹中则得不到结果）
说明：若直接在浏览器地址栏中输入b.html的URL地址或使用打开菜单访问b.html，则document.referrer的值为空字符串




1、页面跳转
（1）location
1）location.属性（例:'http://www.baidu.com:80/index.html?sel=8'）
hash 返回锚点名称，即#以后的内容，如'http://www.baidu.com:80/index.html#index=6'，则返回'index=6'
host 返回主机名称和端口号，hostname:port（例:'www.baidu.com:80'）
hostname 返回地址的主机名，（例:'www.baidu.com'）
port 返回端口号，（例:'80'）
pathname 返回路径（例:'/index.html'）
search 返回查询信息，即?后的内容（例:'sel=8'）
href 完整的URL字符串，即以上所有内容，也可以省略.href直接用location
protocol 返回地址的协议，取值为'http:'、'https:'、'file:'等
href 当前页面网址，可获取可设置，它和window属性是等价的，是属性
即window、self、window.self是等价的：
location.href="/url"
window.location.href="/url"
this.location.href="/url"
self.location.href="/url"
以上效果一样
parent.location.href="/url"     在父页面打开新页面，适用于iframe
top.location.href="/url"        在顶层页面打开新页面，适用于iframe

2）location.方法
reload() 重新加载，相当于IE的刷新F5
replace(website) 用指定的网页取代当前网页，用此方法后，后退不能返回原页面，相当于在IE地址栏输入新网址

（2）window
window.history.back()                           返回上一页
window.history.forward()                        返回下一页
window.history.go()                             返回第几页，也可以使用访问过的URL
window.focus()                                  使当前的窗口在所有窗口之前
window.close();
window.open(this.options[selectedIndex].value)  在新窗口中打开，是方法
window.opener                                   是window.open 打开的子页面调用父页面对象
window.clipboardData.setData("Text", mydata);

clipboardData.setData(sDataFormat, sData)
参数：sDataFormat：要复制内容的格式；sData：要复制的内容。
返回值：复制成功返回true；失败返回false。

clipboardData.getData(sDataFormat) 从剪贴板获取指定格式的数据。
参数：sDataFormat：要获取内容的格式

clipboardData.clearData(sDataFormat) 删除剪贴板中指定格式的数据。
参数：sDataFormat：要清除的内容的格式

    closed 获取引用窗口是否已关闭。
    defaultStatus 设置或获取要在窗口底部的状态栏上显示的缺省信息。
    dialogArguments 设置或获取传递给模式对话框窗口的变量或变量数组。
    dialogHeight 设置或获取模式对话框的高度。
    dialogLeft 设置或获取模式对话框的左坐标。
    dialogTop 设置或获取模式对话框的顶坐标。
    dialogWidth 设置或获取模式对话框的宽度。
    frameElement 获取在父文档中生成 window 的 frame 或 iframe 对象。
    length 设置或获取集合中对象的数目。
    name 设置或获取表明窗口名称的值。
    offscreenBuffering 设置或获取对象在对用户可见之前是否要先在屏幕外绘制。
    opener 设置或获取创建当前窗口的窗口的引用。
    parent 获取对象层次中的父窗口。
    returnValue 设置或获取从模式对话框返回的值。
    screenLeft 获取浏览器客户区左上角相对于屏幕左上角的 x 坐标。
    screenTop 获取浏览器客户区左上角相对于屏幕左上角的 y 坐标。
    self 获取对当前窗口或框架的引用。
    status 设置或获取位于窗口底部状态栏的信息。
    top 获取最顶层的祖先窗口。

    方法 描述
    alert 显示包含由应用程序自定义消息的对话框。
    attachEvent 将指定函数绑定到事件，以便每当该事件在对象上触发时都调用该函数。
    blur 使元素失去焦点并触发 onblur 事件。
    clearInterval 使用 setInterval 方法取消先前开始的间隔事件。
    clearTimeout 取消先前用 setTimeout 方法设置的超时事件。
    close 关闭当前浏览器窗口或 HTML 应用程序(HTA)。
    confirm 显示一个确认对话框，其中包含一个可选的消息和确定取消按钮。
    createPopup 创建弹出窗口。
    detachEvent 从事件中取消指定函数的绑定，这样当事件触发时函数就不会收到通知了。
    execScript 以给定语言执行指定的脚本。
    focus 使得元素得到焦点并执行由 onfocus 事件指定的代码。
    moveBy 将窗口的位置移动指定 x 和 y 偏移值。
    moveTo 将窗口左上角的屏幕位置移动到指定的 x 和 y 位置。
    navigate 在当前窗口中装入指定 URL。
    open 打开新窗口并装入给定 URL 的文档。
    print 打印与窗口关联的文档。
    prompt 显示一个提示对话框，其中带有一条消息和一个输入框。
    resizeBy 更改窗口的当前位置缩放指定的 x 和 y 偏移量。
    resizeTo 将窗口的大小更改为指定的宽度和高度值。
    scroll 将窗口滚动到自左上角起指定的 x 和 y 偏移量。
    scrollBy 将窗口滚动 x 和 y 偏移量。
    scrollTo 将窗口滚动到指定的 x 和 y 偏移量。
    setActive 设置对象为当前对象而不将对象置为焦点。
    setInterval 每经过指定毫秒值后计算一个表达式。
    setTimeout 经过指定毫秒值后计算一个表达式。
    showHelp 显示帮助文件。此方法可用于 microsoft HTML 帮助。
    showModalDialog 创建一个显示指定 HTML 文档的模式对话框。
    showModelessDialog 创建一个显示指定 HTML 文档的非模式对话框。


（3）iframe
Iframe标记的使用格式是: 
<Iframe src="URL" width="x" height="x" scrolling="[OPTION]" frameborder="x"></iframe> 
src：文件的路径，既可是HTML文件，也可以是文本、ASP等； 
width、height："画中画"区域的宽与高； 
scrolling:当SRC的指定的HTML文件在指定的区域不显不完时，滚动选项，如果设置为NO，则不出现滚动条；如为Auto：则自动出现滚动条；如为Yes，则显示; 
FrameBorder：区域边框的宽度，为了让“画中画“与邻近的内容相融合，常设置为0。 
例: 
<Iframe src="http://www.digidc.cn"; width="250" height="200" scrolling="no" frameborder="0"></iframe> 
重新指定一次iframe.src的路径，这种最好加个随机参数，因为有缓存
iframe.src="B.html"

window.top
功能：返回顶层窗口，即浏览器窗口。
注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。

window.parent
功能：返回父窗口。
注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。


window.open并不是一定局限于打开一个新的窗口，当窗口名称和window.open中第二个参数一样时，就会将这个窗口替换，用这个特性的话可以在iframe和frame中来代替location.href，比如：
<iframe name="aa"></iframe>   
  <input type=button value=111  onclick="window.open('frame.html', 'aa', '')"> 
  <input type=button value=222  onclick="self.frames['aa'].location.href='frame.html'">
  <input type=button value=333  onclick="window.open('frame.html', 'a1', '')"> 

iframe内dom、function等的方法：
1）通过javascript
·调用函数：document.frames['jd_iframe'].Ok();
·引用dom元素：document.frames["jd_iframe"].document.getElementByid("GRCWaitingContent").innerText = '111';
2）通过jQuery
·调用函数：$("#jd_iframe").contentWindow.Ok();
·引用dom元素：$(window.frames["jd_iframe"].document).find("#GRCWaitingContent")[0].innerText = '111';
·引用dom元素：$("#GRCWaitingContent", window.frames['jd_iframe'].document)[0].innerText = '111';
           

parent的dom
•js方式
window.parent.document.getElementById("mainDiv").innerHTML = "修改后的主页面数据";
•jquery方式
$(window.parent.document).find(":div#mainDiv");

另：
现在的网页一般上都会避免使用iframe，其比较难维护，而利用以下的方式代替：
$("#divA").load("index.jsp");      //div加载页面

（4）常用页面跳转方法
第一种：
    <script language="javascript" type="text/javascript">
           window.location.href="login.jsp?backurl="+window.location.href; 
    </script>

第二种：
    <script language="javascript">
    alert("返回");
    window.history.back(-1);
   </script>

第三种：
   <script language="javascript">
    window.navigate("top.jsp");
  </script>

第四种：
   <script language="JavaScript">
          self.location='top.htm';
   </script>

第五种：
   <script language="javascript">
          alert("非法访问！");
          top.location='xx.jsp';
   </script>

2、页面传值
（0）页面提交与获取
1）页面提交（ASP.NET的Get和Post方式的区别）
表单提交中，ASP.NET的Get和Post方式的区别归纳如下几点：
1、get是从服务器上获取数据，post是向服务器传送数据。（默认情况下为采用POST方式）
2、get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
3、对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
4、get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为 100KB。
5、get安全性非常低，post安全性较高。但是执行效率却比Post方法好。
建议：
1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式。


2）页面获取Request
string id = Request.QueryString["name"];  
string id2 = Request.Form["name2"];  同Request.Form.Get("name2");
string id3 = Request.Params["name3"]; 
string id4 = Request["name4"]; 

Request详解：
Request.Form：获取以POST方式提交的数据（接收Form提交来的数据）；
Request.QueryString：获取地址栏参数（以GET方式提交的数据），只能读取通过地址栏参数传递过来的名为id的参数
Request：是一个复合功能读取函数，包含以上两种方式(优先获取 GET方式提交的数据)，它的优先级顺序为QueryString > Form > Cookies > ServerVariables，它会在QueryString、Form、ServerVariable中都按先后顺序搜寻一遍。而且有时候也会得到不同的结果。如果你仅仅是需要Form中的一个数据，但是你使用了Request而不是Request.Form，那么程序将在QueryString、 ServerVariable中也搜寻一遍。如果正好你的QueryString或者ServerVariable里面也有同名的项，你得到的就不是你原本想要的值了。
Request.Params：是所有post和get传过来的值的集合，request.params其实是一个集合，它依次包括 request.QueryString、request.Form、request.cookies和request.ServerVariable。
注1：asp.net 默認虽然是POST Form，但是只是自己post自己，不能POST到其他页面。如果非要提交到另一个页面的话用HTML元素把runat="server" 去掉 用submit提交，然后用Request.Form["xxx"] 可以取值。
注2：也就是说，如果存在名为id的地址栏参数，Request[ "id" ] 的效果和 Request.QueryString["id"] 是样的。
如果不存在名为id的地址栏参数，Request.QueryString["id"]将会返回空，但是Request[ "id" ]会继续检查是否存在名为id的表单提交元素，如果不存在，则继续尝试检查名为id的Cookie，如果不存在，继续检查名为id的服务器环境变量。它将最多做出4个尝试，只有四个尝试都失败，才返回空。

context.Request.QueryString，AJAX会用到
---------------------------------------------------
以下是Request[ "id" ]的内部实现代码：
public string this[string key]
    {
        get
        {
            string str = this.QueryString[key];
            if (str != null)
            {
                return str;
            }
            str = this.Form[key];
            if (str != null)
            {
                return str;
            }
            HttpCookie cookie = this.Cookies[key];
            if (cookie != null)
            {
                return cookie.Value;
            }
            str = this.ServerVariables[key];
            if (str != null)
            {
                return str;
            }
            return null;
        }
    }
---------------------------------------------------

（1）利用session（可以同页面内前台、后台互传，也可以两个页面互传）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例
后台代码a.aspx.cs
protected void Page_Load(object sender, EventArgs e)
{
    Session["Wang"] = "wangdongxin";
}
前台代码a.aspx：
<a href="b.aspx" target="_self">去获取Session的页面</a>
前台代码b.aspx：
<div>
<script>
var str='<%=Session["Wang"] %>';
alert("当前会话Session值为:"+str);
</script>
</div>
例例例例例例例例例例例例例例例例例例例例例例例例例例例例
注：看了上面的例子，有个注意点要讲清楚的，那就是var str='<%=Session["Wang"] %>';
这段代码，不管你放在前台的function内，还是放在function外，它都会在页面加载的时候，将后台的Session["Wang"] 的值赋值给str，如果Session["Wang"]不存在，那么str的值就为null或undefined，即使在后期，你通过某个操作对Session["Wang"] 进行了定义并且赋值，或者对Session["Wang"] 进行了修改更新，前台的str是不会跟着改变的，各位想想，如果str跟着改变，那还有何安全性可言？
但是，上面我这么说，并不代表前台不能实时获取Session["Wang"] 值，当然有办法，换个思路而已！可以通过添加一个type=hidden的元素，中转一下。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例
后台代码a.aspx.cs
protected void Page_Load(object sender, EventArgs e)
{
Session["Wang"] = "wangdongxin";
this.sess.Value=Session["Wang"].toString();                  //增加
}
前台代码a.aspx：
<input id="session" type="hidden" runat="server" />          //增加
<a href="b.aspx" target="_self">去获取Session的页面</a>
前台代码b.aspx：
<div>
<script>
var str=document.all.session.value;                          //修改
alert("当前会话Session值为:"+str);
</script>
</div>
例例例例例例例例例例例例例例例例例例例例例例例例例例例例

（2）利用GET（源页面与目标页面也可以相同）
I、赋值页面
说明：进行带get参数的页面跳转，如：
前台a.aspx（前台方法有很多，也可用location等，前文"页面跳转"有介绍）
parent.parent.JqueryDialog.Open('', 'b.aspx?grcId=6&alarmId=153', 662, 427);

<form id="form1" runat="server" method="GET">
    <input id="grcId" runat="server" type="text" value="6" "/>
    <input id="alarmId" runat="server" type="text" value="153" "/>
    <input type="submit" value ="发送" />
</form>
后台a.aspx.cs
response.redirct("b.aspx?grcId=6&alarmId=153")
II、取值页面
说明：在后台获取get参数，如：
后台b.aspx.cs
Request.QueryString["grcId"];
Request.QueryString["alarmId"];
前台b.aspx
QueryString("grcId");
QueryString("alarmId");

（3）利用POST（源页面与目标页面也可以相同）
I、赋值页面
说明：进行带POST参数的页面跳转，如：
前台a.aspx（即不同页面）
<form id="form1" method = POST action="b.aspx">
    <input id="grcId" runat="server" type="text" value="6" "/>
    <input id="alarmId" runat="server" type="text" value="153" "/>
    <input type="submit" value ="发送" />
</form>
前台b.aspx（即同页面）
<form id="form1" runat="server" method="POST">
    <input id="grcId" runat="server" type="text" value="6" "/>
    <input id="alarmId" runat="server" type="text" value="153" "/>
    <input type="submit" value ="发送" />

注：两者区别
runat="server"
action="b.aspx"

II、取值页面
说明：在后台获取POST参数，如：
后台b.aspx.cs
Request.Form["grcId"];//等同于Request.Form.Get("grcId");
Request.Form["alarmId"];//等同于Request.Form.Get("alarmId");

前台b.aspx
QueryString("grcId");//////////////
QueryString("alarmId");////////////

（4）利用hidden（同页面，后台向前台传值）
后台：
this.vv.Value = "name";
前台：
alert(vv.Value);


（5）利用<%=xx%>（同页面，前台从后台取值）
后台：
    protect string returnBack()
    {
        string a = "grcId=6";
        return a;
    }
※后台方法声明须为public或者protected，然后前台才能使用js脚本进行调用。
前台：
alert(<%=returnBack()%>);

（6）利用<%#xx%>（同页面，前台从后台取值）
后台：
dataGrid1.DataSource=ds.Tables["人员库"];
前台：
<%#Eval("description")%>







3、常用页面处理方法
（1）session
说明：
Session["namespace.变量名"]="value";//session变量名最好加上命名空间，以防止冲突！
string s=(string)Session["namespace.变量名"];//session存储的是对象类型，取的时候需要转换一下！
举例：
Session.Add("DEMO", "ABC");//创建
Session["DEMO"]="DEF";//附值
string text1=Session["DEMO"].ToString();//取值
Session.Remove("name");//清空Session


（2）viewstate
viewstate和session的用途一样，只是session的生命周期是整个会话，而viewstate的生命周期则是该页面结束之前，即只能在同一个页面使用，离开页面就会失效 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
protected void Page_Load(object sender, EventArgs e)
{
     if(!IsPostBack)
    {
       ViewState["自定义名称用于区分不用的"] = null; // 定义的开始.
    }
}



ViewState["test"]="abc";
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
    简单来说 ，viewstate其实是系统自动加了一个hidden框来保存你存在viewstate里的值，因此，它的生存周期跟hidden是一样的，只能保证页面PostBack时，里面的值不丢失
也与hidden一样，是客户端机制，不会占用服务器端资源。
    比hidden强的是，使用稍方便一些，另外，安全性稍强一点，在于： <input   type= "hidden "   name= "__VIEWSTATE "   value= "xxxx "> 里的value是经过加密的当然加密算法也不是很复杂，因此，知道加密机制的人依然可以修改其内容。










F、元素及DOM
1、元素处理
（1）获取元素
document.getElementsByTagName("li");
document.getElementById("li");
（2）新建元素
document.creatElement("p").appendChild(document.createTextNode("this is text"));

removeChild(oNewP, oOldP);


（3）属性设置
document.getElementsByTagName("img")[0].getAttribute("little");
document.getElementsByTagName("img")[0].setAttribute("little", 1);

（4）其他
if(UI.hasChildNodes())
if(UI.childNodes[i].nodeName)
if(UI.parentNode.tagName)







2、元素属性
（1）type
<input> button
<input> reset
<input> submit
<input> text
<input> file
//IE8 以上使用时，会出现路径为fakepath的现象：
解决方法一：进入浏览器设置——>安全——>自定义级别，然后把“将文件上载到服务器时包涵本地目录路径”选择启用。
解决方法二：
var file = document.getElementById("fileId");      //其中fileId为file的Id
file.select();
var realPath = document.selection.createRange().text;      //realPath即为file的真实路径
<input> password
<input> checkbox
<input> radio
<input> hidden
textarea
table
image
select
div

（2）value
设置表单中所有文本型的成员的值为空:
 var form = window.document.forms[0]
 for (var i = 0 ; i < form.elements.length ; i++){
     if (form.elements[i].type == "text"){
         form.elements[i].value = "";
     }
 }



（3）id
（4）name
（5）class
（6）runat
（7）style、css（详见html、css部分）
element.style.cssText="width:20px;height:20px;border:solid 1px red;"
（8）事件




3、控件使用
（1）select
1）选取、判断、设置
this.options[this.selectedIndex].value          //注意：javascript是严格区分大小写的！只能写成selectedIndex.
if(objSelect[i].selected == true) objSelect.options[i] = null; 
objSelect.options[i].text = objItemText; 
2）添加
 objSelect.options.add(  new Option(objItemText, objItemValue)  );
3）删除
 objSelect.options[i] = null; 
4）清空
objSelect.options.length



G、函数
js函数代码中有个特殊对象arguments，开发者无需明确指出参数名称，就能直接访问
arguments[0]、arguments[1]、arguments[2]依次类推，类似C#中的params
1、定义一个函数，并给定义的函数添加方法
方法1
var fn = {
  fn0 : function (){
    var textarea = document.getElementById("area");
    var max_length = textarea.maxLength;
  },
  fn1 : function (){}
}
于是就可以用
fn.fn0();
fn.fn1();




方法2
String.Format = function() {
 if(arguments.length == 0)
  return "";
 
 if(arguments.length == 1)
  return arguments[0];
 
 var reg = /{(\d+)?}/g;
 var args = arguments;
 var result = arguments[0].replace(
  reg,
  function($0, $1) {
   return  args[parseInt($1)+1];
  }
 )

 return result;
}





方法3
String.prototype.trim = function() 
{ 
return this.replace(/(^\s*)|(\s*$)/g, ""); 
} 

window.onerror=function(){
}






2、调用后台函数
（1）通过button调用（不带参数，有刷新）
在前台调用后台的函数
前台
js:
document.getElementById("Callfun").click();
or
__doPostBack('Callfun', '');
html:
<input type="button" id="Callfun" runat="server" onserverclick="aa" value="ButtonThis"/>   可加style="DISPLAY: none" 
or
<asp:Button ID="Callfun" runat="server" onclick="aa" Text="ButtonThis" />   可加style="DISPLAY: none" 
后台
protected void aa(object o, EventArgs e)
{
}
※
1、前台要运行在服务端：<input>用onserverclick="aa"、<asp:Button>用onclick="aa"（<asp:Button>默认在服务端运行）
2、前台函数aa不要加()
3、后台函数要加(object o, EventArgs e)参数
（2）通过<%=%>调用（可带参数，此方法属预编译）
后台
protected string CsharpVoid(string strCC)
{
    strCC = "你好！" + strCC;
    return strCC;
 }
※后台方法声明须为public或者protected，然后前台才能使用js脚本进行调用。
前台JS
function Init()
 {
   var v = "中国";
   var s = '<%=CsharpVoid("'+v+'") %>';
   alert(s);
 }
（3）通过ajax（无参数，无刷新）
1）后台cs
using System.Web.Services; 
[WebMethod]
public static string SayHello() 
{ 
return "Hello Ajax!"; 
} 
2）前台aspx
                    $.ajax({
                        //要用post方式 
                        type: "Post",
                        //方法所在页面和方法名 
                        url: "WF1.aspx/SayHello",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        success: function (data) {
                            //返回的数据用data.d获取内容 
                            alert(data.d);
                        },
                        error: function (err) {
                            alert(err);
                        }
                    });
（4）通过ajax（有参数，无刷新）
1）后台cs
[WebMethod] 
public static string GetStr(string str, string str2) 
{ 
return str + str2; 
} 
2）前台aspx
                $.ajax({
                    type: "Post",
                    url: "demo.aspx/GetStr",
                    //方法传参的写法一定要对，str为形参的名字，str2为第二个形参的名字 
                    data: "{'str':'我是', 'str2':'XXX'}",
                    contentType: "application/json; charset=utf-8",
                    dataType: "json",
                    success: function (data) {
                        //返回的数据用data.d获取内容 
                        alert(data.d);
                    },
                    error: function (err) {
                        alert(err);
                    }
                });


（5）自带机制
说明：我们在页面上添加一个LinkButton并给它添加一个事件之后，实际上就是通过JavaScript进行的回传，动态查看代码时，页面会自动添加以下代码：
<div>
<input type="hidden" name="__EVENTTARGET" id="__EVENTTARGET" value="" />
<input type="hidden" name="__EVENTARGUMENT" id="__EVENTARGUMENT" value="" />
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUJMjgwMDQwODEzZGSJ/LHlSmNe6RbypchD4ilNLO1htj6clW54DHcAvw0/Kw==" />
</div>

<script type="text/javascript">
//<![CDATA[
var theForm = document.forms['form1'];
if (!theForm) {
    theForm = document.form1;
}
function __doPostBack(eventTarget, eventArgument) {
    if (!theForm.onsubmit || (theForm.onsubmit() != false)) {
        theForm.__EVENTTARGET.value = eventTarget;
        theForm.__EVENTARGUMENT.value = eventArgument;
        theForm.submit();
    }
}
//]]>
</script>
<div>
    <input type="hidden" name="__EVENTVALIDATION" id="__EVENTVALIDATION" value="/wEWBwL3q+mOBgKln/PuCgKPoYLCDwLdkpmPAQKQ9M/rBQLNzeKFCwKhzZZAASm27CKnTQ8ifiTG+4NRwIzYCmAzHRQuLC7I9zy8XWU=" />
</div>


（6）自带asp.net控件
<asp:Button>的onclick事件、<asp:TextBox>的ontextchanged事件等，直接执行的就是后台cs的函数。
3、call
用法
例例例例例例例例例例例例例例例例
Js代码
function add(a, b)   
{   
    alert(a+b);   
}   
function sub(a, b)   
{   
    alert(a-b);   
}   
add.call(sub, 3, 1);  
用 add 来替换 sub，add.call(sub, 3, 1) == add(3, 1) ，所以运行结果为：alert(4);
例例例例例例例例例例例例例例例例


（7）服务器按钮控件与客户端按钮控件
对于服务器按钮控件（即<asp:Button>类型的按钮）：
服务器响应事件：OnClick
客户端响应属性：OnClientClick

对于html按钮控件（即<input type="button" runat="server">）
服务器响应事件：OnServerClick
客户端响应事件：onclick

button用了onclick事件后 onserverclick不运行了 今天做程序的时候用到了 input 的button 添加了runat="server" ，后来有加一段onclick事件，想在服务器判断一下，发现运行onclick事件后，不再运行onserverclick了。
方法一：
type="button"中 click 如果执行 return 语句 ，无论是否都不会执行之后的语句，想判断提交的话，改成type="submit" 即可
方法二：
在js判断完后，再调用一下下面的这句话：
   __doPostBack('btnAdd', '')


H、事件
select 或text的onchange事件需要手动（通过键盘输入）改变select或text的值才能触发，如果在js中给select或text赋值，则无法触发onchange事件，例如，在页面加载完成以后，需要触发一个onChange事件，在js中用document.getElementById("se").value="ttt";直接给select或text赋值是不行的，要想实现手动触发onchange事件，需要在js给select赋值后，加入下面的语句(假设select的id为sel)
document.getElementById("sel").fireEvent('onchange') 来实现
jQuery方式：$(selector).trigger('onchange')

1、事件种类
（1）onmouseenter：当鼠标进入选区执行代码
<div style="background-color:red" onmouseenter="alert('bem')">123456</div>
（2）onmouseleave：当鼠标离开选区执行代码
<DIV onmouseleave="alert('bem')" style="BACKGROUND-COLOR: red">123456</DIV>
（3）onmousewheel：当鼠标在选区滚轮时执行代码
<DIV onmousewheel="alert('bem')" style="BACKGROUND-COLOR: red">123456</DIV>
（4）onscroll：拖动滚动条执行代码
<div style="width:100px;height:100px;overflow:scroll" onscroll="alert('bem')">123456</div>
（5）onfocusin：当获得焦点时执行代码
<div contentEditable="true" style="background-color:red" onfocusin="alert('bem')" >asdf</div>
（6）onfocusout：当失去焦点时执行代码
<div contentEditable="true" style="background-color:red" onfocusout="alert('bem')" >asdf</div>
（7）onstart：当显示内容时执行代码
<marquee style="background-color:red" onstart="alert('bem')" >asdf</marquee>
（8）onbeforecopy：选中内容后右键执行代码
<div style="background-color:red;" onbeforecopy="alert('bem')" >asdf</div>
（9）onbeforecut：选中内容后右键执行代码
<div style="background-color:red;" onbeforecut="alert('bem')" >asdf</div>
（10）onbeforeeditfocus：当获得焦点时执行代码
<div style="background-color:red;" contentEditable="true" onbeforeeditfocus="alert('bem')" >asdf</div>
（11）onbeforepaste：选中内容后右键执行代码
<div style="background-color:red;" ="true" onbeforepaste="alert('bem')" >asdf</div>
（12）oncontextmenu：鼠标右键执行代码
<div style="background-color:red;" oncontextmenu="alert('bem')" >asdf</div>
（13）oncopy：鼠标右键执行复制时执行代码
<div style="background-color:red;" oncopy="alert('bem')" >asdf</div>
（14）oncut：鼠标右键执行剪切时执行代码
<div contentEditable="true" style="background-color:red;" oncut="alert('bem')" >asdf</div>
（15）ondrag：选择内容并拖动时执行代码
<div style="background-color:red;" ondrag="alert('bem')" >asdf</div>
（16）ondragend：选择内容并拖动松开鼠标执行代码
<div style="background-color:red;" ondragend="alert('bem')" >asdf</div>
（17）ondragenter：选择内容并拖动时执行代码
<div style="background-color:red;" ondragenter="alert('bem')" >asdf</div>
（18）ondragleave：选择内容并拖出边框执行代码
<div contentEditable="true" style="background-color:red;" ondragleave="alert('bem')" >asdf</div>
（19）ondragover：选择内容并拖动时执行代码
<div contentEditable="true" style="background-color:red;" ondragover="alert('bem')" >asdf</div>
（20）ondragstart：选择内容并拖动时执行代码
<div contentEditable="true" style="background-color:red;" ondragstart="alert('bem')" >asdf</div>
（21）ondrop：有内容被拖动进来时执行代码
<div contentEditable="true" style="background-color:red;" ondrop="alert('bem')" >asdf</div>
<div contentEditable="true" style="background-color:green;" ondrop="alert('bem')" >asdf</div>
（22）onlosecapture：选择内容时执行代码
<div contentEditable="true" style="background-color:red;" onlosecapture="alert('bem')" >asdf</div>
（23）onpaste：粘贴时执行代码
<div contentEditable="true" style="background-color:red;" onpaste="alert('bem')" >asdf</div>
（24）onselectstart：选择内容时执行代码
<div contentEditable="true" style="background-color:red;" onselectstart="alert('bem')" >asdf</div>
（25）onhelp：进入焦点按F1时执行代码
<div contentEditable="true" style="background-color:red;" onhelp="alert('bem')" >asdf</div>
（26）onEnd：当时间线执行完毕时执行代码
<div STYLE="background-color:red;behavior:url('#default#time2')" onEnd="alert('bem')">asdf</div>
（27）onBegin：当时间线开始执行代码
<div STYLE="background-color:red;behavior:url('#default#time2')" onBegin="alert('bem')">asdf</div>
（28）onactivate：激活当前标签时执行代码
<div contentEditable="true" STYLE="background-color:red;" onactivate="alert('bem')">asdf</div>
（29）onfilterchange：当滤镜改变时执行代码
<div contentEditable="true" STYLE="background-color:red;filter: Alpha(opacity=100, style=2);" onfilterchange="alert('bem')">asdf</div>
（30）onbeforeactivate：当激活当前标签时执行代码
<div contentEditable="true" STYLE="background-color:red;" onbeforeactivate="alert('bem')">asdf</div>
（31）onbeforedeactivate：当标签内值改变时执行代码
<div contentEditable="true" STYLE="background-color:red;" onbeforedeactivate="alert('bem')">asdf</div>
（32）ondeactivate：当标签内值改变时执行代码
<div contentEditable="true" STYLE="background-color:red;" ondeactivate="alert('bem')">asdf</div>

onchange一个HTML元素的属性改变时且当前元素失去焦点(onblur)时发生。
onpropertychange(非IE浏览器中是oninput)一个HTML元素的属性改变的时时发生。
onkeypress是在用户按下并放开任何字母数字键时发生。系统按钮（例如，箭头键和功能键）无法得到识别。 
onkeyup 是在用户放开任何先前按下的键盘键时发生。 
onkeydown 是在用户按下任何键盘键（包括系统按钮，如箭头键和功能键）时发生。
window.onerror = doNothing; JS中遇到脚本错误时不做任何操作
window.onerror = handleError;指定错误句柄的语法为
onunload()当窗体关闭时调用的文件句柄

★JS之onkeypress,onkeydown,onkeyup区别
键盘事件包括keydown、kepress和keyup三种，每次敲击键盘都会(依次？)触发这三种事件，其中keydown和keyup是比较低级的接近于硬件的事件，通俗的理解是这两个事件可以捕获到你敲击了键盘中某个键；而keypress是相对于字符层面的较为高级点的事件，这个事件能够捕捉到你键入了哪个字符。可以这样理解，如果你敲击了A键，keydown和keyup事件只是知道你敲击了A键，它并不知道你敲的是大写的A(你同时按下了Shift键)还是敲的是小写a，它是以"键"为单位，你敲入了大写的A，它只是当成你敲下了shift和A两个键而已，但是keypress可以捕捉到你是敲入的大写的A还是小写的a。
onkeypress是在用户按下并放开任何字母数字键时发生。系统按钮（例如，箭头键和功能键）无法得到识别。 
onkeyup 是在用户放开任何先前按下的键盘键时发生。 
onkeydown 是在用户按下任何键盘键（包括系统按钮，如箭头键和功能键）时发生。
·onkeypress
As of Microsoft&reg; Internet Explorer 4.0, the onkeypress event fires and can be canceled for the following keys:
Letters: A - Z (uppercase and lowercase)
Numerals: 0 - 9
Symbols: ! @ # $ % ^ & * ( ) _ - + = < [ ] { } , . / ? \ | ' ` " ~
System: ESC, SPACEBAR, ENTER
·onkeydown
As of Microsoft&reg; Internet Explorer 4.0, the onkeydown event fires for the following keys:
Editing: DELETE, INSERT
Function: F1 - F12
Letters: A - Z (uppercase and lowercase)
Navigation: HOME, END, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW
Numerals: 0 - 9
Symbols: ! @ # $ % ^ & * ( ) _ - + = < [ ] { } , . / ? \ | ' ` " ~
System: ESC, SPACEBAR, SHIFT, TAB

As of Internet Explorer 5, the event also fires for the following keys:
Editing: BACKSPACE
Navigation: PAGE UP, PAGE DOWN
System: SHIFT+TAB

As of Internet Explorer 5, this event can be canceled for the following keys and key combinations by specifying event.returnValue=false:
Editing: BACKSPACE, DELETE
Letters: A - Z (uppercase and lowercase)
Navigation: PAGE UP, PAGE DOWN, END, HOME, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW
Numerals: 0 - 9
Symbols: ! @ # $ % ^ & * ( ) _ - + = < [ ] { } , . / ? \ | ' ` " ~
System: SPACEBAR, ESC, TAB, SHIFT+TAB
You can cancel all keys that fire the onkeydown event in HTML Applications, including most accelerator keys, such as ALT+F4.
In Internet Explorer 4.0, you cannot cancel the onkeydown event, but you can use the onkeypress event to cancel keyboard events.
两个一起按，可以这样：
if( window.event.shiftKey && event.keyCode==xx)
function document_onpress()
{
    if(event.keyCode=='13')
    {
        document.all.div_Line.style.pixelLeft=document.all.div_Line.style.pixelLeft+1;
        document.all.div_Q.style.pixelLeft=document.all.div_Q.style.pixelLeft+1;
        document.all.div_T.style.pixelLeft=document.all.div_T.style.pixelLeft+1;
    }
}

★JS之Onunload，onbeforeunload区别
（1）区别
Onunload，onbeforeunload都是在刷新或关闭时调用，可以在<script>脚本中通过window.onunload来指定或者在<body>里指定。
区别在于Onbeforeunload是正要去服务器读取新的页面时调用，此时还没开始读取，在onunload之前执行，它还可以阻止onunload的执行；而onunload则已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。Onunload是无法阻止页面的更新和关闭的。而 Onbeforeunload 可以做到。
（2）触发顺序
页面加载时只执行onload
页面关闭时先执行onbeforeunload，最后onunload
页面刷新时先执行onbeforeunload，然后onunload，最后onload。
（3）onload()当窗体第一次调用时使用的文件句柄
（4）用onUnload方法 
在body 标签里加入onUnload事件 
body onUnload="myClose()" 
然后在javascript里定义myClose()方法 
注意：onUnload方法是在关闭窗口之后执行，不是在关闭窗口之前执行，如果你想在关闭窗口之前做判断，只能用onbeforeunload
（5）用window.onbeforeunload()
例例例例例例例例例例例例例例例例例例
function window.onbeforeunload() { 
if (event.clientX>document.body.clientWidth && event.clientY<0 ||event.altKey) // if ((window.event.screenX - window.screenLeft) > (document.documentElement.scrollWidth - 20) && window.event.clientY < 0 || window.event.altKey)
window.event.returnValue="确定要退出cn-web.com吗？"; 
} 
例例例例例例例例例例例例例例例例例例


2、事件绑定
obj.onclick = function () {};
obj.setAttribute('onclick', function() {} );

//同一事件可绑定多个方法
obj.attachEvent('onclick', function() {} );
obj.attachEvent('onclick', fun3);
  function fun3(){
  }







3、键值处理
（1）键值
keycode   8 = BackSpace BackSpace
keycode   9 = Tab Tab

keycode 12 = Clear
keycode 13 = Enter

keycode 16 = Shift_L
keycode 17 = Control_L
keycode 18 = Alt_L
keycode 19 = Pause
keycode 20 = Caps_Lock

keycode 27 = Escape Escape

keycode 32 = space space
keycode 33 = Prior
keycode 34 = Next
keycode 35 = End
keycode 36 = Home
keycode 37 = Left
keycode 38 = Up
keycode 39 = Right
keycode 40 = Down
keycode 41 = Select
keycode 42 = Print
keycode 43 = Execute

keycode 45 = Insert
keycode 46 = Delete
keycode 47 = Help
keycode 48 = 0 equal braceright
keycode 49 = 1 exclam onesuperior
keycode 50 = 2 quotedbl twosuperior
keycode 51 = 3 section threesuperior
keycode 52 = 4 dollar
keycode 53 = 5 percent
keycode 54 = 6 ampersand
keycode 55 = 7 slash braceleft
keycode 56 = 8 parenleft bracketleft
keycode 57 = 9 parenright bracketright

keycode 65 = a A
keycode 66 = b B
keycode 67 = c C
keycode 68 = d D
keycode 69 = e E EuroSign
keycode 70 = f F
keycode 71 = g G
keycode 72 = h H
keycode 73 = i I
keycode 74 = j J
keycode 75 = k K
keycode 76 = l L
keycode 77 = m M mu
keycode 78 = n N
keycode 79 = o O
keycode 80 = p P
keycode 81 = q Q at
keycode 82 = r R
keycode 83 = s S
keycode 84 = t T
keycode 85 = u U
keycode 86 = v V
keycode 87 = w W
keycode 88 = x X
keycode 89 = y Y
keycode 90 = z Z

keycode 96 = KP_0 KP_0
keycode 97 = KP_1 KP_1
keycode 98 = KP_2 KP_2
keycode 99 = KP_3 KP_3
keycode 100 = KP_4 KP_4
keycode 101 = KP_5 KP_5
keycode 102 = KP_6 KP_6
keycode 103 = KP_7 KP_7
keycode 104 = KP_8 KP_8
keycode 105 = KP_9 KP_9
keycode 106 = KP_Multiply KP_Multiply
keycode 107 = KP_Add KP_Add
keycode 108 = KP_Separator KP_Separator
keycode 109 = KP_Subtract KP_Subtract
keycode 110 = KP_Decimal KP_Decimal
keycode 111 = KP_Divide KP_Divide
keycode 112 = F1
keycode 113 = F2
keycode 114 = F3
keycode 115 = F4
keycode 116 = F5
keycode 117 = F6
keycode 118 = F7
keycode 119 = F8
keycode 120 = F9
keycode 121 = F10
keycode 122 = F11
keycode 123 = F12
keycode 124 = F13
keycode 125 = F14
keycode 126 = F15
keycode 127 = F16
keycode 128 = F17
keycode 129 = F18
keycode 130 = F19
keycode 131 = F20
keycode 132 = F21
keycode 133 = F22
keycode 134 = F23
keycode 135 = F24
keycode 136 = Num_Lock
keycode 137 = Scroll_Lock

keycode 187 = acute grave
keycode 188 = comma semicolon
keycode 189 = minus underscore
keycode 190 = period colon

keycode 192 = numbersign apostrophe

keycode 210 = plusminus hyphen macron
keycode 211 =
keycode 212 = copyright registered
keycode 213 = guillemotleft guillemotright
keycode 214 = masculine ordfeminine
keycode 215 = ae AE
keycode 216 = cent yen
keycode 217 = questiondown exclamdown
keycode 218 = onequarter onehalf threequarters

keycode 220 = less greater bar
keycode 221 = plus asterisk asciitilde

keycode 227 = multiply division
keycode 228 = acircumflex Acircumflex
keycode 229 = ecircumflex Ecircumflex
keycode 230 = icircumflex Icircumflex
keycode 231 = ocircumflex Ocircumflex
keycode 232 = ucircumflex Ucircumflex
keycode 233 = ntilde Ntilde
keycode 234 = yacute Yacute
keycode 235 = oslash Ooblique
keycode 236 = aring Aring
keycode 237 = ccedilla Ccedilla
keycode 238 = thorn THORN
keycode 239 = eth ETH
keycode 240 = diaeresis cedilla currency
keycode 241 = agrave Agrave atilde Atilde
keycode 242 = egrave Egrave
keycode 243 = igrave Igrave
keycode 244 = ograve Ograve otilde Otilde
keycode 245 = ugrave Ugrave
keycode 246 = adiaeresis Adiaeresis
keycode 247 = ediaeresis Ediaeresis
keycode 248 = idiaeresis Idiaeresis
keycode 249 = odiaeresis Odiaeresis
keycode 250 = udiaeresis Udiaeresis
keycode 251 = ssharp question backslash
keycode 252 = asciicircum degree
keycode 253 = 3 sterling
keycode 254 = Mode_switch 

keyCode属性：  表示键盘按键码。因此输入“a”字母和“A”字母时，都是显示键盘码 65 ；IE 与  w 3c兼容浏览器 keydown ,keyup 时 event 的 keyCode 为实际按键的值 。例如：shift + a ==  16 + 65
charCode 属性：表示输入字符码。因此输入“a”字母和“A“字母时，分别显示 97（a 字符码）和 65（A 字符码）；w3c兼容浏览器在 keypress（shift等非实际值键忽略） 时 event 存在 charCode 属性为对应字符值，keyCode 统一为0。IE 只有 keyCode， 则在 keypress（shift等非实际值键忽略） 时仍然采用 keyCode ，不过此时为对应字符值，没有charCode 属性。例如：
shift + a ： {
ie: keyCode :97 ,charCode:undefined
firefox : keyCode:0 ,charCode:97
}
注意：
在标准的DOM 中：既有keyCode属性，还有charCode 属性。
        但在标准的DOM 中，keypress 事件中keyCode 属性值始终为0 值；
在IE 浏览器中：事件对象只有keyCode属性，没有charCode 属性。
        但在IE 浏览器中，keypress 事件中的keyCode 属性值等同于标准DOM 中的charCode 属性的值；
如果要使用组合键，则可以利用event.ctrlKey，event.shiftKey，event .altKey判断是否按下了ctrl键、shift键以及alt键，如：
if( window.event.shiftKey && event.keyCode==xx)


4、事件终止
retrun true； 返回正确的处理结果。
return false；返回错误的处理结果，终止处理。
return；把控制权返回给页面。
window.event.returnvalue = false;

格式：
（1）event.keyCode = 0;return false;
event.keyCode的作用：将当前的KeyCode值变为0，就是一个赋值作用。在用于事件终止时，在事件中要与return false配合使用，终止点为事件返回值位置。（是一个属性值）
（2）event.returnvalue = false;
event.returnValue的作用：当捕捉到事件(event)时，做某些判断，如果判断失败，则阻止当前事件继续运行。在用于事件终止时，直接使用，终止点为执行位置。（是一个状态值）


例：屏蔽键盘所有键
例例例例例例例例例例例例例例例例例
<script language="javascript">
<!--
function document.onkeydown(){
event.keyCode = 0;
event.returnvalue = false;
}
-->
</script>
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
<script type="text/javascript">
function form1(){
event.returnValue = false;
}
function form2(){
return false;
}
</script>
----------------------------------------------------------------
<form onsubmit="form1()">  <!-- 1 -->
<fieldset><legend>event.returnValue = false</legend> <input
    type="submit" /></fieldset>
</form>
<form onsubmit="return form2()"> <!-- 2 -->
<fieldset><legend>return false的正确用法</legend> <input
    type="submit" /></fieldset>
</form>
<form onsubmit="form2()"> <!-- 3 -->
<fieldset><legend>return false的错误用法</legend> <input
    type="submit" /></fieldset>
</form>
----------------------------------------------------------------
三个提交的onsubmit属性都是想让表单提交之前验证，验证失败则不提交表单。第一、二两处做到了，第三出没做到。
   这个只有运行起来才能看到结果
   1处，表单没有提交
   2处，表单没有提交
   3处，表单提交了。这不是希望的
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例





I、Cookie
   1.创建Cookie 
   我们要进行的第一件事就是要创建一个Cookie。下面给出的SctCookie()函数将完成这一功能。
   function SetCookit (name, value) {
     var argv=SetCookie.arguments;
     var argc=SetCookie.arguments.length;
     var expires=(argc>2)?argv[2]: null;
     var path=(argc>3)? argv[3]: null;
     var domain=(argc>4)? argv[4]: null;
     var secure=(argc>5)? argv[5]: false;
     documents.cookie=name+"="+escape
       (value)+
     ((expires==null)?"":(";expires="
       +expires.toGMTString()))+
     ((path==null)?"":(";path="+path))+
     ((domain==null)?"":(";domain="+
       domain))+
     ((secure==true)?";secure":"");
   }
   SetCookie()只要求传递被设置的Cookie的名字和值，但如果必要的话你可以设置其他4 个参数而不必改变这个函数。可选的参数必须用正确的次序使用。如果不想设置某个参数，必须设置一个空串。比如，如果我们创建的一个Cookie需要指定secure域，但不想设置expires, patb或domain，就可以像这样调用SetCokie():  SetCookie("MyN
ewCookie", "Myvalue" , "", "tyue");
   2.读取Cookie 
   下面给出的函数GetCookie()用来读取一个Cookie。当一个Cookie的请求被客户机收到时，该客户机查找它的cookies.txt文件以进行匹配。这个函数首先匹配这个Cookie的名字。如果有多个同名的Cookie，它再匹配路径。函数完成匹配后返回这个Cookie的值。如果客户机中没有这个Cookie，或者路径不匹配，该函数返回一个NULL。
   function GetCookie(name) {
     var arg=name+ "=";
     var alen=arg.length;
     var clen=documents.cookie.length;
     var i=0;
     while (i<clen) {
       var j=i+alen;
       if(documents.cookie.substring(i, j)
       ==arg)
       return getCookieVal(j);
       i=documents.cookie.indexOf("", i)+1;
       if(i==0)break;
     }
     return null;
   }
   函数中使用了getCookieVal()函数，它是GetCookie()函数的补充。getCookieVal()将C ookies.txt文件分解为片断，并从一批Cookie中读出正确的Cookie。该函数的实现如下:
   function getCookieVal(offset) {
     var endstr=documents.cookie.indexOf
       (";", offset);
     if(endstr==-1) //没有指定其他元素
       endstr=documents.cookie.length;
     return unescape(documents.cookie.substring
       (offset, endstr));
   }
   3.删除Cookie
   删除一个Cookie很简单，只需将它的过期时间设为NULL。当用户断开连接后，这个Cookie就过期了(没有过期时间的Cookie将在浏览器关闭时被删除)。下面的函数DeleteCookie() 说明了如何删除一个Cookie:
   function DeleteCookie(name) {
     var exp=new Date();
     exp.setTime(exp.getTime()-1);
     //将exp设为已过期的时间
     var cval=GetCookie(name);
     documents.cookie=name+"="+cval+";
     expires="+exp.toGMTString();
   }






J、其它
1、载入js文件时中文变成乱码
解决办法：
（1）charset="gb2312"，在包含代码中加入charset，<script charset="gb2312" src="/xxx.js" language="javascript"></script>
（2）把js文件保存为当前页面编码（如utf-8）

2、alert时候，后台仍继续运行，但画面不改变

3、一句代码获取网页里的所有JS脚本!
javascript:var s=document.getElementsByTagName("script");var l=s.length;var str="";for(var i=0;i<l;i++){str+="\n代码"+i+"\n"+(s[i].src||s[i].innerHTML)+"\n";}document.write("<textarea style='width:100%;height:350px;'>"+str+"</textarea>");void(0)



4、通过在浏览器地址栏敲入以下Javascript代码查看Body元素包含的内容：
javascript:document.write(document.body.innerHTML.replace(/</g, "&lt;").replace(/>/g, "&gt;"))


5、下面的js代码可以查看某个层包含的内容：
javascript:document.write(document.getElementByIdx_x('div1').innerHTML.replace(/</g, "&lt;").replace(/>/g, "&gt;"))

6、ENTER键可以让光标移到下一个输入框
<input onkeydown="if(event.keyCode==13)event.keyCode=9">

7、一个数组的最后添加一个元素
var myArray = [];  myArray[myArray.length] = 'New Element';  

8、异步加载js
 创建script，插入到DOM中，加载完毕后callBack，见代码：
function loadScript(url, callback){
    var script = document.createElement("script")
    script.type = "text/javascript";
    if (script.readyState){ //IE
        script.onreadystatechange = function(){
            if (script.readyState == "loaded" || script.readyState == "complete"){
                script.onreadystatechange = null;
                callback();
            }
        };
    }
    else { //Others: Firefox, Safari, Chrome, and Opera
        script.onload = function(){
        callback();
        };
    }
    script.src = url;
    document.body.appendChild(script);
}

9、这个技巧可以让你在number的结尾添加一个空的string来把number转换成string，例如：
var mynumber = 234;  
typeof mynumber; //Number     
mynumber += '';  
typeof mynumber; //String 

10、和其他编程语言不同的是，在 JavaScript 中，'+'除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符'++'混淆而引起计算错误。
 var valueA = 20; 
 var valueB = "10"; 
 alert( valueA + valueB);     //ouput: 2010 
 alert( valueA + (+valueB)); //output: 30 
 alert( valueA + +valueB);    //output:30 
 alert( valueA ++valueB);     //Compile error 

11、检测某个网站的链接速度：
把如下代码加入<body>区域中:
<script language=javascript>
tim=1
setInterval("tim++", 100)
b=1

var autourl=new Array()
autourl[1]="http://www.aa25.cn/";
autourl[2]=www.aa24.cn/";
autourl[3]="www.aa24.com.cn/";
autourl[4]="http://www.9tour.cn/";
autourl[5]="http://www.cctv.com/";

function butt(){
document.write("<form name=autof>"
for(var i=1;i<autourl.length;i++)
document.write("<input type=text name=txt"+i+" size=10 value=测试中……> =》<input type=text 

name=url"+i+" size=40> =》<input type=button value=GO 

onclick=window.open(this.form.url"+i+".value)><br>"
document.write("<input type=submit value=刷新></form>"
}
butt()
function auto(url){
document.forms[0]["url"+b].value=url
if(tim>200)
{document.forms[0]["txt"+b].value="链接超时"}
else
{document.forms[0]["txt"+b].value="时间"+tim/10+"秒"}
b++
}
function run(){for(var i=1;i<autourl.length;i++)document.write("<img 

src=http://"+autourl+"/"+Math.random()+" width=1 height=1 

onerror=auto(http://";+autourl+"`)>"}
run()</script>

12、如何给图片抖动怎做的. 
<SCRIPT language=javascript1.2> 
<!-- 
        var rector = 2
        var stopit = 0
        var a = 1
        var count = 0
        function init(which) {
            stopit = 0
            shake = which
            shake.style.left = 0
            shake.style.top = 0
        } 
        function rattleimage() {
            if ((!document.all && !document.getElementById) || stopit == 1 || count == 100)
                return
            count++
            if (a == 1) {
                shake.style.top = parseInt(shake.style.top) + rector
            }
            else if (a == 2) {
                shake.style.left = parseInt(shake.style.left) + rector
            }
            else if (a == 3) {
                shake.style.top = parseInt(shake.style.top) - rector
            }
            else {
                shake.style.left = parseInt(shake.style.left) - rector
            }
            if (a < 4)
                a++
            else
                a = 1
            setTimeout("rattleimage()", 50)
        }
        function stoprattle(which) {
            stopit = 1
            count = 0
            which.style.left = 0
            which.style.top = 0
        } 
//--> 
</SCRIPT> 
<style>.shakeimage {POSITION: relative} 
</style> 
<img src="22.png" onmouseout=stoprattle(this) onmouseover=init(this);rattleimage() class=shakeimage>

13、防止查看源代码
<html>
<head>
<script language="javascript">
function clear(){
 Source=document.body.firstChild.data;
 document.open();
 document.close();
 document.title="看不到源代码";
 document.body.innerHTML=Source;
}
</script>
</head>
<body onload=clear()>
<!--
这招算是目前网上公布的防止查看源代码的方法中最好的了，当然了，要看还是办法的，比如在地址栏中输入<br>
javascript:alert(document.documentElement.outerHTML); 
-->
</body>
</html>
文章出处：标准之路(http://www.aa25.cn/code/226.shtml)


14、网页不会被缓存
<META HTTP-EQUIV="pragma" CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<META HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT">
或者<META HTTP-EQUIV="expires" CONTENT="0">


15、让弹出窗口总是在最上面:
<body onblur="this.focus();">


16、怎样去掉图片链接点击后，图片周围的虚线？
<a href="#" onFocus="this.blur()"><img src="logo.jpg" border=0></a>


17、在打开的子窗口刷新父窗口的代码里如何写？
window.opener.location.reload()


18、document.execCommand()的用法小记
首先要说明的是在firefox下支持不好。
2D-Position 允许通过拖曳移动绝对定位的对象。 
AbsolutePosition 设定元素的 position 属性为“absolute”(绝对)。 
BackColor 设置或获取当前选中区的背景颜色。 
BlockDirLTR 目前尚未支持。 
BlockDirRTL 目前尚未支持。 
Bold 切换当前选中区的粗体显示与否。 
BrowseMode 目前尚未支持。 
Copy 将当前选中区复制到剪贴板。 
CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。 
CreateLink 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。 
Cut 将当前选中区复制到剪贴板并删除之。 
Delete 删除当前选中区。 
DirLTR 目前尚未支持。 
DirRTL 目前尚未支持。 
EditMode 目前尚未支持。 
FontName 设置或获取当前选中区的字体。 
FontSize 设置或获取当前选中区的字体大小。 
ForeColor 设置或获取当前选中区的前景(文本)颜色。 
FormatBlock 设置当前块格式化标签。 
Indent 增加选中文本的缩进。 
InlineDirLTR 目前尚未支持。 
InlineDirRTL 目前尚未支持。 
InsertButton 用按钮控件覆盖当前选中区。 
InsertFieldset 用方框覆盖当前选中区。 
InsertHorizontalRule 用水平线覆盖当前选中区。 
InsertIFrame 用内嵌框架覆盖当前选中区。 
InsertImage 用图像覆盖当前选中区。 
InsertInputButton 用按钮控件覆盖当前选中区。 
InsertInputCheckbox 用复选框控件覆盖当前选中区。 
InsertInputFileUpload 用文件上载控件覆盖当前选中区。 
InsertInputHidden 插入隐藏控件覆盖当前选中区。 
InsertInputImage 用图像控件覆盖当前选中区。 
InsertInputPassword 用密码控件覆盖当前选中区。 
InsertInputRadio 用单选钮控件覆盖当前选中区。 
InsertInputReset 用重置控件覆盖当前选中区。 
InsertInputSubmit 用提交控件覆盖当前选中区。 
InsertInputText 用文本控件覆盖当前选中区。 
InsertMarquee 用空字幕覆盖当前选中区。 
InsertOrderedList 切换当前选中区是编号列表还是常规格式化块。 
InsertParagraph 用换行覆盖当前选中区。 
InsertSelectDropdown 用下拉框控件覆盖当前选中区。 
InsertSelectListbox 用列表框控件覆盖当前选中区。 
InsertTextArea 用多行文本输入控件覆盖当前选中区。 
InsertUnorderedList 切换当前选中区是项目符号列表还是常规格式化块。 
Italic 切换当前选中区斜体显示与否。 
JustifyCenter 将当前选中区在所在格式化块置中。 
JustifyFull 目前尚未支持。 
JustifyLeft 将当前选中区所在格式化块左对齐。 
JustifyNone 目前尚未支持。 
JustifyRight 将当前选中区所在格式化块右对齐。 
LiveResize 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。 
MultipleSelection 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。 
Open 打开。 
Outdent 减少选中区所在格式化块的缩进。 
OverWrite 切换文本状态的插入和覆盖。 
Paste 用剪贴板内容覆盖当前选中区。 
PlayImage 目前尚未支持。 
Print 打开打印对话框以便用户可以打印当前页。 
Redo 重做。 
Refresh 刷新当前文档。 
RemoveFormat 从当前选中区中删除格式化标签。 
RemoveParaFormat 目前尚未支持。 
SaveAs 将当前 Web 页面保存为文件。 
SelectAll 选中整个文档。 
SizeToControl 目前尚未支持。 
SizeToControlHeight 目前尚未支持。 
SizeToControlWidth 目前尚未支持。 
Stop 停止。 
StopImage 目前尚未支持。 
StrikeThrough 目前尚未支持。 
Subscript 目前尚未支持。 
Superscript 目前尚未支持。 
UnBookmark 从当前选中区中删除全部书签。 
Underline 切换当前选中区的下划线显示与否。 
Undo 撤消。 
Unlink 从当前选中区中删除全部超级链接。 
Unselect 清除当前选中区的选中状态。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
例1：
    isNaN是测试是否为数值型 ，限制输入只能为数值如：1981.121，允许最多有一个小数点 

<input type="text" name="text" onkeyup="if(isNaN(value))execCommand('undo')" />
例2：
<input type=button value=剪切 onclick=document.execCommand('Cut')>
<input type=button value=拷贝 onclick=document.execCommand('Copy')>
<input type=button value=粘贴 onclick=document.execCommand('Paste')>
<input type=button value=撤消 onclick=document.execCommand('Undo')>
<input type=button value=重做 onclick=document.execCommand('Redo') id=button2 name=button2>
<input>
<input type=button value=删除 onclick=document.execCommand('Delete')>
<input type=button value=黑体 onclick=document.execCommand('Bold')>
<input type=button value=斜体 onclick=document.execCommand('Italic')>
<input type=button value=下划线 onclick=document.execCommand('Underline')>
<input type=button value=停止 onclick=document.execCommand('stop')>
<input type=button value=保存 onclick=document.execCommand('SaveAs')>
<input type=button value=另存为 onclick=document.execCommand('Saveas', false, 'c:\\test.htm')>
<input type=button value=字体 onclick=document.execCommand('FontName', false, fn)>
<input type=button value=字体大小 onclick=document.execCommand('FontSize', false, fs)>
<input type=button value=刷新 onclick=document.execCommand('refresh', false, 0)>

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


19、
防止点击空链接时，页面往往重置到页首端。 
代码“javascript:void(null)”代替原来的“#”标记 

页面定时刷新
<meta http-equiv="refresh" content="秒" > 

页面定时转向新的地址
<meta http-equiv="refresh" content="秒;url=url"> 

设为首页代码
<a href=# onclick="this.style.behavior='url(#default#homepage)';this.sethomepage('url');">设为首页</a> 

添加收藏代码
<a href="javascript:window.external.addfavorite('url', 'title')">加入收藏夹</a> 


加入背景音乐 
IE:<bgsound src="*.mid" loop=infinite> 
NS:<embed src="*.mid" autostart=true hidden=true loop=true> 
  </embed> 
*.mid你的背景音乐的midi格式文件 


最小化、最大化、关闭窗口
<object id=hh1 classid="clsidDB880A6-D8FF-11CF-9377-00AA003B7A11"> 
<param name="Command" value="Minimize"></object> 
<object id=hh2 classid="clsidDB880A6-D8FF-11CF-9377-00AA003B7A11"> 
<param name="Command" value="Maximize"></object> 
<OBJECT id=hh3 classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"> 
<PARAM NAME="Command" value="Close"></OBJECT> 
<input type=button value=最小化 onclick=hh1.Click()> 
<input type=button value=最大化 onclick=hh2.Click()> 
<input type=button value=关闭   onclick=hh3.Click()> 



20、B/S模式利用FileUpload上传文件，过滤文件类型的方法
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
<script type="text/javascript">
   function CheckFile(str)
   {
        var strRegex = "(.jpg|.JPG|.gif|.GIF)$"; //用于验证图片扩展名的正则表达式
        var re=new RegExp(strRegex);

        if (re.test(str)){
            return (true);
        }
        else{
            alert("禁止的文件扩展名"); 
            return (false);
        }
   }
</script>

<asp:FileUpload ID="FileUpload1" runat="server" onchange="CheckFile(this.value);" /> 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例


21、脚本永不出错
<SCRIPT LANGUAGE="javascript"> 
<!-- Hide 
function killErrors() { 
return true; 
} 
window.onerror = killErrors; 
// --> 
</SCRIPT>





22、页面进入和退出的特效
进入页面<meta http-equiv="Page-Enter" content="revealTrans(duration=x, transition=y)">
推出页面<meta http-equiv="Page-Exit" content="revealTrans(duration=x, transition=y)"> 
这个是页面被载入和调出时的一些特效。Duration表示特效的持续时间，以秒为单位。Transition表示使

用哪种特效，取值为1-23:
0 矩形缩小 
1 矩形扩大 
2 圆形缩小
3 圆形扩大 
4 下到上刷新 
5 上到下刷新
6 左到右刷新 
7 右到左刷新 
8 竖百叶窗
9 横百叶窗 
10 错位横百叶窗 
11 错位竖百叶窗
12 点扩散 
13 左右到中间刷新 
14 中间到左右刷新
15 中间到上下
16 上下到中间 
17 右下到左上
18 右上到左下 
19 左上到右下 
20 左下到右上
21 横条 
22 竖条 
23 以上22种随机选择一种


23、判断浏览器语言
if (navigator.browerLanguage == "zh-cn") {
    alert("The language is Chinese!");
}


24、客户端判断上传图片大小
（1）
<input type="file" name="Photo" onpropertychange="document.getElementById('PhotoImg').src=document.HwForm.Photo.value;" />

<IMG id="PhotoImg" style="POSITION:absolute;TOP:100px;LEFT:100px;" onerror="alert('请选择一个图像文件');" onload="if(document.getElementById('PhotoImg').fileSize>1024*FileMaxSize){alert('图片不能大于'+FileMaxSize+'K，请重新选择');}" />

（2）
function ShowSize(files)  
{  
  var fso, f;  
  fso=new ActiveXObject("Scripting.FileSystemObject");  
  f=fso.GetFile(files);
  var mySize = f.size/1024;
  alert(mySize+" K ");  
}  

25、浏览器的“另存为”
                        //var downdom = window.open(filepath); //这个方法就直接把这个TXT以浏览器的方式打开了  
                        //downdom.document.execCommand("SaveAs");
                        //downdom.document.execCommand('saveas', false, '*.jpg')
                        //downdom.close();

26、
    document.body.clientWidth ==> BODY对象宽度  
    document.documentElement.clientWidth ==> 可见区域宽度
    document.body.scrollWidth ==> 网页正文全文宽

27、
var s = doc.createElement("script"), h = doc.getElementsByTagName("head")[0];
if (!win.alimamatk_show) {
    s.charset = "utf8";
    s.async = true;
    s.src = "http://a.alimama.cn/tkapi.js";
    h.insertBefore(s, h.firstChild);
};


二十三、JQuery
A、概念
1、返回值
注意:在javaScript中函数返回值为null表示false 
*** 当id不在时，采用DOm处理处理会显示错误
*** 当id不在时，采用Jquery 处理不会显示错误

B、自定义添加“$”

String.Format = function() {
 
 if(arguments.length == 0)
  return "";
 
 if(arguments.length == 1)
  return arguments[0];
 
 var reg = /{(\d+)?}/g;
 var args = arguments;
 var result = arguments[0].replace(
  reg,
  function($0, $1) {
   return  args[parseInt($1)+1];
  }
 )

 return result;
}
使用：alert(String.Format('欢迎使用具有{0}功能的{1}语句', "C#", 'JavaScript'));


C、“$”选择器
1、元素定位
（1）元素选择器
$("a[title=ok]").addClass("myClass")                        //选择如<a href="www.baidu.com" title="ok">百度</a>，添加css=myClass
等同于$("a").find("[title=ok]").addClass("myClass")         //都可以选择子孙节点
$("a[href=www.baidu.com]")
$("a[href^=www]")                                           //^=www，以www开头的href
$("a[href$=.com]")                                          //^=.com，以.com结尾的href
$("input")                                                  //选择标签<input></input>
    例例例例例例例例例例例例例例例例例例例例例
    //判断元素是否存在
    if(document.getElementById('div'))
    if ($("#div").length > 0){     }
    例例例例例例例例例例例例例例例例例例例例例
$("#idOne")                                   //选择id=idOne的标签
$("input[href]")                              //选择带有href属性的<input>标签
$(".Someclass")                               //选择css=Someclass的标签
（以下两种方法相同）
$("img[little]")[1]
$("img[little]").get(1)
不带参数的get()方法也可将元素集转换为数组，如：var array=$("img[little]").get();

（2）元素查找
例例例例例例例例例例例例例例例例例例例例例
<div class="css">
<p class="myClass">测试1</p>
</div>

<div class="myClass">
<p>测试2</p>
</div>
例例例例例例例例例例例例例例例例例例例例例
<1>filter----在选择对象的outhtml查找，是对自身集合元素的筛选
功能：对元素集中的各元素进行过滤，例：
 $("div").filter(".myClass");           //结果为测试2
<2>find----在选择对象的innerhtml查找，是对子集元素的查找
功能：在元素集中的各元素的子元素集内进行查找，是否有符合条件的元素（包括子孙节点），例：
 $("div").find(".myClass");             //结果为测试1        //等同于$("div.css=myClass")   可选择子孙节点
<3>siblings
功能：查找指定元素的兄弟节点，例：
 $("div.css").siblings(".myClass");     //结果为<div class="myClass"><p>测试2</p></div>
<4>next、prev
功能：查找指定节点的下（前）一个兄弟节点
<5>nextAll、prevAll
功能：查找指定节点的后（前）面的所有兄弟节点
<6>parent
功能：查找上级节点（父节点）
<7>parents
功能：查找所有符合条件的上级节点（祖先节点）
<8>children
功能：查找所有直接子节点（不可选择孙节点）
<9>not
功能：查找到的节点集合中反选
<10>slice()
功能：选择节点集合中的片段
<11>eq
功能：结果集中选择指定元素
<12>contains
功能：返回对象的text中包含指定字符串的对象，例：
$("p").contains("this is").html;
<13>index
功能：返回指定对象的索引，例：
$("div").index(document.getElementById('test1'))
<14>each()
功能：遍历元素集，它可以遍历一维数组、多维数组、DOM , JSON等等，例：
例例例例例例例例例例例例例例例例例例例例例
 $("img").each(function(index){
   this.title = "this is picture " + index + ", id is " + this.id;
 }
例例例例例例例例例例例例例例例例例例例例例
          $(arrays).each(function(){

                  console.log("\t" + this);

          });
例例例例例例例例例例例例例例例例例例例例例
跳出循环方法：
return true将停止循环 (就像在普通的循环中使用 'break')。 
return false跳至下一个循环(就像在普通的循环中使用'continue')。 
<15>$.each()
功能：遍历数组或dom元素集
格式：$.each(obj, function(i, item){}  );
例1：遍历一维数组
例例例例例例例例例例例例例例例例例例例例例
each处理一维数组

  var arr1 = [ "aaa", "bbb", "ccc" ];      
  $.each(arr1, function(i, val){      
      alert(i);   
      alert(val);
  });   
alert(i)将输出0，1，2
alert(val)将输出aaa,bbb,ccc
例例例例例例例例例例例例例例例例例例例例例
例2：遍历二维数组  
例例例例例例例例例例例例例例例例例例例例例
    var arr2 = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']]      
    $.each(arr, function(i, item){      
      alert(i);   
      alert(item);      
    });  
arr2为一个二维数组，item相当于取这二维数组中的每一个数组。
item[0]相对于取每一个一维数组里的第一个值   
alert(i)将输出为0，1，2，因为这二维数组含有3个数组元素
alert(item)将输出为  ['a', 'aa', 'aaa']，['b', 'bb', 'bbb']，['c', 'cc', 'ccc']
例例例例例例例例例例例例例例例例例例例例例
例3：遍历二维数组2
对此二位数组的处理稍作变更之后
例例例例例例例例例例例例例例例例例例例例例
 var arr = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']]      
     $.each(arr, function(i, item){      
          $.each(item, function(j, val){
                alert(j);
                alert(val);
      }); 
});    
 alert(j)将输出为0，1，2，0，1，2，0，1，2

 alert(val)将输出为a，aa，aaa，b，bb，bbb，c，cc，ccc
例例例例例例例例例例例例例例例例例例例例例
例4：遍历json数据
例例例例例例例例例例例例例例例例例例例例例
     var obj = { one:1, two:2, three:3};      
     each(obj, function(key, val) {      
          alert(key);   
          alert(val);      
     });   
这里alert(key)将输出one two three
alert(val)将输出one,1,two,2,three,3
这边为何key不是数字而是属性呢，因为json格式内是一组无序的属性-值，既然无序，又何来数字呢。
而这个val等同于obj[key]
例例例例例例例例例例例例例例例例例例例例例
例5：遍历dom元素
ecah处理dom元素，此处以一个input表单元素作为例子。
如果你dom中有一段这样的代码
<input name="aaa" type="hidden" value="111" />
<input name="bbb" type="hidden" value="222" />
<input name="ccc" type="hidden" value="333" />
<input name="ddd" type="hidden" value="444" />
例例例例例例例例例例例例例例例例例例例例例
 $.each($("input:hidden"), function(i, val){  
     alert(val);
     alert(i);
     alert(val.name);
     alert(val.value);   
 });  
那么，alert(val)将输出[object HTMLInputElement]，因为它是一个表单元素。   
alert(i)将输出为0，1，2，3 
alert(val.name);将输出aaa, bbb, ccc, ddd，如果使用this.name将输出同样的结果
alert(val.value);  将输出111, 222, 333, 444，如果使用this.value将输出同样的结果
例例例例例例例例例例例例例例例例例例例例例
如果将上面一段代码改变成如下的形式  
$("input:hidden").each(function(i, val){
    alert(i);
    alert(val.name);
    alert(val.value);       
});
 可以看到，输出的结果是一样的，至于两种写法究竟区别在哪，我也还不知。此改变运用到上面几段数组的操作也会输出同样的结果。

JQuery.each的源码
源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源
function (object, callback, args) {
//该方法有三个参数:进行操作的对象obj，进行操作的函数fn，函数的参数args
var name, i = 0, length = object.length;
if (args) {
    if (length == undefined) {
        for (name in object) {
            if (callback.apply(object[name], args) === false) {
            break;
            }
        }
    } else {
        for (; i < length;) {
            if (callback.apply(object[i++], args) === false) {
            break;
            }
        }
    }
} else {
if (length == undefined) {
    for (name in object) {
        if (callback.call(object[name], name, object[name]) === false) {
            break;
        }
    }
} else {
for (var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {}
/*object[0]取得jQuery对象中的第一个DOM元素，通过for循环，
得到遍历整个jQuery对象中对应的每个DOM元素，通过 callback.call( value, i, value);
将callback的this对象指向value对象，并且传递两个参数，i表示索引值，value表示DOM元素；
其中callback是类似于 function(index, elem) { ... } 的方法。
所以就得到 $("...").each(function(index, elem){ ... });
*/
}
}
return object;
}
源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源源




<16>获取子孙节点
Question:如何用jquery来选取一个元素特定的子孙节点(不只是children，还有可能是孙子等)
$("#doRoutingBody [name='doRouting.fromSite.id']") 
$("#doRoutingBody").find(" [name='doRouting.fromSite.id']"); 

<17>判断元素存在
通常我们要判断某个元素是否存在是用：
    if(document.getElementById('example')) {  
        // do something  
    }  
    else {  
        // do something else  
    }  


然而在使用jQuery时，我们可以使用：

    if($('#example').length) {

        // do something
}

    else {

        // do something else

    }

<18>result
  $("button").click(function(e) {
    return ("最后一次点击的鼠标位置是： X" +e.pageX + ", Y" + e.pageY);
  });
  $("button").click(function(e) {
    $("p").html(e.result);
    





2、元素过滤器
（1）选择子元素
$("li>a")                                     //<li>下的所有子元素<a>，不包括孙元素
$("table tr");                                //<table>下的所有子孙元素<tr>，包括孙元素
$("ul li a");                                 //<ul>下的<li>下的所有子孙元素<a>，包括孙元素
（2）元素筛选
1）has
$("ul li:has(a)")                             //<ul>下的<li>（包含<a>的），最终选择的是<li>
$("ul li a")                                  //<ul>下的<li>下的<a>，最终选择的是<a>
区别：前者选择的是<li>，后者选择的是<a>
2）eq、gt、lt、ge、le
$("ul li:eq(0)")                              //<ul>下索引为0的<li>，结果为jQuery对象
也可写成：$("ul li").eq(0)
$("ul li").get(0)等同于$("ul li")[0]          //<ul>下索引为0的<li>，结果为html对象，与$("ul li")[0]相同
区别：eq返回的是一个jQuery对象，get返回的是一个html 对象数组
$("ul li:eq(1)").css("color", "red"); //因为eq(num)返回的是个jquery的对象，所以可以用jquery的方法css。
$("ul li").get(1).style.color="red"; //因为get(num)返回的是个html对象，所以要使用传统的HTML对象方法，jquery对象此时就没用了。
3）checked、disabled
$("input:checked").attr("checked", "")        //寻找带有checked属性的input标签

注：
除eq外，还有:
例：$("ul li:ge(2)")                        //<ul>下索引>=2的<li>
:eq(n)  =
:gt(n)  >
:lt(n)  <
:ge(n)  >=
:le(n)  <=
-------------------------------------------------------------------------------------------
$("p:odd")
$("p:even")
$("p:first-child")                            //选择所有<p>标记，并且这些<p>标记是其父标记的第一个子标记
$("p:odd")                                    //选择"总页面中"奇数行的<p>标记
$("p:nth-child(odd)")                         //选择"各父标记下的"奇数行的<p>标记
该部分选择器功能介绍：
html部分：
  <p>textA1</p>
<div>
  <h1>
    <p>textB1</p>
    <p>textB2</p>
    <p>textB3</p>
  </h1>
    <p>textC1</p>
    <p>textC2</p>
</div>
<div>
    <p>textD1</p>
    <p>textD2</p>
  <h2>
    <p>textE1</p>
    <p>textE2</p>
  </h2>
</div>
说明：
$("p:first|last")               //选取所有<p>为一个元素集，选中第1行或最后1行（A1或E2）
$("p:odd|even")                 //选取所有<p>为一个元素集，选中奇数行或偶数行（B1、B3、C2、D2、E2或）
$("p:first-child|last-child")   //选取所有<p>，以其父元素为单位组成多个元素集，各选中其中的第1行或最后1行（A1、B1、D1、E1或)
$("p:nth-child(odd|even|n)")    //选取所有<p>，以其父元素为单位组成多个元素集，各选中其中的奇数行或偶数行或第n行（A1、B1、B3、C2、D1、E1或）

$("div p:first|last")               //选取所有<div>下的<p>为一个元素集，选中第1行或最后1行（B1或E2）
$("div p:odd|even")                 //选取所有<div>下的<p>为一个元素集，选中奇数行或偶数行（B2、C1、D1、E1或）
$("div p:first-child|last-child")   //选取所有<div>内的<p>，以其父元素为单位组成多个元素集，各选中其中的第1行或最后1行（B1、D1、E1或）
$("div p:nth-child(odd|even|n)")    //选取所有<div>内的<p>，以其父元素为单位组成多个元素集，各选中其中的奇数行或偶数行或第n行（B1、B3、C2、D1、E1或）
$("div p:only-child")               //（）
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
<table>
    <tr><td>Row 1</td></tr>
    <tr><td>Row 2</td></tr>
    <tr><td>Row 3</td></tr>
</table>

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
$("p:eq(n)")  =
$("p:gt(n)")  >
$("p:lt(n)")  <
$("p:ge(n)")  >=
$("p:le(n)")  <=

3、元素处理
（1）属性、类别
1）attr获取、设置、删除属性
$("input").attr("title")
$("input").attr("disabled", "disabled")
$("input").removeAttr("title")
2）data获取、设置、删除属性
    向被选元素附加数据，或者从被选元素获取数据。也是以一种键值对的形式存在。
补充：有时候要在标签上记录数据，但是不想把数据库里面的这些敏感数据展示出来，所以不能自定义属性和属性值来操作，data就相当的方便了，数据存在缓存中，不会暴露，
$("input").data("title")
$("input").data("disabled", "disabled")
$("input").removeData("title")

3）设置、删除、切换、判断class类别
$("input").addClass("myClass1")；     //等同于$("input").attr("class", "myClass1");
$("input").removeClass("myClass1")；  //等同于$("input").removeAttr("class", "myClass1");
$("input").toggleClass("myClass1")；       
$("input").hasClass("myClass1")；     //bool值，等同于$("input").is(".myClass1")；
4）JQuery的.css相当于HTML的.style
$("#id").css('display', 'none'); 
$("#id").css('display', 'block'); 
$("#id")[0].style.display = 'none'; 
$("#id").attr("style", "display:none");

$("#id").hide()表示display:none;
$("#id").show()表示display:block
$("#id").toggle()切换元素的可见状态。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。

$("#id")返回的是JQuery 
$("#id")[0]返回的是HTML

5）jQuery对象转换为html元素
通过在jQuery对象后加"[0]"转换为html元素
$('#GRCWaitingContent')[0].innerText = '111';

（2）元素操作
1）元素添加
<0>js的添加：
$("<p>这是一段话</p>")  //创建DOM元素，等同于js的：
var p = document.creatElement("p");  //新建节点
var TEXT = document.createTextNode("这是一段话")
p.appendChild(TEXT);
<1>after、insertAfter
功能：在<>text1</>外部添加，两者位置相反，例：
$("<p>behind</p>").insertAfter("#before");
等同于$("#before").after("<p>behind</p>");
注：
$("#before").after("#behind");  //#behind将会从原来的位置移到新的位置
<2>append、appendTo
功能:在<>text1</>内部text1后移动追加，例：
$("#before").append("<b>behind</b>")             //在#test内追加
等同于$("<b>behind</b>").appendTo("#before")     //在#test内追加
<3>prepend
功能:在<>text1</>内部text1前追加
<4>wrap、unwrap
功能:在<>text1</>外部包裹一个新的标签
$("#test").children("[value=1]").wrap("<span style='display:none'></span>")      //使该对象隐藏
$("#test").children("[value=1]").unwrap("<span style='display:none'></span>")    //重新显示该隐藏对象
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
.unwrap()，看名称就知道作用与jQuery.wrap是相反的——用来移除匹配元素的父级结构但保留它原有的后代元素。
jQuery('#a').unwrap()外层的DIV被移除了——红色的border不见了！
<div style="border:1px solid red;">
    <a id="a" href="http://www.webercn.com/api/jQuery/index.shtml">jQuery1.7教程</a>
</div> 
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
2）元素修改（见attr）

3）元素删除
<1>empty
功能：删除所有子节点，例：
$("test").empty();
<2>remove
功能：移动匹配对象，例：
$("test").remove();

4）元素复制
clone
功能：复制，例：
$("#test").clone.appendTo($(a));

5）其它功能
<1>length、size()
功能：当前元素集的数量，以下两者相同，例：
$("img").length;
$("img").size();
<2>href
功能：获取或设置元素链接，例：
$("#myId").href();
$("#myId").href("2.html");
<3>is()
功能 ：判断元素中是否包含另一个元素，例：
var bool = $("div").is("img");//判断div中是否包含img
<4>trim
功能：去掉字符串首尾空格，例：
$.trim(str);
<5>add
功能：向查找的结果集中添加节点，例：
$('ul#tmpAnimals li').add('li#tmpBrocoli, li#tmpPepper').addClass('tmpExample');
//id为tmpAnimals的ul节点下的li节点集，添加id为tmpBrocoli的li节点和添加id 为tmpPepper的li节点。并将组合后的集合中所有li节点增加tmpExample样式。


<6>val
功能：val() 方法是获取（设置）第一个匹配元素(记住是第一个)的当前值。
单行文本是不能用text()或html()来获取或者设置值。必须要用val()
$("test").val("textone");
<7>text

<8>html
功能：.html()替代了以前的 .innerHTML，.html('test')，则是替代了.innerHTML = 'test'; 

<9>queue()、dequeue()、clearQueue()

<10>delay()


<11>size

<12>contents
功能：方法获得匹配元素集合中每个元素的子节点，包括文本和注释节点，例：
$("p").contents().filter(function(){ return this.nodeType != 1; }).wrap("<b/>");


<13>each
功能：遍历

context


<14>serialize表单序列化
serialize可用于将表单内的所有元素序列化。
<head>
    <script>
        $(document).ready(function(){
        $("button").click(function(){
            $("div").text($("form").serialize());
        });
        });
    </script>
</head>
<body>
    <form action="">
        First name: <input type="text" id="aa" name="FirstNameAA" value="Bill" /><br />
        Last name: <input type="text" id="bb" name="LastNameBB" value="Gates" /><br />
    </form>
</body>

Result:
FirstNameAA=Bill&LastNameBB=Gates

<15>validate表单验证
<script src="../js/jquery.js" type="text/javascript"></script>
<script src="../js/jquery.validate.js" type="text/javascript"></script> 
功能：验证

$("form").validate({
    //规则
    rules:{ 
        email: {
            required: true,
            email: true,
            remote: {
                url: "/CompanyUsersToB/CheckEmail",         //后台处理程序
                type: "post",                               //数据发送方式
                data: {                                     //要传递的数据
                    email: function () {
                        return $.trim($("#email").val());
                    }
                }
                //success: function (data) {
                //    if (data.indexOf("<script") >= 0) {
                //        window.location.reload();
                //    }
                //}
            }
        },
        pwd:{
            minlength: 7, 
            maxlength: 30 
        },
        confirm_pwd:{
            required: true,
            equalTo: "#pwd"
        }
    },
    //不符合规则提示的消息
    messages: {
        email: {
            required: "<span class=\"tishi\">请输入正确的邮箱</span>",
            remote: "<span class=\"tishi\">邮箱已被占用</span>"
        },
        pwd:{...}
    },
    //提交表单，则
    submitHandler: function (form) {
    },
    //如果成功，则
    success: function (element) {
        //element.parent().find("span").html("<span style='color:Green'>正确</span>");
    },
    onkeyup: false,
    errorElement: "span",
    errorPlacement: function (error, element) {
        element.parent().find("span").remove();
        error.appendTo(element.parent());
    }
});



jQuery.validator.addMethod("byteRangeLength", function(value, element, param) {
    var length = value.length;
    for(var i = 0; i < value.length; i++){
        if(value.charCodeAt(i) > 127){
            length++;
        }
    }
  return this.optional(element) || ( length >= param[0] && length <= param[1] );   
}, $.validator.format("请确保输入的值在{0}-{1}个字节之间(一个中文字算2个字节)"));
※jQuery.validate的optional(element)，用于表单控件的值不为空时才触发验证。 



D、事件
1、概念
在jQuery中，要做到"等網頁載入後再執行"，我們有兩種選擇:
$(document).ready(fn)與$(window).load(fn)
二者的差別在於$(document).ready(fn)發生在"網頁本身的HTML"載入後就觸發，而$(window).load(fn)則會等到"網頁HTML標籤中引用的圖檔、內嵌物件(如Flash)、IFrame"等拉哩拉雜的東西都載入後才會觸發。
我寫了一段示範程式突顯二者的區別。由於Sky_angmap_4.jpg是一張1.2MB的大型圖檔，實際執行時，可以觀察到 “ready event!” –> 圖檔緩慢顯現 -> "load event!”的過程。


一般來說，等網頁全部元素都載入才執行程式時機有點晚，因為在此之前，使用者已經可以點選操作網頁，跳脫我們程式的掌控範圍。因此，我們幾乎都是將 程式放在$(document).read(function() { ... })中(即$(function() { … }))。
$(window).load(fn)適合執行一些要等待圖檔或元素全部載入才可進行的動作，例如: 檢查圖檔長寬。換句話說，上回的大圖自動縮小Script可以透過$(window).load(fn)改寫得更簡單，完全不用擔心圖檔沒下載完成時的特殊處理，算是一個很好的應用範例。
2、种类
事件    说明
bind() 向匹配元素附加一个或更多事件处理器 
blur() 触发、或将函数绑定到指定元素的 blur 事件 
change() 触发、或将函数绑定到指定元素的 change 事件 
click() 触发、或将函数绑定到指定元素的 click 事件 
dblclick() 触发、或将函数绑定到指定元素的 double click 事件 
delegate() 向匹配元素的当前或未来的子元素附加一个或多个事件处理器 
die() 移除所有通过 live() 函数添加的事件处理程序。 
error() 触发、或将函数绑定到指定元素的 error 事件 
event.isDefaultPrevented() 返回 event 对象上是否调用了 event.preventDefault()。 
event.pageX 相对于文档左边缘的鼠标位置。 
event.pageY 相对于文档上边缘的鼠标位置。 
event.preventDefault() 阻止事件的默认动作。但此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。
event.result 包含由被指定事件触发的事件处理器返回的最后一个值。 
event.target 触发事件的 DOM 元素。 
event.timeStamp 该属性返回从 1970 年 1 月 1 日到事件发生时的毫秒数。 
event.type 描述事件的类型。 
event.which 指示按了哪个键或按钮。 
focus() 触发、或将函数绑定到指定元素的 focus 事件 
keydown() 触发、或将函数绑定到指定元素的 key down 事件 
keypress() 触发、或将函数绑定到指定元素的 key press 事件 
keyup() 触发、或将函数绑定到指定元素的 key up 事件 
live() 触发、或将函数绑定到指定元素的 load 事件 
load() 触发、或将函数绑定到指定元素的 load 事件 
mousedown() 触发、或将函数绑定到指定元素的 mouse down 事件 
mouseenter() 触发、或将函数绑定到指定元素的 mouse enter 事件 
mouseleave() 触发、或将函数绑定到指定元素的 mouse leave 事件 
mousemove() 触发、或将函数绑定到指定元素的 mouse move 事件 
mouseout() 触发、或将函数绑定到指定元素的 mouse out 事件 
mouseover() 触发、或将函数绑定到指定元素的 mouse over 事件 
mouseup() 触发、或将函数绑定到指定元素的 mouse up 事件 
one() 向匹配元素添加事件处理器。每个元素只能触发一次该处理器。 
ready() 文档就绪事件（当 HTML 文档就绪可用时） 
resize() 触发、或将函数绑定到指定元素的 resize 事件 
scroll() 触发、或将函数绑定到指定元素的 scroll 事件 
select() 触发、或将函数绑定到指定元素的 select 事件 
submit() 触发、或将函数绑定到指定元素的 submit 事件 
toggle() 绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。 
trigger() 触发所有匹配元素的指定事件 
triggerHandler() 第一个被匹配元素的指定事件 
unbind() 从匹配元素移除一个被添加的事件处理器 
undelegate() 从匹配元素移除一个被添加的事件处理器，现在或将来 
unload() 触发、或将函数绑定到指定元素的 unload 事件 
3、绑定与解绑
（1）bind
方法一
$(selector).bind(event, data, function)
event 必需。规定添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。
data 可选。规定传递到函数的额外数据。 
function 必需。规定当事件发生时运行的函数。 

var message = 'Spoon!';
$('#foo').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});

方法二
$(selector).bind({event:function, event:function, ...})
方法三（不利用bind绑定事件，此方法也可用bind解绑）
$(selector).keydown(data, function)
（2）unbind
<input id="btn1" type="button" onclick="myfun()">
此种onclick不能通过unbind解绑，来看jquery如何巧妙的实现解除elements已绑定事件
("#btn1").unbind('click').removeAttr('onclick').click(function() { });
（3）click鼠标
$(selector).click()
$(selector).click(function)
（4）keydown键盘
$(selector).keydown(function(){})
    $(document).keydown(function (e) {
        if (e.keyCode == 13) {
            $('#a_login').click();
        }
    });

（5）trigger触发
$(selector).trigger('onchange')
js方式：document.getElementById("sel").fireEvent('onchange')

4、绑定判断
    判断某一element是否绑定事件
方法一
jQuery.data(elem, "events")[type] //老版本也能用 
方法二
$(elem).data("events")[type] //1.2.3以后才能用 
例
alert($("#test").data("events")["click"][0].handler.toString());

if( $("#foo").data("events")["click"] ){ 
 //your code 
 } 





var $events = $("#foo").data("events");
if( $events && $events["click"] ){
     //your code
} 




5、自动加载事件
（1）ready
1）最常用也是最标准的 
$(document).ready(){ 
}); 
2）是上面的简写: 
$(function(){ 
}) 
3）
$(document).ready(function(){ 
}); 
4）
jQuery(function($){ 
}); 

（2）onload onunload 
window.onload
（3）两者区别
<1>执行时间 
window.onload必须等到页面内包括图片的所有元素“加载完毕”后才能执行。 
$(document).ready()是DOM结构“绘制完毕”后就执行，不必等到“加载完毕”。 
<2>编写个数不同 
window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 
$(document).ready()可以同时编写多个，并且都可以得到执行 
<3>简化写法 
window.onload没有简化写法 
$(document).ready(function(){})可以简写成$(function(){}); 




E、效果
clearQueue() 对被选元素移除所有排队的函数（仍未运行的） 
delay() 对被选元素的所有排队函数（仍未运行）设置延迟 
dequeue() 运行被选元素的下一个排队函数 
queue() 显示被选元素的排队函数 


1、animate
功能：对被选元素应用“自定义”的动画 
例：$(selector).animate({height:"300px"});

  $("#start").click(function(){
    $("#box").animate({height:300}, "slow");
    $("#box").animate({width:300}, "slow");
    $("#box").queue(function () {
      $(this).css("background-color", "red");  
      $(this).dequeue();
    });
    $("#box").animate({height:100}, "slow");
    $("#box").animate({width:100}, "slow");
  });
  $("#stop").click(function(){
    $("#box").clearQueue();
  });


2、hide、show、toggle（隐藏、显示效果）
功能：hide、show对元素进行隐藏、显示操作，toggle对被选元素进行隐藏和显示的切换
  $("p").hide(1000, function(){
    alert("The paragraph is now hidden");
    });
隐藏1000ms后，执行函数。

功能：toggle()方法切换元素的可见状态，
格式：$(selector).toggle(speed, callback, switch)，例：
  $("p").hide();
3、fadeOut、fadeIn、fadeTo（淡入淡出效果）
功能：fadeOut() 方法使用淡出效果来隐藏被选元素，假如该元素是隐藏的。
格式：$(selector).fadeOut(speed, callback)
speed 可选。规定元素从可见到隐藏的速度。可能的值：
ms、"slow" 、"normal" （默认）、"fast" 
在设置速度的情况下，元素从可见到隐藏的过程中，会逐渐地改变其透明度（这样会创造淡出效果）。
callback 可选。fadeOut 函数执行完之后，要执行的函数。例：
  $(".btn1").click(function(){
  $("p").fadeOut()
  });
  $(".btn2").click(function(){
  $("p").fadeIn();
  });
功能：调整可见度
格式：$(selector).fadeTo(speed, opacity, callback)
opacity 必需。规定要淡入或淡出的可见度。必须是介于 0.00 与 1.00 之间的数字。
4、stop
功能： 停止在被选元素上运行动画 









二十四、正则表达式
https://regexper.com/
A、概念
正则表达式是一个描述字符模式的对象。 
JavaScript的RegExp对象和String对象定义了使用正则表达式来执行强大的模式匹配和文本检索与替换函数的方法. 

B、正则表达式中的特殊字符
字符   含意  
\      做为转意，即通常在"\"后面的字符不按原来意义解释，如/b/匹配字符"b"，当b前面加了反斜杆后/\b/，转意为匹配一个单词的边界。-或- 对正则表达式功能字符的还原，如"*"匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了"\"后，/a\*/将只匹配"a*"。 
^      匹配一个输入或一行的开头，/^a/匹配"an A"，而不匹配"An a"  
$      匹配一个输入或一行的结尾，/a$/匹配"An a"，而不匹配"an A"  
*      匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa  
+      匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa  
?      匹配前面元字符0次或1次，/ba?/将匹配b,ba  
.      匹配除 "\n" 之外的任何单个字符。/ba./将匹配baa,bab,ba1 
(x)    匹配x保存x在名为$1...$9的变量中  
x|y    匹配x或y  
{n}    精确匹配n次  
{n,}   匹配n次以上  
{n,m}  匹配n-m次  
[xyz]  字符集(character set)，匹配这个集合中的任一一个字符(或元字符)  
[^xyz] 不匹配这个集合中的任何一个字符  
[\b]   匹配一个退格符  
\b     匹配一个单词的边界  
\B     匹配一个单词的非边界  
\cX    这儿，X是一个控制符，/\cM/匹配Ctrl-M  
\d     匹配一个字数字符，/\d/ = /[0-9]/  
\D     匹配一个非字数字符，/\D/ = /[^0-9]/  
\n     匹配一个换行符  
\r     匹配一个回车符  
\s     匹配一个空白字符，包括\n,\r,\f,\t,\v等  
\S     匹配一个非空白字符，等于/[^\n\f\r\t\v]/  
\t     匹配一个制表符  
\v     匹配一个重直制表符  
\w     匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\w]匹配"$5.98"中的5，等于[a-zA-Z0-9]  
\W     匹配一个不可以组成单词的字符，如[\W]匹配"$5.98"中的$，等于[^a-zA-Z0-9]。  
(?i)   忽略大小写一般放在各语言的语法中，但也可以放在正则表达式中，如(?i)(abc)，会匹配Abc、AbC、aBc等




下表是元字符及其在正则表达式上下文中的行为的一个完整列表： 

字符 描述 
\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 后向引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 
^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 
$ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 
* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。 
+ 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 
? 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。 
{n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 
{n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 
{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。刘， "o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 
? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 
**********************非贪婪模式***********************
*? 重复任意次，但尽可能少重复 
+? 重复1次或更多次，但尽可能少重复 
?? 重复0次或1次，但尽可能少重复 
{n,m}? 重复n到m次，但尽可能少重复 
{n,}? 重复n次以上，但尽可能少重复 
**********************非贪婪模式***********************
. 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 
(pattern) 匹配pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 
(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。 
(?<=pattern) (?=pattern) 正向前置预查、正向后置预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， 'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 
(?!pattern) 负向预查，在任何不匹配Negative lookahead matches the search string at any point where a string not matching pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 
x|y 匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。 
[xyz] 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 
[^xyz] 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。 
[a-z] 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 
[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 
\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 
\B 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 
\cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 
\d 匹配一个数字字符。等价于 [0-9]。 
\D 匹配一个非数字字符。等价于 [^0-9]。 
\f 匹配一个换页符。等价于 \x0c 和 \cL。 
\n 匹配一个换行符。等价于 \x0a 和 \cJ。 
\r 匹配一个回车符。等价于 \x0d 和 \cM。 
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 
\t 匹配一个制表符。等价于 \x09 和 \cI。 
\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 
\w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。 
\W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。 
\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， '\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。. 
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 
\n 标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 
\nm 标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 
\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 
\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 


优先权顺序 
在构造正则表达式之后，就可以象数学表达式一样来求值，也就是说，可以从左至右并按照一个优先权顺序来求值。 

下表从最高优先级到最低优先级列出各种正则表达式操作符的优先权顺序： 
[code] 操作符 描述 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \anymetacharacter 位置和顺序 | “或”操作 [/code] 


C、RegEx之Javascript
1、准备
regexp规则类包含在System.Text.RegularExpressions.dll文件中，在对应用软件进行编译时你必须引用这个文件，例如在C#中要使用正则表达式类，应加入RegularExpression命名空间，在源文件开头处添加以下语句：
  using System.Text.RegularExpressions;

2、声明
在JavaScript中，正则表达式是由一个RegExp对象表示的，有两种声明方式：
（1）可以使用一个RegExp()构造方法来创建RegExp对象：
用re = new RegExp("pattern",["flags"]) 
pattern : 正则表达式 
flags: g （全文查找出现的所有 pattern） 
i （忽略大小写） 
m （多行查找） 
例：var pattern = new RegExp("s$"); 
这行代码创建一个新的RegExp对象,并将它赋给变量parttern。这个特殊的RegExp对象和所有以字母"s"结尾的字符串都匹配。
（2）正则表达式直接量也被定义为包含在一对斜杠(/)之间的字符，就像字符串直接量被定义为包含在引号内的字符一样：
例：var pattern = /s$/; 
（3）通过下面方法可动态生成正则表达式：
var tst = "(^\\d{0,mmmmm}\\.[\\d]{0,nnnnn}$)|(^\\d{1,mmmmm})$".replace("mmmmm", s1).replace("nnnnn", s2).replace("mmmmm", s1);
var reg = new RegExp(tst);         //var reg = eval("/" + tst + "/");   此两种效果相同

3、使用
（1）属性
属性     含义  
$1...$9  如果它(们)存在，是匹配到的子串  
$_       参见input  
$*       参见multiline  
$&       参见lastMatch  
$+       参见lastParen  
$`       参见leftContext  
$''      参见rightContext  
constructor        创建一个对象的一个特殊的函数原型  
global             是否在整个串中匹配(bool型)  
ignoreCase         匹配时是否忽略大小写(bool型)  
input              被匹配的串  
lastIndex          最后一次匹配的索引  
lastParen          最后一个括号括起来的子串  
leftContext        最近一次匹配以左的子串  
multiline          是否进行多行匹配(bool型)  
prototype          允许附加属性给对象  
rightContext       最近一次匹配以右的子串  
source             正则表达式模式  

（2）正则表达式对象方法 
方法                含义  
compile             正则表达式比较  
exec(string)        查找当前的匹配结果，并以数组的形式返回。
test(string)        查找对应的字符串中是否存在模式，返回 Boolean。
toSource            返回特定对象的定义(literal representing)，其值可用来创建一个新的对象。重载Object.toSource方法得到的。  
toString            返回特定对象的串。重载Object.toString方法得到的。  
valueOf             返回特定对象的原始值。重载Object.valueOf方法得到
注1：exec 方法受参数 g 的影响。若指定了 g，则下次调用 exec 时，会从上个匹配的 lastIndex 开始查找。
注2：exec方法返回的是数组，数组的0元素是完整的匹配对象，第1到n元素中包含的是匹配中出现的各子匹配对象。同时，数组有3个属性，分别是input、index和lastIndex。
     1 input 属性是整个被搜索的字符串。
     2 index属性是指匹配在整个被搜索字符串中的位置。
     3 lastIndex 属性是指匹配的子字符串的最后一个字符的下一个字符位置。
例例例例例例例例例例例例例例例例例例例例例
var str = "1a1b1c";
var reg = new RegExp("1.", "");
alert(reg.exec(str)[0]);
alert(reg.exec(str)[0]);
上述两个输出都是 1a。现在再看看指定参数 g：

var str = "1a1b1c";
var reg = new RegExp("1.", "g");
alert(reg.exec(str)[0]);
alert(reg.exec(str)[0]);
上述第一个输出 1a，第二个输出 1b。
例例例例例例例例例例例例例例例例例例例例例
<script LANGUAGE="javascript">
var u="http://msdn.microsoft.com:80/scripting/default.htm";
var s=/(\w+):\/\/([^/:]+)(:\d*)?([^# ?]*)/;
var a=s.exec(u);
for(i=1;i<a.length;i++){
alert(a[i]);
}
</script>
将该正则表达式应用于上面所示的URL后，子匹配包含下述内容： 
a[1] 包含 "http" 
a[2] 包含 "msdn.microsoft.com" 
a[3] 包含 ":80" 
a[4] 包含 "/scripting/default.htm" 
(也可以用RegExp.$1、RegExp.$2、RegExp.$3、RegExp.$4取值)
例例例例例例例例例例例例例例例例例例例例例
//校验是否全由数字组成 
function isDigit(s) 
{ 
var patrn=/^[0-9]{1,20}$/; 
if (!patrn.exec(s)) return false 
return true 
} 
例例例例例例例例例例例例例例例例例例例例例
//校验是正整数
function checkInt(str) {
    var tst = /^\d+$/.test(str);
    if (tst) {
        return true;
    }
    return false;
}
例例例例例例例例例例例例例例例例例例例例例

（3）字符串对象中的方法
match(pattern) ：根据pattern进行正则匹配，如果匹配到，返回匹配结果，如匹配不到返回null（与exec类似，只不过是字符串对象的方法，不是正则表达式对象的方法）
search(pattern) ：根据pattern进行正则匹配，如果匹配到一个结果，则返回它的索引数;否则返回-1
replace(pattern, replacement) ：根据pattern进行正则匹配，把匹配结果替换为replacement
split(pattern) ：根据pattern进行正则分割，返回一个分割的数组

例例例例例例例例例例例例例例例例例例例例例
<script language = "JavaScript"> 
var myReg = /(w+)s(w+)/; 
var str = "John Smith"; 
var newstr = str.replace(myReg, "$2, $1"); 
document.write(newstr); 
</script> 
将输出"Smith, John" 
例例例例例例例例例例例例例例例例例例例例例
var str = "1a1b1c";
var reg = new RegExp("1.", "g");
alert(str.match(reg));
例例例例例例例例例例例例例例例例例例例例例
 
4、进阶部分
选择，分组和引用
｜

它要求开始和结束的引号匹配(例如两个都是双引号或者都是单引号): 
/[' "] [^ ' "]*[' "]/ 
如果要求开始和结束的引号匹配，我们可以使用如下的引用: 
/( [' "] ) [^ ' "] * \1/ 
\1匹配的是第一个代括号的子表达式所匹配的模式.在这个例子中，它实施了一种规约，那就是开始的引号必须和结束的引号相匹配。注意，如果反斜杠后跟随的数字比代括号的子表达式数多，那么它就会被解析为一个十进制的转义序列，而不是一个引用.你可以坚持使用完整的三个字符来表示转义序列，这们就可以避免混淆了。例如，使用 \044，而不是\44。

| 选择.匹配的要么是该符号左边的子表达式，要么它右边的子表达式 (...) 分组.将几个项目分为一个单元.这个单元可由 *、+、？和|等符号使用，而且还可以记住和这个组匹配的字符以供此后引用使用 \n 和第n个分组所匹配的字符相匹配.分组是括号中的子表达式(可能是嵌套的).分组号是从左到右计数的左括号数 



5、17种常用正则表达式  
"^\\d+$"                                                        // 非负整数（正整数 + 0） 
"^[0-9]*[1-9][0-9]*$"                                           // 正整数 
"^((-\\d+)|(0+))$"                                              // 非正整数（负整数 + 0） 
"^-[0-9]*[1-9][0-9]*$"                                          // 负整数 
"^-?\\d+$"                                                      // 整数 
"^\\d+(\\.\\d+)?$"                                              // 非负浮点数（正浮点数 + 0） 
"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"    //正浮点数 
"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"                            // 非正浮点数（负浮点数 + 0） 
"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"    //负浮点数 
"^(-?\\d+)(\\.\\d+)?$"                                          // 浮点数 
"^[A-Za-z]+$"                                                   // 由26个英文字母组成的字符串 
"^[A-Z]+$"                                                      // 由26个英文字母的大写组成的字符串 
"^[a-z]+$"                                                      // 由26个英文字母的小写组成的字符串 
"^[A-Za-z0-9]+$"                                                // 由数字和26个英文字母组成的字符串 
"^\\w+$"                                                        // 由数字、26个英文字母或者下划线组成的字符串 
"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"                   // email地址 
"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"    // url 

/^([\u4E00-\u9FA5])*$/                                          // 汉字
/^(\w|[\u4E00-\u9FA5])*$/                                       // 汉字或字母或者数字 

D、RegEx之.NET
1.静态Match
    
     例如：
     Match myMatch = Regex.Match("asdf\r\nasdfasdf\r\n", @"\basdf\B");
     Console.WriteLine(myMatch.Value);     程序将输出asdf（这里匹配了文本中第二个asdf）
     
     静态的Match方法有2个重载，分别是
     Regex.Match(string input, string pattern); 
     Regex.Match(string input, string pattern, RegexOptions options);
     第一种重载的参数表示：输入、模式
     第二种重载的参数表示：输入、模式、RegexOptions枚举的“按位或”组合。
     RegexOptions枚举的有效值是：
     Complied表示编译此模式
     CultureInvariant表示不考虑文化背景
     ECMAScript表示符合ECMAScript，这个值只能和IgnoreCase、Multiline、Complied连用
     ExplicitCapture表示只保存显式命名的组
     IgnoreCase表示不区分输入的大小写
     IgnorePatternWhitespace表示去掉模式中的非转义空白，并启用由#标记的注释
     Multiline表示多行模式，改变元字符^和$的含义，它们可以匹配行的开头和结尾
     None表示无设置，此枚举项没有意义     RightToLeft表示从右向左扫描、匹配，这时，静态的Match方法返回从右向左的第一个匹配     Singleline表示单行模式，改变元字符.的意义，它可以匹配换行符
     注意：Multiline在没有ECMAScript的情况下，可以和Singleline连用。Singleline和Multiline不互斥，但是和ECMAScript互斥。
静态的Matches方法
    这个方法的重载形式同静态的Match方法，返回一个MatchCollection，表示输入中，匹配模式的匹配的集合。
静态的IsMatch方法
    此方法返回一个bool，重载形式同静态的Matches，若输入中匹配模式，返回true，否则返回false。     可以理解为：IsMatch方法，返回Matches方法返回的集合是否为空。


2.动态Match
（1）IsMatch
    Regex regex = new Regex(@"-xincache\d*.cn$");
    for (int i = 0; i < listKey.Count(); i++)
    {
        if (regex.IsMatch(listKey[i]))
            listKey[i] += DataUtil.IP_SECURITY_POSTFIX;
    }
（2）Match和Matches
    string str = "...";
    string condition = "【.{0,40}】";
    Regex regex = new Regex(condition);
    
    //Match方法，可以得到源中第一个匹配模式的连续子串。
    Match match = regex.Matches(str);                   //静态方式：Match match = Regex.Matches(str, condition);
    //Matches方法，可以得到源中所有匹配模式的连续子串。
    MatchCollection matches= regex.Matches(str);        //静态方式：MatchCollection matches = Regex.Matches(str, condition);
    
    foreach (object s in matches)
        ...
（3）Replace
    string input = "[1][2][3][4]";
    //静态方式：string output = Regex.Replace(input, @"\[(\d+)\]", "<img src='$1.gif'/>");               //关键在于(\d+)，一定要加()。即()=>$1、$2、$3...
    string output = new Regex(@"\[(\d+)\]").Replace(input, "<img src='$1.gif'/>");
Result:
<img src='1.gif'/><img src='2.gif'/><img src='3.gif'/><img src='4.gif'/>

（4）Replace
通过YouTube的API获取的视频，视频的时长格式是诸如 PT21H4M6S 这种格式，但这种格式不方便用户查看。所以我们可以使用正则表达式转换YouTube视频的时间格式。

 Regex reg = new Regex(@"^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$");
 var time = reg.Replace("PT21H4M6S", new MatchEvaluator(match =>
 {
     if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
     {
         return string.Format("{0}:{1}:{2}",match.Groups[1].Value,match.Groups[2].Value,match.Groups[3].Value);
     }
     return string.Format("{0}:{1}",match.Groups[2].Value,match.Groups[3].Value);
 }));
 Console.WriteLine(time);



二十五、AJax
A、衍变前的起源XMLHttpRequest
1、XMLHttpRequest 对象方法
（1）向服务器发送请求
open("method", "URL"[, asyncFlag[, "userName"[, "password"]]]) 规定请求的类型、URL 以及是否异步处理请求。
    method：请求的类型；GET 或 POST 
    url：文件在服务器上的位置 
    async：true（异步）或 false（同步） 
send(string) 将请求发送到服务器。
    string：仅用于 POST 请求 
abort() 停止当前请求，但还是会执行后面的function()
getAllResponseHeaders()  作为字符串返问完整的headers
getResponseHeader("headerLabel") 作为字符串返问单个的header标签
setRequestHeader("label", "value") 设置header并和请求一起发送
（2）服务器响应
responseText 服务器返回的状态文本信息。 
responseXML 服务器进程返回数据的兼容DOM的XML文档对象。 
（3）onreadystatechange 事件
onreadystatechange 状态改变的事件触发器，每当 readyState 属性改变时，就会调用该函数。 
readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
0：（请求未初始化）send方法还没有被调用
1：（请求加载中）已调用了send方法，请求还在处理
2：（请求已加载）send方法已完成，整个应答已接收
3：（请求处理中）正在解析应答
4：（请求已完成）应答已经解析，准备好进行下一步处理。
5：（请求发生错误）服务器错误



readyState Status Code 
Status of the XMLHttpRequest Object 
(0) UNINITIALIZED 未初始化 
The object has been created but not initialized. (The open method has not been called.) 
（XMLHttpRequest）对象已经创建，但尚未初始化（还没有调用open方法）。 
此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。 

(1) LOADING 载入 
The object has been created, but the send method has not been called. 
（XMLHttpRequest）对象已经创建，但尚未调用send方法。 
(2) LOADED 载入完成 
The send method has been called, but the status and headers are not yet available. 
已经调用send方法，（HTTP响应）状态及头部还不可用。 
此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method, url, true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。 
(3) INTERACTIVE 交互 
Some data has been received. Calling the responseBody and responseText properties at this state to obtain partial results will return an error, because status and response headers are not fully available. 
已经接收部分数据。但若在此时调用responseBody和responseText属性获取部分结果将会产生错误，因为状态和响应头部还不完全可用。 
此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 
(4) COMPLETED 完成 
All the data has been received, and the complete data is available in the responseBody and responseText properties. 
已经接收到了全部数据，并且在responseBody和responseText属性中可以提取到完整的数据。 
此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 




status的属性含义
       200: "OK"
       404: 未找到页面
0**：未被始化
1**：请求收到，继续处理
2**：操作成功收到，分析、接受
3**：完成此请求必须进一步处理
4**：请求包含一个错误语法或不能完成
5**：服务器执行一个完全有效请求失败
100——客户必须继续发出请求
101——客户要求服务器根据请求转换HTTP协议版本
200——交易成功
201——提示知道新文件的URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的GET请求
300——请求的资源可在多处得到
301——删除请求数据
302——在其他地址发现了请求数据
303——建议客户访问其他URL或访问方式
304——客户端已经执行了GET，但文件未变化
305——请求的资源必须从服务器指定的地址得到
306——前一版本HTTP中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
400——错误请求，如语法错误
401——请求授权失败
402——保留有效ChargeTo头响应
403——请求不允许
404——没有发现文件、查询或URl
405——用户在Request-Line字段定义的方法不允许
406——根据用户发送的Accept拖，请求资源不可访问
407——类似401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的Content-Length属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源URL长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
500——服务器产生内部错误
501——服务器不支持请求的函数
502——服务器暂时不可用，有时是为了防止发生系统过载
503——服务器过载或暂停维修
504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
505——服务器不支持或拒绝支请求头中指定的HTTP版本


例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
function loadXMLDoc()
{
    var xmlhttp;
    if (window.XMLHttpRequest)
      xmlhttp=new XMLHttpRequest();// code for IE7+, Firefox, Chrome, Opera, Safari
    else
      xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");// code for IE6, IE5
    xmlhttp.open("GET","/ajax/test1.txt",false);
    xmlhttp.send();
    document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
}

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例

function loadXMLDoc()
{
    var xmlhttp;
    if (window.XMLHttpRequest)
      xmlhttp=new XMLHttpRequest();// code for IE7+, Firefox, Chrome, Opera, Safari
    else
      xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");// code for IE6, IE5

    xmlhttp.onreadystatechange=function()
  {
  if (xmlhttp.readyState==4 && xmlhttp.status==200)
    {
    document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
    }
  }

    xmlhttp.open("GET","/ajax/test1.txt",false);
    xmlhttp.send();
}

例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例




B、JQuery的AJax衍变
jQuery 的 load 函数是一种简单的（但很强大的）AJAX 函数。
参数说明：
(url) 被加载的数据的 URL（地址）
(data) 发送到服务器的数据的键/值对象，多参数形式{key:value, key:value, ...}
(callback) 当数据被加载时，所执行的函数
(type) 被返回的数据的类型 (html,xml,json,jasonp,script,text)
(options) 完整 AJAX 请求的所有键/值对选项
1、jQuery AJAX 请求方法
（1）$(selector).load( url, [data], [callback] ) ：把载入的远程数据加入 DOM 中。
url (String) : 请求的HTML页的URL地址。
data (Map) : (可选参数) 发送至服务器的 key/value 数据。
callback (Callback) : (可选参数) 请求完成时(不需要是success的)的回调函数。

（2）$.get( url, [data], [callback] ) ：使用GET方式来进行异步请求。
url (String) :  发送请求的URL地址。
data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示，会做为QueryString附加到请求URL中。
callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。

（3）$.post( url, [data], [callback] ) ：使用POST方式来进行异步请求。
url (String) : 发送请求的URL地址。
data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示。
callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。
type (String) : (可选)官方的说明是：Type of data to be sent。其实应该为客户端请求的类型(JSON,XML,等等)
如果你设置了请求的格式为"json"，此时你没有设置Response回来的ContentType 为：Response.ContentType = "application/json"; 那么你将无法捕捉到返回的数据。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
Ajax.aspx：

Response.ContentType = "application/json";
Response.Write("{result: '" + Request["Name"] + ",你好！(这消息来自服务器)'}");jQuery 代码：

$.post("Ajax.aspx", { Action: "post", Name: "lulu" },
    function (data, textStatus){
        // data 可以是 xmlDoc, jsonObj, html, text, 等等.
        //this; // 这个Ajax请求的选项配置信息，请参考jQuery.get()说到的this
        alert(data.result);
    }, "json");
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
（4）$.getScript( url, [callback] ) : 通过 GET 方式请求载入并执行一个 JavaScript文件。
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
$.getScript("AjaxEvent.js", function(){
    alert("AjaxEvent.js 加载完成并执行完成.你再点击上面的Get或Post按钮看看有什么不同？");
});
例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例例
（5）$.getJSON( url, [data], [callback] ) ：使用 HTTP GET 来加载远程 JSON 数据。
（6）$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
   参数名       类型         描述
1）url          String     (默认: 当前页地址) 发送请求的地址。
2）type         String     (默认: "GET") 请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求方法，如 PUT 和 Delete 也可以使用，但仅部分浏览器支持。
3）timeout      Number     设置请求超时时间（毫秒）。此设置将覆盖全局设置。
4）async        Boolean    (默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
5）beforeSend  Function   发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。
function (XMLHttpRequest) {
  this; // the options for this ajax request
}
6）cache        Boolean    (默认: true) jQuery 1.2 新功能，设置为 false 将不会从浏览器缓存中加载请求信息。如果设置cache选项为false的话，jQuery会在请求的URL后面附件一个时间戳，以便区分之前的URL地址。
7）complete     Function   请求完成后回调函数 (请求成功或失败时均调用)。参数： XMLHttpRequest 对象，成功信息字符串。
function (XMLHttpRequest, textStatus) {
  this; // the options for this ajax request
}
8）contentType  String    (默认: "application/x-www-form-urlencoded") 发送信息至服务器时内容编码类型。默认值适合大多数应用场合。
9）data         Object,String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:["bar1", "bar2"]} 转换为'&foo=bar1&foo=bar2'。
10）dataType    String    预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回 responseXML 或 responseText，并作为回调函数参数传递，可用值:
"xml": 返回 XML 文档，可用 jQuery 处理。
"html": 返回纯文本 HTML 信息；包含 script 元素。
"script": 返回纯文本 JavaScript 代码。不会自动缓存结果。
"json": 返回 JSON 数据 。
"jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。
11）error       Function   (默认: 自动判断 (xml 或 html)) 请求失败时将调用此方法。这个方法有三个参数：XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象。
function (XMLHttpRequest, textStatus, errorThrown) {
  // 通常情况下textStatus和errorThown只有其中一个有值 
  this; // the options for this ajax request
}
12）global      Boolean   (默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 。可用于控制不同的Ajax事件
13）ifModified  Boolean   (默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。
14）processData Boolean   (默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。
15）success     Function  请求成功后回调函数。这个方法有两个参数：服务器返回数据，返回状态
function (data, textStatus) {
  // data could be xmlDoc, jsonObj, html, text, etc...
  this; // the options for this ajax request
}
例例例例例例例例例例例例例例例例例例例例例例例例例
$.ajax({
    type: "get",
    url: "http://www.cnblogs.com/rss",
    beforeSend: function(XMLHttpRequest){
        //ShowLoading();
    },
    success: function(data, textStatus){
        $(".ajax.ajaxResult").html("");
        $("item",data).each(function(i, domEle){
            $(".ajax.ajaxResult").append("<li>"+$(domEle).children("title").text()+"</li>");
        });
    },
    complete: function(XMLHttpRequest, textStatus){
        //HideLoading();
    },
    error: function(XMLHttpRequest, textStatus, errorThrown){
        alert(XMLHttpRequest.status, XMLHttpRequest.readyState, textStatus, errorThrown);    //返回结果如：200, 4, parsererror, SyntaxError: JSON.parse: unexpected character
        //请求出错处理
    }
});
例例例例例例例例例例例例例例例例例例例例例例例例例
其它：
jQuery.ajaxSetup( options ) : 设置全局 AJAX 默认选项。
例例例例例例例例例例例例例例例例例例例例例例例例例
$.ajaxSetup({
  url: "/xmlhttp/",
  global: false,
  type: "POST"
});
$.ajax({ data: myData });




2、jQuery Ajax 事件
（1）事件种类及触发顺序
Ajax请求会产生若干不同的事件，我们可以订阅这些事件并在其中处理我们的逻辑。在jQuery这里有两种Ajax事件：局部事件 和 全局事件。
局部事件就是在每次的Ajax请求时在方法内定义的，例如：
 $.ajax({
   beforeSend: function(){
     // Handle the beforeSend event
   },
   complete: function(){
     // Handle the complete event
   }
   // ...
 });

事件触发的顺序如下： 
ajaxStart 全局事件 
开始新的Ajax请求，并且此时没有其他ajax请求正在进行。 
beforeSend 局部事件 
当一个Ajax请求开始时触发。如果需要，你可以在这里设置XHR对象。 
ajaxSend 全局事件 
请求开始前触发的全局事件 
success 局部事件 
请求成功时触发。即服务器没有返回错误，返回的数据也没有错误。 
ajaxSuccess 全局事件 
全局的请求成功 
error 局部事件 
仅当发生错误时触发。你无法同时执行success和error两个回调函数。 
ajaxError 全局事件 
全局的发生错误时触发 
complete 局部事件 
不管你请求成功还是失败，即便是同步请求，你都能在请求完成时触发这个事件。 
ajaxComplete 全局事件 
全局的请求完成时触发 
ajaxStop 全局事件 
当没有Ajax正在进行中的时候，触发。


（2）事件终止
//终止请求动作
var request = $.get("ajax.aspx",{id:1},function(data){
    //do something
});
request.abort();

//终止请求动作，可用在防止重复提交请求的地方:
var request;
 if(request != null)
    request.abort();
 request = $.get("ajax.aspx", { id:1 }, function(){
    //do something
});

注意：abort()后，ajax请求立即停止，但还是会执行后面的function()。如果想避免执行其中的操作，可以在function()开始位置加判断:
var ajaxGet = $.get("comet_server.php",{id:1},function(data){
 if(data.length == 0) return true;
 ....//一些操作
 });
ajaxGet.abort();



二十六、nodejs
A、安装
1.步骤
npm install express -g 
npm install jade -g
npm install mysql -g
npm install coffee-script -g       安装CoffeeScript

2.验证安装成功
（1）将以下内容存为test.js，并执行node test.js，会显示：
    Server running at http://127.0.0.1:8888/
（2）接下来，打开浏览器访问 http://127.0.0.1:8888/，会看到一个写着 "Hello World"的网页。 
----------------------------------------
var http = require('http');

http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/plain'});
  response.end('Hello World\n');
}).listen(8888);

console.log('Server running at http://127.0.0.1:8888/');
----------------------------------------

B、功能
1.模块系统
（1）exports
第一步：新建一个myModule.js模块，代码如下：
----------------------------------------
    var name="我是var声明的name变量";
    function sayName(){
        console.log("我是function 声明的sayName()方法！");
    }
    exports.name="我是exports下的属性name";
    exports.sayName1=function(){
        console.log("我是exports下的一个方法！");
    };
----------------------------------------

第二步：新建一个main.js，将上面的模块引入：
----------------------------------------
var myModule=require('./myModule.js');
myModule.sayName1();
console.log(myModule);//输出
----------------------------------------

第三步：执行main.js，即“node main.js”，可以看到输出的结果如下：
{ name: '我是exports下的属性name', sayName1: [Function] }

第四步，总结：
    由以上可以看出，任何exports属性和方法都可以再外部访问，而var声明和funciton直接定义方法都是私有的，只有在exports暴露后才是共有的。外部才可以通过myModule.name类型获取

（2）module.exports
第一步：新建一个myModule.js模块，代码如下：
----------------------------------------
//myModule.js 
function Hello() { 
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log('Hello ' + name); 
    }; 
}; 
module.exports = Hello;
----------------------------------------
第二步：新建一个main.js，将上面的模块引入：
----------------------------------------
//main.js 
var Hello = require('./myModule'); 
hello = new Hello(); 
hello.setName('BYVoid'); 
hello.sayHello(); 
----------------------------------------

★exports和module.exports的区别

即：


I.
myModule1.js
exports.myMethod = function(){
    console.log('1111');
};
main1.js
var m = require('./myModule1.js');
m.myMethod();

II.
myModule2.js
module.exports= function(){
    this.getDate=function(){
        console.log('2222-02-02');
    };
};
main2.js
var M = require('./myModule2.js');
var m = new M();
m.getDate();



**************************************************************
Node.js中 exports 和 module.exports 的三点区别：
1.exports 是指向的 module.exports 的引用：exports.a = xxx 会将修改更新到module.exports对象中，而exports = xxx 直接改变了 exports的指向。
2.module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}
3.require() 返回的是 module.exports 而不是 exports

也就是说exports指向module.exports. 如果写exports.a =1, 意味着module.exports.a也等于1。但如果写成exports=function A(){}, 这个时候, module.exports与exports指的是不同的对象了。这个时候用require引入包括前面这个语句的js文件时，就不能访问exports所指向的function A. 因为require返回的是module.exports所指向的对象。如果想能被引用到也可以写成:module.exports=exports=function A(){};知道这一点的话，如果你想返回function A()就要写成module.exports=function A(){}; 要不然就老老实实地写成exports.A=function A(){}. 只是这两种写法在require之后调用写法不一样而已。前面那种直接var A = require('./A.js'); A()即可。后面的var A = require('./A.js'); A.A()才可以。
**************************************************************

2.事件
1）demo1
----------------------------------------
//event.js 
var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'byvoid', 1991); 

result:
listener1 byvoid 1991 
listener2 byvoid 1991 
----------------------------------------
EventEmitter.on(event, listener)、emitter.addListener(event, listener) 为指定事件注册一个监听器，接受一个字 符串 event 和一个回调函数 listener。
EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。
EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。
EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传递若干可选参数到事件监听器的参数表。

3.函数
同js

4.路由
                   url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)["foo"]    |
                                            |
                         querystring(string)["hello"]
----------------------------------------
var http = require("http");
var url = require("url");

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
----------------------------------------

5.全局对象
（1）process
process.argv是命令行参数数组，第一个元素是 node，第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数
第一步：新建argv.js：
console.log(process.argv); 
第二步：运行argv.js
$ node argv.js 1991 name=byvoid --v "Carbo Kuo" 
[ 'node', 
'/home/byvoid/argv.js', 
'1991', 
'name=byvoid', 
'--v', 
'Carbo Kuo' ]

（2）console
•console.log()：向标准输出流打印字符并以换行符结束。
console.log('Hello world');                  Result:Hello world 
console.log('byvoid%dabcdef');               Result:byvoid%dabcdef 
console.log('byvoid%dabcdef', 9999);         Result:byvoid9999abcdef
•console.error()：与console.log() 用法相同，只是向标准错误流输出。
•console.trace()：向标准错误流输出当前的调用栈。
Result:
Trace: 
at Object.<anonymous> (/home/byvoid/consoletrace.js:1:71) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)

6.util
(1)util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。

(2)util.isArray(object)
var util = require('util');
util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false
(3)util.isRegExp(object)
var util = require('util');
util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp('another regexp'))
  // true
util.isRegExp({})
  // false
(4)util.isDate(object)
var util = require('util');
util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without 'new' returns a String)
util.isDate({})
  // false
(5)util.isDate(object)
var util = require('util');
util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without 'new' returns a String)
util.isDate({})
  // false
(6)util.isError(object)
var util = require('util');
util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: 'Error', message: 'an error occurred' })
  // false

7.GET/POST
(1)GET
var http = require('http');
var url = require('url');
var util = require('util');
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
在浏览器中访问http://localhost:3000/user?name=w3c&email=w3c@w3cschool.cc 然后查看返回结果: 
{ protocol: null,
  slashes: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: '?name=w3c&email=w3c@w3cschool.cc',
  query: { name:'w3c', email:'w3cw3cschool.cc' },
  pathname: '/user',
  path: '/user?name=w3c&email=w3c@w3cschool.cc',
  href: '/user?name=w3c&email=w3c@w3cschool.cc' }

(2)POST
var http = require('http');
var querystring = require('querystring');
var util = require('util');

http.createServer(function(req, res){
    var post = '';     //定义了一个post变量，用于暂存请求体的信息
    req.on('data', function(chunk){    //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
        post += chunk;
    });
    req.on('end', function(){    //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(3000);


二十七、HTTP协议
A、介绍
HTTP协议的主要特点可概括如下：
1、支持客户/服务器模式。
2、接单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接的数据量增大。另一方面，在服务器不需要先前信息时，它的应答就较快。

B、格式
http://host[":"port][abs_path]
http表示要通过HTTP协议来定位网络资源；
host表示合法的Internet主机域名或者IP地址；
port指定一个端口号，为空则使用缺省端口80；
abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。

C、请求
http请求由三部分组成，分别是：请求行、消息报头、请求正文
1、请求行
以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF，其中：
    Method表示请求方法；
    Request-URI是一个统一资源标识符；
    HTTP-Version表示请求的HTTP协议版本；
    CRLF表示回车和换行(除了作为结尾的CRLF外，不允许出现单独的CR或LF字符)。
例如：POST /hello.htm HTTP/1.1("/r/n")
  1) 请求方法：
    请求方法（所有方法全为大写）有多种，各个方法的解释如下：
    GET        请求获取Request-URI所标识的资源
    POST       在Request-URI所标识的资源后附加新的数据
    HEAD       请求获取由Request-URI所标识的资源的响应消息报头
    PUT        请求服务器存储一个资源，并用Request-URI作为其标识
    DELETE     请求服务器删除Request-URI所标识的资源
    TRACE      请求服务器回送收到的请求信息，主要用于测试或诊断
    CONNECT    保留将来使用
    OPTIONS    请求查询服务器的性能，或者查询与资源相关的选项和需求
***********************************************************************
根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的 。 　　
    1.所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 　　
    * 注意：这里安全的含义仅仅是指是非修改信息。 　　
    2.幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等 这个概念： 　　
    幂等 （idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 　　
    幂等有以下几种定义：
    
    对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a) = abs(abs(a)) 。 　　
    对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x 。 看完上述解释后，应该可以理解GET幂等的含义了。 　　
    实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 
    根据HTTP规范，POST表示可能修改变服务器上的资源的请求 。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 　　
    上面大概说了一下HTTP规范中，GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说： 　　
    1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。 　　
    2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 　　
    3.另外一个是，早期的但是Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计 。还有一个较为严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。 　
***********************************************************************
  2) Request-URI：
    用于标识要访问的网络资源。通常只要给出相对于服务器的根目录的相对目录即可，因此以“/”开头。
  3) 协议版本。
2、消息报头
消息报头分为：通用报头、请求报头、响应报头、实体报头
其中：请求方的http报头结构：通用报头、请求报头、实体报头 
      响应方的http报头结构：通用报头、响应报头、实体报头
  1）普通报头
    在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。
    Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。
    请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
    响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage 。
    Date：普通报头域表示消息产生的日期和时间。
    Connection：普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接。
  2）请求报头：
    允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头如下：
    Accept：Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。
    Accept-Charset：Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。
    Accept-Encoding：Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。
    Accept-Language：Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。
    Authorization：Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
    Host（发送请求时，该报头域是必需的）：Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
    eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html。浏览器发送的请求消息中，就会包含Host请求报头域，如下：
    Host：www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号
    User-Agent：我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。
    例：
    GET /form.html HTTP/1.1 (CRLF)
    Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-
    powerpoint,application/msword,*/* (CRLF)
    Accept-Language:zh-cn (CRLF)
    Accept-Encoding:gzip,deflate (CRLF)
    If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
    If-None-Match:W/"80b1a4c018f3c41:8317" (CRLF)
    User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)
    Host:www.guet.edu.cn (CRLF)
    Connection:Keep-Alive (CRLF)
    Authorization: Basic eXV6aGFvOnoxMjM0NTYr
    (CRLF)
  3）响应报头：
    响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。
    常用的响应报头：
    Location：Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。
    Server：Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：
    Server：Apache-Coyote/1.1
    WWW-Authenticate：WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm="Basic Auth Test!"  //可以看出服务器对请求资源采用的是基本验证机制。
  4）实体报头：
    请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。
    常用的实体报头：
    Content-Encoding：
    Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法。eg：Content-Encoding：gzip
    Content-Language：
    Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:da
    Content-Length：
    Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。
    Content-Type：
    Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1、Content-Type:text/html;charset=GB2312
    Last-Modified：
    Last-Modified实体报头域用于指示资源的最后修改日期和时间。
    Expires：
    Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT
    HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader("Expires","0");

D、响应
    在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。
    主要说一下状态行。状态行格式如下：
    HTTP-Version Status-Code Reason-Phrase CRLF
    其中：
    HTTP-Version表示服务器HTTP协议的版本；
    Status-Code表示服务器发回的响应状态代码；
    Reason-Phrase表示状态代码的文本描述。
    状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：
    1xx：指示信息--表示请求已接收，继续处理
    2xx：成功--表示请求已被成功接收、理解、接受
    3xx：重定向--要完成请求必须进行更进一步的操作
    4xx：客户端错误--请求有语法错误或请求无法实现
    5xx：服务器端错误--服务器未能实现合法的请求
    常见状态代码、状态描述、说明：
    200 OK    //客户端请求成功
    400 Bad Request    //客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized    //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
    403 Forbidden    //服务器收到请求，但是拒绝提供服务
    404 Not Found    //请求资源不存在，eg：输入了错误的URL
    500 Internal Server Error    //服务器发生不可预期的错误
    503 Server Unavailable    //服务器当前不能处理客户端的请求，一段时间后，可能恢复正常
    eg：HTTP/1.1 200 OK （CRLF）

E、Http报头Accept与Content-Type的区别
1.Accept属于请求头， Content-Type属于实体头。 
2.
Accept代表发送端（客户端）希望接受的数据类型。比如：Accept：text/xml; 代表客户端希望接受的数据类型是xml类型
Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。比如：Content-Type：text/html; 代表发送端发送的数据格式是html。

二者合起来，
Accept:text/xml；
Content-Type:text/html
即代表客户端希望接收的数据类型是xml格式，本次请求发送的数据的数据格式是html。


F、HTTPS（SSL）
1.步骤
round 1
验证证书的有效性，并得到“公钥”
client：发起请求，包括加密算法、随机数                  -----> server：返回包含公钥（用于获取对称加密的密钥）的证书
client：通过浏览器验证证书的归属                        <-----┘
¤目的
客户端获取公钥（包含在证书中）。（其中证书被用于证明此被访问的网站确实是目标网站，即访问url不是被拦截伪造的。因为此步为第一步，尚未达成约定，使用的是明文，因此要确定回复来源的合法性）
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
SSL证书的作用
(1)网站实现加密传输
用户通过http协议访问网站时，浏览器和服务器之间是明文传输，这就意味着用户填写的密码、帐号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，被黑客加以利用。
(2)认证服务器真实身份
SSL证书有什么作用?钓鱼欺诈网站泛滥，用户如何识别网站是钓鱼网站还是安全网站?网站部署全球信任的SSL证书后，浏览器内置安全机制，实时查验证书状态，通过浏览器向用户展示网站认证信息，让用户轻松识别网站真实身份，防止钓鱼网站仿冒。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

round 2
通过“公钥”换“对称密钥”
client：公钥加密，并发送random对称加密密钥[公钥|RSA]    -----> server：私钥解密，得到对称加密密钥
client：公钥解密并验证random字符串的正确性              <-----┘
¤目的
客户端生成并发送加密的对称加密密钥。

round 3
client：发送实际请求内容（被对称加密）                  -----> server：密钥解密，返回响应（对称加密密钥）
client：                                                <-----┘



2.数字签名作用：
（1）保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。
（2）接收方可以验证信息自签发后到收到为止未曾做过任何修改，签发的文件是真实文件。

3.说明
（1）为什么数据传输采用对称加密，而不采用非对称加密？
●CPU 计算资源消耗非常大。一次完全 TLS 握手，密钥交换时的非对称解密计算量占整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。
●非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。
所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。

（2）为什么抓包时，还是能看到明文的用户名和密码呢?
原因是https(ssl)的加密是发生在应用层与传输层之间，所以，在传输层看到的数据才是经过加密的，而我们捕捉到的http post的，是应用层的，是还没经过加密的数据。加密的数据只有客户端和服务器端才能得到明文客户端到服务端的通信是安全的。


F、TCP协议
三次握手是为了确认客户端跟服务器都能接受到对方的信息。
第一次握手，客户端给服务器发包。 此时服务器确认自己可以接收客户端的包，客户端不确认服务器是否接收到了自己发的包。
第二次握手，服务器端回复客户端。 此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。
第三次握手，客户端回复服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的包。两边都没有问题，开始通信。


四次挥手
A：B 啊，我不想玩了
B：哦，你不想玩了啊，我知道了
这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。
B：A 啊，好吧，我也不玩了，拜拜
A：好的，拜拜


二十七、百科
1.URI与URL解析
A.什么是URI：
URI是Uniform Resource Identifier的缩写，译为“统一资源标识符”。URI一般由三部分组1、访问资源的命名机制。 2、存放资源的主机名。 3、 资源自身的名称，由路径表示。 考虑下面的URI，它表示了当前的HTML 4.0规范http://www.tf988.com.com/html/html40/这个URI是这样的：这是一个可通过HTTP协议访问的资源，位于主机www.webmonkey.com.cn上，通过路径“/html/html40”访问。在HTML文档中其它资源包括"mailto"（收发email）和"ftp"（FTP访问）。 
这是URI的另一个例子，指向一个用户的邮箱：mailto:joe@someplace.com
注：大多数读者可能熟悉"URL"，而不是URI。URL是URI命名机制的一个子集。
片段标志符有的URI指向一个资源的内部。 这种URI以"#"结束，并跟着一个anchor标志符（称为片段标志符）。例如，下面是一个指向section_2的URI：
http://somesite.com/html/top.htm#section_相对URI相对URI 不包含任何命名规范信息。它的路径通常指同一台机器上的资源。相对URI可能含有相对路径（如，“..”表示上一层路径），还可能包含片段标志符。为了说明相对URI，假设我们有一个基本的URI http://www.acme.com/support/intro.htm下面的链接中使用了相对USuppliers
它扩展成完全的URI就是 "http://www.acme.com/support/suppliers.htm"， 
下面是一个图像的相对URI：
<IMG src="../../../icons/logo.gif" alt="logo">
它扩展成完全的URI就是 "http://www.acme.com/icons/logo.gif"。
在HTML中，URI被用来：
链接到另一个文档或资源(参看A和LINK元素)。 
链接到一个外部样式表或脚本(参看LINK和SCRIPT元素)。 
在页内包含图像、对象或applet(参看IMAG、OBJECT、APPLET和INPUT
元素)。 
建立图像映射(参看MAP和AREA元素)。 
提交一个表单(参看FORM)。 
建立一个框架文档(参看FRAME和IFRAME元素)。 
引用一个外部参考(参看Q、BLOCKQUOTE, INS和DEL元素)。 
指向一个描述文档的metadata(参看HEAD元素)。
B.什么是URL：
URL是Uniform Resource Location的缩写，译为“统一资源定位符”。通俗地说，URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 
◇ URL的格式
URL的格式由下列三部分组成： 
第一部分是协议（或称为服务方式）； 
第二部分是存有该资源的主机IP地址（有时也包括端口号）； 
第三部分是主机资源的具体地址。，如目录和文件名等。 
第一部分和第二部分之间用“：//”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。
◇ URL示例 
文件的URL： 
用URL表示文件时，服务器方式用file表示，后面要有主机IP地址、文件的存取路径（即目录）和文件名等信息。有时可以省略目录和文件名，但“/”符号不能省略。
例一：file://ftp.yoyodyne.com/pub/files/foobar.txt
代表存放主机ftp.yoyodyne.com上的pub/files/目录下的一个文件，文件名是foobar.txt。
例二：file://ftp.yoyodyne.com/pub
代表主机ftp.yoyodyne.com上的目录/pub。
例三：file://ftp.yoyodyne.com/
代表主机ftp.yoyodyne.com上的根目录。
Gopher的URL： 
Gopher服务器有可能使用特殊的端口，在这种情况下，主机IP地址与端口之间要用“：隔开。
例一：gopher://gopher.yoyodyne.com/
表示主机gopher.yoyodyne.com上的gopher服务器。
例二：gopher://gopher.banzai.edu:1234
表示主机gopher.banzai.edu上的gopher服务器，在端口1234上。
网络新闻的URL： 
利用URL表示网络新闻组时，如果是usenet的话只要指定出新闻组的名字即可。
例如：news:rec.gardening
表示usenet上的rec.gardening新闻组（园艺）。
HTTP的 URL：
使用超级文本传输协议HTTP，提供超级文本信息服务的资源。
例一：http://www.peopledaily.com.cn/channel/welcome.htm
其计算机域名为www.peopledaily.com.cn。超级文本文件（文件类型为.html）是在目录/channel下的welcome.htm。这是中国人民日报的一台计算机。
例二：http://www.rol.cn.net/talk/talk1.htm
其其计算机域名为www.rol.cn.net。超级文本文件（文件类型为.html）是在目录/talk下的talk1.htm。这是瑞得聊天室的地址，可由此进入瑞得聊天室的第1室。
URI、URL和URN之间的区别与联系
URI：Uniform Resource Identifier，统一资源标识符；
URL：Uniform Resource Locator，统一资源定位符；
URN：Uniform Resource Name，统一资源名称。
其中，URL，URN是URI的子集。
Web上地址的基本形式是URI，它代表统一资源标识符。有两种形式：
URL：目前URI的最普遍形式就是无处不在的URL或统一资源定位器。
URN：URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。
URI是以某种统一的（标准化的）方式标识资源的简单字符串。
典型情况下，这种字符串以scheme（命名URI的名字空间的标识符——一组相关的名称）开头，语法如下：
[scheme:] scheme-specific-part 
URI以scheme和冒号开头。Scheme用大写/小写字母开头，后面为空或者跟着更多的大写/小写字母、数字、加号、减号和点号。冒号把scheme与scheme-specific-part分开了，并且scheme-specific-part的语法和语义（意思）由URI的名字空间决定。如下面的例子：
http://www.cnn.com，其中http是scheme，//www.cnn.com是 schemespecific-part，并且它的scheme与scheme-specific-part被冒号分开了。
URI有绝对和相对之分，绝对的URI指以scheme（后面跟着冒号）开头的URI。前面提到的http://www.cnn.com就是绝对的URI的一个例子，其它的例子还有mailto:jeff@javajeff.com、news:comp.lang.java.help和xyz://whatever。你可以把绝对的URI看作是以某种方式引用某种资源，而这种方式对标识符出现的环境没有依赖。如果使用文件系统作类比，绝对的URI类似于从根目录开始的某个文件的径。 
与绝对的URI不同的，相对的URI不是以scheme（后面跟着冒号）开始的URI。 它的一个例子是articles/articles.html。你可以把相对的URI看作是以某种方式引用某种资源，而这种方式依赖于标识符出现的环境。如果用文件系统作类比，相对的URI类似于从当前目录开始的文件路径。
URL是Uniform Resource Location的缩写，译为"统一资源定位符"。通俗地说，URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 
目前最大的缺点是当信息资源的存放地点发生变化时，必须对URL作相应的改变。因此人们正在研究新的信息资源表示方法，例如：URI(Universal Resource Identifier)即"通用资源标识"（参见RFC 1630）、URN（Uniform Resource Name）即"统一资源名"和URC（Uniform Resource Citation）即"统一资源引用符"等。
URI目前还处在进一步的研究当中。研究的方向就是弥补URL目前存在的缺点。




2.几种刷新方式的不同
三种刷新方式会导致浏览器采取不同的缓存机制：
F5：不允许浏览器直接使用本地缓存，因此Last-Modified能起作用，但Expires无效
Ctrl+F5：是强制刷新，因此缓存机制失效
“转至”或地址栏里回车：正常的访问，Last-Modified和Expires都有效





3.跨平台
C语言肯定不能跨平台的，他只能获得“源代码级的可移植性”，因为不同类型或版本的机器其指令集是不同的，我们不能保证C等高级语言在一台机器上生成的可执行程序能完全在另外一台机器上运行，因为可能这台机器上生成的可执行程序中用到了另外一台机器中未曾有的指令(格式)，但是在源代码级上，C还是具有移植性的，当然移植是，我们可能还是需要修改代码的，因为不同操作系统他们提供的API不一样，不同编译器的编译方式也是有所差别。 在说为什么java能跨平台，本质上是由于他在每个机器上都装了“与该类型机器对应的虚拟机”，而java编译器生成的是一种中间代码(即字节码)，这种中间代码是与具体机器无关的，他完全是java设计者为了让java能跨平台而设计的，这种字节码最后由虚拟机解释成该机器上的指令，这样只要保证每种类型的机器都有对应的虚拟机，那么我们就能让java完全跨平台。






4.半双工和全双工
1. 单工（Simplex）通信：数据信号只能沿着一个方向上传输，发送方只能发送不能接收，接收方只能接收而不能发送。任何时候都不能改变信号传输的方向。例如无线电广播和电视广播。
2. 半双工（Half-Duplex）通信：数据信号可以沿两个方向传输，但两个方向不能同时发送数据，必须交替进行。半双工通信适用于会话式通信，例如警察使用的“对讲机”和军队使用的“步话机”。
3. 全双工（Full-Duplex）通信：数据信号可以同时沿两个方向传输，两个方向可以同时进行发送和接收。例如电话。
如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。
如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在，称为半双工传输。
如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。
电话线就是二线全双工信道。由于采用了回波抵消技术，双向的传输信号不致混淆不清。双工信道有时也将收、发信道分开，采用分离的线路或频带传输相反方向的信号，如回线传输。

单工通信：寻呼机 只能接受信息
半双工通信：对讲机 可以双方都发信息和接收 但是不能同时发
全双工通信：手机 双方可以同时发信息或者接收信息



5.幻数（magic number）
在程序中有些数是表示一定的意义的，但是由于他（她）等编程风格不好，没有给它一个特定的意思的单词描述，所有过了一段时间这个数表示的意思就可能被你忘记了。对你来重读这些代码时这些数字就像魔法师用的魔法数字，很难让你接受。
因此一般程序中多会有如下的定义；
 #define MAXSIZE 100  //C++
 const MAXSIZE 100  //C++
当你看到MAXSIZE的时候就能比较容易的明白它的意思。但是如果你遇到了100的话，你是不是有时候会想入非非的呢？



6.组件与控件的区别
组件（Component）比控件（Control）涵盖的范围要广，控件是组件的一种。
什么是组件？可以把它理解成一个可以反反复复使用的模块。就是说只要一个模块能够重用，它就可以称当上一个组件，而不用在乎这个模块有没有“外型”。
控件不仅是可以“重用”的模块，而且还有“外型”。平常看到的除了UI对象之外的程序子窗体，都算得上控件。UI对象有3种：菜单、工具栏、快捷键，除开它们其它可以看得到的子窗体都是控件，比如按钮、标签、单选框、复选框、列表、树型选单等。实际上最能体现“控件”本意的就是按钮了。可以把整个程序当作一台收音机，按钮用来控制这台收音机的一些功能。
总结一下：（1）控件是组件的一种，全称叫“控制组件”；（2）控件一定有UI外型，一定看得到。




7.Visual Studio实用快捷键
F12、Ctrl + 减号、CTRL + SHIFT + 减号 (视频查看)
这三个键在查看代码的时候，特别有用。通过F12你可以快速的找到一个函数的定义，通过Ctrl+减号你可以快速的返回到函数的调用处。
 
Ctrl + Tab、Ctrl + F6、Ctrl + Alt + 向下箭头 （视频查看）
活动文件的3种切换方式，比你用鼠标点击方便一些噢。

Shift + Alt + T ：编辑.行转置，将包含插入点的行移动到下一行之下。

Ctrl + R, I：提取接口

Ctrl + R, M：提取方法

Ctrl + R, R：重命名

Ctrl + M, O：折叠到定义
Ctrl + M, M：切换大纲显示/展开

Alt + Shift + F10：实现接口
Ctrl + K, M：生成方法存根

Alt + 上/下：整体向上/下移

Alt + Shift + Enter：全屏

Ctrl + Shift + `：在代码上显示调用堆栈

Ctrl + Shift + N：新建项目

8.什么是跨域访问
一句话：同一个IP、同一个网络协议、同一个端口，三者都满足就是同一个域。
否则就是跨域访问了。


9.C#在电子邮件中显示附件中的图片
发送邮件时，邮件中的图片如果以链接的形式出现，在离线阅读或图片源发生问题时，往往图片的显示会出现问题，此时可采用内嵌图片的形式，让邮件使用附件中的图片源。
例1
using System.Net.Mail;

string htmlBody = "<html><body><h1>Picture</h1><br><img src=\"cid:Pic1\"></body></html>";
AlternateView avHtml = AlternateView.CreateAlternateViewFromString
    (htmlBody, null, MediaTypeNames.Text.Html);

// Create a LinkedResource object for each embedded image
LinkedResource pic1 = new LinkedResource("pic.jpg", MediaTypeNames.Image.Jpeg);
pic1.ContentId = "Pic1";
avHtml.LinkedResources.Add(pic1);

// Add the alternate views instead of using MailMessage.Body
MailMessage m = new MailMessage();
m.AlternateViews.Add(avHtml);

// Address and send the message
m.From = new MailAddress("rizwan@dotnetplayer.com", "Rizwan Qureshi");
m.To.Add(new MailAddress("shayan@dotnetplayer.com", "Shayan Qureshi"));
m.Subject = "A picture using alternate views";
SmtpClient client = new SmtpClient("smtp.dotnetplayer.com");
client.Send(m);

例2
    static void Main(string[] args)
    {
        MailMessage m = new MailMessage();
        m.From = new MailAddress("fromMail.com");
        m.To.Add(new MailAddress("toMail.com"));
        //1.配置附件
        m.Attachments.Add(new Attachment("C:\\img\\ewen.gif"));                                 //添加附件
        m.Attachments[0].ContentType.Name = "image/gif" ;                                       //配置附件类型
        m.Attachments[0].ContentId = "MyPic";                                                   //设置附件ID，邮件正文会用到
        m.Attachments[0].ContentDisposition.Inline = true;                                      //设置是否内联
        m.Attachments[0].TransferEncoding = System.Net.Mime.TransferEncoding.Base64;            //设置编码格式
        m.Attachments[0].NameEncoding = m.SubjectEncoding = m.BodyEncoding = Encoding.UTF8;
        //2.邮件正文
        m.Subject = "";
        m.IsBodyHtml = true;                                                                    //设置正文格式
        m.Body += string.Format(@"<img src=""{0}"" />", "cid:" + m.Attachments[0].ContentId);   //设置正文内容
        //3.发送邮件
        SmtpClient smtp = new SmtpClient();
        smtp.Port = 25;
        smtp.Host = "smtp.126.com";
        smtp.Credentials = new System.Net.NetworkCredential("username","pwd");

        smtp.Send(m);
    }


10.虚拟主机、vps、主机租用有什么区别？
虚拟主机指在同一台服务器、同一个操作系统上，运用虚拟主机管理软件划分的若干个空间，每个用户都占用一部分系统资源。适用于容量较小的网站；VPS是指在同一台服务器上，利用虚拟服务器软件创建多个相互隔离的小服务器，它有自己操作系统，运行和管理与独立服务器完全相同。适用于访问量较大，管理者有一定的服务器操作技术的网站。主机租用是指租用一台服务器，让用户独享服务器的资源。适用于网站访问量大，管理者有专业的服务器维护技术的网站。

11.备份的种类
·完全备份
·差异备份
·增量备份
Binding RelativeSource


12.Hash散列表原理
    在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。
    具体如何做呢？大家是否有注意到前面说的话：“数组可以通过下标直接定位到相应的空间”，对就是这句，哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。
    其中的数组：HashMap里面实现一个静态内部类Entry，其重要的属性有key , value, next。
即：
（1）将key转成hashcode，得到结果
hashcode转换公式：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 
使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。（空字符串的哈希码为 0。） 
    //String的hashCode方法
    @Override public int hashCode() {
        int hash = hashCode;
        if (hash == 0) {
            if (count == 0) {
                return 0;
            }
            final int end = count + offset;
            final char[] chars = value;
            for (int i = offset; i < end; ++i) {
                hash = 31*hash + chars[i];
            }
            hashCode = hash;
        }
        return hash;
    }

（2）将结果对数组长取余，余数为数组下标
****************************************************************************************************
// 存储时:
int hash  = key.hashCode();             //每个key的hash是一个固定的int值
int index  = hash % Entry[].length;
Entry[index] = value;

// 取值时:
int hash  = key.hashCode();
int index  = hash % Entry[].length;
return Entry[index];
****************************************************************************************************

※如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？
　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。



13.FTP访问格式
ftp://user:pass@ip:端口/文件夹/提供下载的文件(需要用户密码的链接)

14.POSIX
POSIX是可移植操作系统接口(Portable Operating System Interface)

15.品控
QC：Quality Control，品质控制，产品的质量检验，发现质量问题后的分析、改善和不合格品控制相关人员的总称。一般包括IQC（Incoming Quality Control来料检验），IPQC（In-Process Quality Control制程检验），FQC（Final Quality Control成品检验），OQC（Out-going Quality Control出货检验），也有的公司不管三七二十一，将整个质控部全部都称之为QC。QA：Quality Assurance，品质保证，通过建立和维持质量管理体系来确保产品质量没有问题。一般包括体系工程师，SQE（Supplier Quality Engineer  供应商质量工程师），CTS（客户技术服务人员），6sigma工程师，计量器具的校验和管理等方面的人员。QA不仅要知道问题出在哪里，还要知道这些问题解决方案如何制订，今后改如何的预防，QC要知道仅仅是有问题就去控制，但不一定要知道为什么要这样去控制。打个不恰当的比方， QC是警察，QA是法官，QC只要把违反法律的抓过来就可以了，并不能防止别人犯罪和给别人最终定罪，而法官就是制订法律来预防犯罪，依据法律宣判处置结果。总结说明一下，QC：主要是事后的质量检验类活动为主，默认错误是允许的。期望发现并选出错误。QA主要是事先的质量保证类活动，以预防为主。期望降低错误的发生几率。

16.测试
功能
边界
状态
压力
错误处理
回归
UI测试

单元测试：单元测试是对软件中的基本组成单位进行的测试。目的是检验软件基本组成单位的正确性。 
集成测试：集成测试是在软件系统集成过程中所进行的测试。目的是检查软件单位之间的接口是否正确。 
系统测试：系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。 
验收测试：验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买都展示该软件系统满足其用户的需求。 

17.二级域名和子域名
（1）什么是二级域名？
    大家都知道，我们在登录百度的时候，当点击了百度知道，域名就会从www.baidu.com变为zhidao.baidu.com，而变化的这个域名，就是一个二级域名，它相对于主域名来说，也是一个独立的域名。用比较好确定是不是二级域名的方法就是，看域名中有几个点，有两个点，就是二级域名。在选择二级域名时，如果你的网站内容不多，不建议大家使用二级域名，因为二级域名比较多，就会分摊了主域名的网站内容，从而分摊了权重。另外在了解购买老域名要注意什么时，也要注意二级域名。
★很多人都误把带www当成一级域名，把其他前缀的当成二级域名，是非常错误的。正确的域名划分为：
baidu.com           主(一级)域名
www.baidu.com       二级域名
bbs.baidu.com       二级域名
tieba.baidu.com     二级域名
（2）什么是子域名？
    网站子域名就是网站主域名的的所有下级。比如像www.intersk.com、bbs.intersk.com、sz.bbs.intersk.com统称为intersk.com的子域名。简而言之就是intersk.com也就是顶级域名下面的所有扩展域名，都是父域名下的子域名。

18.多用户登录
fSingleSessionPerUser


19.Windows常用快捷命令
compmgmt.msc
Inetmgr
mstsc
services.msc


20.工作集
所谓工作集是指进程已映射的物理内存部分（即这些内存块全在物理内存中，并且 CPU 可以直接访问），还有一部分不在工作集中的虚拟内存则可能在转换列表中（CPU 不能通过虚地址访问，需要 Windows 映射之后才能访问），还有一部分则在磁盘上的页面文件里。工作集在进程运行时会被 Windows 自动调整，频繁访问的页面（4KB 的块）会留在内存中，而不频繁访问的页面在内存紧张时会被从工作集中移出，暂时保存在内存中的“转换列表”中，或者进一步换出到页面文件中。当应用程序再次访问某一页面时，操作系统会将它重新加回工作集中。
（1）内存---工作集（私人工作集中的内存数量与进程正在使用且可以由其他进程共享的内存数量的总和）
（2）内存--高峰工作集（进程所使用的工作集内存的最大数量）
（3）内存--工作集增量（进程所使用的工作集内存中的更改量）
（4）内存--专用工作集（工作集的子集，它专门描述了某个进程正在使用且无法与其他进程共享的内存数量）
（5）内存--提交大小（进程为用户保留的虚拟内存数量）
（6）内存--页面缓冲池（可以写入其他存储媒体（例如硬盘）的某个进程的认可虚拟内存数量）
（7）内存--非页面缓冲池（无法写入其他存储媒体的某个进程的认可虚拟内存数量）
    public static float getPrivateWorkingSet(string processName)
    {
        using (var p1 = new PerformanceCounter("Process", "Working Set - Private", processName))
        {
            return p1.NextValue();
        }
    }

21.修改aspx文件，不用重新发布
第一个选项是：允许更新此预编译站点
指定发布后是不是可以修改aspx文件，如果勾选，则发布后的网站行为基本与ASP.NET 1.1一致，只要没有增删改修控件，可以直接在服务器上修改aspx文件不用重新发布网站。
第二个选项是：使用固定命名和单页程序集
指定是不是将每个aspx文件都编译成一个DLL文件，这样，就可以在修改了哪个aspx网页（包括aspx和cs文件），只需要更新一个DLL文件就行了，不用整站全部更新。


22.md5“不是”加密算法
    md5 是摘要算法不是加密算法，两者的本质区别是：摘要算法是单向的，即明文可以通过摘要算法生成摘要结果，但反之则不能通过摘要结果还原成明文。而加密算法是双向的，即可以从明文通过加密算法生成密文，反之也可以通过解密算法将密文还原成明文。
    王小云教授关于破解md5的意思是这样的：因为只要明文发生一个字节的变动，则重新生成的摘要结果就会完全不同，因此通常用md5算法处理明文的登录密码并保存在 /etc/passwd 中(当然现在大多会保存在 /etc/master.passwd 或 /etc/shadow中)，用户登录时输入明文密码，系统根据明文密码生成md5后，再和 /etc/passwd 中对应用户的 md5 进行比较，容两者一致，则证明密码符合。因此在这种场合，系统直接比较摘要结果，并不需要根据md5还原出明文，所以md5是适用的，即使用户通过其它手段看到了 /etc/passwd 中的md5摘要，他也无法根据摘要还原出明文，所以密码就会很安全。但王小云教授找到了md5的问题，即通过碰撞算法刻意生成的不同明文可以拥有相同的md5摘要，这意味着只要得到md5摘要，就可以人为地找出一个符合这个摘要的明文，说白了就是两个不同的密码可以拥有完全相同的摘要，这两个密码可以产生同样的登录效果，这下就麻烦了，如果有人通过别的手段得到了密码的md5摘要，他就可以通过碰撞算法自行生成一个密码并登录成功！
    sha256

23.热备份、冷备份
I.冷备份
    冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备份时将关键性文件拷贝到另外的位置的一种说法。对于备份Oracle信息而言，冷备份时最快和最安全的方法。
优点：
（1）是非常快速的备份方法（只需拷文件）
（2）容易归档（简单拷贝即可）
（3）容易恢复到某个时间点上（只需将文件再拷贝回去）
（4）能与归档方法相结合，做数据库“最佳状态”的恢复。
（5）低度维护，高度安全。
不足：
（1）单独使用时，只能提供到“某一时间点上”的恢复。
（2）再实施备份的全过程中，数据库必须要作备份而不能作其他工作。也就是说，在冷备份过程中，数据库必须是关闭状态。
（3）若磁盘空间有限，只能拷贝到磁带等其他外部存储设备上，速度会很慢。
（4）不能按表或按用户恢复。
如果可能的话（主要看效率），应将信息备份到磁盘上，然后启动数据库（使用户可以工作）并将备份的信息拷贝到磁带上（拷贝的同时，数据库也可以工作）。冷备份中必须拷贝的文件包括：
（1）所有数据文件
（2）所有控制文件
（3）所有联机REDO LOG文件
（4）Init.ora文件（可选）

值得注意的使冷备份必须在数据库关闭的情况下进行，当数据库处于打开状态时，执行数据库文件系统备份是无效的。
下面是作冷备份的完整例子。
（1）关闭数据库
sqlplus /nolog
sql>connect /as sysdba
sql>shutdown normal;
（2）用拷贝命令备份全部的时间文件、重做日志文件、控制文件、初始化参数文件
sql>cp
（3）重启Oracle数据库
sql>startup

II.热备份
热备份是在数据库运行的情况下，采用archivelog mode方式备份数据库的方法。所以，如果你有昨天夜里的一个冷备份而且又有今天的热备份文件，在发生问题时，就可以利用这些资料恢复更多的信息。热备份要求数据库在Archivelog方式下操作，并需要大量的档案空间。一旦数据库运行在archivelog状态下，就可以做备份了。热备份的命令文件由三部分组成：
1．数据文件一个表空间一个表空间的备份。
（1）设置表空间为备份状态
（2）备份表空间的数据文件
（3）回复表空间为正常状态
2．备份归档log文件
（1）临时停止归档进程
（2）log下那些在archive rede log目标目录中的文件
（3）重新启动archive进程
（4）备份归档的redo log文件
3． 用alter database bachup controlfile命令来备份控制文件热备份的优点是：
（1）可在表空间或数据库文件级备份，备份的时间短。
（2）备份时数据库仍可使用。
（3）可达到秒级恢复（恢复到某一时间点上）。
（4）可对几乎所有数据库实体做恢复
（5）恢复是快速的，在大多数情况下爱数据库仍工作时恢复。
不足：
（1）不能出错，否则后果严重
（2）若热备份不成功，所得结果不可用于时间点的恢复
（3）因难于维护，所以要特别仔细小心，不允许“以失败告终”。

24.悲观锁与乐观锁
    悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
    乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
    两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

25.split brain（脑裂）
    就是说，本来一个大脑的两半球互相配合，变成了分裂成两个独立的大脑，都认为对方已死。此时，双方都尝试接管集群资源，造成冲突，后果严重。解决办法：使用硬盘心跳，scsi reservation，以及最极端的power fence。
可选解决方案：将集群设置为节点数大于某一预设值才允许启动。

26.正向代理与反向代理
A.正向代理的概念
正向代理，也就是传说中的代理，他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器。这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。
从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。

结论就是：正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

B.反向代理的概念（Reverse Proxy server）
继续举例:
例用户访问 http://ooxx.me/readme，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来，然后作为自己的内容吐给用户，但用户并不知情。这里所提到的 ooxx.me 这个域名对应的服务器就设置了反向代理功能。
结论就是：反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。


反向代理就是是网站通过一台机器发布到公网。你访问的时候是直接访问那台代理机器的，然后通过那台机器才访问到网站。你无法得到网站的真实ip地址。这样的好处是保护了网站服务器，而且可以通过一个被动代理服务器将很多机器解析到同一ip地址。

Client1
Client2->Proxy->Server               --正向代理，Proxy是Client的代理，不暴露Client。Server不知道自己访问的是代理
Client3

               Server1
Client->Proxy->Server2               --反向代理，Proxy是Server的代理，不暴露Server。Client不知道自己访问的是代理
               Server3

C.两者区别
从用途上来讲：
正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。
另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。
从安全性来讲：
正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。
反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。



系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。





27.system32目录
C:\Windows\SysWOW64\inetsrv
C:\Windows\System32\inetsrv

28.斐波那锲
public static long fib(long n) {
    checkArgument(n >= 0, "Fib from only positive numbers");
    if (n <= 1) return n;
    
    long fibNMinus1 = 1;
    long fibNMinus2 = 0;
    long fib = 0;
    
    for (int i = 2; i <= n; i++) {
        fib = fibNMinus1 + fibNMinus2;
        fibNMinus2 = fibNMinus1;
        fibNMinus1 = fib;
    }
    return fib;
}

29.清除TFS版本控制信息
------------------------------------------------------------------------------------------------
Hereis how to remove this association:
1. Remove all *.vssscc and *.vspscc files from your Solution folders. 
2. Check if your Solution *.sln file is Read-Only. Remove this flag if needed. 
3. Open *.sln file in an editor. I prefer Windows Notepad for such operations. 
4. Find GlobalSection(TeamFoundationVersionControl) looking as showing belowand remove it begining with GlobalSection and ending with EndGlobalSection:
    GlobalSection(TeamFoundationVersionControl) = preSolution   
    SccNumberOfProjects = 2   
    SccEnterpriseProvider = {4CA58AB2-18FA-4F8D-95D4-32DDF27D184C}   
    SccTeamFoundationServer = http://<YourTFS>/tfs/defaultcollection   
    SccLocalPath0 = .   
    SccProjectUniqueName1 = <Your Project path and name in TFS>.csproj   
    SccProjectName1 = <Project Name>   
    SccLocalPath1 = <Project Path>   
    EndGlobalSection  
5.Save and close your Solution file.
6. Go ahead and open this Solution in Visual Studio IDE as usual. 
7. If you will get IDE warning similar as shown below, just select"Permanently remove source control association bindings".
------------------------------------------------------------------------------------------------

30.删除
"TF10169：尝试对团队项目文件夹$/Catch进行不支持的扶起更改。请使用团队资源管理器中的“项目创建向导”来创建项目，或使用团队项目删除工具来删除项目。"
或者：
"TF10169: Unspported pending change attempted on team project folder $/Test.  Use the Project Creation Wizard in Team Explorer to create a project or the Team Project deletion tool to delete one."

这是后要使用TFSDeleteProject.exe （D:\Program Files\Microsoft Visual Studio 10.0\Common7\IDE文件夹下）工具来删除项目
命令使用方法：
TFSDeleteproject [/q] [/force] [/excludewss] /collection:URL TeamProjectName
e.g:
TFSDeleteProject.exe /collection:http:\\[ServerName]:8080\tfs\DefaultCollection [ProjectName]

Option                  Description
/q                  Optional. Use the quiet mode. Do not prompt the user for confirmation.
/force              Optional. Specifies that the deletion process should continue even if some components cannot be deleted.
/excludewss         Optional. Specifies to not delete the SharePoint site that is associated with the team project. Specify this option to maintain the existing site so that other team projects can continue using it.
/collection:URL     Required. Specifies the URI of the team project collection. You must use the following format for the URI:http://ServerName:Port/VirtualDirectoryName/CollectionName.If you do not specify a virtual directory, you must use the following format for the URI:
http://ServerName:Port/CollectionName.
TeamProjectName     Required. The name of the project. If the name includes spaces, enclose it in quotations marks.
 

31.环境变量
System.Environment.GetEnvironmentVariable("systemdrive");
System.Environment.SetEnvironmentVariable("key", "value");
bool is64 = System.Environment.Is64BitOperatingSystem;

32.连接
mklink /d d:\GitStack\Git "C:\Program Files (x86)\Git"
mklink /d "D:\My Weblog Posts" "C:\Users\用户名\Documents\My Weblog Posts"
mklink /d target source
    /D      创建目录符号链接。默认为文件
            符号链接。
    /H      创建硬链接而非符号链接。
    /J      创建目录联接。
    Link    指定新的符号链接名称。
    Target  指定新链接引用的路径
            (相对或绝对)。


33.Bug管理
BugFree的7种解决方案各自的含义： 
By Design - 就是这么设计的，无效的Bug 
Duplicate - 这个问题别人已经发现了，重复的Bug 
External - 是个外部因素(比如浏览器、操作系统、其他第3方软件)造成的问题 
Fixed - 问题被修理掉了。Tester要尽可能找到这种Bug 
Not Repro - 无法复现你这个问题，无效的Bug 
Postponed - 是个问题，但是目前不必修理了，推迟到以后再解 
Won't Fix - 是个问题，但是不值得修理了，不管它吧 

Bugzilla(v3.2.2)中的BUG解决方案有如下7种：
    Fixed：已修复，即BUG中描述的与需求或设计不一致的问题已解决，不再出现。
    Duplicate：重复的，该BUG与另外一个BUG描述的问题是一样的。
    WontFix：不处理，该BUG无足轻重。
    WorksForMe：无法重现，开发人员无法复现该BUG。
    Invalid：无效的，开发人员认为该BUG不是一个缺陷，可能是设计问题或系统环境配置不正确。
    Moved：已转移，转移到别的BUG分类或别的版本下。
    Later：推迟，该BUG在当前版本不易处理，推迟处理或在新版本中处理。

Bugfree(v1.1)中一个Bug有7种解法（摘自Bugfree文档）：
    By Design - 就是这么设计的，无效的Bug
    Duplicate - 这个问题别人已经发现了，重复的Bug
    External - 是个外部因素(比如浏览器、操作系统、其他第3方软件)造成的问题
    Fixed - 问题被修理掉了。Tester要尽可能找到这种Bug
    Not Repro - 无法复现你这个问题，无效的Bug
    Postponed - 是个问题，但是目前不必修理了，推迟到以后再解
    Won't Fix - 是个问题，但是不值得修理了，不管它吧

34.链接
mklink /D "D:\Program Files\Code\eclipse\jre" "D:\Program Files\Code\Java\jre7"

35.名词解析
ops的确就是 OPerationS的意思. 不过ops也份sysops和appops.前者关注系统方面问题多点.后者关注应用方面的问题多一点 
quot是quote的缩写，quote是引用的意思；amp是ampersand的缩写，ampersand就表示&意思和and一样
OOM out of mana法力耗尽
slash /
backslash \

36.分布式与集群的区别
分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。
·集群：
分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式的。举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一台去完成。
·分布式：
分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务就不可访问了。
从狭义上理解，也跟集群差不多，但是它的组织比较松散，不像集群，有一个组织性，一台服务器垮了，其它的服务器可以顶上来。

37.PV UV VV IP
PV即PageView，网站浏览量，指页面的浏览次数，用以衡量网站用户访问的网页数量。用户没打开一个页面便记录1次PV，多次打开同一页面则浏览量累计；
UV即UniqueVistor，独立访客数，指1天内访问某站点的人数，以cookie为依据。1天内同一访客的多次访问只计为1个访客；
VV即VisitView，访客的访问次数，用以记录所有访客1天内访问了多少次您的网站。当访客完成所有浏览并最终关掉该网站的所有页面时便完成了一次访问，同一访客1天内可能有多次访问行为，访问次数累计；
IP即独立IP数，指1天内使用不同IP地址的用户访问网站的数量，同一IP无论访问了几个页面，独立IP数均为1


38.侵入式与非侵入式
侵入式，扩展功能需要修改原代码
非侵入式，扩展功能不需修改原代码，直接在原有的基础上构建

39.函数和方法的区别
函数function —— A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body.
方法method —— A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which is usually called self).

40.开发Web服务有两种方式：
·Simple Object Access Protocol (SOAP)
·Representational State Transfer (REST)

41.ESB
ESB的全称是Enterprise Service Bus（企业服务总线）。它是一个ielinghuode用于集成各种企业应用即服务的连接基础架构，企业服务总线能够通过简化企业应用及服务之间的链接数量，接口大小以及接口复杂度使企业的面向服务体系SOA更加强大。
Enterprise Service Bus 主要提供一下几方面的功能：
·在服务于服务之间或者应用于应用之间路由消息；
·在服务请求者与服务提供者之间转换传输协议；
·在服务请求者与服务提供者之间转换消息格式；
·处理来自于各种已购源的业务事件；
企业服务总线使企业可以更主要的关于企业的核心业务而不用在关注与连接各种应用的IT基础架构，它还可以让企业在增加新的服务及对已有服务进行修改时，可以对原有系统及服务不产生影响或者只有微小的影响。

42.Unix时间
表示自格林尼治标准时间1970-01-01-00.00.00.000000以来的秒数, 取值范围为-377705145943~253402271999

43.fire-and-forget
RabbitMQ解决的是应用程序之间互联(connect)和规模(scale)的问题，消息发送和接收是隔离，发送方不知道消息最终由谁接收，接收方也不必关心消息是谁步发出的；发送和接收是隔离的，消息本质上就是异步的。这种隔离也就解耦了应用程序之间的依赖.RabbitMQ的角色就是应用程序中间的路由器.对于消息的发布方来讲这是一种“发后即忘”(fire-and-forget)的发布方式。

44.
●PV（page view）
即页面浏览量或点击量，是衡量一个网站或网页用户访问量。具体的说，PV值就是所有访问者在24小时（0点到24点）内看了某个网站多少个页面或某个网页多少次。PV是指页面刷新的次数，每一次页面刷新，就算做一次PV流量。
　　度量方法就是从浏览器发出一个对网络服务器的请求（Request），网络服务器接到这个请求后，会将该请求对应的一个网页（Page）发送给浏览器，从而产生了一个PV。那么在这里只要是这个请求发送给了浏览器，无论这个页面是否完全打开（下载完成），那么都是应当计为1个PV。
●UV（unique visitor）即独立访客数，指访问某个站点或点击某个网页的不同IP地址的人数。在同一天内，UV只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。UV提供了一定时间内不同观众数量的统计指标，而没有反应出网站的全面活动。
●IP可以理解为独立IP的访问用户，指1天内使用不同IP地址的用户访问网站的数量，同一IP无论访问了几个页面，独立IP数均为1。但是假如说两台机器访问而使用的是同一个IP，那么只能算是一个IP的访问。

45.调用的目标发生了异常
当发生此类异常时，可通过查看该异常内部错误，获取该错误详细信息。

46.
QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
TPS是 TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器 做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使 用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。

47.SQL Server调整字段顺序
在 Microsoft SQL Server Management Studio 中：
第一步：工具->选项->Designers->表设计器和数据库设计器->将“阻止保存要求重新创建表的更改”的选项的勾去掉。
第二步：右键单击你要更改的数据表，点选“设计”，然后在表设计器中用鼠标拖动各列的位置，最后保存即可。

48.
SQL Sever提示Microsoft SQL Server Management Studio cannot find one or more components
为Microsoft Visual Studio 2010 Shell(Isolate)-CHS辅助程序的问题，从https://www.microsoft.com/zh-CN/download/details.aspx?id=1366，下载VSIsoShell，安装。

49.
卸载
vs_ultimate.exe /uninstall /force

50.linux目录中的.d表示什么意思？
这个 ".d" 是表示目录(directory)的意思
早期 unix 中很多应用软件通常都只用一个独立的配置文件，如 fstab 等。随着应用越来越复杂，软件中需要配置的项目越来越多，单个配置文件开始显得复杂无比，难以操作。这时很多软件就逐渐开始将配置项放入多个文件。使用多个配置文件更容易分配操作权限，内容也可以更专一，因此更适合模块化管理。但这也造成了 /etc/ 目录下的文件急剧增加，且文件名冲突现象越来越严重。
因此unix 中约定系统软件除创建一个(特例下可以多个，如 rc 簇)传统的全局配置文件外，将附属的其它配置文件保存到同名的目录中，区别是在名称后面加 ".d" 后缀，同时全局配置文件后面也加上后缀 ".conf"，这样就使得配置文件更容易进行模块化管理，同时兼容了 unix 的老习惯：直接操作 /etc/ 下的配置文件，而不是操作 /etc/ 下子目录中的配置文件。
对于安装在 unix 中的应用软件来说，它们的配置文件除自己使用外，很少会由其它应用来读取或修改，因此应用软件完全可以由自己来管理配置文件，所以应用类软件通常直接在 /etc/ 下创建一个子目录用来保存所有的配置文件，而不再创建传统的全局配置文件。
所以，我们现在能在 /etc/ 看到的就是这三种不同的配置文件组织方式下的文件和子目录。分别是：传统的单一配置文件(都是比较早期开发的软件)、系统软件的全局配置文件(.conf) + 附属配置文件(.d)、以及应用软件的配置文件（存放在子目录且子目录名不加 ".d"）。
另外，unix 中还有一个约定，凡是守护进程的执行文件名后会加上 "d" ，这个 "d" 前不带 "." 号，代表的才是 daemon 的意思，通常存放在 /usr/sbin/ 下。



52.the different between redirect and rewrite
https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/url-rewriting?tabs=aspnetcore2x

53.vCPU
vCPU，顾名思义，是虚拟CPU。 创建虚拟机时，需要配置vCPU资源。 因此vCPU是虚拟机的部件。 因此脱离VM，谈论vCPU是没有意义的。
虚拟化管理系统如何调度vCPU，取决于系统内的虚拟机数目以及虚拟机配置的vCPU的情况。
大致的情况如下：
（1）当系统内VM所需的vCPU总数少于物理CPU的核数（包括超线程Core）时，虚拟化管理系统为vCPU分配的资源不超过一个物理CPU核。 vCPU与物理核的分配关系可以是绑定的，也可能是动态的。
比如服务器有20个核心，你创建了2个VM，每个VM 4个vCPU，那么这两个VM最多能够使用服务器的8个核心。
（2）当系统内的VM所需要的vCPU核大于物理CPU核数时，虚拟化管理系统首先按照时间片轮流调度一遍，然后如果还有剩余的CPU资源，则给所需要的vCPU。 比如系统配置了40个vCPU，只有20个物理核。那么平均每个vCPU获取一个核心50%的资源。由于一些VM忙，一些VM空闲，虚拟化系统会在一个调度周期内，划分出若干时间片，轮流给每个vCPU使用。忙的vCPU可以使用完整个时间片，而闲的vCPU用不完整个时间片，会提前释放资源。这样在一个调度周期内，对每个vCPU都调度一遍后还有空闲的时间，调度器会把用这剩余的资源去调度忙的vCPU。 这样兼顾公平和效率。  这中调度算法具体下来，大致是如下效果：系统有1个CPU 2.0 Ghz，两个VM，分配1个vCPU。 如果VM1 和 VM2都忙，那么各自相当于拥有一个1.0 Ghz的CPU。 如果VM1很忙，VM1只需要 500Mhz的处理能力，那么在VM1看来，相当于暂时获得了 1.5Ghz的处理器。
（3）通过对Xen的测试，系统所有虚拟机的vCPU的总数目小于和等于CPU核数时，VM的性能是比较稳定的。 VM的vCPU基本上绑定到了一个CPU核。 当vCPU数目大于物理核数时，VM的性能稳定性变差。

54.Repository
Repository是对象的仓库，也就是保存对象的地方，这个仓库就是我们普通意义的仓库，一个真正OO系统，业务层是围绕活动的对象进行，活动的对象是从仓库中获取的，也是通过交给仓库进行对象长久保管，也就是持久化意思，说白了，就是保存到数据库。
而DAO则没有如此OO概念，DAO是Data access Object，DAO中有数据概念，还是没有摆脱数据库的影子。
所以，Repository替代DAO，是OO深入的趋势，但是在具体处理中，由于性能或设计不够周到或者一些事情把握不定，DAO还会继续存在一段时间，属于过渡式消失。
Repository和DAO两个概念比较中发现，Repository是相对对象而言，而DAO是相对数据库而言，只要我们还是使用关系数据库保存对象，也可能这两者都同时存在，因为侧重点不一样，但是可以肯定的是，业务层应该直接和Repository打交道，而不是DAO.


55.为什么0.1+0.2≠0.3？
计算机是通过二进制进行计算，所以
Stop 1:
  0.1转换为二进制：0.0001100110011001...
    0.1 * 2 = 0.2           0
    0.2 * 2 = 0.4           0
    0.4 * 2 = 0.8           0
    0.8 * 2 = 1.6           1
    0.6 * 2 = 1.2           1
    0.2 * 2 = 0.8           0
    ...

Step 2:
  0.2转换为二进制：0.0011001100110011...

Step 3:
  0.1(10) + 0.2(10) = 0.0001100110011001...(2) + 0.0011001100110011...(2) = 0.0100110011001100...(2) = 0.0100110011001100(2) = 0.29998779296875(10)


56.OF（OffsiteFacility）
Responsibility:
1. Overall responsible for OF (Offsite Facility )Site IT operations and distribution related function;
2. Supervise and ensure both infrastructure and delivery application system running properly;
3. Enforces compliance of IT policies, standard, security of global IT strategy;
4. Responsible for improving team performance, people development, and providing coach to subordinate;
5. Collaborate with business department to find opportunity to improve business process and provide added-value service;
6. Keep active cooperation with regional/corporate IT team;
7. Identify end user training needs and develop training plan accordingly.

Key Words: Microsoft system, IT Services, Infrastructure 
1. IT Major Bachelor Degree or above;
2. At least 3 years working experience with Microsoft system & technologies background and over 2 years position in IT Services
3. Proficient in both infrastructure and Microsoft technologies knowledge and ongoing support;
4. More than 1 IT Project management experience;
5. Strong team cooperation spirit & Accountability;
6. Effectively communication skill;
7. Fluent English;
8. Good planning and priority management;
9. Self-motivated, enthusiastic and creative;
10. Ability to make connections in developing new ideas and approaches










二十八、兼容性
document.all 只有ie支持
document.getElementById 为标准的W3C支持
 
二十九、c#版本迭代
1.C#6.0
------------------------------------------------------------------
public string Name { get; set; } = "summit";
------------------------------------------------------------------
Console.WriteLine($"年龄:{account.Age()}");
------------------------------------------------------------------
using static System.Math;//注意这里Math不是命名空间哦
 
Console.WriteLine($"之前的使用方式: {Math.Pow(4, 2)}");
Console.WriteLine($"导入后可直接使用方法: {Pow(4,2)}");
------------------------------------------------------------------
IDictionary<int, string> dict = new Dictionary<int, string>() {
       [1]="first",
       [2]="second"
};
------------------------------------------------------------------
static void TestExceptionFilter()
{
    try
    {
        Int32.Parse("s");
    }
    catch (Exception e) when (e is BusinessException)
    {
        Console.WriteLine("catch");
        return;
    }
}
------------------------------------------------------------------
private static void Add(Account account)
{
     if (account == null)
         throw new ArgumentNullException(nameof(account));
}
------------------------------------------------------------------
Person person = persons.FirstOrDefault();
string name = person?.Name;                     //过去if (persons != null &&  persons.Count > 0)
------------------------------------------------------------------
public int AddOld()
{
    return 1 + 1;
}
public int AddNewMethod() => i + 1;
public int AddNewAttribute => i + 1;
------------------------------------------------------------------

2.C#7.0
------------------------------------------------------------------
static (string First, string Middle, string Last) GetFullName() => ("first name", "blackheart", "last name");
static void Main(string[] args)
{
    var fullName = GetFullName();

    Console.WriteLine(fullName.First);  // 终于可以不是Item1,2,3了，，，
    Console.WriteLine(fullName.Middle);
    Console.WriteLine(fullName.Last);
}
------------------------------------------------------------------




二十九、名词
阿姆达尔定律
InternalClass 
diagonal   //斜线
constraint
primary
references
token
Singleton 单例
module
component
Deprecated
decouple
intercept   拦截
interpreter 解释器




三十、常见问题
1.VS调试时提示：类型“... ”同时存在于“...”和“ ...”中
原因：在定义了类时，由于以前定义好了此类，并且编译成功后，后来又修改了此类。在Bin里面还有一个老版本的DLL，而新版的DLL名字换掉了，新的盖不掉老的，并存在BIN里时，就会发生这种错误。
解决方法：把BIN里的手动删掉，C:\WINDOWS\Microsoft.NET\Framework\版本号\Temporary ASP.NET Files 的临时文件里，把相应的目录都删掉，然后重新编译运行就OK。记着bin目录下组件一定要手动删除。


2.TFS撤销别人的“签出”
社员某也试着写个超级小白篇的技术说明。。。以资快速忘记这个事情吧。
背景： 在TFS使用过程中，发现某文件被UserA用户独占签出， 此时管理员要在TFSServer上强行撤销用户UserA的签出。
适用：无法联系到UserA，或者UserA的工作区已经不存在等情况， 基本上能在Server端上包治此类的通病！
    此段可忽略：不过TFS真真够难用的，以后大中小规模开发（基本上50人以下的并行开发吧，或者项目设计模块复杂度较小的，总之，只要不是非用TFS不可的巨型项目。。hehe）坚决不要用TFS了。。VSS或者SVN都比这个大而重的烂牛刀好用。 咱们这个民间作坊、江湖术士，只要能用、好用就行啊，太复杂的东西搞得实在很无聊！好了言归正传吧…
步骤：
1、可以在TFSServer端上，用管理员权限用户登录后，在VS的源代码管理界面上首先针对被人签出的源码项，进行下“签出”类的操作，看一下“视图”–>“输出”窗口中的提示，以确定该签出项所属的“工作区”“签出用户”以及“路径”。如图：
2、然后在TFSServer端，进入CMD，打开命令行窗口， 然后进入目录：
       C:\Program Files\Microsoft Visual Studio 8\Common7\IDE 下
     此处有tf.exe用于TFS的命令行操作。
     输入： tf workspaces /owner:UserA /server:ServerName /computer:*
            此命令是为了查看Server端记录的UserA用户的操作状况。
              注： ServerName： 可以用ipconfig /all 看一下自己Server的名称
      输出如下图：具体信息，可根据实际情况进行判断处理。

3、针对上述输出，可以使用以下命令，将UserA用户的当前工作区进行清楚处理，其该工作区中的签出等，自然随之烟消云散辽。。。
      输入：tf workspace /delete 工作区名称;UserA /s:http://ServerIP:8080
     操作及输出如图：

4、OK
注意：以上办法使用效果好、操作便捷，但是其后遗症无法清晰了解，若参照此办法出现种种问题及疑难杂症等，后果自负！
End of this file
From - http://www.nixiongfei.com/index.php/archives/148

5、VMware Workstation 和 Hyper-V不兼容
Q：提示“VMware Workstation 和 Hyper-V不兼容...”
A：
（1）bcdedit /copy {default} /d "Windows Server 2008 R2 Without Hyper-V"
将显示出的GUID号复制起来
（2）继续在命令行下键入以下代码，“{}”里为刚才复制得到的GUID号
bcdedit /set {} hypervisorlaunchtype off
（3）成功重启系统，进入新建的启动项启用。


6.Object reference not set to an instance of an object
Q：Object reference not set to an instance of an object
A：空指针引用




三十三、Nuget
A、介绍
博客中国镜像：https://nuget.cnblogs.com/v3/index.json
配置文件：~/.nuget/NuGet/NuGet.Config
  <add key="nuget.cnblogs.com" value="https://nuget.cnblogs.com/v3/index.json" protocolVersion="3" />
B、配置
NuGet feed v3 (VS 2015 / NuGet v3.x): https://api.nuget.org/v3/index.json
NuGet feed v2 (VS 2013 and earlier / NuGet 2.x): https://www.nuget.org/api/v2

C、步骤
1.注册
在Nuget网站上注册，得到API Key，如：3f994c5e-92ba-4e1a-b61f-4b6525116ed9

2.下载Nuget
从http://nuget.codeplex.com/downloads/get/669083下载Nuget.exe

3.设置API Key
nuget setApiKey <my_api_key>

4.自定义类库
根据实际情况更新AssemblyInfo.cs中的内容：
如：
[assembly: AssemblyVersion("1.0.0.0")]

5.生成.nuspec文件
在csproj文件所在目录，通过命令nuget spec产生.nuspec文件，.nuspec是NuGet将项目打包成nupkg所需的输入文件。
根据实际情况，更新该文件：
<?xml version="1.0"?>
<package >
  <metadata>
    <id>$id$</id>
    <version>$version$</version>
    <title>$title$</title>
    <authors>$author$</authors>
    <owners>$author$</owners>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>MyClass</description>
    <copyright>Copyright 2014</copyright>
  </metadata>
</package>

6.生成.nupkg文件
nuget pack <MyClass.csproj>
可选参数：-Build 
-Build                               Determines if the project should be built before building the package.
可选参数：-Properties Configuration=Release
-Properties +                        Provides the ability to specify a semicolon ";" delimited list of properties when creating a package.

7.发布类库
nuget push 3f994c5e-92ba-4e1a-b61f-4b6525116ed9.1.0.0.0.nupkg
可选参数：-Source http://127.0.0.1:8005 1234                                      //指定要发布的目标源的位置

8.更新类库
打开AssemblyInfo.cs，修改版本号，重新编译、产生、发布。

9.安装类库
Install-Package 3f994c5e-92ba-4e1a-b61f-4b6525116ed9 -Version 1.9 -Source http://nuget.gw.symbolsource.org/MyGet/exceptionless/FeedService.mvc -ProjectName projectNameXXX

nuget package.config
Get-Package -ProjectName MvcApp                   # 获得项目引用的包列表
Install-Package 类库ID                            # 安装指定Package
Install-Package 类库ID -Source http://...         # 通过指定源安装指定Package
Uninstall-Package 类库ID                          # 卸载指定Package
Update-Package 类库ID -Version 1.9                # 更新指定Package
Update-Package 类库ID -ProjectName MvcApp         # 更新指定项目的指定Package
Update-Package -Reinstall                         # 重装指定Package（使用相同版本）
Update-Package -Safe                              # 重装指定Package（使用相同的major和minor版本号），如老版本是1.2.0，新版本可以是1.2.1或1.2.9999，而非1.3.0
.\.nuget\nuget restore ABC.sln                    # 恢复指定解决方案
Install-Package 类库ID -IgnoreDependencies        # 忽略依赖包
Install-Package 类库ID -IncludePrerelease         # 包括预览版
Install-Package 类库ID

由于使用控制台需要知道类库的准确ID，可以到http://www.nuget.org/packages这里去查找，把自己常用的ID记录下方便以后使用

下载地址：
http://nuget.codeplex.com/releases/59864/clickOnce/NuGetPackageExplorer.application




Nuget.Server




三十四、性能优化
1.使用快速的序列化方式
2.使用手写ADO.NET
3.减少程序和数据库间的数据往返次数



三十五、调试
#define TMARK

using System.Diagnostics;

namespace ConsoleApp
{
    class Program
    {
        class ToolKit
        {
            [Conditional("TRELEASE")]
            [Conditional("DEBUG")]          // 生效
            public static void Method1()
            { Console.WriteLine("1"); }

            [Conditional("TRELEASE")]
            [Conditional("NOBUG")]
            public static void Method2() 
            { Console.WriteLine("2"); }

            [Conditional("TMARK")]          // 生效
            [Conditional("DEBUG")]          // 生效
            public static void Method3()
            { Console.WriteLine("3"); }

            [Conditional("TMARK")]          // 生效
            [Conditional("NOBUG")]
            public static void Method4()
            { Console.WriteLine("4"); }
        }
        
        static void Main(string[] args)
        {
            ToolKit.Method1();
            ToolKit.Method2();
            ToolKit.Method3();
            ToolKit.Method4();
        }
    }
}
在调试模式下的结果
Result:
1
3
4


三十六、VSCode
launch.json是用来描述Debugger
stackoverflow.com



三十七、Cloud
https://azure.microsoft.com/zh-cn/documentation/learning-paths/service-fabric/








四十、OWIN（Open Web Interface for .Net）
Microsoft ASP.NET Web API 2.2 OWIN Self Host
A.Katana介绍

B.相关组件
Katana作为OWIN的规范实现，除了实现Host和Server之外，还提供了一系列的API帮助开发应用程序，其中已经包括一些功能组件如身份验证（Authentication）、诊断（Diagnostics）、静态文件处理（Static Files）、ASP.NET Web API和SignalR的绑定等。
Microsoft.Owin – 提供了一组辅助类型，以及为简化创建OWIN组件而建的各种抽象类型。
Microsoft.Owin.Diagnostics – 提供了各种中间件组件，以辅助开发基于OWIN的应用程序。
Microsoft.Owin.FileSystems – 这个包里提供了文件系统相关的抽象与实现。
Microsoft.Owin.Testing – 提供了对OWIN组件进行单元测试的一些辅助类。
Microsoft.Owin.SelfHost – 包含了为在自行指定的进程中托管基于OWIN的应用程序所必需的一些组件。
Microsoft.Owin.Hosting – 提供了托管与运行基于OWIN的应用程序所需的默认基础框架类型。
                          提供了自托管功能，WebApp就在这里。
OwinHost – 提供了一个单独的可执行程序（OwinHost.exe），通过它可以托管一个基于OWIN的应用程序的运行。
            注意它并不是一个程序集，而是.exe应用程序位于<solution root>/packages/OwinHost.(version)/tools文件夹。
Microsoft.Owin.Cors – 这个包里包含了一些能够在OWIN中间件中进行跨域资源共享（CORS）的组件。
Microsoft.Owin.StaticFiles – 这个包里包含了一些OWIN中间件，能够处理来自于文件系统资源的请求，包括文件与目录。
Microsoft.Owin.Security – 包含了一些各种不同的认证中间件组件所共享的 通用类型。
Microsoft.Owin.Security.ActiveDirectory – 一组允许应用程序使用微软技术进行认证的中间件。
Microsoft.Owin.Security.Cookies – 允许应用程序使用基于cookie进行认证的中间件，类似于ASP.NET中的表单认证方式。
Microsoft.Owin.Security.Facebook – 允许应用程序支持Facebook所使用的OAuth 2.0认证工作流的一些中间件。
Microsoft.Owin.Security.Google – 包含了一组支持Google的OpenId及OAuth 2.0认证工作流的中间件。
Microsoft.Owin.Security.Jwt – 一组允许应用程序保护及验证JSON Web令牌的中间件。
Microsoft.Owin.Security.MicrosoftAccount – 一组允许应用程序支持微软帐号认证工作流的中间件。
Microsoft.Owin.Security.OAuth – 允许应用程序支持任何标准OAuth 2.0认证工作流的中间件。
Microsoft.Owin.Security.OpenIdConnect – 允许应用程序使用OpenIdConnect方式进行认证的中间件。
Microsoft.Owin.Security.Twitter – 允许应用程序支持Twitter的OAuth 2.0认证工作流的中间件。
Microsoft.Owin.Security.WsFederation – 允许应用程序使用WsFederation进行认证的中间件。
Microsoft.Owin.Host.HttpListener – 基于.Net Framework中的HttpListener类创建的OWIN服务器，也是目前用于自托管的默认服务器。
                                    缺少会报the server factory could not be located for the given input。
Microsoft.Owin.Host.SystemWeb – 也是OWIN服务器实现，但它允许基于OWIN的应用程序运行在传统IIS中，并能够使用ASP.NET的请求管道。
                                 [assembly: OwinStartup(typeof(WebOWIN.Startup))]要通过它才能找到“IIS托管Katana-based应用程序”的入口。

Microsoft.AspNet.Identity.Owin
Microsoft.AspNet.WebApi.Owin



C.托管
1. WebApp 方式（OWIN自托管）
using Microsoft.Owin.Hosting;
1.1 简单方式
    string url = "http://localhost:26634/";
    IDisposable disposable = WebApp.Start(url, Startup.Configuration);
    //或
    string url = "http://localhost:26634/";
    IDisposable disposable = WebApp.Start<Startup>(url);

1.2 自定义方式
    StartOptions options = new StartOptions();
    options.Urls.Add(url);
    options.ServerFactory = "Microsoft.Owin.Host.HttpListener";
    IDisposable disposable = WebApp.Start(options, Startup.Configuration);

2. OwinHost 方式 （OwinHost.exe托管）
它将加载.\bin文件下所有的程序集
（1）C:\MyProjects\ProjectDemo>..\packages\Owinhost<Version>\tools\Owinhost.exe [FriendlyName]
（2）浏览http://localhost:5000/



D.Startup
1.结构说明
引用Microsoft.Owin.Host.SystemWeb后，带有[assembly: OwinStartup(typeof(WebOWIN.Startup1))]标记的Startup为入口。与此同时，传统的Global.asax.cs中的Application_Start()依然为有效入口。
（1）Install-Package Microsoft.Owin.Host.SystemWeb
（2）自建OWIN Startup类
//※有此标记的为程序入口，类似控制台的Main方法
[assembly: OwinStartup(typeof(WebOWIN.Startup1))]                                               // 通过OWIN会隐式寻找程序集下名称叫做Startup的类。当然这里也可手动显式指定入口类。
[assembly: OwinStartup(typeof(WebOWIN.Startup1), Configuration)]                                // 甚至可指定入口方法
                                                                                                // 如果有多个OWIN Startup入口类，可通过在<appSetting>元素中<add key="owin:appStartup" value="WebOWIN.Startup1, WebOWIN" />的方式，显式指定入口。（如果定义了多条，则最后一条生效）
[assembly: OwinStartup("ProductionConfiguration", typeof(WebOWIN.Startup1))]                    // 同上，也可通过在<appSetting>元素中<add key="owin:appStartup" value="ProductionConfiguration" />的方式，以“友好类”的方式显式指定入口。（如果定义了多条，则最后一条生效）

// OWIN 的 Startup
namespace WebOWIN
{
    // Framework Startup
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // 有关如何配置应用程序的详细信息，请访问 http://go.microsoft.com/fwlink/?LinkID=316888
            HttpConfiguration config = new HttpConfiguration();
            // 添加WebApi自带默认路由
            WebApiConfig.Register(config);
            // 添加WebApi自带默认路由，同上
            /*
            config.Routes.MapHttpRoute(
                name: "DefaultApi",
                routeTemplate: Constant.RestfulWebUrlRoot + "/{controller}/{id}",
                defaults: new { id = RouteParameter.Optional }
            );
            */
            app.UseWebApi(config);
        }
        
        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            loggerFactory.AddConsole(Configuration.GetSection("Logging"));
            loggerFactory.AddDebug();

            app.UseMvc();
        }
    }
}


E.中间件
（1）ThrottlingMiddleware
-----------------------------------------------------------
class Startup
{
    public static void Configuration(Owin.IAppBuilder app)
    {
        // Configure Web API for self-host.  
        HttpConfiguration config = new HttpConfiguration();
        config.Routes.MapHttpRoute(
            name: "DefaultApi",
            //routeTemplate: "api/{controller}/{id}",
            routeTemplate: "ConfigServer/{controller}/{id}",
            defaults: new { id = RouteParameter.Optional }
        );

        //两者方式皆可
        app.Use<CustomMiddleware>();                                                                // 自定义
        app.Use(typeof(ThrottlingMiddleware),                                                       // 第三方
            new ThrottlePolicy(perSecond: 3, perMinute: 80, perHour: 200, perDay: 1500, perWeek: 3000)
            {
                //开关
                IpThrottling = true,                                                                // 基于IP
                EndpointThrottling = true,                                                          // 基于终结点
                StackBlockedRequests = true,                                                        // 计数器是否记录被拒绝的请求
                //规则                        
                IpWhitelist = new List<string> {                                                    // 白名单规则
                    "::1",                      
                    "192.168.0.0/24",                       
                    "192.168.0.0-192.168.0.255"                     
                },
                EndpointRules = new Dictionary<string, RateLimits>()                                // 终结点规则
                { 
                    {
                        "api/search",
                        new RateLimits { PerSecond = 10, PerMinute = 100, PerHour = 1000 }
                    }
                },
                ClientThrottling = true,
                ClientWhitelist = new List<string> { "admin-key" }
                
            },                                                                                      // 或通过配置文件ThrottlePolicy.FromStore(new PolicyConfigurationProvider()),
            new PolicyMemoryCacheRepository(),                                                      // PolicyCacheRepository使用的是Asp.net版本，自寄宿Owin上的WebApi使用PolicyMemoryCacheRepository
            new MemoryCacheRepository(),                                                            // CacheRepository使用的是Asp.net版本的缓存，自寄宿Owin上的WebApi使用MemoryCacheRepository
            new TracingThrottleLogger(ToyBlockBus.CommonUtil.Logger.LoggerThrottle),                // 或null,
            null);

        app.UseWebApi(config);
    }
    
    //可通过此方法，刷新内存中的策略数据
    private void UpdateRateLimits()
    {
        //初始化策略仓库
        var policyRepository = new PolicyCacheRepository();
    
        //从缓存中获取策略对象
        var policy = policyRepository.FirstOrDefault(ThrottleManager.GetPolicyKey());
    
        //更新客户端限制频率
        policy.ClientRules["api-client-key-1"] =
            new RateLimits { PerMinute = 80, PerHour = 800 };
    
        //添加新的客户端限制频率
        policy.ClientRules.Add("api-client-key-3",
            new RateLimits { PerMinute = 60, PerHour = 600 });
    
        //应用策略更新
        ThrottleManager.UpdatePolicy(policy, policyRepository);
    }
}
//限流的请求日志
public class TracingThrottleLogger : IThrottleLogger
{
    private readonly Library.Assist.LocalLogger logger;

    public TracingThrottleLogger(Library.Assist.LocalLogger logger)
    {
        this.logger = logger;
    }

    public void Log(ThrottleLogEntry entry)
    {
        if (logger != null)
        {
            //logger.WriteLine(string.Format("WebApiThrottle : {0} Request {1} from {2} has been throttled (blocked), quota {3}/{4} exceeded by {5}", entry.LogDate.ToLocalTime(), entry.RequestId, entry.ClientIp, entry.RateLimit, entry.RateLimitPeriod, entry.TotalRequests));
            logger.WriteLine(Library.Serializer.JsonSerializerHelper.Obj2ShortJson(entry));
        }
    }
}
-----------------------------------------------------------
WebAPI（也可以在控制器中自定义限流频率）
[EnableThrottling(PerSecond = 2)]
public class ValuesController : ApiController
{
    [EnableThrottling(PerSecond = 1, PerMinute = 30, PerHour = 100)]
    public IEnumerable<string> Get()
    {
        return new string[] { "value1", "value2" };
    }
    [DisableThrotting]
    public string Get(int id)
    {
        return "value";
    }
}
-----------------------------------------------------------
（2）AOP中间件
    public class CustomMiddleware : OwinMiddleware
    {
        object options;

        public CustomMiddleware(OwinMiddleware next)
            : base(next)
        {
            //构造方法
        }

        public CustomMiddleware(OwinMiddleware next, object options)
            : base(next)
        {
            //引入参数类，并可以再类中使用
            this.options = options;
        }

        public override Task Invoke(IOwinContext context)
        {
            string root = Constant.UrlPathBase;
            string path = context.Request.Path.Value;
            //string root = "/bus/request";
            //if (context.Request.Path.StartsWithSegments(tickPath))
            bool isGet = context.Request.Method.Equals("get", StringComparison.CurrentCultureIgnoreCase);
            bool pathStartWith = Regex.IsMatch(path, string.Format("^{0}", root), RegexOptions.IgnoreCase);
            bool queryStringNotStartWith = !Regex.IsMatch(context.Request.QueryString.ToString(), "\\?value=", RegexOptions.IgnoreCase);
            bool b = isGet && pathStartWith && queryStringNotStartWith;
            if (b)
            {
                string renewPath = Regex.Match(path, root, RegexOptions.IgnoreCase).Value;
                context.Request.QueryString = new QueryString("value=" + System.Web.HttpUtility.UrlEncode(path.Replace(renewPath, string.Empty) + context.Request.QueryString.ToString()));
                context.Request.Path = new PathString(renewPath);

                //context.Response.StatusCode = 200;
                //context.Response.Expires = DateTimeOffset.Now;
                context.Response.Redirect(context.Request.Uri.ToString());//.Write(content);
                return Task.FromResult(new HttpResponseMessage());                              // 解答者告诉Server解答已经完毕，后续Middleware不需要处理
            }
            else
                return Next.Invoke(context);                                                    // 继续下一步
        }
    }

（3）OAuth中间件
// context/OAuthAuthorizationServerOptions/...
OAuthAuthorizationServerOptions OAuthOptions = new OAuthAuthorizationServerOptions()
{
    // 是否允许普通http协议。当设置为false时，若登记的Client端重定向url未采用https，则不重定向！！！
    AllowInsecureHttp = true,
    AuthenticationType = OAuthDefaults.AuthenticationType,
    // In passive mode the middleware need to be invoked by name. In active mode the middleware will kick in for any 401 response
    // 在Active主动模式下，身份验证中间件将在请求到达时更改用户标识，并在响应离开时更改 401 纯文本。
    //在无权限访问的情况下，会返回302自动重定向到登录页面
    // 在Passive被动模式下，身份验证中间件只在提示时提供用户标识，并且只会更改在附加质询数据中指定了身份验证类型的 401 响应。
    //在无权限访问的情况下，会提示{"Message":"Authorization has been denied for this request."}
    AuthenticationMode = AuthenticationMode.Active,
    // 设置了以下两个值后，便不需要设置OAuthAuthorizationServerProvider的MatchEndpoint方法
    // “获取授权”终结点。访问此地址时，通过中间件跳转至认证流程，以获取授权码。
    AuthorizeEndpointPath = new PathString("/OAuth/Authorize"),
    // “获取令牌”终结点。访问此地址时，通过中间件跳转至授权流程，以获取令牌。
    TokenEndpointPath = new PathString("/OAuth/Token"),

    // “获取授权”过期时间
    AuthorizationCodeExpireTimeSpan = TimeSpan.FromMinutes(30),
    // “获取令牌”过期时间
    AccessTokenExpireTimeSpan = TimeSpan.FromMinutes(30),
    
    // 该接口以AOP的形式，封装了整个OAuth的流程，可能会涉及以下两个接口
    Provider = new SimpleAuthorizationServerProvider(),
    // 该接口以AOP的形式，封装了“授权码”的Create与Receive操作
    AuthorizationCodeProvider = new SimpleAuthorizationCodeProvider(),
    // 该接口以AOP的形式，封装了刷新Token时“RefreshToken”的Create与Receive操作
    RefreshTokenProvider = new SimpleRefreshTokenProvider(),
};

app.UseOAuthAuthorizationServer(OAuthOptions);
// 使应用程序可以使用Bearer进行授权，以Bearer方式检验ClientId和ClientSecret时会用到，以Form形式则不会用到
app.UseOAuthBearerAuthentication(new OAuthBearerAuthenticationOptions());

// 使应用程序可以使用不记名令牌来验证用户身份，可近似认为实现了以上两步
//app.UseOAuthBearerTokens(OAuthOptions);                                       // 表示 token_type 使用 bearer 方式
/* 其内部代码为：
{
    UseOAuthAuthorizationServer();                                              // authorization server middleware
    UseOAuthBearerAuthentication(ApplicationOAuthBearerProvider);               // application bearer token middleware           
    UseOAuthBearerAuthentication(ExternalOAuthBearerProvider);                  // external bearer token middleware
}
*/

¤
[assembly: PreApplicationStartMethod(typeof(SwaggerConfig), "Register")]
namespace Dealer.SJFYRJ.Com {
    public class SwaggerConfig {
        public static void Register()
        {}
    }
}







http://httpvshttps.cn/

yundoc.cc

.net core
http://www.cnblogs.com/savorboard/
http://www.cnblogs.com/CreateMyself/

http://www.nfine.cn/

blog
http://www.cnblogs.com/huangxincheng/
http://www.cnblogs.com/bnbqian/

This project references NuGet package(s) that are missing on this computer.
Install Nuget.
Right click on the solution and select "Enable NuGet Package Restore".
Click Ok on the warning.
Close and re-open the solution.

https://docs.nuget.org/consume/installing-nuget
http://mt.sohu.com/20141218/n407074203.shtml


MySQL数据的主从复制、半同步复制和主主复制详解
http://blog.csdn.net/goustzhu/article/details/9339621

https://github.com/ef-labs/nanoprofiler
CoreOS


https://github.com/dotnet

汤雪华
http://www.cnblogs.com/netfocus/
http://www.cnblogs.com/netfocus/archive/2013/06/17/3139661.html

博客
http://www.cnblogs.com/Leo_wl/p/4375442.html        // 架构之经典分层
http://www.cnblogs.com/Leo_wl/p/5918170.html        // EQueue 2.3.2版本发布（支持高可用）
http://www.cnblogs.com/Leo_wl/p/5918224.html        // WebSocket

//蟋蟀
http://www.cnblogs.com/xishuai/tag/%5B17%5D%E5%B0%8F%E8%8F%9C%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B-DDD/              // 当前标签: [17]小菜学习编程-DDD
http://www.jianshu.com/nb/4720272

//abp
http://www.cnblogs.com/farb/p/ABPTheory.html
http://www.cnblogs.com/farb/p/ModuleZeroContent.html
http://www.aspnetboilerplate.com/ 这个是官网
http://www.cnblogs.com/mienreal/p/4528470.html
http://www.cnblogs.com/sheng-jie/p/6260035.html
http://www.cnblogs.com/sheng-jie/category/934433.html

//Docker
http://www.cnblogs.com/Leo_wl/p/5982798.html

//博客
www.cnblogs.com/wangiqngpei557/

https://www.receivesmsonline.net/

http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650994591&idx=1&sn=7e0d837ab28d27df3a00a388e2f13140&chksm=bdbf0fcc8ac886da65b0aca74b1c4f04eb9c309a70da107fb8091b1788be67784b64a5a33f85&mpshare=1&scene=23&srcid=11022es8XjAcNtXzRJcV9Kmq#rd

//烧脑电影
http://www.gamersky.com/wenku/201601/705666.shtml

//在WebApi中基于Owin OAuth使用授权发放Token
http://www.jianshu.com/p/b556a227e9a2

//elk视频
http://edu.csdn.net/course/detail/3374/57174?auto_start=1

//新华网
http://news.xinhuanet.com/english/2017-01/10/c_135968145.htm?from=groupmessage&isappinstalled=0

https://laod.cn/hosts/2017-google-hosts.html

//Redis监控
http://www.cnblogs.com/qtqq/p/6280183.html

//vue.js
http://edu.csdn.net/course/detail/3656

//综合
http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&mid=2650862316&idx=1&sn=a5cd2ce50e4f387fb0802997b9155cee&chksm=8b6615a9bc119cbf758010f423dd9bd1915964fa92734d4973cb1b701294de2999f4979e9e7d&mpshare=1&scene=23&srcid=01039L8biWYQjGWs21Hwumg5#rd

//翻译
https://www.oschina.net/translate/list

//VS2XXX
https://www.visualstudio.com/zh-hans/downloads/
http://www.atool.org/httptest.php

//MVP
https://mvp.microsoft.com/zh-cn/Overview

//招聘
https://wx.xiaomiquan.com/mweb/views/topicdetail/topicdetail.html?topic_id=551185521144

//blog
https://my.oschina.net/renguijiayi/blog

usyiyi.cn

https://c.163.com/

//DDD
http://www.cnblogs.com/daxnet/category/252402.html

trietree

http://www.ampc8.com/

//DNS查询
http://tool.chinaz.com/dns

http://www.360doc.com/content/11/0914/11/621500_148132875.shtml

SharpConfig

http://mockbin.com/

https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/

//Win10一周年纪念版，瞧一瞧Linux子系统
http://www.cnblogs.com/leehavin/p/5751762.html

//初码-Azure系列-记一次从阿里云到Azure的迁移和部署
http://www.cnblogs.com/printhelloworld/p/6857603.html?from=timeline

补脾益肠丸

http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&mid=2650862316&idx=1&sn=a5cd2ce50e4f387fb0802997b9155cee&chksm=8b6615a9bc119cbf758010f423dd9bd1915964fa92734d4973cb1b701294de2999f4979e9e7d&mpshare=1&scene=23&srcid=01039L8biWYQjGWs21Hwumg5#rd

http://www.person168.com/

http://backlogtool.com/git-guide/cn/

//Service Fabric
http://www.cnblogs.com/mschiefevangelist/p/6358122.html

//jsbin
jsbin.com

//zookeeper
http://blog.csdn.net/top_code/article/details/51258030

zookeeper解决keepalived的脑裂问题

Redis Zookeeper
//Thrift
http://blog.csdn.net/bbdxf/article/category/7049581

http://www.cnblogs.com/Leo_wl/p/4142064.html

http://www.jb51.net/article/35610.htm


https://github.com/interagent/http-api-design/blob/master/en/responses/use-utc-times-formatted-in-iso8601.md

//Fabio
http://www.cnblogs.com/xishuai/p/macos-and-ubuntu-install-fabio.html



最终一致性，保证写一致


FluentScheduler


http://www.cnblogs.com/netfocus/p/3307971.html
https://github.com/dotnetcore/CAP
https://www.zhihu.com/question/20152327
https://getkong.org/about/

那你就必须面对分布式事务（有时被称作Sagas）。

微服务 粒度


SpinLock


System.ComponentModel.DataAnnotations




Redis只用作cache，写请求只交给MySQL处理。否则你就要自己去解决一个分布式事务的问题，这个目前还没有性价比高的解决方案。如果应用是write heavy的，请使用HBase和Cassandra。


第三步：接下来就是主机头设置的关键了，网站IP地址处信息保持默认的“全部未分配”即可，端口是默认的80，最下面的“此网站的主机头”输入一个域名，当然如果真的要对internet发布自己的网站，这个域名是要输入真实的已经注册的。笔者填写www.softer.com作为该网站的主机头。






http://cdn.code.baidu.com/

http://bigbully.github.io/Dapper-translation/
http://www.infoq.com/cn/articles/distributed-real-time-monitoring-and-control-system





https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md



http://www.rupeng.com/topics/corplive/2.shtml?lianbo

 @北京爱康鼎-MVP-架构师-张占岭 恩，我想到一个问题，cap是基于数据库事务来保证最终一致性，那不支持事务的环境用什么方式来解决？

CAP支持补偿型业务处理，简单说你的错误可能有两种，第一种是业务上的逻辑不符合，比如库存不足之类的，需求回滚调用方。第二种是消费者代码错误，导致不能成功执行。第一种情况CAP是支持的，你可以在发送的时候指定一个补偿的回滚操作。第二种情况CAP会进行不停的重试，用户也可以在控制台看到错误的消息。当然这种错误消费者方法自己try catch，然后发送一个回滚事件到生产者也是可以的


http://edisonxu.org/archives/2017/03/

http://www.cnblogs.com/wangiqngpei557/p/3950048.html

https://github.com/asukhodko/serilog-sinks-logstash-http
http://www.cnblogs.com/nnhy/p/Redis220.html

gadget





得到的没有不同，但是 .Result 在某种情况下会造成死锁。
await 时是释放线程，线程能去执行其它任务；.Result 就是让线程暂停


HttpContext.AllowAsyncDuringSyncStages


在使用async/task/await的代码遭遇这样的错误：
异步模块或处理程序已完成，而当时仍有异步操作处于未定状态。
对应的英文错误信息：
An asynchronous module or handler completed while an asynchronous operation was still pending.


总结：主线程使用result，其中的子线程不能使用await，除非指定了task.ConfigureAwait(false)





dudusay
之前认为只要在同步方法中使用.Result调用async方法，就有可能引发死锁。

通过这篇博文学到了：只有在同步方法所调用的async方法以及下级async方法中，在await时没有加.ConfigureAwait(false)的情况下，才会引发死锁。

.Result会阻塞当前线程，等待异步操作的完成，异步操作完成后继续在这个线程中执行。
await会释放当前线程，异步操作完成后会在一个新的线程中执行。
死锁是因为.Result阻塞的线程占用着线程上下文不释放，某个异步操作完成后在另外一个线程中执行时需要这个被占有着的上下文。如果不需要这个上下文，就不会发生死锁，这就是.ConfigureAwait(false)的作用所在。








JavaScriptSerializer



















ticks
是一个很大的长整数，单位是 100 毫微秒。表示自 0001 年 1 月 1 日午夜 12:00:00 以来已经过的时间的以 100 毫微秒为间隔的间隔数，已经说得很清楚了，如果单位是秒或天 LZ 可以就更容易理解了。
1 毫秒 = 10^-3 秒，
1 微秒 = 10^-6 秒，
1 毫微秒 = 10^-9 秒，
100 毫微秒 = 10^-7 秒。









各个数据库的连接串大全
The Connection Strings Reference
https://www.connectionstrings.com/




Ox7fffffff是什么意思？



X-Frame-Options












https://www.ximalaya.com/yule/269483/p4/






select *
from (
  SELECT ROW_NUMBER() over(partition by fldUserId order by createTime desc) row,
    batchId, checkItemId, checkItem, fldUserId, fldName, fldMobile, template,
    fldSubId, fldSubName, createTime, creatorId, creatorName, sum(rating) as rating
  FROM [dbo].[tblSaleEvaluationRecord]
  GROUP BY
    batchId, checkItemId, checkItem, fldUserId, fldName, fldMobile, template,
    fldSubId, fldSubName, createTime, creatorId, creatorName
) ret
where row<=2
--GROUP BY




写的顺序：select ... from... where.... group by... having... order by..
执行顺序：from... where...group by... having.... select ... order by...

